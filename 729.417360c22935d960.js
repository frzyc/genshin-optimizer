(()=>{"use strict";var e,t,n={61729:(e,t,n)=>{function a(e,t){if(e&&t)return!Array.isArray(t)&&console.error(t),t.reduce(((e,t)=>null==e?void 0:e[t]),e)}function s(e,t){return Object.fromEntries(e.map(((e,n)=>[e,t(e,n)])))}function r(e,t){return Object.fromEntries(e.map(((e,n)=>t(e,n))))}function o(e,t){return Object.fromEntries(Object.entries(e).map((([e,n],a)=>[e,t(n,e,a)])))}const i=function*(e,t){for(let n=e;n<=t;n++)yield n};function l(e,t){return[...i(e,t)]}function c(e){throw new Error(`Should not reach this with value ${e}`)}u(NaN,{name:"TODO"}),d(1),d(0),u("none");function u(e,t){return"number"==typeof e?{operation:"const",operands:[],type:"number",value:e,info:t}:{operation:"const",operands:[],type:"string",value:e,info:t}}function d(e,t){return e>=Number.MAX_VALUE/100&&(e=1/0),e<=-Number.MAX_VALUE/100&&(e=-1/0),u(e,Object.assign({unit:"%"},t))}function h(e){return e.map((e=>"object"==typeof e?e:u(e)))}function p(e){return"object"!=typeof e?u(e):e}function f(e,t,n){const a=new Set,s=new Set;e.forEach((function e(r){s.has(r)||(a.has(r)?console.error("Found cyclical dependency during formula traversal"):(a.add(r),t(r),r.operands.forEach(e),n(r),a.delete(r),s.add(r)))}))}function m(e,t,n){const a=new Set,s=new Map,r=new Map;function o(e){let i=s.get(e);if(i)return i;i=t(e);let l=r.get(i);return l||(a.has(i)?(console.error("Found cyclical dependency during formula mapping"),u(NaN)):(a.add(i),l=n(function(e){const t=e.operands.map(o);return v(t,e.operands)?e:Object.assign({},e,{operands:t})}(i),e),a.delete(i),s.set(e,l),r.set(i,l),l))}const i=e.map(o);return v(i,e)?e:i}function g(e,t,n){const a=new Map;function s(e,t){let r=a.get(t);r||a.set(t,r=[new Set,new Map]);const[o,i]=r,l=i.get(e);if(l)return l;if(o.has(e))throw new Error("Found cyclical dependency during formula mapping");o.add(e);const c=n(e,t,s);return i.set(e,c),o.delete(e),c}return e.map((e=>s(e,t)))}function v(e,t){return void 0===e?void 0===t:void 0!==t&&(e.length===t.length&&e.every(((e,n)=>e===t[n])))}const b={min:e=>Math.min(...e),max:e=>Math.max(...e),add:e=>e.reduce(((e,t)=>e+t),0),mul:e=>e.reduce(((e,t)=>e*t),1)},w=Object.assign({},b,{res:([e])=>e<0?1-e/2:e>=.75?1/(4*e+1):1-e,sum_frac:e=>e[0]/e.reduce(((e,t)=>e+t)),threshold:([e,t,n,a])=>e>=t?n:a}),y=new Set(Object.keys(b));function k(e){return m(e,(e=>e),(e=>{let t=e;if(y.has(e.operation)){const n=e,{operation:a}=n;let s=!1;const r=n.operands.flatMap((e=>e.operation===a?(s=!0,e.operands):[e]));t=s?Object.assign({},n,{operands:r}):n}return t}))}function x(e){function t(e){const t=new Map;for(const a of e){var n;t.set(a,(null!=(n=t.get(a))?n:0)+1)}return t}const n={common:{counts:new Map,formulas:new Set,operation:"add"}};for(;;){let s;const r={operation:n.common.operation,operands:(a=n.common.counts,[...a].flatMap((([e,t])=>Array(t).fill(e))))},o=new Map;for(const e of Object.keys(b))o.set(e,[]);if(e=m(e,(e=>{if(n.common.formulas.has(e)){const t=e,a=new Map(n.common.counts),s=t.operands.filter((e=>{const t=a.get(e);return!t||(a.set(e,t-1),!1)}));return s.length?(s.push(r),Object.assign({},t,{operands:s})):r}return e}),(e=>{if(!y.has(e.operation))return e;const n=e;if(s){if(s.operation===n.operation){const e=t(n.operands),r=new Map,o=s.counts;let i=0;for(const[t,n]of e.entries()){var a;const e=Math.min(n,null!=(a=o.get(t))?a:0);e?(r.set(t,e),i+=e):r.delete(t)}i>1&&(s.counts=r,s.formulas.add(n))}}else{const e=o.get(n.operation),a=t(n.operands);for(const[t,i]of e){let e=0;const l=new Map;for(const[t,n]of i.entries()){var r;const s=Math.min(n,null!=(r=a.get(t))?r:0);s&&(l.set(t,s),e+=s)}if(e>1){s={counts:l,formulas:new Set([n,t]),operation:n.operation},o.clear();break}}s||e.push([n,a])}return n})),!s)break;n.common=s}var a;return e}function S(e,t,n=(e=>!1)){const s={data:[],processed:new Map},r=new Map([[s,new Map]]),o={data:[t],processed:new Map};return r.set(o,new Map),r.get(s).set(t,o),g(e,o,((e,t,o)=>{var i;const{operation:l}=e,d=(e,t)=>o(e,t),h=(e,t)=>o(e,t);let p;switch(l){case"const":p=e;break;case"add":case"mul":case"max":case"min":const v=w[l],b=[],y=e.operands.filter((e=>{const n=d(e,t);return"const"!==n.operation||(b.push(n.value),!1)})).map((e=>d(e,t))),k=v(b);if(isFinite(k)){if("mul"===l&&0===k){p=u(k);break}}else if("mul"!==l&&("max"!==l||k>0)&&("min"!==l||k<0)){p=u(k);break}k!==v([])&&y.push(u(k)),p=y.length<=1?null!=(i=y[0])?i:u(v([])):{operation:l,operands:y};break;case"res":case"sum_frac":{const n=e.operands.map((e=>d(e,t))),a=w[l];p=n.every((e=>"const"===e.operation))?u(a(n.map((e=>e.value)))):Object.assign({},e,{operands:n});break}case"lookup":{const n=h(e.operands[0],t);if("const"===n.operation){var f;const a=null!=(f=e.table[n.value])?f:e.operands[1];if(a){p=o(a,t);break}}throw new Error(`Unsupported ${l} node while folding`)}case"prio":{const n=e.operands.find((e=>{const n=h(e,t);if("const"!==n.operation)throw new Error(`Unsupported ${l} node while folding`);return void 0!==n.value}));p=n?h(n,t):u(void 0);break}case"small":{var m;let n;for(const a of e.operands){var g;const e=h(a,t);if("const"!==e.operation)throw new Error(`Unsupported ${l} node while folding`);(void 0===(null==(g=n)?void 0:g.value)||void 0!==e.value&&e.value<n.value)&&(n=e)}p=null!=(m=n)?m:u(void 0);break}case"match":{const[n,a,s,r]=e.operands.map((e=>o(e,t)));if("const"!==n.operation||"const"!==a.operation)throw new Error(`Unsupported ${l} node while folding`);p=n.value===a.value?s:r;break}case"threshold":{const[n,a,s,r]=e.operands.map((e=>o(e,t)));p="const"===s.operation&&"const"===r.operation&&s.value===r.value?s:"const"===n.operation&&"const"===a.operation?n.value>=a.value?s:r:Object.assign({},e,{operands:[n,a,s,r]});break}case"subscript":{const n=d(e.operands[0],t);if("const"!==n.operation)throw new Error("Found non-constant subscript node while folding");p=u(e.list[n.value]);break}case"read":{const s=t.data.map((t=>a(t,e.path))).filter((e=>e));if(0===s.length)if(n(e)){const{accu:t}=e;p=void 0===t||"small"===t?"string"===e.type?u(void 0):u(NaN):u(w[t]([]))}else p=e;else p=void 0===e.accu||1===s.length?o(s[s.length-1],t):o({operation:e.accu,operands:s},t);break}case"data":{e.reset&&(t=s);const n=r.get(t);let a=n.get(e.data);a||(a={data:[...t.data,e.data],processed:new Map},r.set(a,new Map),n.set(e.data,a)),p=o(e.operands[0],a);break}default:c(l)}return p.info&&(p=Object.assign({},p),delete p.info),p}))}n(15735),n(6886),n(39529);const O=["Albedo","Alhaitham","Aloy","Amber","AratakiItto","Barbara","Beidou","Bennett","Candace","Chongyun","Collei","Cyno","Diluc","Diona","Dori","Eula","Faruzan","Fischl","Ganyu","Gorou","HuTao","Jean","KaedeharaKazuha","Kaeya","KamisatoAyaka","KamisatoAyato","Keqing","Klee","KujouSara","KukiShinobu","Layla","Lisa","Mona","Nahida","Nilou","Ningguang","Noelle","Qiqi","RaidenShogun","Razor","Rosaria","SangonomiyaKokomi","Sayu","Shenhe","ShikanoinHeizou","Sucrose","Tartaglia","Thoma","Tighnari","Venti","Wanderer","Xiangling","Xiao","Xingqiu","Xinyan","YaeMiko","Yanfei","Yaoyao","Yelan","Yoimiya","YunJin","Zhongli"],M=["TravelerAnemo","TravelerGeo","TravelerElectro","TravelerDendro"];const j=["flower","plume","sands","goblet","circlet"],T=["AmenomaKageuchi","AquilaFavonia","BlackcliffLongsword","CinnabarSpindle","CoolSteel","KagotsurubeIsshin","DarkIronSword","DullBlade","FavoniusSword","FesteringDesire","FilletBlade","FreedomSworn","HaranGeppakuFutsu","HarbingerOfDawn","IronSting","KeyOfKhajNisut","LightOfFoliarIncision","LionsRoar","MistsplitterReforged","PrimordialJadeCutter","PrototypeRancour","RoyalLongsword","SacrificialSword","SapwoodBlade","SilverSword","SkyriderSword","SkywardBlade","SummitShaper","SwordOfDescension","TheAlleyFlash","TheBlackSword","TheFlute","ToukabouShigure","TravelersHandySword","XiphosMoonlight"],E=["Akuoumaru","BlackcliffSlasher","BloodtaintedGreatsword","DebateClub","FavoniusGreatsword","FerrousShadow","ForestRegalia","KatsuragikiriNagamasa","LithicBlade","LuxuriousSeaLord","MakhairaAquamarine","OldMercsPal","PrototypeArchaic","Rainslasher","RedhornStonethresher","RoyalGreatsword","SacrificialGreatsword","SerpentSpine","SkyriderGreatsword","SkywardPride","SnowTombedStarsilver","SongOfBrokenPines","TheBell","TheUnforged","WasterGreatsword","Whiteblind","WhiteIronGreatsword","WolfsGravestone"],N=["BeginnersProtector","BlackcliffPole","BlackTassel","CalamityQueller","CrescentPike","Deathmatch","DragonsBane","DragonspineSpear","EngulfingLightning","FavoniusLance","Halberd","IronPoint","KitainCrossSpear","LithicSpear","MissiveWindspear","Moonpiercer","PrimordialJadeWingedSpear","PrototypeStarglitter","RoyalSpear","SkywardSpine","StaffOfHoma","StaffOfTheScarletSands","TheCatch","VortexVanquisher","WavebreakersFin","WhiteTassel"],F=["AlleyHunter","AmosBow","AquaSimulacra","BlackcliffWarbow","CompoundBow","ElegyForTheEnd","EndOfTheLine","FadingTwilight","FavoniusWarbow","Hamayumi","HuntersBow","HuntersPath","KingsSquire","Messenger","MitternachtsWaltz","MouunsMoon","PolarStar","Predator","PrototypeCrescent","RavenBow","RecurveBow","RoyalBow","Rust","SacrificialBow","SeasonedHuntersBow","SharpshootersOath","SkywardHarp","Slingshot","TheStringless","TheViridescentHunt","ThunderingPulse","WindblumeOde"],$=["ApprenticesNotes","AThousandFloatingDreams","BlackcliffAgate","DodocoTales","EmeraldOrb","EverlastingMoonglow","EyeOfPerception","FavoniusCodex","Frostbearer","FruitOfFulfillment","HakushinRing","KagurasVerity","LostPrayerToTheSacredWinds","MagicGuide","MappaMare","MemoryOfDust","OathswornEye","OtherworldlyStory","PocketGrimoire","PrototypeAmber","RoyalGrimoire","SacrificialFragments","SkywardAtlas","SolarPearl","TheWidsith","ThrillingTalesOfDragonSlayers","TulaytullahsRemembrance","TwinNephrite","WanderingEvenstar","WineAndSong"],A=["flower","plume","sands","goblet","circlet"],B=["TravelerAnemo","TravelerGeo","TravelerElectro","TravelerDendro"];function R(e,t,n,a,s,r){let o=r;const i={pruneNodeRange:!0},l={pruneNodeRange:!0},c={reaffine:!0},u={pruneOrder:!0,pruneArtRange:!0,pruneNodeRange:!0};let d=0;for(;Object.values(o).some((e=>e))&&d++<20;){if(o.pruneOrder){delete o.pruneOrder;const e=C(n,a,s);n!==e&&(n=e,o=Object.assign({},o,i))}if(o.pruneArtRange){delete o.pruneArtRange;const a=P(e,n,t);n!==a&&(n=a,o=Object.assign({},o,l))}if(o.pruneNodeRange){delete o.pruneNodeRange;const t=I(e,n);e!==t&&(e=t,o=Object.assign({},o,c))}if(o.reaffine){delete o.reaffine;const{nodes:t,arts:a}=D(e,n);e===t&&n===a||(e=t,n=a,o=Object.assign({},o,u))}}return{nodes:e,arts:n}}function D(e,t,n=!1){const a=new Set,r=new Set;function i(e,t){t?a.add(e):e.operands.forEach((e=>a.has(e)&&r.add(e)))}const l=new Set;if(f(e,(e=>{}),(e=>{const{operation:t}=e;switch(t){case"read":l.add(e.path[1]),i(e,!0);break;case"add":i(e,e.operands.every((e=>a.has(e))));break;case"mul":{const t=e.operands.filter((e=>"const"!==e.operation));i(e,0===t.length||1===t.length&&a.has(t[0]));break}case"const":i(e,!0);break;case"res":case"threshold":case"sum_frac":case"max":case"min":i(e,!1);break;default:c(t)}})),[...r].every((({operation:e})=>"read"===e||"const"===e))&&Object.keys(t.base).length===l.size)return{nodes:e,arts:t};let d=-1;function h(){for(;l.has(""+ ++d););return`${d}`}e.forEach((e=>a.has(e)&&r.add(e)));const p=[...r].filter((e=>"const"!==e.operation)),g=new Map(p.map((e=>{return[e,n||"read"!==e.operation||"dyn"!==e.path[0]?Object.assign({},(t=["dyn",`${h()}`],{operation:"read",operands:[],path:t,info:a,type:"number"}),{accu:"add"}):e];var t,a})));function v(e){const t=S([...g.keys()],{dyn:o(e,(e=>u(e)))},(e=>!0));return Object.fromEntries([...g.values()].map(((e,n)=>[e.path[1],t[n].value])))}const b={nodes:e=m(e,(e=>{var t;return null!=(t=g.get(e))?t:e}),(e=>e)),arts:{base:v(t.base),values:s(A,(e=>t.values[e].map((({id:e,set:t,values:n})=>({id:e,set:t,values:v(n)})))))}},w=Object.entries(v({}));for(const s of Object.values(b.arts.values))for(const{values:e}of s)for(const[t,n]of w)e[t]-=n;return b}function C(e,t,n){var a;let r=!1;const o=!(null!=(a=n.rainbow)&&a.length),i=Object.keys(e.base),l=new Set(Object.entries(n).filter((([e,t])=>t.length)).map((([e])=>e))),c=new Set(Object.entries(n).filter((([e,t])=>t.includes(2)&&!t.includes(4))).map((([e])=>e))),u=s(A,(n=>{const a=e.values[n],s=a.filter((e=>{let n=0;return a.every((a=>{const s=i.every((t=>{var n,s;return(null!=(n=a.values[t])?n:0)>=(null!=(s=e.values[t])?s:0)})),r=i.some((t=>{var n,s;return(null!=(n=a.values[t])?n:0)>(null!=(s=e.values[t])?s:0)})),u=s&&(r||a.id>e.id),d=o&&!l.has(a.set)&&!c.has(e.set)||e.set===a.set;return u&&d&&n++,n<t}))}));return s.length!==a.length&&(r=!0),s}));return r?{base:e.base,values:u}:e}function P(e,t,n){const a=Object.fromEntries(Object.entries(t.base).map((([e,t])=>[e,{min:t,max:t}]))),r={arts:t};for(;;){const t=s(A,(e=>U(r.arts.values[e]))),o=s(A,(e=>K(Object.entries(t).map((t=>t[0]===e?a:t[1])).filter((e=>e)))));let i=!1;const l=s(A,(t=>{const a=r.arts.values[t].filter((a=>{const s=K([U([a]),o[t]]),r=W(e,s);return e.every(((e,t)=>{var a;return r.get(e).max>=(null!=(a=n[t])?a:-1/0)}))}));return a.length!==r.arts.values[t].length&&(i=!0),a}));if(!i)break;r.arts={base:r.arts.base,values:l}}return r.arts}function I(e,t){const n=W(e,K([Object.fromEntries(Object.entries(t.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(t.values).map((e=>U(e)))]));return m(e,(e=>{{const{min:t,max:a}=n.get(e);if(t===a)return u(t)}const{operation:t}=e,a=e.operands.map((e=>n.get(e)));switch(t){case"threshold":{const[t,n,s,r]=a;if(t.min>=n.max)return e.operands[2];if(t.max<n.min)return e.operands[3];if(s.max===s.min&&r.max===r.min&&s.min===r.min&&isFinite(s.min))return u(s.max);break}case"min":{const t=e.operands.filter(((e,t)=>{const n=a[t];return a.every(((e,t)=>n.min<=e.max))}));if(t.length<a.length)return function(...e){return{operation:"min",operands:h(e)}}(...t);break}case"max":{const t=e.operands.filter(((e,t)=>{const n=a[t];return a.every((e=>n.max>=e.min))}));if(t.length<a.length)return function(...e){return{operation:"max",operands:h(e)}}(...t);break}}return e}),(e=>e))}function K(e){const t={};return e.forEach((e=>{Object.entries(e).forEach((([e,n])=>{t[e]?(t[e].min+=n.min,t[e].max+=n.max):t[e]=Object.assign({},n)}))})),t}function U(e){const t={};return e.length&&(Object.keys(e[0].values).filter((t=>e.every((e=>e.values[t])))).forEach((n=>t[n]={min:e[0].values[n],max:e[0].values[n]})),e.forEach((({values:e})=>{for(const[n,a]of Object.entries(e))t[n]?(t[n].max<a&&(t[n].max=a),t[n].min>a&&(t[n].min=a)):t[n]={min:0,max:a}}))),t}function W(e,t){const n=new Map;return f(e,(e=>{}),(e=>{var a;const{operation:s}=e,r=e.operands.map((e=>n.get(e)));let o;switch(s){case"read":if("dyn"!==e.path[0])throw new Error(`Found non-dyn path ${e.path} while computing range`);o=null!=(a=t[e.path[1]])?a:{min:0,max:0};break;case"const":o=z([e.value]);break;case"add":case"min":case"max":o={min:w[s](r.map((e=>e.min))),max:w[s](r.map((e=>e.max)))};break;case"res":o={min:w[s]([r[0].max]),max:w[s]([r[0].min])};break;case"mul":o=r.reduce(((e,t)=>z([e.min*t.min,e.min*t.max,e.max*t.min,e.max*t.max])));break;case"threshold":o=r[0].min>=r[1].max?r[2]:r[0].max<r[1].min?r[3]:z([],[r[2],r[3]]);break;case"sum_frac":{const[e,t]=r,n={min:e.min+t.min,max:e.max+t.max};o=n.min<=0&&n.max>=0?e.min<=0&&e.max>=0?{min:NaN,max:NaN}:{min:-1/0,max:1/0}:z([e.min/n.min,e.min/n.max,e.max/n.min,e.max/n.max]);break}default:c(s)}n.set(e,o)})),n}function z(e,t=[]){const n=Math.max(...e,...t.map((e=>e.max)));return{min:Math.min(...e,...t.map((e=>e.min))),max:n}}function G(e,t){return{base:e.base,values:s(A,(n=>{const a=t[n];switch(a.kind){case"id":return e.values[n].filter((e=>a.ids.has(e.id)));case"exclude":return e.values[n].filter((e=>!a.sets.has(e.set)));case"required":return e.values[n].filter((e=>a.sets.has(e.set)))}}))}}function L(e){return A.reduce(((t,n)=>t*e.values[n].length),1)}function q(e){return new Set(null!=e&&e.includes(2)?e.includes(4)?[0,1]:[0,1,4,5]:null!=e&&e.includes(4)?[0,1,2,3]:[0,1,2,3,4,5])}function*H(e,t){const n=[...new Set(t)],a=q(e.rainbow);let r=[];function i(e,t){if(!l(t+1,4).some((t=>5!==e[t])))return(e=[...e])[t]=5,e.reduce(((e,t)=>6*e+t),0)}!function e(t,n,s){if(5!==t.length){for(const a of n)e([...t,a],n,s.filter((e=>e!==a)));e([...t,t.length],new Set([...n,t.length]),[...s,t.length])}else a.has(s.length)&&r.push(t)}([0],new Set([0]),[0]);for(let s=4;s>=0;s--){const e=new Map;for(const t of r){var c;const n=i(t,s);void 0!==n&&e.set(n,(null!=(c=e.get(n))?c:new Set(t.slice(0,s)).size+1)-1)}for(const[t,n]of e.entries())if(0===n){const e=[...r.find((e=>i(e,s)===t))];e[s]=5,r=r.filter((e=>i(e,s)!==t)),r.push(e)}}const u={kind:"exclude",sets:new Set},d=s(A,(e=>u)),h=Object.assign({},o(e,(e=>0)),s(n,(e=>0))),p=o(e,q);function*f(e){const t=new Set;let a=[],s=[];for(const n of e)a.push([]),5===n?s.push(a.length-1):a[n].push(a.length-1);a=a.filter((e=>e.length)).sort(((e,t)=>t.length-e.length));let r=s.length;function*o(e){const t=s.length-e,a=[],r=[],i=[];let c=0;for(const s of n){const e=p[s],n=h[s];e&&(l(1,t).every((t=>!e.has(n+t)))?i.push(s):e.has(n)?l(0,t).some((t=>!e.has(n+t)))&&a.push(s):(c+=[...e].find((e=>e>n))-n,r.push(s)))}if(!(c>t))if(e!==s.length)if(c!==t){for(const t of[...a,...r])h[t]++,d[A[s[e]]]={kind:"required",sets:new Set([t])},yield*o(e+1),h[t]--;d[A[s[e]]]={kind:"exclude",sets:new Set([...r,...i,...a])},yield*o(e+1)}else for(const n of r)h[n]++,d[A[s[e]]]={kind:"required",sets:new Set([n])},yield*o(e+1),h[n]--;else yield Object.assign({},d)}yield*function*e(s){if(s===a.length)return yield*o(0);for(const o of n){if(t.has(o))continue;const n=a[s].length,c=p[o];let u=0;var i;if(c&&!c.has(n))if(u=(null!=(i=l(n+1,5).find((e=>c.has(e))))?i:6)-n,u>r)continue;t.add(o),h[o]=a[s].length,a[s].forEach((e=>d[A[e]]={kind:"required",sets:new Set([o])})),r-=u,yield*e(s+1),r+=u,h[o]=0,t.delete(o)}}(0)}for(const s of r)yield*f(s)}class V{constructor({arts:e,optTarget:t,constraints:n,topN:a},s){this.min=void 0,this.nodes=void 0,this.arts=void 0,this.topN=void 0,this.filters=[],this.interim=void 0,this.firstUncalculated=0,this.callback=void 0,this.arts=e,this.min=[-1/0,...n.map((e=>e.min))],this.nodes=[t,...n.map((e=>e.value))],this.callback=s,this.topN=a,J(this.nodes,e)}addFilter(e){const t=G(this.arts,e),n=L(t);n&&this.filters.push({nodes:this.nodes,arts:t,maxConts:[],approxs:[],age:0,count:n})}setThreshold(e){e>this.min[0]&&(this.min[0]=e,this.firstUncalculated=0,this.filters.forEach((e=>delete e.calculated)))}*split(e,t){for(this.addFilter(e);this.filters.length;){const e=this.getApproxFilter(),{arts:n,count:a}=e;if(a<=t){if(!a)continue;this.firstUncalculated<this.filters.length&&this.calculateFilter(this.firstUncalculated++),this.reportInterim(!1),yield o(n.values,(e=>({kind:"id",ids:new Set(e.map((e=>e.id)))})))}else this.splitOldFilter(e)}this.reportInterim(!0)}reportInterim(e=!1){this.interim&&(this.interim.skipped>1e6||!0===e)&&(this.callback(this.interim),this.interim=void 0)}splitOldFilter({nodes:e,arts:t,approxs:n,age:a}){const s=o(t.values,(e=>{var t,a;const s=e.map((e=>({art:e,cont:n[0].conts[e.id]}))).sort((({cont:e},{cont:t})=>t-e)),r=null!=(t=null==(a=s[s.length-1])?void 0:a.cont)?t:0;let o=s.reduce(((e,{cont:t})=>e+t),-r*s.length)/3;const i=Math.max(1,s.findIndex((({cont:e})=>(o-=e-r)<=0))),l=s.splice(i).map((({art:e})=>e)),c=s.map((({art:e})=>e));return{high:{arts:c,maxConts:n.map((e=>_(c,e)))},low:{arts:l,maxConts:n.map((e=>_(l,e)))}}})),r=Object.keys(s),{filters:i}=this,l={},c={};!function u(d){if(!r.length){const s=n.map(((e,t)=>o(c,(e=>e[t])))),r={base:t.base,values:Object.assign({},l)};return void i.push({nodes:e,arts:r,maxConts:s,approxs:n,age:a+1,count:d})}const h=r.pop(),{high:p,low:f}=s[h];f.arts.length&&(l[h]=f.arts,c[h]=f.maxConts,u(d*f.arts.length)),p.arts.length&&(l[h]=p.arts,c[h]=p.maxConts,u(d*p.arts.length)),r.push(h)}(1)}getApproxFilter(){return this.calculateFilter(this.filters.length-1),this.firstUncalculated>this.filters.length&&(this.firstUncalculated=this.filters.length),this.filters.pop()}calculateFilter(e){let{nodes:t,arts:n,maxConts:a,approxs:s,age:i,count:l,calculated:c}=this.filters[e];if(c)return;(i<3||i%5==2)&&(({nodes:t,arts:n}=R(t,this.min,n,this.topN,{},{pruneNodeRange:!0})),Object.values(n.values).every((e=>e.length))&&(s=function(e,t){return J(e,t).map((e=>({base:X(t.base,e,e.$c),conts:r(Object.values(t.values).flat(),(t=>[t.id,X(t.values,e,0)]))})))}(t,n),a=s.map((e=>o(n.values,(t=>_(t,e)))))));const u=a.map(((e,t)=>Object.values(e).reduce(((e,t)=>e+t),s[t].base-this.min[t]))),d=o(n.values,((e,t)=>{const n=u.map(((e,n)=>a[n][t]-e));return e.filter((({id:e})=>s.every((({conts:t},a)=>t[e]>=n[a]))))}));n={base:n.base,values:d};const h=L(n);h!==l&&(this.interim?this.interim.skipped+=l-h:this.interim={resultType:"interim",buildValues:void 0,tested:0,failed:0,skipped:l-h}),this.filters[e]={nodes:t,arts:n,maxConts:a,approxs:s,age:i,count:h,calculated:!0}}}function _(e,t){return Math.max(...e.map((({id:e})=>t.conts[e])))}function X(e,t,n){return Object.entries(e).reduce(((e,[n,a])=>{var s;return e+(null!=(s=t[n])?s:0)*a}),n)}function Y(...e){const t={};for(const[a,s]of e)for(const[e,r]of Object.entries(s)){var n;t[e]=(null!=(n=t[e])?n:0)+a*r}return t}function J(e,t){const n=Y([1,t.base],...Object.values(t.values).map((e=>[1/e.length,Y(...e.map((e=>[1,e.values])))]))),a=e=>X(n,e,e.$c),s=new Map;f(e,(e=>{const{operation:t}=e;switch("mul"===t&&s.set(e,{min:NaN,max:NaN}),t){case"mul":case"min":case"max":case"threshold":case"res":case"sum_frac":e.operands.forEach((e=>s.set(e,{min:NaN,max:NaN})))}}),(e=>e));const r=W([...s.keys()],function(e){return K([Object.fromEntries(Object.entries(e.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(e.values).map((e=>U(e)))])}(t));for(const[c,d]of r.entries())s.set(c,d);function o(e,t,n,a){return Y([1,{$c:n-e*t}],[e,a])}function i(e,t,n,a,s,r){return Math.abs(e-n)<1e-10?{$c:r?Math.max(t,a):Math.min(t,a)}:o((a-t)/(n-e),e,t,s)}const l="u",u="l";return g(e,l,((e,t,n)=>{const{operation:r}=e,d=(e,a=t)=>n(e,a),f=t===l?u:l;if("o"===t){const{min:t,max:n}=s.get(e);if(t<0&&n>0)throw new Z("Zero-crossing",r);return d(e,n<=0?u:l)}switch(r){case"const":return{$c:e.value};case"read":return{$c:0,[e.path[1]]:1};case"add":return Y(...e.operands.map((e=>[1,d(e)])));case"min":case"max":{const n=w[r],a=e.operands.filter((e=>"const"!==e.operation)),[o]=a;if(1!==a.length)throw new Z("Multivariate",r);const c=d(o),h=n(e.operands.filter((e=>"const"===e.operation)).map((e=>e.value)));if("max"===r&&t===u||"min"===r&&t===l)return c;const{min:p,max:f}=s.get(o);return i(p,n([p,h]),f,n([f,h]),c,t===l)}case"res":{if(t!==l)throw new Z("Unsupported direction",r);const n=w[r],[a]=e.operands,{min:o,max:c}=s.get(a),u=d(a,f);return o<0&&c<1.75?Y([1,{$c:1}],[-.5,u]):i(o,n([o]),c,n([c]),u,t===l)}case"sum_frac":{if(t!==l)throw new Z("Unsupported direction",r);const[n,a]=e.operands;if("const"!==a.operation)throw new Z("Non-constant node",r);const i=d(n),c=a.value,{min:u,max:h}=s.get(n),p=Math.sqrt((u+c)*(h+c));if(u<=-c)throw new Z("Unsupported pattern",r);return o(c/(c+p)/(c+p),p,p/(p+c),i)}case"threshold":{const[n,a,i,c]=e.operands;if("const"!==c.operation||"const"!==a.operation)throw new Z("Non-constant node",r);if("const"!==i.operation){if(0!==c.value)throw new Z("Unsupported pattern",r);const e=(m=a,g=1,v=c,{operation:"threshold",operands:[p(n),p(m),p(g),p(v)],info:b}),t=function(...e){return{operation:"mul",operands:h(e)}}(e,i),{min:o,max:l}=s.get(i);return s.set(e,{min:0,max:1}),s.set(t,{min:Math.min(o,0),max:Math.max(l,0)}),d(t)}const{min:u,max:w}=s.get(n),y=a.value,k=i.value,x=c.value,S=k>x==(t===l);return o((k-x)/(S?y-u:w-y),y,S?k:x,d(n,k>x?t:f))}case"mul":{const{min:n,max:o}=s.get(e);if(n<0&&o>0)throw new Z("Zero-crossing",r);if(n<0&&t!==u||o>0&&t!==l)throw new Z("Unsupported direction",r);const i=[...e.operands],c=[];let h=1;for(;i.length;){const e=i.pop();"mul"===e.operation?i.push(...e.operands):"const"===e.operation?h*=e.value:c.push(e)}const p=c.map((e=>d(e,"o"))),f=c.map((e=>s.get(e))),m=p.map(a),g=m.reduce(((e,t,n)=>e+(t>=0?f[n].max:f[n].min)/t),0),v=m.reduce(((e,t)=>e*g*t/p.length),h/g);return Y(...p.map(((e,t)=>[v/m[t],e])))}default:c(r)}var m,g,v,b}))}class Z extends Error{constructor(e,t){super(`Found ${e} in ${t} node when generating polynomial upper bound`)}}class Q{constructor({arts:e,optTarget:t,constraints:n,plotBase:a,topN:s},r){this.builds=[],this.buildValues=void 0,this.plotData=void 0,this.threshold=-1/0,this.topN=void 0,this.min=void 0,this.arts=void 0,this.nodes=void 0,this.callback=void 0,this.arts=e,this.min=n.map((e=>e.min)),this.topN=s,this.callback=r,this.nodes=n.map((e=>e.value)),this.nodes.push(t),a&&(this.plotData={},this.nodes.push(a)),this.nodes=function(e,t,n=(e=>!1)){let a=S(e,t,n);return a=k(a),x(a)}(this.nodes,{},(e=>!1))}setThreshold(e){this.threshold>e&&(this.threshold=e)}compute(e){const{min:t}=this,n=this;let a=G(this.arts,e);const s=L(a),r=this.builds.length;let o=this.nodes;({nodes:o,arts:a}=R(o,t,a,this.topN,{},{pruneArtRange:!0,pruneNodeRange:!0}));const i=Object.values(a.values).sort(((e,t)=>e.length-t.length)),l=function(e,t,n,a){let s='\n"use strict";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0',r=1;const o=new Map;return f(e,(e=>{}),(e=>{const{operation:i,operands:l}=e,u="x"+r++,d=l.map((e=>o.get(e)));switch(o.set(e,u),i){case"read":{const r=n(e);let o=new Array(a).fill(null).map(((e,t)=>`(b[${t}].values["${r}"] ?? 0)`));t[r]&&0!==t[r]&&(o=[t[r].toString(),...o]),s+=`,${u}=${o.join("+")}`;break}case"const":o.set(e,`(${e.value})`);break;case"add":case"mul":s+=`,${u}=${d.join("add"===i?"+":"*")}`;break;case"min":case"max":s+=`,${u}=Math.${i}(${d})`;break;case"threshold":{const[e,t,n,a]=d;s+=`,${u}=(${e}>=${t})?${n}:${a}`;break}case"res":s+=`,${u}=res(${d[0]})`;break;case"sum_frac":s+=`,${u}=${d[0]}/(${d[0]}+${d[1]})`;break;default:c(i)}})),s+=`;\nreturn [${e.map((e=>o.get(e)))}]`,new Function("b",s)}(o,a.base,(e=>e.path[1]),i.length),u=Array(i.length),d={tested:0,failed:0,skipped:s-L(a)};!function e(a){if(a<0){const e=l(u);if(t.every(((t,n)=>t<=e[n]))){const a=e[t.length],{builds:s,plotData:r}=n;let o;if(a>=n.threshold&&(o={value:a,artifactIds:u.map((e=>e.id)).filter((e=>e))},s.push(o)),r){const n=e[t.length+1];(!r[n]||r[n].value<a)&&(o||(o={value:a,artifactIds:u.map((e=>e.id)).filter((e=>e))}),o.plot=n,r[n]=o)}}else d.failed+=1}else i[a].forEach((t=>{u[a]=t,e(a-1)})),0===a&&(d.tested+=i[0].length,d.tested>65536&&n.interimReport(d))}(i.length-1),this.interimReport(d,this.builds.length>r)}refresh(e){var t;const{topN:n}=this;var a;(Object.keys(null!=(t=this.plotData)?t:{}).length>=1e5&&(this.plotData=function(e){let t=.01,n=new Set(e.flatMap((e=>Object.values(e).map((e=>Math.round(e.plot/t))))));for(;n.size>1500;)t*=2,n=new Set([...n].map((e=>Math.round(e/2))));const a={};for(const s of e)for(const e of Object.values(s)){const n=Math.round(e.plot/t)*t;(!a[n]||a[n].value<e.value)&&(a[n]=e)}return a}([this.plotData])),this.builds.length>=1e3||e)&&(this.builds=this.builds.sort(((e,t)=>t.value-e.value)).slice(0,n),this.buildValues=this.builds.map((e=>e.value)),this.threshold=Math.max(this.threshold,null!=(a=this.buildValues[n-1])?a:-1/0))}interimReport(e,t=!1){this.refresh(t),this.callback(Object.assign({resultType:"interim",buildValues:this.buildValues},e)),this.buildValues=void 0,e.tested=0,e.failed=0,e.skipped=0}}class ee{constructor({arts:e},t){this.arts=void 0,this.stack=[],this.arts=e}setThreshold(e){}add(e,t){this.stack.push({filter:e,count:L(G(this.arts,e)),splittedBy:t})}*split(e,t){this.add(e,"set");for(let n=this.stack.pop();n;n=this.stack.pop()){const{filter:e,count:a,splittedBy:s}=n;if(a<=t)yield e;else switch(s){case"set":this.splitBySet(e);break;case"id":this.splitByID(e,a,t);break;default:c(s)}}}splitBySet(e){const t=G(this.arts,e),n=j.map((e=>({slot:e,sets:new Set(t.values[e].map((e=>e.set)))}))).filter((({sets:e})=>e.size>1));if(!n.length)return this.add(e,"id");const{sets:a,slot:s}=n.reduce(((e,t)=>e.sets.size<t.sets.size?e:t));a.forEach((t=>this.add(Object.assign({},e,{[s]:{kind:"required",sets:new Set([t])}}),"set")))}splitByID(e,t,n){const a=G(this.arts,e),{slot:s,length:r}=j.map((e=>({slot:e,length:a.values[e].length}))).filter((e=>e.length>1)).reduce(((e,t)=>e.length<t.length?e:t)),o=Math.ceil(t/n),i=Math.min(o,r),l=Array(i).fill(0).map((e=>new Set));a.values[s].forEach((({id:e},t)=>l[t%i].add(e))),l.forEach((t=>this.add(Object.assign({},e,{[s]:{kind:"id",ids:t}}),"id")))}}let te,ne;onmessage=async e=>{const{data:t}=e,{command:n}=t;switch(n){case"split":for(const e of te.split(t.filter,t.maxIterateSize))postMessage({command:"iterate",filter:e}),await Promise.resolve();break;case"iterate":ne.compute(t.filter);break;case"threshold":return te.setThreshold(t.threshold),void ne.setThreshold(t.threshold);case"finalize":{ne.refresh(!0);const{builds:e,plotData:t}=ne;postMessage({resultType:"finalize",builds:e,plotData:t});break}case"count":{const{exclusion:e,maxIterateSize:n}=t,a=ne.arts,s=function*(e,t){const n=o(t.values,(e=>new Set(e.map((e=>e.set)))));e:for(const a of e){for(const[e,t]of Object.entries(a)){const a=n[e];switch(t.kind){case"required":if([...t.sets].every((e=>!a.has(e))))continue e;break;case"exclude":if([...a].every((e=>t.sets.has(e))))continue e}}yield a}}(H(e,[...new Set(Object.values(a.values).flatMap((e=>e.map((e=>e.set)))))]),a);let r=0;for(const t of s)postMessage({command:"split",filter:t,maxIterateSize:n}),r+=L(G(a,t));postMessage({resultType:"count",count:r});break}case"setup":try{te=new V(t,(e=>postMessage(e)))}catch(a){te=new ee(t,(e=>postMessage(e)))}ne=new Q(t,(e=>postMessage(e)));break;default:c(n)}postMessage({resultType:"done"})}}},a={};function s(e){var t=a[e];if(void 0!==t)return t.exports;var r=a[e]={exports:{}};return n[e](r,r.exports,s),r.exports}s.m=n,s.x=()=>{var e=s.O(void 0,[531],(()=>s(61729)));return e=s.O(e)},e=[],s.O=(t,n,a,r)=>{if(!n){var o=1/0;for(u=0;u<e.length;u++){for(var[n,a,r]=e[u],i=!0,l=0;l<n.length;l++)(!1&r||o>=r)&&Object.keys(s.O).every((e=>s.O[e](n[l])))?n.splice(l--,1):(i=!1,r<o&&(o=r));if(i){e.splice(u--,1);var c=a();void 0!==c&&(t=c)}}return t}r=r||0;for(var u=e.length;u>0&&e[u-1][2]>r;u--)e[u]=e[u-1];e[u]=[n,a,r]},s.f={},s.e=e=>Promise.all(Object.keys(s.f).reduce(((t,n)=>(s.f[n](e,t),t)),[])),s.u=e=>e+".70e812a17b341528.js",s.miniCssF=e=>{},s.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),s.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e;s.g.importScripts&&(e=s.g.location+"");var t=s.g.document;if(!e&&t&&(t.currentScript&&(e=t.currentScript.src),!e)){var n=t.getElementsByTagName("script");n.length&&(e=n[n.length-1].src)}if(!e)throw new Error("Automatic publicPath is not supported in this browser");e=e.replace(/#.*$/,"").replace(/\?.*$/,"").replace(/\/[^\/]+$/,"/"),s.p=e})(),(()=>{var e={729:1};s.f.i=(t,n)=>{e[t]||importScripts(s.p+s.u(t))};var t=self.webpackChunk=self.webpackChunk||[],n=t.push.bind(t);t.push=t=>{var[a,r,o]=t;for(var i in r)s.o(r,i)&&(s.m[i]=r[i]);for(o&&o(s);a.length;)e[a.pop()]=1;n(t)}})(),t=s.x,s.x=()=>s.e(531).then(t);s.x()})();