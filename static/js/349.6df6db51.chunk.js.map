{"version":3,"file":"static/js/349.6df6db51.chunk.js","mappings":"gHAqFO,SAASA,EAAaC,EAAyBC,GACpD,GAAKD,GAAQC,EAEb,OADCC,MAAMC,QAAQF,IAASG,QAAQC,MAAMJ,GAC/BA,EAAKK,QAAO,SAACC,EAAGC,GAAJ,cAAUD,QAAV,IAAUA,OAAV,EAAUA,EAAIC,EAAd,GAAkBR,EACtC,CA2BM,SAASS,EAA2CR,EAAoBS,GAC7E,OAAOC,OAAOC,YAAYX,EAAKS,KAAI,SAACF,EAAGK,GAAJ,MAAU,CAACL,EAAGE,EAAIF,EAAGK,GAArB,IACpC,CAEM,SAASC,EAAmDC,EAAqBL,GACtF,OAAOC,OAAOC,YAAYG,EAAML,KAAI,SAACM,EAAGH,GAAJ,OAAUH,EAAIM,EAAGH,EAAjB,IACrC,CAIM,SAASI,EAAkCjB,EAA4BkB,GAC5E,OAAOP,OAAOC,YAAYD,OAAOQ,QAAQnB,GAAKU,KAC5C,WAASG,GAAT,mBAAEL,EAAF,KAAKY,EAAL,WAAe,CAACZ,EAAGU,EAAGE,EAAGZ,EAAGK,GAA5B,IAEH,CAED,IAAMQ,GAAQ,eAAG,SAAXA,EAAsBC,EAAcC,GAAzB,4EACNV,EAAIS,EADE,YACIT,GAAKU,GADT,gBACkB,OADlB,SACwBV,EADxB,OACaA,IADb,mDAAXQ,EAAW,IAKV,SAASG,EAAMF,EAAcC,GAClC,OAAO,OAAIF,EAASC,EAAMC,GAC3B,CAEM,SAASE,EAAkBC,GAChC,MAAM,IAAIC,MAAJ,2CAA8CD,GACrD,CCtI4BE,EAASC,IAAK,CAAEC,KAAM,SAChCC,EAAQ,GAAaA,EAAQ,GAC5BH,EAAS,QAKtB,SAASA,EAASF,EAAoCM,GAC3D,MAAwB,kBAAVN,EACV,CAAEO,UAAW,QAASC,SAAU,GAAIC,KAAM,SAAUT,MAAAA,EAAOM,KAAAA,GAC3D,CAAEC,UAAW,QAASC,SAAU,GAAIC,KAAM,SAAUT,MAAAA,EAAOM,KAAAA,EAChE,CAEM,SAASD,EAAQL,EAAeM,GAGrC,OAFIN,GAASU,OAAOC,UAAY,MAAKX,EAAQY,KACzCZ,IAAUU,OAAOC,UAAY,MAAKX,GAASY,KACxCV,EAASF,GAAD,QAAUa,KAAM,KAAQP,GACxC,CAkBM,SAASQ,IAAoC,IAAD,uBAA5BC,EAA4B,yBAA5BA,EAA4B,gBACjD,MAAO,CAAER,UAAW,MAAOC,SAAUQ,EAAQD,GAC9C,CAEM,SAASE,IAAoC,IAAD,uBAA5BF,EAA4B,yBAA5BA,EAA4B,gBACjD,MAAO,CAAER,UAAW,MAAOC,SAAUQ,EAAQD,GAC9C,CA6FM,SAASG,EAAWC,EAAyBb,GAClD,MAAO,CAAEC,UAAW,OAAQC,SAAU,GAAIW,KAAAA,EAAMb,KAAAA,EAAMG,KAAM,SAC7D,CAuBD,SAASO,EAAQD,GACf,OAAOA,EAAO/B,KAAI,SAAAgB,GAAK,MAAqB,kBAAVA,EAAqBA,EAAQE,EAASF,EAAjD,GACxB,CC5JM,SAASoB,EAAaC,EAAkBC,EAAkCC,GAC/E,IAAMC,EAAW,IAAIC,IAAaC,EAAU,IAAID,IAqBhDJ,EAASM,SAnBT,SAASC,EAASC,GACZH,EAAQI,IAAID,KAEZL,EAASM,IAAID,GACfnD,QAAQC,MAAM,uDAGhB6C,EAASO,IAAIF,GAEbP,EAAQO,GAERA,EAAQrB,SAASmB,QAAQC,GAEzBL,EAASM,GAETL,EAASQ,OAAOH,GAChBH,EAAQK,IAAIF,IACb,GAGF,CAGM,SAASI,EAAYZ,EAAkBa,EAAqCC,GACjF,IAAMX,EAAW,IAAIC,IACfW,EAAgB,IAAIC,IACpBC,EAAiB,IAAID,IAE3B,SAASE,EAAMV,GACb,IAAIP,EAAUc,EAAcI,IAAIX,GAChC,GAAIP,EAAS,OAAOA,EACpBA,EAAUY,EAAWL,GAErB,IAAIN,EAAWe,EAAeE,IAAIlB,GAClC,OAAIC,IAEAC,EAASM,IAAIR,IACf5C,QAAQC,MAAM,oDACPuB,EAASC,OAElBqB,EAASO,IAAIT,GAEbC,EAAWY,EASb,SAAkBN,GAChB,IAAMrB,EAAWqB,EAAQrB,SAASxB,IAAIuD,GACtC,OAAOE,EAAWjC,EAAUqB,EAAQrB,UAAYqB,GAAzC,kBAAwDA,GAAxD,IAAiErB,SAAAA,GACzE,CAZwBoB,CAASN,GAAUO,GAE1CL,EAASQ,OAAOV,GAEhBc,EAAcM,IAAIb,EAASN,GAC3Be,EAAeI,IAAIpB,EAASC,GACrBA,GACR,CAOD,IAAMoB,EAAStB,EAASrC,IAAIuD,GAC5B,OAAOE,EAAWE,EAAQtB,GAAYA,EAAWsB,CAClD,CAyBD,SAASF,EAAc5D,EAA6B+D,GAClD,YAAUC,IAANhE,OAA8BgE,IAAND,OAClBC,IAAND,IAEG/D,EAAEiE,SAAWF,EAAEE,QAAUjE,EAAEkE,OAAM,SAAC/C,EAAOb,GAAR,OAAca,IAAU4C,EAAEzD,EAA1B,IACzC,CCnGD,IAAM6D,EAAkG,CACtGlC,IAAK,SAACmC,GAAD,OAAyBC,KAAKpC,IAAL,MAAAoC,MAAI,OAAQD,GAArC,EACLhC,IAAK,SAACgC,GAAD,OAAyBC,KAAKjC,IAAL,MAAAiC,MAAI,OAAQD,GAArC,EACLlB,IAAK,SAACkB,GAAD,OAAyBA,EAAErE,QAAO,SAACC,EAAG+D,GAAJ,OAAU/D,EAAI+D,CAAd,GAAiB,EAAnD,EACLO,IAAK,SAACF,GAAD,OAAyBA,EAAErE,QAAO,SAACC,EAAG+D,GAAJ,OAAU/D,EAAI+D,CAAd,GAAiB,EAAnD,GAEMQ,GAA2E,kBACnFJ,GADmF,IAEtFK,IAAK,YAA8B,IAA5BA,GAA2B,eAChC,OAAIA,EAAM,EAAU,EAAIA,EAAM,EACrBA,GAAO,IAAa,GAAW,EAANA,EAAU,GACrC,EAAIA,CACZ,EACDC,SAAU,SAACL,GAAD,OAAyBA,EAAE,GAAKA,EAAErE,QAAO,SAACC,EAAG+D,GAAJ,OAAU/D,EAAI+D,CAAd,GAAzC,EACVW,UAAW,+BAAEvD,EAAF,KAASuD,EAAT,KAAoBC,EAApB,KAA0BC,EAA1B,YAAsDzD,GAASuD,EAAYC,EAAOC,CAAlF,IAGPC,EAAgC,IAAIjC,IAAIxC,OAAOV,KAAKyE,IAuD1D,SAASW,EAAQtC,GACf,OAAOY,EAAYZ,GAAU,SAAAuC,GAAC,OAAIA,CAAJ,IAAO,SAAAC,GACnC,IAAIlB,EAASkB,EACb,GAAIH,EAA8B5B,IAAI+B,EAAStD,WAAmB,CAChE,IAAMsB,EAAUgC,EACRtD,EAAcsB,EAAdtB,UAEJuD,GAAY,EACVtD,EAAWqB,EAAQrB,SAASuD,SAAQ,SAAAC,GAAG,OAC1CA,EAAIzD,YAAcA,GAAcuD,GAAY,EAAME,EAAIxD,UAAY,CAACwD,EADzB,IAE7CrB,EAASmB,GAAS,kBAAQjC,GAAR,IAAiBrB,SAAAA,IAAaqB,CACjD,CAED,OAAOc,CACR,GACF,CACD,SAASsB,EAAY5C,GACnB,SAAS6C,EAAiBC,GACxB,IAD6D,EACvDxB,EAAS,IAAIN,IAD0C,UAEzC8B,GAFyC,IAE7D,2BAA2B,OAAhBnE,EAAgB,QAAA2C,EAAOD,IAAI1C,GAAO,UAAC2C,EAAOH,IAAIxC,UAAZ,QAAsB,GAAK,EAAE,CAFb,+BAG7D,OAAO2C,CACR,CAaD,IARA,IAAMyB,EAAO,CACXC,OAAQ,CACNC,OAAQ,IAAIjC,IACZhB,SAAU,IAAII,IACdlB,UAAW,QAdoC,aAwBjD,IALA,IAb0B+D,EAatBC,OAAoC,EAElCC,EAAwB,CAAEjE,UAAW6D,EAAKC,OAAO9D,UAAWC,UAfxC8D,EAekEF,EAAKC,OAAOC,QAdjG,OAAIA,GAAQP,SAAQ,+BAAEC,EAAF,KAAOS,EAAP,YAAkBjG,MAAMiG,GAAOC,KAAKV,EAApC,MAgBvBW,EAAwB,IAAItC,IAChC,MAAwBpD,OAAOV,KAAKyE,GAApC,gBAAK,IAAMzC,EAAS,KAClBoE,EAAsBjC,IAAInC,EAAW,GADvC,CA2EA,GAxEAc,EAAWY,EAAYZ,GAAU,SAAAwC,GAC/B,GAAIO,EAAKC,OAAOhD,SAASS,IAAI+B,GAAsB,CACjD,IAAMhC,EAAUgC,EACVe,EAAkB,IAAIvC,IAAI+B,EAAKC,OAAOC,QACtC9D,EAAWqB,EAAQrB,SAASqE,QAAO,SAAAb,GACvC,IAAMS,EAAQG,EAAgBpC,IAAIwB,GAClC,OAAIS,IACFG,EAAgBlC,IAAIsB,EAAKS,EAAQ,IAC1B,EAGV,IAED,OAAKjE,EAASsC,QAEdtC,EAASsE,KAAKN,IACP,kBAAK3C,GAAZ,IAAqBrB,SAAAA,KAFZgE,CAGV,CACD,OAAOX,CACR,IAAE,SAAAA,GACD,IAAKH,EAA8B5B,IAAI+B,EAAStD,WAAmB,OAAOsD,EAC1E,IAAMhC,EAAUgC,EAEhB,GAAIU,GACF,GAAIA,EAAKhE,YAAcsB,EAAQtB,UAAW,CACxC,IADwC,EAClCwE,EAAgBb,EAAcrC,EAAQrB,UAAWwE,EAAe,IAAI3C,IACpE4C,EAAaV,EAAKD,OACpBY,EAAQ,EAH4B,UAKCH,EAActF,WALf,IAKxC,2BAAkE,CAAC,IAAD,uBAAtD0F,EAAsD,KAA1CC,EAA0C,KAC1DC,EAAcnC,KAAKpC,IAAIsE,EAAT,UAAuBH,EAAWzC,IAAI2C,UAAtC,QAAqD,GACrEE,GACFL,EAAatC,IAAIyC,EAAYE,GAC7BH,GAASG,GACJL,EAAahD,OAAOmD,EAC5B,CAXuC,+BAYpCD,EAAQ,IACVX,EAAKD,OAASU,EACdT,EAAKlD,SAASU,IAAIF,GAErB,MACI,CACL,IADK,EACCyD,EAAaX,EAAsBnC,IAAIX,EAAQtB,WAC/C+D,EAASJ,EAAcrC,EAAQrB,UAFhC,UAIsC8E,GAJtC,IAIL,2BAAuD,CAAC,IAAD,uBAA3CC,EAA2C,KAAhCC,EAAgC,KACjDN,EAAQ,EAENF,EAAe,IAAI3C,IAH4B,UAIVmD,EAAgB/F,WAJN,IAIrD,2BAAsE,CAAC,IAAD,uBAA1D0F,EAA0D,KAA9CM,EAA8C,KAC9DhB,EAAQvB,KAAKpC,IAAI2E,EAAT,UAAyBnB,EAAO9B,IAAI2C,UAApC,QAAmD,GAC7DV,IACFO,EAAatC,IAAIyC,EAAYV,GAC7BS,GAAST,EAEZ,CAVoD,+BAWrD,GAAIS,EAAQ,EAAG,CACbX,EAAO,CACLD,OAAQU,EACR3D,SAAU,IAAII,IAAI,CAACI,EAAS0D,IAC5BhF,UAAWsB,EAAQtB,WAErBoE,EAAsBe,QACtB,KACD,CACF,CAxBI,+BAyBAnB,GAAMe,EAAWR,KAAK,CAACjD,EAASyC,GACtC,CAED,OAAOzC,CACR,KAEG0C,EACC,cADKH,EAAKC,OAASE,CAnGyB,IAkBtC,kBAkFN,KACN,CAED,OAAOlD,CACR,CAMM,SAASsE,EAAatE,EAAqBuE,GAAyG,IAArFC,EAAoF,uDAAvE,SAAChC,GAAD,OAAqD,CAArD,EAE3EiC,EAAkB,CAAEC,KAAM,GAAIC,UAAW,IAAI3D,KAC7C4D,EAAiB,IAAI5D,IAAI,CAAC,CAACyD,EAAQ,IAAIzD,OAK7C,SAAS6D,EAAKrE,EAA4BsE,GAAsC,IAAD,EACvEC,EAAMD,EAAQH,UAAUxD,IAAIX,GAClC,GAAIuE,EAAK,OAAOA,EAEhB,IACIzD,EADIpC,EAAcsB,EAAdtB,UAER,OAAQA,GACN,IAAK,QAAS,OAAOsB,EACrB,IAAK,MAAO,IAAK,MAAO,IAAK,MAAO,IAAK,MACvC,IAAM+B,EAAIR,EAAc7C,GAClB8F,EAA4B,GAC5BC,EAA6BzE,EAAQrB,SAASqE,QAAO,SAAAhD,GACzD,IAAM0E,EAASL,EAAKrE,EAASsE,GAC7B,MAA6B,UAArBI,EAAOhG,YACV8F,EAAgBvB,KAAKyB,EAAOvG,QAAQ,EAE1C,IAAEhB,KAAI,SAAAiE,GAAC,OAAIiD,EAAKjD,EAAGkD,EAAZ,IACFK,EAAe5C,EAAEyC,GAcvB,GAAKI,SAASD,IAOP,GAAkB,QAAdjG,GAAwC,IAAjBiG,EAAoB,CACpD7D,EAASzC,EAASsG,GAClB,KACD,OATC,GAAmB,QAAdjG,IACY,QAAdA,GAAuBiG,EAAe,KACxB,QAAdjG,GAAuBiG,EAAe,GAAI,CAC3C7D,EAASzC,EAASsG,GAClB,KACD,CAMCA,IAAiB5C,EAAE,KACrB0C,EAAgBxB,KAAK5E,EAASsG,IACC7D,EAA7B2D,EAAgBxD,QAAU,EAAS,UAAGwD,EAAgB,UAAnB,QAAyBpG,EAAS0D,EAAE,KAC7D,CAAErD,UAAAA,EAAWC,SAAU8F,GACrC,MACF,IAAK,MAAO,IAAK,WACf,IAAM9F,EAAWqB,EAAQrB,SAASxB,KAAI,SAAAiE,GAAC,OAAIiD,EAAKjD,EAAGkD,EAAZ,IACjCvC,EAAIR,EAAc7C,GAEtBoC,EADEnC,EAASuC,OAAM,SAAAE,GAAC,MAAoB,UAAhBA,EAAE1C,SAAN,IACTL,EAAS0D,EAAEpD,EAASxB,KAAI,SAAAiE,GAAC,OAAKA,EAA2BjD,KAAhC,OACzB,kBAAQ6B,GAAR,IAAiBrB,SAAAA,IAC5B,MAEF,IAAK,SACH,IAAMkG,EAAQR,EAAKrE,EAAQrB,SAAS,GAAI2F,GACxC,GAAwB,UAApBO,EAAMnG,UAAuB,CAAC,IAAD,EACzBoG,EAAQ,UAAG9E,EAAQ+E,MAAMF,EAAM1G,cAAvB,QAAkC6B,EAAQrB,SAAS,GACjE,GAAImG,EAAU,CACZhE,EAASuD,EAAKS,EAAUR,GACxB,KACD,CACF,CACD,MAAM,IAAIlG,MAAJ,sBAAyBM,EAAzB,wBAER,IAAK,OACH,IAAMsG,EAAQhF,EAAQrB,SAASsG,MAAK,SAAAC,GAClC,IAAMR,EAASL,EAAKa,EAAIZ,GACxB,GAAyB,UAArBI,EAAOhG,UACT,MAAM,IAAIN,MAAJ,sBAAyBM,EAAzB,wBACR,YAAwBsC,IAAjB0D,EAAOvG,KACf,IACD2C,EAASkE,EAAQX,EAAKW,EAAOV,GAAWjG,OAAS2C,GACjD,MAEF,IAAK,QAAU,IAAD,IACRmE,OAAWnE,EADH,UAEUhB,EAAQrB,UAFlB,IAEZ,2BAAwC,CAAC,IAAD,EAChC+F,EAASL,EADuB,QACTC,GAC7B,GAAyB,UAArBI,EAAOhG,UACT,MAAM,IAAIN,MAAJ,sBAAyBM,EAAzB,8BACgBsC,KAAZ,QAAR,EAAAmE,SAAA,eAAUhH,aAAyC6C,IAAjB0D,EAAOvG,OAAuBuG,EAAOvG,MAAQgH,EAAShH,SAC1FgH,EAAWT,EACd,CARW,+BASZ5D,EAAM,UAAGqE,SAAH,QAAe9G,OAAS2C,GAC9B,MAEF,IAAK,QACH,MAAiChB,EAAQrB,SAASxB,KAAI,SAACiE,GAAD,OAA0BiD,EAAKjD,EAAGkD,EAAlC,IAAtD,eAAOc,EAAP,KAAWC,EAAX,KAAeC,EAAf,KAAsBC,EAAtB,KACA,GAAqB,UAAjBH,EAAG1G,WAA0C,UAAjB2G,EAAG3G,UACjC,MAAM,IAAIN,MAAJ,sBAAyBM,EAAzB,wBACRoC,EAAUsE,EAAGjH,QAAUkH,EAAGlH,MAASmH,EAAQC,EAC3C,MAEF,IAAK,YACH,MAAuCvF,EAAQrB,SAASxB,KAAI,SAAAiE,GAAC,OAAIiD,EAAKjD,EAAGkD,EAAZ,IAA7D,eAAOnG,EAAP,KAAcuD,EAAd,KAAyBC,EAAzB,KAA+BC,EAA/B,KAEEd,EADqB,UAAnBa,EAAKjD,WAA4C,UAAnBkD,EAAKlD,WAAyBiD,EAAKxD,QAAUyD,EAAKzD,MACzEwD,EACkB,UAApBxD,EAAMO,WAAiD,UAAxBgD,EAAUhD,UACvCP,EAAMA,OAASuD,EAAUvD,MAAQwD,EAAOC,GAE3C,kBAAQ5B,GAAR,IAAiBrB,SAAU,CAACR,EAAOuD,EAAWC,EAAMC,KAC5D,MAEF,IAAK,YACH,MAAgB5B,EAAQrB,SAASxB,KAAI,SAAAiE,GAAC,OAAIiD,EAAKjD,EAAGkD,EAAZ,IAA/BO,GAAP,eACA/D,EAA8B,UAApB+D,EAAMnG,UACZL,EAAS2B,EAAQwF,KAAKX,EAAM1G,SADvB,QAAC,UAED6B,GAFA,IAESrB,SAAU,CAACkG,KAC7B,MAEF,IAAK,OACH,IAAMlG,EAAW2F,EAAQJ,KACtB/G,KAAI,SAAAiE,GAAC,OAAI5E,EAAa4E,EAAGpB,EAAQV,KAA5B,IACL0D,QAAO,SAAA5B,GAAC,OAAIA,CAAJ,IAEX,GAAwB,IAApBzC,EAASsC,OACX,GAAI+C,EAAWhE,GAAU,CACvB,IAAQyF,EAASzF,EAATyF,KAEN3E,OADWE,IAATyE,GAA+B,UAATA,EACE,WAAjBzF,EAAQpB,KAAoBP,OAAS2C,GAAa3C,EAASC,KACxDD,EAASkD,EAAckE,GAAM,IAC5C,MAAM3E,EAASd,OAEhBc,OAD0BE,IAAjBhB,EAAQyF,MAA0C,IAApB9G,EAASsC,OACvCoD,EAAK1F,EAASA,EAASsC,OAAS,GAAIqD,GAEpCD,EAAK,CAAE3F,UAAWsB,EAAQyF,KAAM9G,SAAAA,GAAyC2F,GACpF,MAEF,IAAK,OACCtE,EAAQ0F,QAAOpB,EAAUL,GAC7B,IAAM9G,EAAMiH,EAAezD,IAAI2D,GAC3BqB,EAAcxI,EAAIwD,IAAIX,EAAQkE,MAC7ByB,IACHA,EAAc,CAAEzB,KAAK,GAAD,eAAMI,EAAQJ,MAAd,CAAoBlE,EAAQkE,OAAOC,UAAW,IAAI3D,KACtE4D,EAAevD,IAAI8E,EAAa,IAAInF,KACpCrD,EAAI0D,IAAIb,EAAQkE,KAAMyB,IAExB7E,EAASuD,EAAKrE,EAAQrB,SAAS,GAAIgH,GACnC,MACF,QAASzH,EAAkBQ,GAQ7B,OALIoC,EAAOrC,aACTqC,GAAM,UAAQA,IACArC,KAEhB6F,EAAQH,UAAUtD,IAAIb,EAASc,GACxBA,CACR,CAED,IAAMwD,EAAU,CAAEJ,KAAM,CAACH,GAAeI,UAAW,IAAI3D,KAGvD,OAFA4D,EAAevD,IAAIyD,EAAS,IAAI9D,KAChC4D,EAAezD,IAAIsD,GAASpD,IAAIkD,EAAcO,GACvC9E,EAASrC,KAAI,SAAAiE,GAAC,OAAIiD,EAAKjD,EAAGkD,EAAZ,GACtB,CAEM,IC5WMsB,EAAc,CAAC,SAAU,QAAS,QAAS,SAAU,WAwDrDC,GAtDkB,CAAI,YAAJ,OADJ,CAAC,QAAS,MAAO,UAAW,QAAS,OAAQ,OAAQ,WAuDxC,CACtC,SACA,OACA,QACA,cACA,UACA,SACA,UACA,UACA,WACA,SACA,OACA,QACA,QACA,OACA,OACA,SACA,QACA,QACA,QACA,OACA,kBACA,QACA,gBACA,gBACA,SACA,OACA,YACA,cACA,OACA,OACA,QACA,YACA,SACA,OACA,eACA,QACA,UACA,oBACA,OACA,SACA,kBACA,UACA,YACA,QACA,WACA,QACA,YACA,OACA,UACA,SACA,UACA,SACA,QACA,UACA,SACA,YAwBWC,GAtBqB,UAC7BD,EAD6B,CAEhC,aAoB0B,CAC1B,gBACA,cACA,kBACA,mBAE2B,UACxBA,EACAC,GAG6B,UAC7BD,EAxBwB,CAC3B,iBACA,eACA,mBACA,mBAE2B,CAC3B,iBACA,eACA,mBACA,oBA0LwB,UAvKQ,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,iBACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,sBACA,mBAImC,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,qBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIkC,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBA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","sources":["Util/Util.ts","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/ComputeWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BNBSplitWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/DefaultSplitWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\r\nexport function getRandomInt(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\r\n}\r\nexport function getRandomIntInclusive(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\r\n}\r\nexport function getRandomArbitrary(min, max) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\n/**\r\n * Assumes that the object entries are all primitives + objects\r\n * shallow copy the object,\r\n * deep copy the\r\n * @param obj\r\n * @returns\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  if (!obj) return obj\r\n  if (!Object.keys(obj).length) return {} as T\r\n  const ret = { ...obj }\r\n  Object.entries(obj).forEach(([k, v]: any) => {\r\n    if (typeof v !== \"object\") return\r\n    ret[k] = JSON.parse(JSON.stringify(v))\r\n  })\r\n  return ret\r\n}\r\n\r\nexport const clamp = (val, low, high) => {\r\n  if (val < low) return low;\r\n  if (val > high) return high;\r\n  return val\r\n}\r\nexport const getArrLastElement = (arr) =>\r\n  arr.length ? arr[arr.length - 1] : null\r\n\r\nexport const clamp01 = (val) => clamp(val, 0, 1)\r\nexport const clampPercent = (val) => clamp(val, 0, 100)\r\n\r\n//use to pretty print timestamps, or anything really.\r\nexport function strPadLeft(string, pad, length) {\r\n  return (new Array(length + 1).join(pad) + string).slice(-length);\r\n}\r\n\r\n//fuzzy compare strings. longer the distance, the higher the mismatch.\r\nexport function hammingDistance(str1, str2) {\r\n  var dist = 0;\r\n  str1 = str1.toLowerCase();\r\n  str2 = str2.toLowerCase();\r\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\r\n    let match = true\r\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\r\n      match = false\r\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\r\n      match = true\r\n    if (!match) dist++\r\n  }\r\n  return dist;\r\n}\r\n\r\n//multiplies every numerical value in the obj by a multiplier.\r\nexport function objMultiplication(obj, multi) {\r\n  if (multi === 1) return obj\r\n  Object.keys(obj).forEach((prop: any) => {\r\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\r\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\r\n  })\r\n  return obj\r\n}\r\n\r\n//assign obj.[keys...] = value\r\nexport function layeredAssignment(obj, keys: readonly string[], value) {\r\n  keys.reduce((accu, key, i, arr) => {\r\n    if (i === arr.length - 1) return (accu[key] = value)\r\n    if (!accu[key]) accu[key] = {}\r\n    return accu[key]\r\n  }, obj)\r\n  return obj\r\n}\r\n//get the value in a nested object, giving array of path\r\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\r\n  if (!obj || !keys) return undefined;\r\n  !Array.isArray(keys) && console.error(keys)\r\n  return keys.reduce((a, k) => a?.[k], obj)\r\n}\r\n//delete the value denoted by the path. Will also delete empty objects as well.\r\nexport function deletePropPath(obj, path) {\r\n  const tempPath = [...path]\r\n  const lastKey = tempPath.pop()\r\n  const objPathed = objPathValue(obj, tempPath)\r\n  delete objPathed?.[lastKey];\r\n}\r\n\r\nexport function objClearEmpties(o) {\r\n  for (const k in o) {\r\n    if (typeof o[k] !== \"object\") continue\r\n    objClearEmpties(o[k])\r\n    if (!Object.keys(o[k]).length) delete o[k];\r\n  }\r\n}\r\nexport function crawlObject(obj: any, keys: string[] = [], validate: (o: any, keys: string[]) => boolean, cb: (o: any, keys: string[]) => void) {\r\n  if (validate(obj, keys)) cb(obj, keys)\r\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\r\n}\r\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\r\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\r\n\r\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\r\n  return typeof value === \"function\" ? (value as any)(arg) : value\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T, i: number) => [K, V]): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(items.map((t, i) => map(t, i))) as any\r\n}\r\n\r\nexport function objectMap<K extends string, V, T>(obj: Record<K, Exclude<V, undefined>>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\r\n  return Object.fromEntries(Object.entries(obj).map(\r\n    ([k, v], i) => [k, fn(v, k, i)]\r\n  )) as any\r\n}\r\n\r\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\r\n  for (let i = from; i <= to; i++) yield i;\r\n};\r\n\r\n/** range of [from, to], inclusive */\r\nexport function range(from: number, to: number): number[] {\r\n  return [...rangeGen(from, to)]\r\n}\r\n\r\nexport function assertUnreachable(value: never): never {\r\n  throw new Error(`Should not reach this with value ${value}`)\r\n}\r\n\r\n/** Will change `arr` in-place */\r\nexport function toggleInArr<T>(arr: T[], value: T) {\r\n  const ind = arr.indexOf(value)\r\n  if (ind < 0) arr.push(value)\r\n  else arr.splice(ind, 1)\r\n}\r\n\r\nexport function toggleArr<T>(arr: T[], value: T) {\r\n  return arr.includes(value) ? arr.filter(a => a !== value) : [...arr, value]\r\n}\r\n\r\nexport function deepFreeze(obj: any, layers: number = 5) {\r\n  if (layers === 0) return\r\n  if (typeof obj === \"object\")\r\n    Object.values(Object.freeze(obj)).forEach(o => deepFreeze(o, layers--))\r\n}\r\n\r\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\r\n  if (newIndex < 0 || newIndex >= arr.length) return arr\r\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\r\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\r\n  return arr\r\n}\r\n","\r\nimport { objectKeyMap } from \"../Util/Util\"\r\nimport type { ComputeNode, ConstantNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, StrPrioNode, SubscriptNode, ThresholdNode } from \"./type\"\r\n\r\ntype Num = number | NumNode\r\ntype Str = string | undefined | StrNode\r\ntype N_S = Num | Str\r\ntype AnyNode = NumNode | StrNode\r\n\r\nexport const todo: NumNode = constant(NaN, { name: \"TODO\" })\r\nexport const one = percent(1), naught = percent(0)\r\nexport const none = constant(\"none\")\r\n\r\nexport function constant(value: number, info?: Info): ConstantNode<number>\r\nexport function constant(value: string | undefined, info?: Info): ConstantNode<string | undefined>\r\nexport function constant(value: number | string | undefined, info?: Info): ConstantNode<number> | ConstantNode<string | undefined>\r\nexport function constant(value: number | string | undefined, info?: Info): ConstantNode<number | string | undefined> {\r\n  return typeof value === \"number\"\r\n    ? { operation: \"const\", operands: [], type: \"number\", value, info }\r\n    : { operation: \"const\", operands: [], type: \"string\", value, info }\r\n}\r\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\r\nexport function percent(value: number, info?: Info): ConstantNode<number> {\r\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\r\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\r\n  return constant(value, { unit: \"%\", ...info })\r\n}\r\n/** Inject `info` to the node in-place */\r\nexport function infoMut(node: NumNode, info: Info): NumNode\r\nexport function infoMut(node: StrNode, info: Info): StrNode\r\nexport function infoMut(node: AnyNode, info: Info): AnyNode {\r\n  if (info) node.info = { ...node.info, ...info }\r\n  return node\r\n}\r\n\r\n/** `table[string] ?? defaultNode` */\r\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): LookupNode<NumNode>\r\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): LookupNode<StrNode>\r\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: N_S | \"none\", info?: Info): LookupNode<AnyNode> {\r\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\r\n  return { operation: \"lookup\", operands, table, info }\r\n}\r\n\r\n/** min( x1, x2, ... ) */\r\nexport function min(...values: Num[]): ComputeNode {\r\n  return { operation: \"min\", operands: intoOps(values) }\r\n}\r\n/** max( x1, x2, ... ) */\r\nexport function max(...values: Num[]): ComputeNode {\r\n  return { operation: \"max\", operands: intoOps(values) }\r\n}\r\n/** x1 + x2 + ... */\r\nexport function sum(...values: Num[]): ComputeNode {\r\n  return { operation: \"add\", operands: intoOps(values) }\r\n}\r\n/** x1 * x2 * ... */\r\nexport function prod(...values: Num[]): ComputeNode {\r\n  return { operation: \"mul\", operands: intoOps(values) }\r\n}\r\n/** x / (x + c) */\r\nexport function frac(x: Num, c: Num): ComputeNode {\r\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\r\n}\r\nexport function res(base: Num): ComputeNode {\r\n  return { operation: \"res\", operands: intoOps([base]) }\r\n}\r\n\r\n/** v1 == v2 ? eq : neq */\r\nexport function compareEq(v1: Num, v2: Num, eq: Num, neq: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function compareEq(v1: Num, v2: Num, eq: Str, neq: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function compareEq(v1: Str, v2: Str, eq: Num, neq: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function compareEq(v1: Str, v2: Str, eq: Str, neq: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function compareEq(v1: N_S, v2: N_S, eq: N_S, neq: N_S, info?: Info): MatchNode<AnyNode, AnyNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)], info }\r\n}\r\n/** v1 == v2 ? pass : 0 */\r\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function equal(v1: N_S, v2: N_S, pass: Num, info?: Info): MatchNode<AnyNode, NumNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 == v2 ? pass : `undefined` */\r\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function equalStr(v1: N_S, v2: N_S, pass: Str, info?: Info): MatchNode<AnyNode, StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 != v2 ? pass : 0 */\r\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function unequal(v1: N_S, v2: N_S, pass: Num, info?: Info): MatchNode<AnyNode, NumNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\r\n}\r\n/** v1 != v2 ? pass : `undefined` */\r\nexport function unequalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function unequalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function unequalStr(v1: N_S, v2: N_S, pass: Str, info?: Info): MatchNode<AnyNode, StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(undefined), intoV(pass)], info, emptyOn: \"match\" }\r\n}\r\n/** v1 >= v2 ? pass : 0 */\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode> {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 >= v2 ? pass : `undefined` */\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): ThresholdNode<StrNode> {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 < v2 ? pass : 0 */\r\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): ThresholdNode<NumNode> {\r\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\r\n}\r\n/** v1 >= v2 ? ge : le */\r\nexport function threshold(v1: Num, v2: Num, ge: Num, le: Num, info?: Info): NumNode {\r\n  return { operation: \"threshold\", operands: intoOps([v1, v2, ge, le]) as any, info }\r\n}\r\n\r\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\r\n  if (nodeList.operation) {\r\n    if (nodeList.operation !== \"read\")\r\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\r\n    return { ...nodeList, path: prefix }\r\n  } else {\r\n    return objectKeyMap(Object.keys(nodeList), key =>\r\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\r\n  }\r\n}\r\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\r\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\r\nexport function data(base: AnyNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\r\nexport function data(base: AnyNode, data: Data): DataNode<NumNode> | DataNode<StrNode> {\r\n  return { operation: \"data\", operands: [base as any], data }\r\n}\r\nexport function resetData(base: NumNode, data: Data, info?: Info): DataNode<NumNode>\r\nexport function resetData(base: StrNode, data: Data, info?: Info): DataNode<StrNode>\r\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<AnyNode>\r\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<AnyNode> {\r\n  return { operation: \"data\", operands: [base], data, reset: true, info }\r\n}\r\n\r\n\r\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\r\n}\r\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\r\n  return { operation: \"read\", operands: [], path, type: \"string\" }\r\n}\r\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\r\n}\r\n/**\r\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\r\n */\r\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\r\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\r\n}\r\nexport function stringPrio(...operands: Str[]): StrPrioNode {\r\n  return { operation: \"prio\", operands: intoOps(operands) }\r\n}\r\n/** list[index] */\r\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\r\n  return { operation: \"subscript\", operands: [index], list, info }\r\n}\r\n\r\nfunction intoOps(values: Num[]): NumNode[]\r\nfunction intoOps(values: Str[]): StrNode[]\r\nfunction intoOps(values: N_S[]): AnyNode[] {\r\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\r\n}\r\nfunction intoV(value: Num): NumNode\r\nfunction intoV(value: Str): StrNode\r\nfunction intoV(value: N_S): AnyNode\r\nfunction intoV(value: N_S): AnyNode {\r\n  return (typeof value !== \"object\") ? constant(value) : value\r\n}\r\n\r\ntype _NodeList = { [key: string]: NodeList } & { operation?: never }\r\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\r\n\r\n/**\r\n * `v1` === `v2` ? `match` : `unmatch`\r\n * @deprecated Use `equal`, `unequal`, `equalStr`, or `compareEq` instead\r\n */\r\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function matchFull(v1: N_S, v2: N_S, match: N_S, unmatch: N_S, info?: Info): MatchNode<AnyNode, AnyNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\r\n}\r\n","import { crawlObject, deepClone, objPathValue } from \"../Util/Util\"\r\nimport { NodeData, NumNode, StrNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\ntype Node = NumNode | StrNode\r\n\r\nexport function deepNodeClone<T extends NodeData<NumNode | StrNode | undefined>>(data: T): T {\r\n  const result = deepClone(data)\r\n  // Restore `Info`\r\n  crawlObject(result, [], n => n.operation, (node, path) =>\r\n    node.info = { ...objPathValue(data, path).info })\r\n  return result\r\n}\r\n\r\nexport function forEachNodes(formulas: Node[], topDown: (formula: Node) => void, bottomUp: (formula: Node) => void): void {\r\n  const visiting = new Set<Node>(), visited = new Set<Node>()\r\n\r\n  function traverse(formula: Node) {\r\n    if (visited.has(formula)) return\r\n\r\n    if (visiting.has(formula)) {\r\n      console.error(\"Found cyclical dependency during formula traversal\")\r\n      return\r\n    }\r\n    visiting.add(formula)\r\n\r\n    topDown(formula)\r\n\r\n    formula.operands.forEach(traverse)\r\n\r\n    bottomUp(formula)\r\n\r\n    visiting.delete(formula)\r\n    visited.add(formula)\r\n  }\r\n\r\n  formulas.forEach(traverse)\r\n}\r\n\r\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: Node) => Node, bottomUpMap: (current: Node, orig: Node) => Node): NumNode[]\r\nexport function mapFormulas(formulas: Node[], topDownMap: (formula: Node) => Node, bottomUpMap: (current: Node, orig: Node) => Node): Node[] {\r\n  const visiting = new Set<Node>()\r\n  const topDownMapped = new Map<Node, Node>()\r\n  const bottomUpMapped = new Map<Node, Node>()\r\n\r\n  function check(formula: Node): Node {\r\n    let topDown = topDownMapped.get(formula)\r\n    if (topDown) return topDown\r\n    topDown = topDownMap(formula)\r\n\r\n    let bottomUp = bottomUpMapped.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n    visiting.add(topDown)\r\n\r\n    bottomUp = bottomUpMap(traverse(topDown), formula)\r\n\r\n    visiting.delete(topDown)\r\n\r\n    topDownMapped.set(formula, bottomUp)\r\n    bottomUpMapped.set(topDown, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: Node): Node {\r\n    const operands = formula.operands.map(check)\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\r\n  }\r\n\r\n  const result = formulas.map(check)\r\n  return arrayEqual(result, formulas) ? formulas : result\r\n}\r\n\r\nexport function customMapFormula<Context, Output>(formulas: NumNode[], context: Context, map: (formula: Node, context: Context, map: (node: NumNode, context: Context) => Output) => Output): Output[] {\r\n  const contextMapping = new Map<Context, [Set<NumNode>, Map<NumNode, Output>]>()\r\n  function internalMap(formula: NumNode, context: Context): Output {\r\n    let current = contextMapping.get(context)\r\n    if (!current) contextMapping.set(context, current = [new Set(), new Map()])\r\n    const [visiting, mapping] = current\r\n\r\n    const old = mapping.get(formula)\r\n    if (old) return old\r\n\r\n    if (visiting.has(formula))\r\n      throw new Error(\"Found cyclical dependency during formula mapping\")\r\n\r\n    visiting.add(formula)\r\n    const newFormula = map(formula, context, internalMap)\r\n    mapping.set(formula, newFormula)\r\n    visiting.delete(formula)\r\n\r\n    return newFormula\r\n  }\r\n  return formulas.map(formula => internalMap(formula, context))\r\n}\r\n\r\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\r\n  if (a === undefined) return b === undefined\r\n  if (b === undefined) return false\r\n\r\n  return a.length === b.length && a.every((value, i) => value === b[i])\r\n}\r\n","import type { ArtifactBuildData } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\r\nimport { assertUnreachable, objPathValue } from \"../Util/Util\"\r\nimport { forEachNodes, mapFormulas } from \"./internal\"\r\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\r\n  min: (x: number[]): number => Math.min(...x),\r\n  max: (x: number[]): number => Math.max(...x),\r\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\r\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\r\n}\r\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\r\n  ...allCommutativeMonoidOperations,\r\n  res: ([res]: number[]): number => {\r\n    if (res < 0) return 1 - res / 2\r\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n    return 1 - res\r\n  },\r\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\r\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\r\n}\r\n\r\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\r\n\r\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  formulas = constantFold(formulas, topLevelData, shouldFold)\r\n  formulas = flatten(formulas)\r\n  formulas = deduplicate(formulas)\r\n  return formulas\r\n}\r\nexport function precompute(formulas: NumNode[], initial: ArtifactBuildData[\"values\"], binding: (readNode: ReadNode<number> | ReadNode<string | undefined>) => string, slotCount: number): (_: ArtifactBuildData[]) => number[] {\r\n  let body = `\r\n\"use strict\";\r\n// copied from the code above\r\nfunction res(res) {\r\n  if (res < 0) return 1 - res / 2\r\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n  return 1 - res\r\n}\r\nconst x0=0`; // making sure `const` has at least one entry\r\n\r\n  let i = 1;\r\n  const names = new Map<NumNode | StrNode, string>()\r\n  forEachNodes(formulas, _ => { }, f => {\r\n    const { operation, operands } = f, name = `x${i++}`, operandNames = operands.map(x => names.get(x)!)\r\n    names.set(f, name)\r\n    switch (operation) {\r\n      case \"read\": {\r\n        const key = binding(f)\r\n        let arr = new Array(slotCount).fill(null).map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\r\n        if (initial[key] && initial[key] !== 0) {\r\n          arr = [initial[key].toString(), ...arr]\r\n        }\r\n        body += `,${name}=${arr.join('+')}`\r\n        break\r\n      }\r\n      case \"const\": names.set(f, `(${f.value})`); break\r\n      case \"add\": case \"mul\": body += `,${name}=${operandNames.join(operation === \"add\" ? \"+\" : \"*\")}`; break\r\n      case \"min\": case \"max\": body += `,${name}=Math.${operation}(${operandNames})`; break\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = operandNames\r\n        body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\r\n        break\r\n      }\r\n      case \"res\": body += `,${name}=res(${operandNames[0]})`; break\r\n      case \"sum_frac\": body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`; break\r\n\r\n      case \"match\": case \"lookup\": case \"subscript\":\r\n      case \"prio\": case \"small\":\r\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n  body += `;\\nreturn [${formulas.map(f => names.get(f)!)}]`\r\n  return new (Function as any)(`b`, body)\r\n}\r\n\r\nfunction flatten(formulas: NumNode[]): NumNode[] {\r\n  return mapFormulas(formulas, f => f, _formula => {\r\n    let result = _formula\r\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\r\n      const formula = _formula as ComputeNode\r\n      const { operation } = formula\r\n\r\n      let flattened = false\r\n      const operands = formula.operands.flatMap(dep =>\r\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\r\n      result = flattened ? { ...formula, operands } : formula\r\n    }\r\n\r\n    return result\r\n  })\r\n}\r\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\r\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\r\n    const result = new Map<T, number>()\r\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\r\n    return result\r\n  }\r\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\r\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\r\n  }\r\n\r\n  const wrap = {\r\n    common: {\r\n      counts: new Map<NumNode, number>(),\r\n      formulas: new Set<NumNode>(),\r\n      operation: \"add\" as Operation\r\n    }\r\n  }\r\n\r\n  while (true) {\r\n    let next: typeof wrap.common | undefined\r\n\r\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\r\n\r\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\r\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\r\n      candidatesByOperation.set(operation, [])\r\n\r\n    formulas = mapFormulas(formulas, _formula => {\r\n      if (wrap.common.formulas.has(_formula as NumNode)) {\r\n        const formula = _formula as ComputeNode\r\n        const remainingCounts = new Map(wrap.common.counts)\r\n        const operands = formula.operands.filter(dep => {\r\n          const count = remainingCounts.get(dep)\r\n          if (count) {\r\n            remainingCounts.set(dep, count - 1)\r\n            return false\r\n          }\r\n          return true\r\n        })\r\n\r\n        if (!operands.length)\r\n          return factored\r\n        operands.push(factored)\r\n        return { ...formula, operands }\r\n      }\r\n      return _formula\r\n    }, _formula => {\r\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\r\n      const formula = _formula as ComputeNode\r\n\r\n      if (next) {\r\n        if (next.operation === formula.operation) {\r\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\r\n          const nextCounts = next.counts\r\n          let total = 0\r\n\r\n          for (const [dependency, currentCount] of currentCounts.entries()) {\r\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\r\n            if (commonCount) {\r\n              commonCounts.set(dependency, commonCount)\r\n              total += commonCount\r\n            } else commonCounts.delete(dependency)\r\n          }\r\n          if (total > 1) {\r\n            next.counts = commonCounts\r\n            next.formulas.add(formula)\r\n          }\r\n        }\r\n      } else {\r\n        const candidates = candidatesByOperation.get(formula.operation)!\r\n        const counts = elementCounts(formula.operands)\r\n\r\n        for (const [candidate, candidateCounts] of candidates) {\r\n          let total = 0\r\n\r\n          const commonCounts = new Map<NumNode, number>()\r\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\r\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\r\n            if (count) {\r\n              commonCounts.set(dependency, count)\r\n              total += count\r\n            }\r\n          }\r\n          if (total > 1) {\r\n            next = {\r\n              counts: commonCounts,\r\n              formulas: new Set([formula, candidate]),\r\n              operation: formula.operation\r\n            }\r\n            candidatesByOperation.clear()\r\n            break\r\n          }\r\n        }\r\n        if (!next) candidates.push([formula, counts])\r\n      }\r\n\r\n      return formula\r\n    })\r\n\r\n    if (next) wrap.common = next\r\n    else break\r\n  }\r\n\r\n  return formulas\r\n}\r\n\r\n/**\r\n * Replace nodes with known values with appropriate constants,\r\n * avoiding removal of any nodes that pass `isFixed` predicate\r\n */\r\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\r\n  const origin: Context = { data: [], processed: new Map() }\r\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\r\n\r\n  function fold(formula: StrNode, context: Context): StrNode\r\n  function fold(formula: NumNode, context: Context): NumNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\r\n    const old = context.processed.get(formula)\r\n    if (old) return old\r\n\r\n    const { operation } = formula\r\n    let result: NumNode | StrNode\r\n    switch (operation) {\r\n      case \"const\": return formula\r\n      case \"add\": case \"mul\": case \"max\": case \"min\":\r\n        const f = allOperations[operation]\r\n        const numericOperands: number[] = []\r\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\r\n          const folded = fold(formula, context)\r\n          return (folded.operation === \"const\")\r\n            ? (numericOperands.push(folded.value), false)\r\n            : true\r\n        }).map(x => fold(x, context))\r\n        const numericValue = f(numericOperands)\r\n\r\n        // Fold degenerate cases. This may incorrectly compute NaN\r\n        // results, which shouldn't appear under expected usage.\r\n        // - zero\r\n        //   - 0 * ... = 0\r\n        // - infinity\r\n        //   - max(infinity, ...) = infinity\r\n        //   - infinity + ... = infinity\r\n        // - (-infinity)\r\n        //   - min(-infinity, ...) - infinity\r\n        //   - (-infinity) + ... = -infinity\r\n        // - NaN\r\n        //   - operation(NaN, ...) = NaN\r\n        if (!isFinite(numericValue)) {\r\n          if ((operation !== \"mul\") &&\r\n            (operation !== \"max\" || numericValue > 0) &&\r\n            (operation !== \"min\" || numericValue < 0)) {\r\n            result = constant(numericValue)\r\n            break\r\n          }\r\n        } else if (operation === \"mul\" && numericValue === 0) {\r\n          result = constant(numericValue)\r\n          break\r\n        }\r\n\r\n        if (numericValue !== f([])) // Skip vacuous values\r\n          formulaOperands.push(constant(numericValue))\r\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\r\n        else result = { operation, operands: formulaOperands }\r\n        break\r\n      case \"res\": case \"sum_frac\": {\r\n        const operands = formula.operands.map(x => fold(x, context))\r\n        const f = allOperations[operation]\r\n        if (operands.every(x => x.operation === \"const\"))\r\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\r\n        else result = { ...formula, operands }\r\n        break\r\n      }\r\n      case \"lookup\": {\r\n        const index = fold(formula.operands[0], context)\r\n        if (index.operation === \"const\") {\r\n          const selected = formula.table[index.value!] ?? formula.operands[1]\r\n          if (selected) {\r\n            result = fold(selected, context)\r\n            break\r\n          }\r\n        }\r\n        throw new Error(`Unsupported ${operation} node while folding`)\r\n      }\r\n      case \"prio\": {\r\n        const first = formula.operands.find(op => {\r\n          const folded = fold(op, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          return folded.value !== undefined\r\n        })\r\n        result = first ? fold(first, context) : constant(undefined)\r\n        break\r\n      }\r\n      case \"small\": {\r\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\r\n        for (const operand of formula.operands) {\r\n          const folded = fold(operand, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\r\n            smallest = folded\r\n        }\r\n        result = smallest ?? constant(undefined)\r\n        break\r\n      }\r\n      case \"match\": {\r\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\r\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\r\n          throw new Error(`Unsupported ${operation} node while folding`)\r\n        result = (v1.value === v2.value) ? match : unmatch\r\n        break\r\n      }\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context) as NumNode)\r\n        if (pass.operation === \"const\" && fail.operation === \"const\" && pass.value === fail.value)\r\n          result = pass\r\n        else if (value.operation === \"const\" && threshold.operation === \"const\")\r\n          result = value.value >= threshold.value ? pass : fail\r\n        else\r\n          result = { ...formula, operands: [value, threshold, pass, fail] }\r\n        break\r\n      }\r\n      case \"subscript\": {\r\n        const [index] = formula.operands.map(x => fold(x, context))\r\n        result = (index.operation === \"const\")\r\n          ? constant(formula.list[index.value])\r\n          : { ...formula, operands: [index] }\r\n        break\r\n      }\r\n      case \"read\": {\r\n        const operands = context.data\r\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\r\n          .filter(x => x)\r\n\r\n        if (operands.length === 0) {\r\n          if (shouldFold(formula)) {\r\n            const { accu } = formula\r\n            if (accu === undefined || accu === \"small\")\r\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\r\n            else result = constant(allOperations[accu]([]))\r\n          } else result = formula\r\n        } else if (formula.accu === undefined || operands.length === 1)\r\n          result = fold(operands[operands.length - 1], context)\r\n        else\r\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\r\n        break\r\n      }\r\n      case \"data\":\r\n        if (formula.reset) context = origin\r\n        const map = nextContextMap.get(context)!\r\n        let nextContext = map.get(formula.data)\r\n        if (!nextContext) {\r\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\r\n          nextContextMap.set(nextContext, new Map())\r\n          map.set(formula.data, nextContext)\r\n        }\r\n        result = fold(formula.operands[0], nextContext)\r\n        break\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    if (result.info) {\r\n      result = { ...result }\r\n      delete result.info\r\n    }\r\n    context.processed.set(formula, result)\r\n    return result\r\n  }\r\n\r\n  const context = { data: [topLevelData], processed: new Map() }\r\n  nextContextMap.set(context, new Map())\r\n  nextContextMap.get(origin)!.set(topLevelData, context)\r\n  return formulas.map(x => fold(x, context))\r\n}\r\n\r\nexport const testing = {\r\n  constantFold, flatten, deduplicate\r\n}\r\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\r\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\r\nexport const allAmpReactions = [\"vaporize\", \"melt\",] as const\r\nexport const allAdditiveReactions = [\"spread\", \"aggravate\"] as const\r\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\r\nexport const allRarities = [5, 4, 3, 2, 1] as const\r\nexport const allArtifactRarities = [5, 4, 3] as const\r\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\r\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo', 'dendro'] as const\r\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\r\nexport const allInfusionAuraElements = [\"pyro\", 'cryo', 'hydro'] as const\r\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\r\nexport const allRollColorKeys = ['roll1', 'roll2', 'roll3', 'roll4', 'roll5', 'roll6'] as const\r\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\r\nexport const allRefinement = [1, 2, 3, 4, 5] as const\r\nexport const substatType = [\"max\", \"mid\", \"min\"] as const\r\nexport const genderKeys = [\"F\", \"M\"] as const\r\nexport type Gender = typeof genderKeys[number]\r\n\r\n\r\nexport const allArtifactSets = [\r\n  \"Adventurer\",\r\n  \"ArchaicPetra\",\r\n  \"Berserker\",\r\n  \"BlizzardStrayer\",\r\n  \"BloodstainedChivalry\",\r\n  \"BraveHeart\",\r\n  \"CrimsonWitchOfFlames\",\r\n  \"DeepwoodMemories\",\r\n  \"DefendersWill\",\r\n  \"EchoesOfAnOffering\",\r\n  \"EmblemOfSeveredFate\",\r\n  \"Gambler\",\r\n  \"GildedDreams\",\r\n  \"GladiatorsFinale\",\r\n  \"HeartOfDepth\",\r\n  \"HuskOfOpulentDreams\",\r\n  \"Instructor\",\r\n  \"Lavawalker\",\r\n  \"LuckyDog\",\r\n  \"MaidenBeloved\",\r\n  \"MartialArtist\",\r\n  \"NoblesseOblige\",\r\n  \"OceanHuedClam\",\r\n  \"PaleFlame\",\r\n  \"PrayersForDestiny\",\r\n  \"PrayersForIllumination\",\r\n  \"PrayersForWisdom\",\r\n  \"PrayersToSpringtime\",\r\n  \"ResolutionOfSojourner\",\r\n  \"RetracingBolide\",\r\n  \"Scholar\",\r\n  \"ShimenawasReminiscence\",\r\n  \"TenacityOfTheMillelith\",\r\n  \"TheExile\",\r\n  \"ThunderingFury\",\r\n  \"Thundersoother\",\r\n  \"TinyMiracle\",\r\n  \"TravelingDoctor\",\r\n  \"VermillionHereafter\",\r\n  \"ViridescentVenerer\",\r\n  \"WanderersTroupe\",\r\n] as const\r\nexport const nonTravelerCharacterKeys = [\r\n  \"Albedo\",\r\n  \"Aloy\",\r\n  \"Amber\",\r\n  \"AratakiItto\",\r\n  \"Barbara\",\r\n  \"Beidou\",\r\n  \"Bennett\",\r\n  \"Candace\",\r\n  \"Chongyun\",\r\n  \"Collei\",\r\n  \"Cyno\",\r\n  \"Diluc\",\r\n  \"Diona\",\r\n  \"Dori\",\r\n  \"Eula\",\r\n  \"Fischl\",\r\n  \"Ganyu\",\r\n  \"Gorou\",\r\n  \"HuTao\",\r\n  \"Jean\",\r\n  \"KaedeharaKazuha\",\r\n  \"Kaeya\",\r\n  \"KamisatoAyaka\",\r\n  \"KamisatoAyato\",\r\n  \"Keqing\",\r\n  \"Klee\",\r\n  \"KujouSara\",\r\n  \"KukiShinobu\",\r\n  \"Lisa\",\r\n  \"Mona\",\r\n  \"Nilou\",\r\n  \"Ningguang\",\r\n  \"Noelle\",\r\n  \"Qiqi\",\r\n  \"RaidenShogun\",\r\n  \"Razor\",\r\n  \"Rosaria\",\r\n  \"SangonomiyaKokomi\",\r\n  \"Sayu\",\r\n  \"Shenhe\",\r\n  \"ShikanoinHeizou\",\r\n  \"Sucrose\",\r\n  \"Tartaglia\",\r\n  \"Thoma\",\r\n  \"Tighnari\",\r\n  \"Venti\",\r\n  \"Xiangling\",\r\n  \"Xiao\",\r\n  \"Xingqiu\",\r\n  \"Xinyan\",\r\n  \"YaeMiko\",\r\n  \"Yanfei\",\r\n  \"Yelan\",\r\n  \"Yoimiya\",\r\n  \"YunJin\",\r\n  \"Zhongli\",\r\n] as const\r\nexport const locationCharacterKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  \"Traveler\",\r\n] as const\r\nexport const travelerElements = [\r\n  \"anemo\",\r\n  \"geo\",\r\n  \"electro\",\r\n  \"dendro\"\r\n] as const\r\nexport const travelerFKeys = [\r\n  \"TravelerAnemoF\",\r\n  \"TravelerGeoF\",\r\n  \"TravelerElectroF\",\r\n  \"TravelerDendroF\",\r\n] as const\r\nexport const travelerMKeys = [\r\n  \"TravelerAnemoM\",\r\n  \"TravelerGeoM\",\r\n  \"TravelerElectroM\",\r\n  \"TravelerDendroM\",\r\n] as const\r\nexport const travelerKeys = [\r\n  \"TravelerAnemo\",\r\n  \"TravelerGeo\",\r\n  \"TravelerElectro\",\r\n  \"TravelerDendro\",\r\n] as const\r\nexport const allCharacterKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  ...travelerKeys\r\n] as const\r\n\r\nexport const allCharacterSheetKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  ...travelerFKeys,\r\n  ...travelerMKeys,\r\n]\r\n\r\nexport const allWeaponSwordKeys = [\r\n  \"AmenomaKageuchi\",\r\n  \"AquilaFavonia\",\r\n  \"BlackcliffLongsword\",\r\n  \"CinnabarSpindle\",\r\n  \"CoolSteel\",\r\n  \"KagotsurubeIsshin\",\r\n  \"DarkIronSword\",\r\n  \"DullBlade\",\r\n  \"FavoniusSword\",\r\n  \"FesteringDesire\",\r\n  \"FilletBlade\",\r\n  \"FreedomSworn\",\r\n  \"HaranGeppakuFutsu\",\r\n  \"HarbingerOfDawn\",\r\n  \"IronSting\",\r\n  \"KeyOfKhajNisut\",\r\n  \"LionsRoar\",\r\n  \"MistsplitterReforged\",\r\n  \"PrimordialJadeCutter\",\r\n  \"PrototypeRancour\",\r\n  \"RoyalLongsword\",\r\n  \"SacrificialSword\",\r\n  \"SapwoodBlade\",\r\n  \"SilverSword\",\r\n  \"SkyriderSword\",\r\n  \"SkywardBlade\",\r\n  \"SummitShaper\",\r\n  \"SwordOfDescension\",\r\n  \"TheAlleyFlash\",\r\n  \"TheBlackSword\",\r\n  \"TheFlute\",\r\n  \"TravelersHandySword\",\r\n  \"XiphosMoonlight\",\r\n] as const\r\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\r\n\r\nexport const allWeaponClaymoreKeys = [\r\n  \"Akuoumaru\",\r\n  \"BlackcliffSlasher\",\r\n  \"BloodtaintedGreatsword\",\r\n  \"DebateClub\",\r\n  \"FavoniusGreatsword\",\r\n  \"FerrousShadow\",\r\n  \"ForestRegalia\",\r\n  \"KatsuragikiriNagamasa\",\r\n  \"LithicBlade\",\r\n  \"LuxuriousSeaLord\",\r\n  \"MakhairaAquamarine\",\r\n  \"OldMercsPal\",\r\n  \"PrototypeArchaic\",\r\n  \"Rainslasher\",\r\n  \"RedhornStonethresher\",\r\n  \"RoyalGreatsword\",\r\n  \"SacrificialGreatsword\",\r\n  \"SerpentSpine\",\r\n  \"SkyriderGreatsword\",\r\n  \"SkywardPride\",\r\n  \"SnowTombedStarsilver\",\r\n  \"SongOfBrokenPines\",\r\n  \"TheBell\",\r\n  \"TheUnforged\",\r\n  \"WasterGreatsword\",\r\n  \"Whiteblind\",\r\n  \"WhiteIronGreatsword\",\r\n  \"WolfsGravestone\",\r\n] as const\r\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\r\n\r\nexport const allWeaponPolearmKeys = [\r\n  \"BeginnersProtector\",\r\n  \"BlackcliffPole\",\r\n  \"BlackTassel\",\r\n  \"CalamityQueller\",\r\n  \"CrescentPike\",\r\n  \"Deathmatch\",\r\n  \"DragonsBane\",\r\n  \"DragonspineSpear\",\r\n  \"EngulfingLightning\",\r\n  \"FavoniusLance\",\r\n  \"Halberd\",\r\n  \"IronPoint\",\r\n  \"KitainCrossSpear\",\r\n  \"LithicSpear\",\r\n  \"MissiveWindspear\",\r\n  \"Moonpiercer\",\r\n  \"PrimordialJadeWingedSpear\",\r\n  \"PrototypeStarglitter\",\r\n  \"RoyalSpear\",\r\n  \"SkywardSpine\",\r\n  \"StaffOfHoma\",\r\n  \"StaffOfTheScarletSands\",\r\n  \"TheCatch\",\r\n  \"VortexVanquisher\",\r\n  \"WavebreakersFin\",\r\n  \"WhiteTassel\",\r\n] as const\r\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\r\n\r\nexport const allWeaponBowKeys = [\r\n  \"AlleyHunter\",\r\n  \"AmosBow\",\r\n  \"AquaSimulacra\",\r\n  \"BlackcliffWarbow\",\r\n  \"CompoundBow\",\r\n  \"ElegyForTheEnd\",\r\n  \"EndOfTheLine\",\r\n  \"FadingTwilight\",\r\n  \"FavoniusWarbow\",\r\n  \"Hamayumi\",\r\n  \"HuntersBow\",\r\n  \"HuntersPath\",\r\n  \"KingsSquire\",\r\n  \"Messenger\",\r\n  \"MitternachtsWaltz\",\r\n  \"MouunsMoon\",\r\n  \"PolarStar\",\r\n  \"Predator\",\r\n  \"PrototypeCrescent\",\r\n  \"RavenBow\",\r\n  \"RecurveBow\",\r\n  \"RoyalBow\",\r\n  \"Rust\",\r\n  \"SacrificialBow\",\r\n  \"SeasonedHuntersBow\",\r\n  \"SharpshootersOath\",\r\n  \"SkywardHarp\",\r\n  \"Slingshot\",\r\n  \"TheStringless\",\r\n  \"TheViridescentHunt\",\r\n  \"ThunderingPulse\",\r\n  \"WindblumeOde\",\r\n] as const\r\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\r\n\r\nexport const allWeaponCatalystKeys = [\r\n  \"ApprenticesNotes\",\r\n  \"BlackcliffAgate\",\r\n  \"DodocoTales\",\r\n  \"EmeraldOrb\",\r\n  \"EverlastingMoonglow\",\r\n  \"EyeOfPerception\",\r\n  \"FavoniusCodex\",\r\n  \"Frostbearer\",\r\n  \"FruitOfFulfillment\",\r\n  \"HakushinRing\",\r\n  \"KagurasVerity\",\r\n  \"LostPrayerToTheSacredWinds\",\r\n  \"MagicGuide\",\r\n  \"MappaMare\",\r\n  \"MemoryOfDust\",\r\n  \"OathswornEye\",\r\n  \"OtherworldlyStory\",\r\n  \"PocketGrimoire\",\r\n  \"PrototypeAmber\",\r\n  \"RoyalGrimoire\",\r\n  \"SacrificialFragments\",\r\n  \"SkywardAtlas\",\r\n  \"SolarPearl\",\r\n  \"TheWidsith\",\r\n  \"ThrillingTalesOfDragonSlayers\",\r\n  \"TwinNephrite\",\r\n  \"WanderingEvenstar\",\r\n  \"WineAndSong\",\r\n] as const\r\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\r\n\r\nexport const allWeaponKeys = [\r\n  ...allWeaponSwordKeys,\r\n  ...allWeaponClaymoreKeys,\r\n  ...allWeaponPolearmKeys,\r\n  ...allWeaponBowKeys,\r\n  ...allWeaponCatalystKeys,\r\n] as const\r\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\r\n\r\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"dendro_dmg_\"] as const\r\n\r\nexport type HitModeKey = typeof allHitModes[number]\r\nexport type Region = typeof allRegions[number]\r\nexport type AmpReactionKey = typeof allAmpReactions[number]\r\nexport type AdditiveReactionKey = typeof allAdditiveReactions[number]\r\nexport type SetNum = typeof allArtifactSetCount[number]\r\nexport type Rarity = typeof allRarities[number]\r\nexport type ArtifactRarity = typeof allArtifactRarities[number]\r\nexport type SlotKey = typeof allSlotKeys[number]\r\nexport type ElementKey = typeof allElements[number]\r\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\r\nexport type InfusionAuraElements = typeof allInfusionAuraElements[number]\r\nexport type ArtifactSetKey = typeof allArtifactSets[number]\r\nexport type NonTravelerCharacterKey = typeof nonTravelerCharacterKeys[number]\r\nexport type CharacterKey = typeof allCharacterKeys[number]\r\nexport type CharacterSheetKey = typeof allCharacterSheetKeys[number]\r\nexport type LocationCharacterKey = typeof locationCharacterKeys[number]\r\nexport type TravelerKey = typeof travelerKeys[number]\r\nexport type TravelerElementKey = typeof travelerElements[number]\r\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\r\nexport type RollColorKey = typeof allRollColorKeys[number]\r\nexport type Ascension = typeof allAscension[number]\r\nexport type Refinement = typeof allRefinement[number]\r\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\r\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\r\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\r\n  pyro: [\"vaporize\", \"melt\"],\r\n  hydro: [\"vaporize\"],\r\n  cryo: [\"melt\"],\r\n  anemo: [\"vaporize\", \"melt\"],\r\n}\r\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> = {\r\n  dendro: [\"spread\"],\r\n  electro: [\"aggravate\"],\r\n  anemo: [\"aggravate\"],\r\n}\r\n\r\nexport type SubstatType = typeof substatType[number]\r\n\r\nexport function charKeyToLocCharKey(charKey: CharacterKey): LocationCharacterKey {\r\n  if (travelerKeys.includes(charKey as TravelerKey)) return \"Traveler\"\r\n  return charKey as LocationCharacterKey\r\n}\r\n\r\nexport function TravelerToElement(key: TravelerKey, element: TravelerElementKey): TravelerKey {\r\n  return \"Traveler\" + element.toUpperCase().slice(0, 1) + element.slice(1) as TravelerKey\r\n}\r\n\r\nexport type LocationKey = LocationCharacterKey | \"\"\r\n\r\nexport function charKeyToCharName(ck: CharacterKey, gender: Gender): string {\r\n  return ck.startsWith(\"Traveler\") ? \"Traveler\" + gender : ck\r\n}\r\n","import { ArtSetExclusion } from \"../../../../Database/DataManagers/BuildsettingData\";\r\nimport { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\r\nimport { allOperations, constantFold } from \"../../../../Formula/optimization\";\r\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\r\nimport { constant, customRead, max, min, threshold } from \"../../../../Formula/utils\";\r\nimport { allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\";\r\nimport { assertUnreachable, objectKeyMap, objectMap, range } from \"../../../../Util/Util\";\r\n\r\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\r\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\r\n  let should = forced\r\n  /** If `key` makes progress, all operations in `value` should be performed */\r\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\r\n    pruneOrder: { pruneNodeRange: true },\r\n    pruneArtRange: { pruneNodeRange: true },\r\n    pruneNodeRange: { reaffine: true },\r\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\r\n  }\r\n  let count = 0\r\n  while (Object.values(should).some(x => x) && count++ < 20) {\r\n    if (should.pruneOrder) {\r\n      delete should.pruneOrder\r\n      const newArts = pruneOrder(arts, numTop, exclusion)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneOrder }\r\n      }\r\n    }\r\n    if (should.pruneArtRange) {\r\n      delete should.pruneArtRange\r\n      const newArts = pruneArtRange(nodes, arts, minimum)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneArtRange }\r\n      }\r\n    }\r\n    if (should.pruneNodeRange) {\r\n      delete should.pruneNodeRange\r\n      const newNodes = pruneNodeRange(nodes, arts)\r\n      if (nodes !== newNodes) {\r\n        nodes = newNodes\r\n        should = { ...should, ...deps.pruneNodeRange }\r\n      }\r\n    }\r\n    if (should.reaffine) {\r\n      delete should.reaffine\r\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\r\n      if (nodes !== newNodes || arts !== newArts) {\r\n        nodes = newNodes\r\n        arts = newArts\r\n        should = { ...should, ...deps.reaffine }\r\n      }\r\n    }\r\n  }\r\n  return { nodes, arts }\r\n}\r\n\r\nexport function pruneExclusion(nodes: NumNode[], exclusion: ArtSetExclusion): NumNode[] {\r\n  const maxValues: Dict<keyof typeof exclusion, number> = {}\r\n  for (const [key, e] of Object.entries(exclusion)) {\r\n    if (!e.includes(4)) continue\r\n    maxValues[key] = e.includes(2) ? 1 : 3\r\n  }\r\n  return mapFormulas(nodes, f => f, f => {\r\n    if (f.operation !== \"threshold\") return f\r\n\r\n    const [v, t, pass, fail] = f.operands as readonly NumNode[]\r\n    if (v.operation === \"read\" && t.operation === \"const\") {\r\n      const key = v.path[v.path.length - 1], thres = t.value\r\n      if (key in maxValues) {\r\n        const max: number = maxValues[key]\r\n        if (max < thres) return fail\r\n        if (thres === 2 && exclusion[key]!.includes(2))\r\n          return threshold(v, 4, pass, fail)\r\n      }\r\n    }\r\n    return f\r\n  })\r\n}\r\n\r\nfunction reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\r\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\r\n\r\n  function visit(node: NumNode, isAffine: boolean) {\r\n    if (isAffine) affineNodes.add(node)\r\n    else node.operands.forEach(_op => {\r\n      const op = _op as NumNode\r\n      affineNodes.has(op) && topLevelAffine.add(op)\r\n    })\r\n  }\r\n\r\n  const dynKeys = new Set<string>()\r\n\r\n  forEachNodes(nodes, _ => { }, _f => {\r\n    const f = _f as NumNode, { operation } = f\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\r\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\r\n        dynKeys.add(f.path[1])\r\n        visit(f, true)\r\n        break\r\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\r\n      case \"mul\": {\r\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\r\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\r\n        break\r\n      }\r\n      case \"const\":\r\n        if (typeof f.value === \"string\" || f.value === undefined)\r\n          throw new Error(`Found constant ${f.value} while compacting`)\r\n        visit(f as NumNode, true); break\r\n      case \"res\": case \"threshold\": case \"sum_frac\":\r\n      case \"max\": case \"min\": visit(f, false); break\r\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\":\r\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n\r\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\r\n    Object.keys(arts.base).length === dynKeys.size)\r\n    return { nodes, arts }\r\n\r\n  let current = -1\r\n  function nextDynKey(): string {\r\n    while (dynKeys.has(`${++current}`));\r\n    return `${current}`\r\n  }\r\n\r\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\r\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\r\n  const affineMap = new Map(affine.map(node => [node,\r\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\r\n      ? node\r\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\r\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\r\n\r\n  function reaffineArt(stat: DynStat): DynStat {\r\n    const values = constantFold([...affineMap.keys()], {\r\n      dyn: objectMap(stat, (value) => constant(value))\r\n    } as any, _ => true)\r\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\r\n  }\r\n  const result = {\r\n    nodes, arts: {\r\n      base: reaffineArt(arts.base),\r\n      values: objectKeyMap(allSlotKeys, slot =>\r\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\r\n    }\r\n  }\r\n  const offsets = Object.entries(reaffineArt({}))\r\n  for (const arts of Object.values(result.arts.values))\r\n    for (const { values } of arts)\r\n      for (const [key, baseValue] of offsets)\r\n        values[key] -= baseValue\r\n  return result\r\n}\r\n/** Remove artifacts that cannot be in top `numTop` builds */\r\nfunction pruneOrder(arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion): ArtifactsBySlot {\r\n  let progress = false\r\n  const noRainbow = !exclusion.rainbow?.length\r\n  const noSwitchIn = new Set(Object.entries(exclusion).filter(([_, v]) => v.length).map(([k]) => k) as ArtifactSetKey[])\r\n  const noSwitchOut = new Set(Object.entries(exclusion).filter(([_, v]) => v.includes(2) && !v.includes(4)).map(([k]) => k) as ArtifactSetKey[])\r\n  const values = objectKeyMap(allSlotKeys, slot => {\r\n    const list = arts.values[slot]\r\n    const newList = list.filter(art => {\r\n      let count = 0\r\n      return list.every(other => {\r\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\r\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\r\n        if (greaterEqual && (greater || other.id > art.id) &&\r\n          ((noRainbow && !noSwitchIn.has(other.set!) && !noSwitchOut.has(art.set!)) || art.set === other.set))\r\n          count++\r\n        return count < numTop\r\n      })\r\n    })\r\n    if (newList.length !== list.length) progress = true\r\n    return newList\r\n  })\r\n  return progress ? { base: arts.base, values } : arts\r\n}\r\n/** Remove artifacts that cannot reach `minimum` in any build */\r\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const wrap = { arts }\r\n  while (true) {\r\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\r\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\r\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\r\n\r\n    let progress = false\r\n    const values = objectKeyMap(allSlotKeys, slot => {\r\n      const result = wrap.arts.values[slot].filter(art => {\r\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\r\n        const newRange = computeNodeRange(nodes, read)\r\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\r\n      })\r\n      if (result.length !== wrap.arts.values[slot].length)\r\n        progress = true\r\n      return result\r\n    })\r\n    if (!progress) break\r\n    wrap.arts = { base: wrap.arts.base, values }\r\n  }\r\n  return wrap.arts\r\n}\r\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\r\n  const nodeRange = computeNodeRange(nodes, reads)\r\n\r\n  return mapFormulas(nodes, f => {\r\n    {\r\n      const { min, max } = nodeRange.get(f as NumNode)!\r\n      if (min === max) return constant(min)\r\n    }\r\n    const { operation } = f\r\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\r\n    switch (operation) {\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = operandRanges\r\n        if (value.min >= threshold.max) return f.operands[2]\r\n        else if (value.max < threshold.min) return f.operands[3]\r\n        if (pass.max === pass.min &&\r\n          fail.max === fail.min &&\r\n          pass.min === fail.min && isFinite(pass.min))\r\n          return constant(pass.max)\r\n        break\r\n      }\r\n      case \"min\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\r\n        break\r\n      }\r\n      case \"max\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every(op2 => op1.max >= op2.min)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\r\n        break\r\n      }\r\n    }\r\n    return f\r\n  }, f => f)\r\n}\r\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  ranges.forEach(range => {\r\n    Object.entries(range).forEach(([key, value]) => {\r\n      if (result[key]) {\r\n        result[key].min += value.min\r\n        result[key].max += value.max\r\n      } else result[key] = { ...value }\r\n    })\r\n  })\r\n  return result\r\n}\r\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  if (arts.length) {\r\n    Object.keys(arts[0].values)\r\n      .filter(key => arts.every(art => art.values[key]))\r\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\r\n    arts.forEach(({ values }) => {\r\n      for (const [key, value] of Object.entries(values)) {\r\n        if (!result[key]) result[key] = { min: 0, max: value }\r\n        else {\r\n          if (result[key].max < value) result[key].max = value\r\n          if (result[key].min > value) result[key].min = value\r\n        }\r\n      }\r\n    })\r\n  }\r\n  return result\r\n}\r\nexport function computeFullArtRange(arts: ArtifactsBySlot): DynMinMax {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  return addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\r\n}\r\nexport function computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\r\n  const range = new Map<NumNode, MinMax>()\r\n\r\n  forEachNodes(nodes, _ => { }, _f => {\r\n    const f = _f as NumNode\r\n    const { operation } = f\r\n    const operands = f.operands.map(op => range.get(op)!)\r\n    let current: MinMax\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.path[0] !== \"dyn\")\r\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\r\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\r\n        break\r\n      case \"const\": current = computeMinMax([f.value]); break\r\n      case \"subscript\": current = computeMinMax(f.list); break\r\n      case \"add\": case \"min\": case \"max\":\r\n        current = {\r\n          min: allOperations[operation](operands.map(x => x.min)),\r\n          max: allOperations[operation](operands.map(x => x.max)),\r\n        }; break\r\n      case \"res\": current = {\r\n        min: allOperations[operation]([operands[0].max]),\r\n        max: allOperations[operation]([operands[0].min]),\r\n      }; break\r\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\r\n        accu.min * current.min, accu.min * current.max,\r\n        accu.max * current.min, accu.max * current.max,\r\n      ])); break\r\n      case \"threshold\":\r\n        if (operands[0].min >= operands[1].max) current = operands[2]\r\n        else if (operands[0].max < operands[1].min) current = operands[3]\r\n        else current = computeMinMax([], [operands[2], operands[3]])\r\n        break\r\n      case \"sum_frac\": {\r\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\r\n        if (sum.min <= 0 && sum.max >= 0)\r\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\r\n        else\r\n          // TODO: Check this\r\n          current = computeMinMax([\r\n            x.min / sum.min, x.min / sum.max,\r\n            x.max / sum.min, x.max / sum.max\r\n          ])\r\n        break\r\n      }\r\n      case \"data\": case \"lookup\": case \"match\":\r\n        throw new Error(`Unsupported ${operation} node`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n    range.set(f, current)\r\n  })\r\n  return range\r\n}\r\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\r\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\r\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\r\n  return { min, max }\r\n}\r\n\r\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\r\n  return {\r\n    base: arts.base,\r\n    values: objectKeyMap(allSlotKeys, slot => {\r\n      const filter = filters[slot]\r\n      switch (filter.kind) {\r\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\r\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\r\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\r\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\r\n}\r\nexport function mergePlot(plots: PlotData[]): PlotData {\r\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\r\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\r\n  while (keys.size > maxCount) {\r\n    scale *= reductionScaling\r\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\r\n  }\r\n  const result: PlotData = {}\r\n  for (const plot of plots)\r\n    for (const build of Object.values(plot)) {\r\n      const x = Math.round(build.plot! / scale) * scale\r\n      if (!result[x] || result[x]!.value < build.value)\r\n        result[x] = build\r\n    }\r\n  return result\r\n}\r\n\r\nexport function countBuilds(arts: ArtifactsBySlot): number {\r\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\r\n}\r\n\r\n\r\nexport function* filterFeasiblePerm(filters: Iterable<RequestFilter>, _artSets: ArtifactsBySlot): Iterable<RequestFilter> {\r\n  const artSets = objectMap(_artSets.values, values => new Set(values.map(v => v.set)))\r\n  filter_loop: for (const filter of filters) {\r\n    for (const [slot, f] of Object.entries(filter)) {\r\n      const available = artSets[slot]!\r\n      switch (f.kind) {\r\n        case \"required\": if ([...f.sets].every(s => !available.has(s))) continue filter_loop; break\r\n        case \"exclude\": if ([...available].every(s => f.sets.has(s!))) continue filter_loop; break\r\n        case \"id\": break\r\n      }\r\n    }\r\n    yield filter\r\n  }\r\n}\r\nexport function exclusionToAllowed(exclusion: number[] | undefined): Set<number> {\r\n  return new Set(exclusion?.includes(2)\r\n    ? exclusion.includes(4) ? [0, 1] : [0, 1, 4, 5]\r\n    : exclusion?.includes(4) ? [0, 1, 2, 3] : [0, 1, 2, 3, 4, 5])\r\n}\r\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\r\nexport function* artSetPerm(exclusion: ArtSetExclusion, _artSets: ArtifactSetKey[]): Iterable<RequestFilter> {\r\n  /**\r\n   * This generation algorithm is separated into two parts:\r\n   * - \"Shape\" generation\r\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\r\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\r\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\r\n   * - Shape filling\r\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\r\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\r\n   */\r\n  const artSets = [...new Set(_artSets)], allowedRainbows = exclusionToAllowed(exclusion.rainbow)\r\n  let shapes: number[][] = []\r\n  function populateShapes(current: number[], list: Set<number>, rainbows: number[]) {\r\n    if (current.length === 5) {\r\n      if (allowedRainbows.has(rainbows.length))\r\n        shapes.push(current)\r\n      return\r\n    }\r\n    for (const i of list) populateShapes([...current, i], list, rainbows.filter(j => j !== i))\r\n    populateShapes([...current, current.length], new Set([...list, current.length]), [...rainbows, current.length])\r\n  }\r\n  populateShapes([0], new Set([0]), [0])\r\n  function indexOfShape(shape: number[], replacing: number) {\r\n    if (range(replacing + 1, 4).some(i => shape[i] !== 5))\r\n      return undefined\r\n    shape = [...shape]\r\n    shape[replacing] = 5\r\n    return shape.reduce((a, b) => a * 6 + b, 0)\r\n  }\r\n  for (let replacing = 4; replacing >= 0; replacing--) {\r\n    const required: Map<number, number> = new Map()\r\n    for (const shape of shapes) {\r\n      const id = indexOfShape(shape, replacing)\r\n      if (id === undefined) continue\r\n      required.set(id, (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1)\r\n    }\r\n    for (const [id, remaining] of required.entries()) {\r\n      if (remaining === 0) {\r\n        const shape = [...shapes.find(shape => indexOfShape(shape, replacing) === id)!]\r\n        shape[replacing] = 5\r\n        shapes = shapes.filter(shape => indexOfShape(shape, replacing) !== id)\r\n        shapes.push(shape)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Shapes are now calculated and merged, proceed to fill in the sets\r\n\r\n  const noFilter = { kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }\r\n  const result: RequestFilter = objectKeyMap(allSlotKeys, _ => noFilter)\r\n\r\n  const counts = { ...objectMap(exclusion, _ => 0), ...objectKeyMap(artSets, _ => 0) }\r\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\r\n\r\n  function* check(shape: number[]) {\r\n    const used: Set<ArtifactSetKey> = new Set()\r\n    let groupped: number[][] = [], rainbows: number[] = []\r\n    for (const i of shape) {\r\n      groupped.push([])\r\n      if (i === 5) rainbows.push(groupped.length - 1)\r\n      else groupped[i].push(groupped.length - 1)\r\n    }\r\n    groupped = groupped.filter(v => v.length).sort((a, b) => b.length - a.length)\r\n    let usableRainbows = rainbows.length\r\n\r\n    // Inception.. because js doesn't like functions inside a for-loop\r\n    function* check(i: number) {\r\n      if (i === groupped.length)\r\n        return yield* check_free(0)\r\n\r\n      for (const set of artSets) {\r\n        if (used.has(set)) continue\r\n        const length = groupped[i].length, allowedSet = allowedCounts[set]\r\n        let requiredRainbows = 0\r\n\r\n        if (allowedSet && !allowedSet.has(length)) {\r\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\r\n          requiredRainbows = (range(length + 1, 5).find(l => allowedSet.has(l)) ?? 6) - length\r\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\r\n        }\r\n\r\n        used.add(set)\r\n        counts[set] = groupped[i].length\r\n        groupped[i].forEach(j => result[allSlotKeys[j]] = { kind: \"required\", sets: new Set([set]) })\r\n        usableRainbows -= requiredRainbows\r\n\r\n        yield* check(i + 1)\r\n\r\n        usableRainbows += requiredRainbows\r\n        counts[set] = 0\r\n        used.delete(set)\r\n      }\r\n    }\r\n    // We separate filling rainbow slots from groupped slots because it has an entirely\r\n    // different set of rules regarding what can be filled and what states to be kept.\r\n    function* check_free(i: number) {\r\n      const remaining = rainbows.length - i, isolated: ArtifactSetKey[] = [], missing: ArtifactSetKey[] = [], rejected: ArtifactSetKey[] = []\r\n      let required = 0\r\n      for (const set of artSets) {\r\n        const allowedSet = allowedCounts[set], count = counts[set]\r\n        if (!allowedSet) continue\r\n        if (range(1, remaining).every(j => !allowedSet.has(count + j))) rejected.push(set)\r\n        else if (!allowedSet.has(count)) {\r\n          required += [...allowedSet].find(x => x > count)! - count\r\n          missing.push(set)\r\n        }\r\n        else if (range(0, remaining).some(j => !allowedSet.has(count + j))) isolated.push(set)\r\n      }\r\n      if (required > remaining) return\r\n      if (i === rainbows.length) {\r\n        yield { ...result }\r\n        return\r\n      }\r\n      if (required === remaining) {\r\n        for (const set of missing) {\r\n          counts[set]++\r\n          result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\r\n          yield* check_free(i + 1)\r\n          counts[set]--\r\n        }\r\n        return\r\n      }\r\n      for (const set of [...isolated, ...missing]) {\r\n        counts[set]++\r\n        result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\r\n        yield* check_free(i + 1)\r\n        counts[set]--\r\n      }\r\n      result[allSlotKeys[rainbows[i]]] = { kind: \"exclude\", sets: new Set([...missing, ...rejected, ...isolated]) }\r\n      yield* check_free(i + 1)\r\n    }\r\n    yield* check(0)\r\n  }\r\n  for (const shape of shapes) yield* check(shape)\r\n}\r\n\r\nexport type RequestFilter = StrictDict<SlotKey,\r\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"id\", ids: Set<string> }\r\n>\r\n\r\nexport type DynStat = { [key in string]: number }\r\nexport type ArtifactBuildData = {\r\n  id: string\r\n  set?: ArtifactSetKey\r\n  values: DynStat\r\n}\r\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\r\n\r\nexport type PlotData = Dict<number, Build>\r\nexport interface Build {\r\n  value: number\r\n  plot?: number\r\n  artifactIds: string[]\r\n}\r\n\r\nexport type DynMinMax = { [key in string]: MinMax }\r\nexport type MinMax = { min: number, max: number }\r\n","import { optimize, precompute } from '../../../../Formula/optimization';\r\nimport type { NumNode } from '../../../../Formula/type';\r\nimport type { InterimResult, Setup } from './BackgroundWorker';\r\nimport { ArtifactBuildData, ArtifactsBySlot, Build, countBuilds, filterArts, mergePlot, PlotData, pruneAll, RequestFilter } from './common';\r\n\r\nexport class ComputeWorker {\r\n  builds: Build[] = []\r\n  buildValues: number[] | undefined = undefined\r\n  plotData: PlotData | undefined\r\n  threshold: number = -Infinity\r\n  maxBuilds: number\r\n  min: number[]\r\n\r\n  arts: ArtifactsBySlot\r\n  nodes: NumNode[]\r\n\r\n  callback: (interim: InterimResult) => void\r\n\r\n  constructor({ arts, optimizationTarget, filters, plotBase, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\r\n    this.arts = arts\r\n    this.min = filters.map(x => x.min)\r\n    this.maxBuilds = maxBuilds\r\n    this.callback = callback\r\n    this.nodes = filters.map(x => x.value)\r\n    this.nodes.push(optimizationTarget)\r\n    if (plotBase) {\r\n      this.plotData = {}\r\n      this.nodes.push(plotBase)\r\n    }\r\n    this.nodes = optimize(this.nodes, {}, _ => false)\r\n  }\r\n\r\n  compute(newThreshold: number, filter: RequestFilter) {\r\n    if (this.threshold > newThreshold) this.threshold = newThreshold\r\n    const { min, interimReport } = this, self = this // `this` in nested functions means different things\r\n    let preArts = filterArts(this.arts, filter)\r\n    const totalCount = countBuilds(preArts), oldMaxBuildCount = this.builds.length\r\n\r\n    let nodes = this.nodes;\r\n    ({ nodes, arts: preArts } = pruneAll(nodes, min, preArts, this.maxBuilds, {}, {\r\n      pruneArtRange: true, pruneNodeRange: true,\r\n    }))\r\n    const arts = Object.values(preArts.values).sort((a, b) => a.length - b.length)\r\n    const compute = precompute(nodes, preArts.base, f => f.path[1], arts.length)\r\n\r\n    const buffer = Array<ArtifactBuildData>(arts.length)\r\n    const count = { tested: 0, failed: 0, skipped: totalCount - countBuilds(preArts) }\r\n\r\n    function permute(i: number) {\r\n      if (i < 0) {\r\n        const result = compute(buffer)\r\n        if (min.every((m, i) => (m <= result[i]))) {\r\n          const value = result[min.length], { builds, plotData } = self\r\n          let build: Build | undefined\r\n          if (value >= self.threshold) {\r\n            build = { value, artifactIds: buffer.map(x => x.id) }\r\n            builds.push(build)\r\n          }\r\n          if (plotData) {\r\n            const x = result[min.length + 1]\r\n            if (!plotData[x] || plotData[x]!.value < value) {\r\n              if (!build) build = { value, artifactIds: buffer.map(x => x.id) }\r\n              build.plot = x\r\n              plotData[x] = build\r\n            }\r\n          }\r\n        }\r\n        else count.failed += 1\r\n        return\r\n      }\r\n      arts[i].forEach(art => {\r\n        buffer[i] = art\r\n        permute(i - 1)\r\n      })\r\n      if (i === 0) {\r\n        count.tested += arts[0].length\r\n        if (count.tested > 1 << 16)\r\n          interimReport(count)\r\n      }\r\n    }\r\n\r\n    permute(arts.length - 1)\r\n    interimReport(count, this.builds.length > oldMaxBuildCount)\r\n  }\r\n\r\n  refresh(force: boolean): void {\r\n    const { maxBuilds } = this\r\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\r\n      this.plotData = mergePlot([this.plotData!])\r\n\r\n    if (this.builds.length >= 1000 || force) {\r\n      this.builds = this.builds\r\n        .sort((a, b) => b.value - a.value)\r\n        .slice(0, maxBuilds)\r\n      this.buildValues = this.builds.map(x => x.value)\r\n      this.threshold = Math.max(this.threshold, this.buildValues[maxBuilds - 1] ?? -Infinity)\r\n    }\r\n  }\r\n  interimReport = (count: { tested: number, failed: number, skipped: number }, forced = false) => {\r\n    this.refresh(forced)\r\n    this.callback({ command: \"interim\", buildValues: this.buildValues, ...count })\r\n    this.buildValues = undefined\r\n    count.tested = 0\r\n    count.failed = 0\r\n    count.skipped = 0\r\n  }\r\n}\r\n","import { customMapFormula, forEachNodes } from \"../../../../Formula/internal\";\r\nimport { allOperations } from \"../../../../Formula/optimization\";\r\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\r\nimport { prod, threshold } from \"../../../../Formula/utils\";\r\nimport { SlotKey } from \"../../../../Types/consts\";\r\nimport { assertUnreachable, objectKeyValueMap, objectMap } from \"../../../../Util/Util\";\r\nimport type { InterimResult, Setup, SplitWorker } from \"./BackgroundWorker\";\r\nimport { ArtifactBuildData, ArtifactsBySlot, computeFullArtRange, computeNodeRange, countBuilds, DynStat, filterArts, MinMax, pruneAll, RequestFilter } from \"./common\";\r\n\r\ntype Approximation = {\r\n  base: number,\r\n  /** optimization target contribution from a given artifact (id) */\r\n  conts: StrictDict<string, number>\r\n}\r\ntype Filter = {\r\n  nodes: NumNode[], arts: ArtifactsBySlot\r\n  /**\r\n   * The contribution of each artifact to the optimization target. The (over)estimated\r\n   * optimization target value is the sum of contributions of all artifacts in the build.\r\n   */\r\n  approxs: Approximation[], maxConts: Record<SlotKey, number>[]\r\n  /** How many times has this filter been splitted */\r\n  age: number\r\n  /** Total number of builds in this filter */\r\n  count: number\r\n  /** Whether or not this filter is in a valid (calculated) state */\r\n  calculated?: boolean\r\n}\r\nexport class BNBSplitWorker implements SplitWorker {\r\n  min: number[]\r\n  nodes: NumNode[]\r\n  arts: ArtifactsBySlot\r\n  maxBuilds: number\r\n\r\n  /**\r\n   * Filters are not neccessarily in a valid state, i.e., \"calculated\".\r\n   * We amortize the calculation to 1-per-split so that the calculation\r\n   * overhead doesn't lead to lag.\r\n   */\r\n  filters: Filter[] = []\r\n  interim: InterimResult | undefined\r\n  firstUncalculated = 0\r\n\r\n  callback: (interim: InterimResult) => void\r\n\r\n  constructor({ arts, optimizationTarget, filters, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\r\n    this.arts = arts\r\n    this.min = [-Infinity, ...filters.map(x => x.min)]\r\n    this.nodes = [optimizationTarget, ...filters.map(x => x.value)]\r\n    this.callback = callback\r\n    this.maxBuilds = maxBuilds\r\n\r\n    // make sure we can approximate it\r\n    linearUpperBound(this.nodes, arts)\r\n  }\r\n\r\n  addFilter(filter: RequestFilter): void {\r\n    const arts = filterArts(this.arts, filter), count = countBuilds(arts)\r\n    if (count)\r\n      this.filters.push({ nodes: this.nodes, arts, maxConts: [], approxs: [], age: 0, count })\r\n  }\r\n  split(newThreshold: number, minCount: number): RequestFilter | undefined {\r\n    if (newThreshold > this.min[0]) {\r\n      this.min[0] = newThreshold\r\n      // All calculations become stale\r\n      this.firstUncalculated = 0\r\n      this.filters.forEach(filter => delete filter.calculated)\r\n    }\r\n    if (this.firstUncalculated < this.filters.length)\r\n      this.calculateFilter(this.firstUncalculated++) // Amortize the filter calculation to 1-per-split\r\n\r\n    while (this.filters.length) {\r\n      const filter = this.getApproxFilter(), { arts, count } = filter\r\n      this.reportInterim(false)\r\n      if (!count) continue\r\n\r\n      if (count <= minCount) {\r\n        this.reportInterim(true)\r\n        return objectMap(arts.values, arts => ({ kind: \"id\" as const, ids: new Set(arts.map(art => art.id)) }))\r\n      }\r\n      this.splitOldFilter(filter)\r\n    }\r\n    this.reportInterim(true)\r\n    return undefined\r\n  }\r\n\r\n  reportInterim(forced = false) {\r\n    if (this.interim && (this.interim.skipped > 1000000 || forced === true)) {\r\n      this.callback(this.interim)\r\n      this.interim = undefined\r\n    }\r\n  }\r\n\r\n  splitOldFilter({ nodes, arts, approxs, age }: Filter) {\r\n    /**\r\n     * Split the artifacts in each slot into high/low main (index 0) contribution along 1/3 of the\r\n     * contribution range. If the main contribution of a slot is in range 500-2000, the the high-\r\n     * contibution artifact has contribution of at least 1500, and the rest are low-contribution.\r\n     */\r\n    const splitted = objectMap(arts.values, arts => {\r\n      const remaining = arts.map((art) => ({ art, cont: approxs[0].conts[art.id] }))\r\n        .sort(({ cont: c1 }, { cont: c2 }) => c2 - c1)\r\n      const minCont = remaining[remaining.length - 1]?.cont ?? 0\r\n      let contCutoff = remaining.reduce((accu, { cont }) => accu + cont, -minCont * remaining.length) / 3\r\n\r\n      const index = Math.max(1, remaining.findIndex(({ cont }) => (contCutoff -= cont - minCont) <= 0))\r\n      const lowArts = remaining.splice(index).map(({ art }) => art), highArts = remaining.map(({ art }) => art)\r\n      return {\r\n        high: { arts: highArts, maxConts: approxs.map(approx => maxContribution(highArts, approx)), },\r\n        low: { arts: lowArts, maxConts: approxs.map(approx => maxContribution(lowArts, approx)) },\r\n      }\r\n    })\r\n    const remaining = Object.keys(splitted), { filters } = this\r\n    const current: StrictDict<SlotKey, ArtifactBuildData[]> = {} as any\r\n    const currentCont: StrictDict<SlotKey, number[]> = {} as any\r\n    function partialSplit(count: number) {\r\n      if (!remaining.length) {\r\n        const maxConts = approxs.map((_, i) => objectMap(currentCont, val => val[i]))\r\n        const currentArts = { base: arts.base, values: { ...current } }\r\n        filters.push({ nodes, arts: currentArts, maxConts, approxs, age: age + 1, count })\r\n        return\r\n      }\r\n      const slot = remaining.pop()!, { high, low } = splitted[slot]\r\n      if (low.arts.length) {\r\n        current[slot] = low.arts\r\n        currentCont[slot] = low.maxConts\r\n        partialSplit(count * low.arts.length)\r\n      }\r\n      if (high.arts.length) {\r\n        current[slot] = high.arts\r\n        currentCont[slot] = high.maxConts\r\n        partialSplit(count * high.arts.length)\r\n      }\r\n      remaining.push(slot)\r\n    }\r\n    partialSplit(1)\r\n  }\r\n\r\n  /** *Precondition*: `this.filters` must not be empty */\r\n  getApproxFilter(): Filter {\r\n    this.calculateFilter(this.filters.length - 1)\r\n    if (this.firstUncalculated > this.filters.length)\r\n      this.firstUncalculated = this.filters.length\r\n    return this.filters.pop()!\r\n  }\r\n  /** Update calculate on filter at index `i` if not done so already */\r\n  calculateFilter(i: number): void {\r\n    let { nodes, arts, maxConts, approxs, age, count: oldCount, calculated } = this.filters[i]\r\n    if (calculated) return\r\n    if (age < 3 || age % 5 === 2) { // Make sure the condition includes initial filter `age === 0`\r\n      // Either the filter is so early that we can get a good cutoff, or the problem has\r\n      // gotten small enough that the old approximation becomes inaccurate\r\n      ({ nodes, arts } = pruneAll(nodes, this.min, arts, this.maxBuilds, {}, { pruneNodeRange: true }))\r\n      if (Object.values(arts.values).every(x => x.length)) {\r\n        approxs = approximation(nodes, arts)\r\n        maxConts = approxs.map(approx => objectMap(arts.values, val => maxContribution(val, approx)))\r\n      }\r\n    }\r\n    // Removing artifacts that doesn't meet the required opt target contributions.\r\n    //\r\n    // We could actually loop `newValues` computation if the removed artifacts have\r\n    // the highest contribution in one of the target node as the removal will raise\r\n    // the required contribution even further. However, once is generally enough.\r\n    const leadingConts = maxConts.map((cont, i) => Object.values(cont)\r\n      .reduce((accu, val) => accu + val, approxs[i].base - this.min[i]))\r\n    const newValues = objectMap(arts.values, (arts, slot) => {\r\n      const requiredConts = leadingConts.map((lc, i) => maxConts[i][slot] - lc)\r\n      return arts.filter(({ id }) => approxs.every(({ conts }, i) => conts[id] > requiredConts[i]))\r\n    })\r\n    arts = { base: arts.base, values: newValues }\r\n    const newCount = countBuilds(arts)\r\n    if (newCount !== oldCount)\r\n      if (this.interim) this.interim.skipped += oldCount - newCount\r\n      else this.interim = { command: \"interim\", buildValues: undefined, tested: 0, failed: 0, skipped: oldCount - newCount }\r\n    this.filters[i] = { nodes, arts, maxConts, approxs, age, count: newCount, calculated: true }\r\n  }\r\n}\r\n\r\nfunction maxContribution(arts: ArtifactBuildData[], approximation: Approximation): number {\r\n  return Math.max(...arts.map(({ id }) => approximation.conts[id]!))\r\n}\r\nfunction approximation(nodes: NumNode[], arts: ArtifactsBySlot): Approximation[] {\r\n  return linearUpperBound(nodes, arts).map(weight => ({\r\n    base: dot(arts.base, weight, weight.$c),\r\n    conts: objectKeyValueMap(Object.values(arts.values).flat(),\r\n      data => [data.id, dot(data.values, weight, 0)])\r\n  }))\r\n}\r\nfunction dot(values: DynStat, lin: DynStat, c: number): number {\r\n  return Object.entries(values).reduce((accu, [k, v]) => accu + (lin[k] ?? 0) * v, c)\r\n}\r\n\r\nfunction weightedSum(...entries: readonly (readonly [number, Linear])[]): Linear\r\nfunction weightedSum(...entries: readonly (readonly [number, DynStat])[]): DynStat\r\nfunction weightedSum(...entries: readonly (readonly [number, DynStat])[]): DynStat {\r\n  const result = {}\r\n  for (const [weight, entry] of entries)\r\n    for (const [k, v] of Object.entries(entry))\r\n      result[k] = (result[k] ?? 0) + weight * v\r\n  return result\r\n}\r\nexport type Linear = DynStat & { $c: number }\r\n/** Compute a linear upper bound of `nodes` */\r\nexport function linearUpperBound(nodes: NumNode[], arts: ArtifactsBySlot): Linear[] {\r\n  const cents = weightedSum([1, arts.base], ...Object.values(arts.values).map(arts =>\r\n    [1 / arts.length, weightedSum(...arts.map(art => [1, art.values] as const))] as const))\r\n  const getCent = (lin: Linear) => dot(cents, lin, lin.$c)\r\n\r\n  const minMaxes = new Map<NumNode, MinMax>()\r\n  forEachNodes(nodes, _f => {\r\n    const f = _f as NumNode, { operation } = f\r\n    if (operation === \"mul\") minMaxes.set(f, { min: NaN, max: NaN })\r\n    switch (operation) {\r\n      case \"mul\": case \"min\": case \"max\": case \"threshold\": case \"res\": case \"sum_frac\":\r\n        f.operands.forEach(op => minMaxes.set(op, { min: NaN, max: NaN })); break\r\n    }\r\n  }, _ => _)\r\n  const nodeRanges = computeNodeRange([...minMaxes.keys()], computeFullArtRange(arts))\r\n  for (const [node, minMax] of nodeRanges.entries()) minMaxes.set(node, minMax)\r\n\r\n  function slopePoint(slope: number, x0: number, y0: number, lin: Linear): Linear {\r\n    return weightedSum([1, { $c: y0 - slope * x0 }], [slope, lin])\r\n  }\r\n  function interpolate(x0: number, y0: number, x1: number, y1: number, lin: Linear, upper: boolean): Linear {\r\n    if (Math.abs(x0 - x1) < 1e-10)\r\n      return { $c: upper ? Math.max(y0, y1) : Math.min(y0, y1) }\r\n    return slopePoint((y1 - y0) / (x1 - x0), x0, y0, lin)\r\n  }\r\n\r\n  const upper = \"u\", lower = \"l\", outward = \"o\"\r\n  type Context = typeof upper | typeof lower | typeof outward\r\n  return customMapFormula<Context, Linear>(nodes, upper, (_f, context, _map) => {\r\n    const f = _f as NumNode, { operation } = f\r\n    const map: (op: NumNode, c?: Context) => Linear = (op, c = context) => _map(op, c)\r\n    const oppositeContext = context === upper ? lower : upper\r\n\r\n    if (context === outward) {\r\n      const { min, max } = minMaxes.get(f)!\r\n      if (min < 0 && max > 0)\r\n        // TODO: We can bypass this restriction by converting `f`\r\n        // to `min(f, 0)` or `max(f, 0)` as appropriate\r\n        throw new PolyError(\"Zero-crossing\", operation)\r\n      return map(f, max <= 0 ? lower : upper)\r\n    }\r\n\r\n    switch (operation) {\r\n      case \"const\": return { $c: f.value }\r\n      case \"read\": return { $c: 0, [f.path[1]]: 1 }\r\n      case \"add\": return weightedSum(...f.operands.map(op => [1, map(op)] as const))\r\n      case \"min\": case \"max\": {\r\n        const op = allOperations[operation]\r\n        const xs = f.operands.filter(op => op.operation !== \"const\"), [xOp] = xs\r\n        if (xs.length !== 1) throw new PolyError(\"Multivariate\", operation)\r\n\r\n        const x = map(xOp), c = op(f.operands.filter(op => op.operation === \"const\")\r\n          .map(c => (c as ConstantNode<number>).value))\r\n        if ((operation === \"max\" && context === lower) || (operation === \"min\" && context === upper))\r\n          return x\r\n        const { min, max } = minMaxes.get(xOp)!, yMin = op([min, c]), yMax = op([max, c])\r\n        return interpolate(min, yMin, max, yMax, x, context === upper)\r\n      }\r\n      case \"res\": {\r\n        if (context !== upper) throw new PolyError(\"Unsupported direction\", operation)\r\n        const op = allOperations[operation]\r\n        const [xOp] = f.operands, { min, max } = minMaxes.get(xOp)!\r\n        const x = map(xOp, oppositeContext)\r\n        // Linear region 1 - base/2 or concave region with peak at base = 0\r\n        if (min < 0 && max < 1.75) return weightedSum([1, { $c: 1 }], [-0.5, x])\r\n        // Clamp `min` to guarantee upper bound\r\n        else return interpolate(min, op([min]), max, op([max]), x, context === upper)\r\n      }\r\n      case \"sum_frac\": {\r\n        if (context !== upper) throw new PolyError(\"Unsupported direction\", operation)\r\n        const [xOp, cOp] = f.operands\r\n        if (cOp.operation !== \"const\") throw new PolyError(\"Non-constant node\", operation)\r\n        const x = map(xOp), c = cOp.value, { min, max } = minMaxes.get(xOp)!\r\n        const loc = Math.sqrt((min + c) * (max + c))\r\n        if (min <= -c) throw new PolyError(\"Unsupported pattern\", operation)\r\n        return slopePoint(c / (c + loc) / (c + loc), loc, loc / (loc + c), x)\r\n      }\r\n      case \"threshold\": {\r\n        const [vOp, tOp, pOp, fOp] = f.operands\r\n        if (fOp.operation !== \"const\" || tOp.operation !== \"const\")\r\n          throw new PolyError(\"Non-constant node\", operation)\r\n        if (pOp.operation !== \"const\") {\r\n          if (fOp.value !== 0) throw new PolyError(\"Unsupported pattern\", operation)\r\n\r\n          const threshOp = threshold(vOp, tOp, 1, fOp), mulOp = prod(threshOp, pOp)\r\n          // Populate `minMaxes` to ensure consistency\r\n          const { min, max } = minMaxes.get(pOp)!\r\n          minMaxes.set(threshOp, { min: 0, max: 1 })\r\n          minMaxes.set(mulOp, { min: Math.min(min, 0), max: Math.max(max, 0) })\r\n          return map(mulOp)\r\n        }\r\n        const { min, max } = minMaxes.get(vOp)!\r\n        const thresh = tOp.value, pass = pOp.value, fail = fOp.value\r\n        const isFirstHalf = (pass > fail) === (context === upper)\r\n\r\n        const v = map(vOp, pass > fail ? context : oppositeContext)\r\n        const yThresh = isFirstHalf ? pass : fail\r\n        const slope = (pass - fail) / (isFirstHalf ? (thresh - min) : (max - thresh))\r\n        return slopePoint(slope, thresh, yThresh, v)\r\n      }\r\n      case \"mul\": {\r\n        const { min, max } = minMaxes.get(f)!\r\n        if (min < 0 && max > 0) throw new PolyError(\"Zero-crossing\", operation)\r\n        if ((min < 0 && context !== lower) || (max > 0 && context !== upper))\r\n          throw new PolyError(\"Unsupported direction\", operation)\r\n\r\n        // For x/a >= 0, sum{x/a} <= n, and k > 0, it follows that\r\n        //\r\n        //   k prod{x} <= k/n prod{a} sum{x/a}\r\n        //\r\n        // This follows from AM-GM; prod{x/a} <= (sum{x/a}/n)^n <= sum{x/a}/n\r\n        const operands = [...f.operands], flattenedOperands: NumNode[] = []\r\n        let coeff = 1\r\n        while (operands.length) {\r\n          const operand = operands.pop()!\r\n          if (operand.operation === \"mul\") operands.push(...operand.operands)\r\n          else if (operand.operation === \"const\") coeff *= operand.value;\r\n          else flattenedOperands.push(operand)\r\n        }\r\n        const lins = flattenedOperands.map(op => map(op, outward))\r\n        const ranges = flattenedOperands.map(op => minMaxes.get(op)!)\r\n\r\n        // Set `a` to the centroid of `x`, normalizing so that `sum{x/a} = n`\r\n        const cents = lins.map(getCent)\r\n        const factor = cents.reduce((accu, cent, i) => accu + (cent >= 0 ? ranges[i].max : ranges[i].min) / cent, 0)\r\n        const prod = cents.reduce((a, b) => a * factor * b / lins.length, coeff / factor)\r\n        return weightedSum(...lins.map((op, i) => [prod / cents[i], op] as const))\r\n      }\r\n\r\n      case \"data\": case \"match\": case \"lookup\": case \"subscript\":\r\n        throw new PolyError(\"Unsupported operation\", operation)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n}\r\nclass PolyError extends Error {\r\n  constructor(cause: string, operation: string) {\r\n    super(`Found ${cause} in ${operation} node when generating polynomial upper bound`)\r\n  }\r\n}\r\n","import { ArtSetExclusion } from '../../../../Database/DataManagers/BuildsettingData'\r\nimport { NumNode } from '../../../../Formula/type'\r\nimport { assertUnreachable } from '../../../../Util/Util'\r\nimport { ArtifactsBySlot, artSetPerm, Build, countBuilds, filterArts, filterFeasiblePerm, PlotData, RequestFilter } from \"./common\"\r\nimport { ComputeWorker } from \"./ComputeWorker\"\r\nimport { BNBSplitWorker } from \"./BNBSplitWorker\"\r\nimport { DefaultSplitWorker } from './DefaultSplitWorker'\r\n\r\nlet id: number, splitWorker: SplitWorker, computeWorker: ComputeWorker\r\n\r\nonmessage = ({ data }: { data: WorkerCommand }) => {\r\n  const { command } = data\r\n  let result: WorkerResult\r\n  switch (command) {\r\n    case \"setup\":\r\n      id = data.id\r\n      const splitID = `split${id}`, computeID = `compute${id}`\r\n      try {\r\n        splitWorker = new BNBSplitWorker(data, interim => postMessage({ id, source: splitID, ...interim }))\r\n      } catch {\r\n        splitWorker = new DefaultSplitWorker(data, interim => postMessage({ id, source: splitID, ...interim }))\r\n      }\r\n      computeWorker = new ComputeWorker(data, interim => postMessage({ id, source: computeID, ...interim }))\r\n      result = { command: \"iterate\" }\r\n      break\r\n    case \"split\": {\r\n      if (data.filter) splitWorker.addFilter(data.filter)\r\n      const filter = splitWorker.split(data.threshold, data.minCount)\r\n      result = { command: \"split\", filter }\r\n      break\r\n    }\r\n    case \"iterate\": {\r\n      const { threshold, filter } = data\r\n      computeWorker.compute(threshold, filter)\r\n      result = { command: \"iterate\" }\r\n      break\r\n    }\r\n    case \"finalize\": {\r\n      computeWorker.refresh(true)\r\n      const { builds, plotData } = computeWorker\r\n      result = { command: \"finalize\", builds, plotData }\r\n      break\r\n    }\r\n    case \"count\": {\r\n      const { exclusion } = data, arts = computeWorker.arts\r\n      const setPerm = filterFeasiblePerm(artSetPerm(exclusion, [...new Set(Object.values(arts.values).flatMap(x => x.map(x => x.set!)))]), arts)\r\n      let counts = data.arts.map(_ => 0)\r\n      for (const perm of setPerm)\r\n        data.arts.forEach((arts, i) => counts[i] += countBuilds(filterArts(arts, perm)));\r\n      result = { command: \"count\", counts }\r\n      break\r\n    }\r\n    default: assertUnreachable(command)\r\n  }\r\n  postMessage({ id, ...result })\r\n}\r\n\r\nexport interface SplitWorker {\r\n  addFilter(filter: RequestFilter): void\r\n  split(newThreshold: number, minCount: number): RequestFilter | undefined\r\n}\r\n\r\nexport type WorkerCommand = Setup | Split | Iterate | Finalize | Count\r\nexport type WorkerResult = SourcedInterimResult | SplitResult | IterateResult | FinalizeResult | CountResult\r\n\r\nexport interface Setup {\r\n  command: \"setup\"\r\n\r\n  id: number\r\n  arts: ArtifactsBySlot\r\n\r\n  optimizationTarget: NumNode\r\n  filters: { value: NumNode, min: number }[]\r\n  plotBase: NumNode | undefined,\r\n  maxBuilds: number\r\n}\r\nexport interface Split {\r\n  command: \"split\"\r\n  threshold: number\r\n  minCount: number\r\n  filter?: RequestFilter\r\n}\r\nexport interface Iterate {\r\n  command: \"iterate\"\r\n  threshold: number\r\n  filter: RequestFilter\r\n}\r\n\r\nexport interface Finalize {\r\n  command: \"finalize\"\r\n}\r\nexport interface Count {\r\n  command: \"count\"\r\n  arts: ArtifactsBySlot[]\r\n  exclusion: ArtSetExclusion\r\n}\r\nexport interface SplitResult {\r\n  command: \"split\"\r\n  filter: RequestFilter | undefined\r\n}\r\nexport interface IterateResult {\r\n  command: \"iterate\"\r\n}\r\nexport interface FinalizeResult {\r\n  command: \"finalize\"\r\n  builds: Build[]\r\n  plotData?: PlotData\r\n}\r\nexport interface CountResult {\r\n  command: \"count\"\r\n  counts: number[]\r\n}\r\nexport interface InterimResult {\r\n  command: \"interim\"\r\n  buildValues: number[] | undefined\r\n  /** The number of builds since last report, including failed builds */\r\n  tested: number\r\n  /** The number of builds that does not meet the min-filter requirement since last report */\r\n  failed: number\r\n  skipped: number\r\n}\r\nexport interface SourcedInterimResult extends InterimResult {\r\n  /** the source of the message, must be unique for each source of `buildValues` */\r\n  source: string\r\n}\r\n","import { allSlotKeys } from '../../../../Types/consts';\r\nimport type { InterimResult, Setup, SplitWorker } from './BackgroundWorker';\r\nimport { ArtifactsBySlot, countBuilds, filterArts, RequestFilter } from './common';\r\n\r\nexport class DefaultSplitWorker implements SplitWorker {\r\n  arts: ArtifactsBySlot\r\n  filters: RequestFilter[] = []\r\n\r\n  constructor({ arts }: Setup, _callback: (interim: InterimResult) => void) {\r\n    this.arts = arts\r\n  }\r\n  addFilter(filter: RequestFilter) {\r\n    this.filters.push(filter)\r\n  }\r\n  split(_newThreshold: number, minCount: number) {\r\n    while (this.filters.length) {\r\n      const filter = this.filters.pop()!, count = countBuilds(filterArts(this.arts, filter))\r\n      if (count <= minCount) return filter\r\n      splitBySetOrID(this.arts, filter, minCount).forEach(filter => this.addFilter(filter))\r\n    }\r\n  }\r\n}\r\n\r\nfunction splitBySetOrID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\r\n  const arts = filterArts(_arts, filter)\r\n\r\n  const candidates = allSlotKeys\r\n    .map(slot => ({ slot, sets: new Set(arts.values[slot].map(x => x.set)) }))\r\n    .filter(({ sets }) => sets.size > 1)\r\n  if (!candidates.length)\r\n    return splitByID(arts, filter, limit)\r\n  const { sets, slot } = candidates.reduce((a, b) => a.sets.size < b.sets.size ? a : b)\r\n  return [...sets].map(set => ({ ...filter, [slot]: { kind: \"required\", sets: new Set([set]) } }))\r\n}\r\nfunction splitByID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\r\n  const arts = filterArts(_arts, filter)\r\n  const count = countBuilds(arts)\r\n\r\n  const candidates = allSlotKeys\r\n    .map(slot => ({ slot, length: arts.values[slot].length }))\r\n    .filter(x => x.length > 1)\r\n  const { slot, length } = candidates.reduce((a, b) => a.length < b.length ? a : b)\r\n\r\n  const numChunks = Math.ceil(count / limit)\r\n  const boundedNumChunks = Math.min(numChunks, length)\r\n  const chunk = Array(boundedNumChunks).fill(0).map(_ => new Set<string>())\r\n  arts.values[slot].forEach(({ id }, i) => chunk[i % boundedNumChunks].add(id))\r\n  return chunk.map(ids => ({ ...filter, [slot]: { kind: \"id\", ids } }))\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [676], function() { return __webpack_require__(18349); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"1b7bd000\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/genshin-optimizer/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t349: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkgenshin_optimizer\"] = self[\"webpackChunkgenshin_optimizer\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(676).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyMap","map","Object","fromEntries","i","objectKeyValueMap","items","t","objectMap","fn","entries","v","rangeGen","from","to","range","assertUnreachable","value","Error","constant","NaN","name","percent","info","operation","operands","type","Number","MAX_VALUE","Infinity","unit","min","values","intoOps","max","customRead","path","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","b","undefined","length","every","allCommutativeMonoidOperations","x","Math","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","f","_formula","flattened","flatMap","dep","deduplicate","elementCounts","array","wrap","common","counts","next","factored","count","fill","candidatesByOperation","remainingCounts","filter","push","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","smallest","v1","v2","match","unmatch","list","accu","reset","nextContext","allSlotKeys","nonTravelerCharacterKeys","travelerKeys","filterFeasiblePerm","artSetPerm","pruneAll","nodes","minimum","arts","numTop","exclusion","forced","should","deps","pruneNodeRange","reaffine","pruneOrder","pruneArtRange","some","newArts","newNodes","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","_op","dynKeys","_","_f","nonConst","base","size","current","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","slot","id","offsets","key","baseValue","progress","noRainbow","rainbow","noSwitchIn","noSwitchOut","includes","newList","art","other","greaterEqual","greater","baseRange","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","nodeRange","operandRanges","newOperands","op1","op2","j","ranges","reads","computeMinMax","c","sum","minMaxes","filterArts","filters","kind","ids","sets","countBuilds","_count","_artSets","artSets","available","s","exclusionToAllowed","populateShapes","indexOfShape","shape","check_free","remaining","rainbows","isolated","missing","rejected","required","allowedSet","allowedCounts","groupped","used","requiredRainbows","l","usableRainbows","sort","replacing","allowedRainbows","shapes","slice","noFilter","ComputeWorker","callback","optimizationTarget","plotBase","maxBuilds","builds","buildValues","plotData","interimReport","refresh","command","tested","failed","skipped","this","optimize","newThreshold","self","preArts","totalCount","oldMaxBuildCount","compute","initial","binding","slotCount","body","names","operandNames","arr","toString","join","Function","precompute","buffer","permute","m","build","artifactIds","plot","force","plots","scale","round","mergePlot","BNBSplitWorker","interim","firstUncalculated","linearUpperBound","maxConts","approxs","age","minCount","calculated","calculateFilter","getApproxFilter","reportInterim","splitOldFilter","splitted","cont","conts","c1","minCont","contCutoff","findIndex","lowArts","splice","highArts","high","approx","maxContribution","low","currentCont","partialSplit","pop","val","currentArts","oldCount","weight","dot","$c","flat","approximation","leadingConts","newValues","requiredConts","lc","newCount","lin","weightedSum","entry","cents","getCent","nodeRanges","computeFullArtRange","minMax","slopePoint","slope","x0","y0","interpolate","x1","y1","upper","abs","lower","contextMapping","internalMap","mapping","newFormula","customMapFormula","_map","oppositeContext","PolyError","xs","xOp","cOp","loc","sqrt","vOp","tOp","pOp","fOp","threshOp","mulOp","prod","thresh","isFirstHalf","flattenedOperands","coeff","operand","lins","factor","cent","splitWorker","computeWorker","cause","DefaultSplitWorker","_callback","_newThreshold","splitBySetOrID","addFilter","_arts","limit","numChunks","ceil","boundedNumChunks","chunk","splitByID","onmessage","splitID","computeID","postMessage","source","split","setPerm","perm","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","__webpack_exports__","O","deferred","chunkIds","priority","notFulfilled","fulfilled","r","d","definition","o","defineProperty","enumerable","e","chunkId","Promise","all","promises","u","miniCssF","prop","prototype","hasOwnProperty","call","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}