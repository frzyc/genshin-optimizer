{"version":3,"file":"static/js/184.f5adb655.chunk.js","mappings":"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AAc,CAAC,SAAU,QAAS,QAAS,SAAU,WAwDrDC,GAtDkB,CAAI,YAAJ,OADJ,CAAC,QAAS,MAAO,UAAW,QAAS,OAAQ,OAAQ,WAuDxC,CACtC,SACA,QACA,UACA,SACA,UACA,WACA,QACA,QACA,SACA,QACA,QACA,OACA,QACA,SACA,OACA,YACA,cACA,OACA,OACA,YACA,SACA,OACA,QACA,UACA,YACA,eACA,QACA,YACA,OACA,UACA,SACA,UACA,SACA,OACA,kBACA,gBACA,OACA,SACA,UACA,OACA,oBACA,QACA,QACA,cACA,UACA,SACA,UACA,gBACA,QACA,kBACA,SACA,OACA,aAwBWC,GAtBqB,UAC7BD,EAD6B,CAEhC,aAoB0B,CAC1B,gBACA,cACA,kBACA,mBAE2B,UACxBA,EACAC,GAG6B,UAC7BD,EAxBwB,CAC3B,iBACA,eACA,mBACA,mBAE2B,CAC3B,iBACA,eACA,mBACA,oBAoLwB,UAjKQ,CAChC,kBACA,gBACA,sBACA,kBACA,YACA,oBACA,gBACA,YACA,gBACA,kBACA,cACA,eACA,oBACA,kBACA,YACA,YACA,uBACA,uBACA,mBACA,iBACA,mBACA,eACA,cACA,gBACA,eACA,eACA,oBACA,gBACA,gBACA,WACA,uBAImC,CACnC,YACA,oBACA,yBACA,aACA,qBACA,gBACA,gBACA,wBACA,cACA,mBACA,cACA,mBACA,cACA,uBACA,kBACA,wBACA,eACA,qBACA,eACA,uBACA,oBACA,UACA,cACA,mBACA,aACA,sBACA,mBAIkC,CAClC,qBACA,iBACA,cACA,kBACA,eACA,aACA,cACA,mBACA,qBACA,gBACA,UACA,YACA,mBACA,cACA,cACA,4BACA,uBACA,aACA,eACA,cACA,WACA,mBACA,kBACA,eAI8B,CAC9B,cACA,UACA,gBACA,mBACA,cACA,iBACA,iBACA,iBACA,WACA,aACA,cACA,cACA,YACA,oBACA,aACA,YACA,WACA,oBACA,WACA,aACA,WACA,OACA,iBACA,qBACA,oBACA,cACA,YACA,gBACA,qBACA,kBACA,eACA,gBAIm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","sources":["Util/Util.ts","Formula/utils.ts","Formula/internal.ts","Formula/optimization.ts","Types/consts.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/common.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/BackgroundWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/ComputeWorker.ts","PageCharacter/CharacterDisplay/Tabs/TabOptimize/SplitWorker.ts","../webpack/bootstrap","../webpack/runtime/chunk loaded","../webpack/runtime/define property getters","../webpack/runtime/ensure chunk","../webpack/runtime/get javascript chunk filename","../webpack/runtime/get mini-css chunk filename","../webpack/runtime/hasOwnProperty shorthand","../webpack/runtime/publicPath","../webpack/runtime/importScripts chunk loading","../webpack/runtime/startup chunk dependencies","../webpack/startup"],"sourcesContent":["export const getRandomElementFromArray = <T>(array: readonly T[]): T => array[Math.floor(Math.random() * array.length)];\r\nexport function getRandomInt(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min) + min); //The maximum is exclusive and the minimum is inclusive\r\n}\r\nexport function getRandomIntInclusive(min, max) {\r\n  min = Math.ceil(min);\r\n  max = Math.floor(max);\r\n  return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive\r\n}\r\nexport function getRandomArbitrary(min, max) {\r\n  return Math.random() * (max - min) + min;\r\n}\r\n\r\n/**\r\n * Assumes that the object entries are all primitives + objects\r\n * shallow copy the object,\r\n * deep copy the\r\n * @param obj\r\n * @returns\r\n */\r\nexport function deepClone<T>(obj: T): T {\r\n  if (!obj) return obj\r\n  if (!Object.keys(obj).length) return {} as T\r\n  const ret = { ...obj }\r\n  Object.entries(obj).forEach(([k, v]: any) => {\r\n    if (typeof v !== \"object\") return\r\n    ret[k] = JSON.parse(JSON.stringify(v))\r\n  })\r\n  return ret\r\n}\r\n\r\nexport const clamp = (val, low, high) => {\r\n  if (val < low) return low;\r\n  if (val > high) return high;\r\n  return val\r\n}\r\nexport const getArrLastElement = (arr) =>\r\n  arr.length ? arr[arr.length - 1] : null\r\n\r\nexport const clamp01 = (val) => clamp(val, 0, 1)\r\nexport const clampPercent = (val) => clamp(val, 0, 100)\r\n\r\n//use to pretty print timestamps, or anything really.\r\nexport function strPadLeft(string, pad, length) {\r\n  return (new Array(length + 1).join(pad) + string).slice(-length);\r\n}\r\n\r\n//fuzzy compare strings. longer the distance, the higher the mismatch.\r\nexport function hammingDistance(str1, str2) {\r\n  var dist = 0;\r\n  str1 = str1.toLowerCase();\r\n  str2 = str2.toLowerCase();\r\n  for (var i = 0, j = Math.max(str1.length, str2.length); i < j; i++) {\r\n    let match = true\r\n    if (!str1[i] || !str2[i] || str1[i] !== str2[i])\r\n      match = false\r\n    if (str1[i - 1] === str2[i] || str1[i + 1] === str2[i])\r\n      match = true\r\n    if (!match) dist++\r\n  }\r\n  return dist;\r\n}\r\n\r\n//multiplies every numerical value in the obj by a multiplier.\r\nexport function objMultiplication(obj, multi) {\r\n  if (multi === 1) return obj\r\n  Object.keys(obj).forEach((prop: any) => {\r\n    if (typeof obj[prop] === \"object\") objMultiplication(obj[prop], multi)\r\n    if (typeof obj[prop] === \"number\") obj[prop] = obj[prop] * multi\r\n  })\r\n  return obj\r\n}\r\n\r\n//assign obj.[keys...] = value\r\nexport function layeredAssignment(obj, keys: readonly string[], value) {\r\n  keys.reduce((accu, key, i, arr) => {\r\n    if (i === arr.length - 1) return (accu[key] = value)\r\n    if (!accu[key]) accu[key] = {}\r\n    return accu[key]\r\n  }, obj)\r\n  return obj\r\n}\r\n//get the value in a nested object, giving array of path\r\nexport function objPathValue(obj: object | undefined, keys: readonly string[]): any {\r\n  if (!obj || !keys) return undefined;\r\n  !Array.isArray(keys) && console.error(keys)\r\n  return keys.reduce((a, k) => a?.[k], obj)\r\n}\r\n//delete the value denoted by the path. Will also delete empty objects as well.\r\nexport function deletePropPath(obj, path) {\r\n  const tempPath = [...path]\r\n  const lastKey = tempPath.pop()\r\n  const objPathed = objPathValue(obj, tempPath)\r\n  delete objPathed?.[lastKey];\r\n}\r\n\r\nexport function objClearEmpties(o) {\r\n  for (const k in o) {\r\n    if (typeof o[k] !== \"object\") continue\r\n    objClearEmpties(o[k])\r\n    if (!Object.keys(o[k]).length) delete o[k];\r\n  }\r\n}\r\nexport function crawlObject(obj: any, keys: string[] = [], validate: (o: any, keys: string[]) => boolean, cb: (o: any, keys: string[]) => void) {\r\n  if (validate(obj, keys)) cb(obj, keys)\r\n  else obj && typeof obj === \"object\" && Object.entries(obj).forEach(([key, val]) => crawlObject(val, [...keys, key], validate, cb))\r\n}\r\n// const getObjectKeysRecursive = (obj) => Object.values(obj).reduce((a, prop) => typeof prop === \"object\" ? [...a, ...getObjectKeysRecursive(prop)] : a, Object.keys(obj))\r\nexport const getObjectKeysRecursive = (obj) => typeof obj === \"object\" ? Object.values(obj).flatMap(getObjectKeysRecursive).concat(Object.keys(obj)) : (typeof obj === \"string\" ? [obj] : [])\r\n\r\nexport function evalIfFunc<T, X>(value: T | ((arg: X) => T), arg: X): T {\r\n  return typeof value === \"function\" ? (value as any)(arg) : value\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyMap<K extends string | number, V>(keys: readonly K[], map: (key: K, i: number) => V): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(keys.map((k, i) => [k, map(k, i)])) as any\r\n}\r\n//fromEntries doesn't result in StrictDict, this is just a utility wrapper.\r\nexport function objectKeyValueMap<T, K extends string | number, V>(items: readonly T[], map: (item: T) => [K, V]): StrictDict<`${K}`, V> {\r\n  return Object.fromEntries(items.map(t => map(t))) as any\r\n}\r\n\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>>\r\nexport function objectMap<K extends string, V, T>(obj: Record<K, V>, fn: (value: V, key: `${K}`, index: number) => T): Record<K, T>\r\nexport function objectMap<K extends string, V, T>(obj: Partial<Record<K, V>>, fn: (value: V, key: `${K}`, index: number) => T): Partial<Record<K, T>> {\r\n  return Object.fromEntries(Object.entries(obj).map(\r\n    ([k, v], i) => [k, fn(v, k, i)]\r\n  )) as any\r\n}\r\n\r\nconst rangeGen = function* (from: number, to: number): Iterable<number> {\r\n  for (let i = from; i <= to; i++) yield i;\r\n};\r\n\r\n/** range of [from, to], inclusive */\r\nexport function range(from: number, to: number): number[] {\r\n  return [...rangeGen(from, to)]\r\n}\r\n\r\nexport function assertUnreachable(value: never): never {\r\n  throw new Error(`Should not reach this with value ${value}`)\r\n}\r\n\r\n/** Will change `arr` in-place */\r\nexport function toggleInArr<T>(arr: T[], value: T) {\r\n  const ind = arr.indexOf(value)\r\n  if (ind < 0) arr.push(value)\r\n  else arr.splice(ind, 1)\r\n}\r\n\r\nexport function toggleArr<T>(arr: T[], value: T) {\r\n  return arr.includes(value) ? arr.filter(a => a !== value) : [...arr, value]\r\n}\r\n\r\nexport function deepFreeze(obj: any, layers: number = 5) {\r\n  if (layers === 0) return\r\n  if (typeof obj === \"object\")\r\n    Object.values(Object.freeze(obj)).forEach(o => deepFreeze(o, layers--))\r\n}\r\n\r\nexport function arrayMove<T>(arr: T[], oldIndex: number, newIndex: number) {\r\n  if (newIndex < 0 || newIndex >= arr.length) return arr\r\n  if (oldIndex < 0 || oldIndex >= arr.length) return arr\r\n  arr.splice(newIndex, 0, arr.splice(oldIndex, 1)[0]);\r\n  return arr\r\n}\r\n","\r\nimport { objectKeyMap } from \"../Util/Util\"\r\nimport type { AnyNode, Data, DataNode, Info, LookupNode, MatchNode, NumNode, ReadNode, StrNode, SubscriptNode } from \"./type\"\r\n\r\ntype Num = number | NumNode\r\ntype Str = string | undefined | StrNode\r\ntype Any = Num | Str\r\n\r\nexport const todo: NumNode = constant(NaN, { key: \"TODO\" })\r\nexport const one = percent(1), naught = percent(0)\r\nexport const none = constant(\"none\")\r\n\r\nexport function constant(value: number, info?: Info): NumNode\r\nexport function constant(value: string | undefined, info?: Info): StrNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode\r\nexport function constant(value: number | string | undefined, info?: Info): AnyNode {\r\n  return { operation: \"const\", operands: [], value, info }\r\n}\r\n/** `value` in percentage. The value is written as non-percentage, e.g., `percent(1)` for 100% */\r\nexport function percent(value: number, info?: Info): NumNode {\r\n  if (value >= Number.MAX_VALUE / 100) value = Infinity\r\n  if (value <= -Number.MAX_VALUE / 100) value = -Infinity\r\n  return constant(value, { key: \"_\", ...info })\r\n}\r\n/** Inject `info` to the node in-place */\r\nexport function infoMut(node: NumNode, info: Info): NumNode\r\nexport function infoMut(node: StrNode, info: Info): StrNode\r\nexport function infoMut(node: NumNode | StrNode, info: Info): NumNode | StrNode {\r\n  if (info) node.info = { ...node.info, ...info }\r\n  return node\r\n}\r\n\r\n/** `table[string] ?? defaultNode` */\r\nexport function lookup(index: StrNode, table: Dict<string, NumNode>, defaultV: Num | \"none\", info?: Info): NumNode\r\nexport function lookup(index: StrNode, table: Dict<string, StrNode>, defaultV: Str | \"none\", info?: Info): StrNode\r\nexport function lookup(index: StrNode, table: Dict<string, AnyNode>, defaultV: Any | \"none\", info?: Info): LookupNode<any> {\r\n  const operands = defaultV !== \"none\" ? [intoV(index), intoV(defaultV)] as const : [intoV(index)] as const\r\n  return { operation: \"lookup\", operands, table, info }\r\n}\r\n\r\n/** min( x1, x2, ... ) */\r\nexport function min(...values: Num[]): NumNode {\r\n  return { operation: \"min\", operands: intoOps(values) }\r\n}\r\n/** max( x1, x2, ... ) */\r\nexport function max(...values: Num[]): NumNode {\r\n  return { operation: \"max\", operands: intoOps(values) }\r\n}\r\n/** x1 + x2 + ... */\r\nexport function sum(...values: Num[]): NumNode {\r\n  return { operation: \"add\", operands: intoOps(values) }\r\n}\r\n/** x1 * x2 * ... */\r\nexport function prod(...values: Num[]): NumNode {\r\n  return { operation: \"mul\", operands: intoOps(values) }\r\n}\r\n/** x / (x + c) */\r\nexport function frac(x: Num, c: Num): NumNode {\r\n  return { operation: \"sum_frac\", operands: intoOps([x, c]) }\r\n}\r\nexport function res(base: Num): NumNode {\r\n  return { operation: \"res\", operands: intoOps([base]) }\r\n}\r\n\r\n/** v1 == v2 ? eq : neq */\r\nexport function compareEq(v1: Num, v2: Num, eq: Num, neq: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function compareEq(v1: Num, v2: Num, eq: Str, neq: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function compareEq(v1: Str, v2: Str, eq: Num, neq: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function compareEq(v1: Str, v2: Str, eq: Str, neq: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function compareEq(v1: Num | Str, v2: Num | Str, eq: Num | Str, neq: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(eq), intoV(neq)], info }\r\n}\r\n/** v1 == v2 ? pass : 0 */\r\nexport function equal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function equal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function equal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(0)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 == v2 ? pass : `undefined` */\r\nexport function equalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function equalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function equalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<NumNode | StrNode, StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)], info, emptyOn: \"unmatch\" }\r\n}\r\n/** v1 != v2 ? pass : 0 */\r\nexport function unequal(v1: Num, v2: Num, pass: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function unequal(v1: Str, v2: Str, pass: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function unequal(v1: Num | Str, v2: Num | Str, pass: Num, info?: Info): MatchNode<NumNode | StrNode, NumNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(0), intoV(pass)], info, emptyOn: \"match\" }\r\n}\r\n/** v1 != v2 ? pass : `undefined` */\r\nexport function unequalStr(v1: Num, v2: Num, pass: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function unequalStr(v1: Str, v2: Str, pass: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function unequalStr(v1: Num | Str, v2: Num | Str, pass: Str, info?: Info): MatchNode<NumNode | StrNode, StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(undefined), intoV(pass)], info, emptyOn: \"match\" }\r\n}\r\n/** v1 >= v2 ? pass : 0 */\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function greaterEq(v1: Num, v2: Num, pass: Num, info?: Info): NumNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(0)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 >= v2 ? pass : `undefined` */\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): StrNode\r\nexport function greaterEqStr(v1: Num, v2: Num, pass: Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(pass), intoV(undefined)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"l\" }\r\n}\r\n/** v1 < v2 ? pass : 0 */\r\nexport function lessThan(v1: Num, v2: Num, pass: Num, info?: Info): NumNode\r\nexport function lessThan(v1: Num, v2: Num, pass: Num | Str, info?: Info): NumNode | StrNode {\r\n  const operands = [intoV(v1), intoV(v2), intoV(0), intoV(pass)] as any\r\n  return { operation: \"threshold\", operands, info, emptyOn: \"ge\" }\r\n}\r\n\r\nexport function setReadNodeKeys<T extends NodeList>(nodeList: T, prefix: string[] = []): T {\r\n  if (nodeList.operation) {\r\n    if (nodeList.operation !== \"read\")\r\n      throw new Error(`Found ${(nodeList as any).operation} node while making reader`)\r\n    return { ...nodeList, path: prefix }\r\n  } else {\r\n    return objectKeyMap(Object.keys(nodeList), key =>\r\n      setReadNodeKeys(nodeList[key], [...prefix, key])) as any\r\n  }\r\n}\r\nexport function data(base: NumNode, data: Data): DataNode<NumNode>\r\nexport function data(base: StrNode, data: Data): DataNode<StrNode>\r\nexport function data(base: NumNode | StrNode, data: Data): DataNode<NumNode> | DataNode<StrNode>\r\nexport function data(base: AnyNode, data: Data): DataNode<AnyNode> {\r\n  return { operation: \"data\", operands: [base], data }\r\n}\r\nexport function resetData(base: NumNode, data: Data, info?: Info): NumNode\r\nexport function resetData(base: StrNode, data: Data, info?: Info): StrNode\r\nexport function resetData(base: NumNode | StrNode, data: Data, info?: Info): DataNode<NumNode | StrNode>\r\nexport function resetData(base: AnyNode, data: Data, info?: Info): DataNode<any> {\r\n  return { operation: \"data\", operands: [base], data, reset: true, info }\r\n}\r\n\r\n\r\nexport function customRead(path: readonly string[], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path, info, type: \"number\" }\r\n}\r\nexport function customStringRead(path: readonly string[]): ReadNode<string> {\r\n  return { operation: \"read\", operands: [], path, type: \"string\" }\r\n}\r\nexport function read(accu?: ReadNode<number>[\"accu\"], info?: Info): ReadNode<number> {\r\n  return { operation: \"read\", operands: [], path: [], accu, info, type: \"number\" }\r\n}\r\n/**\r\n * CAUTION: Use `prio` accumulation sparingly. WR don't assume the reading order, so the result may be unstable\r\n */\r\nexport function stringRead(accu?: ReadNode<string | undefined>[\"accu\"]): ReadNode<string | undefined> {\r\n  return { operation: \"read\", operands: [], path: [], accu, type: \"string\" }\r\n}\r\nexport function stringPrio(...operands: Str[]): StrNode {\r\n  return { operation: \"prio\", operands: intoOps(operands) }\r\n}\r\n/** list[index] */\r\nexport function subscript<V>(index: NumNode, list: V[], info?: Info): SubscriptNode<V> {\r\n  return { operation: \"subscript\", operands: [index], list, info }\r\n}\r\n\r\nfunction intoOps(values: Num[]): NumNode[]\r\nfunction intoOps(values: Str[]): StrNode[]\r\nfunction intoOps(values: Any[]): AnyNode[]\r\nfunction intoOps(values: Any[]): AnyNode[] {\r\n  return values.map(value => typeof value === \"object\" ? value : constant(value))\r\n}\r\nfunction intoV(value: Num): NumNode\r\nfunction intoV(value: Str): StrNode\r\nfunction intoV(value: Num | Str): NumNode | StrNode\r\nfunction intoV(value: Any): AnyNode {\r\n  return (typeof value !== \"object\") ? constant(value) : value\r\n}\r\n\r\ntype _NodeList = {\r\n  [key: string]: NodeList\r\n} & {\r\n  operation?: never\r\n}\r\ntype NodeList = _NodeList | ReadNode<number> | ReadNode<string>\r\n\r\n/**\r\n * `v1` === `v2` ? `match` : `unmatch`\r\n * @deprecated Use `equal`, `unequal`, `equalStr`, or `compareEq` instead\r\n */\r\nexport function matchFull(v1: Num, v2: Num, match: Num, unmatch: Num, info?: Info): MatchNode<NumNode, NumNode>\r\nexport function matchFull(v1: Num, v2: Num, match: Str, unmatch: Str, info?: Info): MatchNode<NumNode, StrNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Num, unmatch: Num, info?: Info): MatchNode<StrNode, NumNode>\r\nexport function matchFull(v1: Str, v2: Str, match: Str, unmatch: Str, info?: Info): MatchNode<StrNode, StrNode>\r\nexport function matchFull(v1: Num | Str, v2: Num | Str, match: Num | Str, unmatch: Num | Str, info?: Info): MatchNode<NumNode | StrNode, NumNode | StrNode> {\r\n  return { operation: \"match\", operands: [intoV(v1), intoV(v2), intoV(match), intoV(unmatch)], info }\r\n}\r\n","import { AnyNode, NumNode, StrNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nexport function forEachNodes(formulas: (NumNode | StrNode)[], topDown: (formula: (NumNode | StrNode)) => void, bottomUp: (formula: (NumNode | StrNode)) => void): void {\r\n  const visiting = new Set<(NumNode | StrNode)>(), visited = new Set<(NumNode | StrNode)>()\r\n\r\n  function traverse(formula: (NumNode | StrNode)) {\r\n    if (visited.has(formula)) return\r\n\r\n    if (visiting.has(formula)) {\r\n      console.error(\"Found cyclical dependency during formula traversal\")\r\n      return\r\n    }\r\n    visiting.add(formula)\r\n\r\n    topDown(formula)\r\n\r\n    formula.operands.forEach(traverse)\r\n\r\n    bottomUp(formula)\r\n\r\n    visiting.delete(formula)\r\n    visited.add(formula)\r\n  }\r\n\r\n  formulas.forEach(traverse)\r\n}\r\n\r\nexport function mapFormulas(formulas: NumNode[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): NumNode[]\r\nexport function mapFormulas(formulas: (NumNode | StrNode)[], topDownMap: (formula: (NumNode | StrNode)) => (NumNode | StrNode), bottomUpMap: (current: (NumNode | StrNode), orig: (NumNode | StrNode)) => (NumNode | StrNode)): (NumNode | StrNode)[] {\r\n  const visiting = new Set<(NumNode | StrNode)>()\r\n  const topDownMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n  const bottomUpMapped = new Map<(NumNode | StrNode), (NumNode | StrNode)>()\r\n\r\n  function check(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    let topDown = topDownMapped.get(formula)\r\n    if (topDown) return topDown\r\n    topDown = topDownMap(formula)\r\n\r\n    let bottomUp = bottomUpMapped.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n    visiting.add(topDown)\r\n\r\n    bottomUp = bottomUpMap(traverse(topDown), formula)\r\n\r\n    visiting.delete(topDown)\r\n\r\n    topDownMapped.set(formula, bottomUp)\r\n    bottomUpMapped.set(topDown, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: (NumNode | StrNode)): (NumNode | StrNode) {\r\n    const operands = formula.operands.map(check)\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands } as any\r\n  }\r\n\r\n  const result = formulas.map(check)\r\n  return arrayEqual(result, formulas) ? formulas : result\r\n}\r\n\r\nexport function mapContextualFormulas(formulas: NumNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): NumNode[]\r\nexport function mapContextualFormulas(formulas: AnyNode[], baseContextId: number, topDownMap: (formula: AnyNode, contextId: ContextID) => [AnyNode, ContextID], bottomUpMap: (formula: AnyNode, orig: AnyNode, contextId: ContextID, origContextId: ContextID) => AnyNode): AnyNode[] {\r\n  const visiting = new Set<AnyNode>()\r\n  const topDownByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n  const bottomUpByContext = new Map<ContextID, Map<AnyNode, AnyNode>>()\r\n\r\n  function check(formula: AnyNode, parentContextId: ContextID): AnyNode {\r\n    let topDownMapping = topDownByContext.get(parentContextId)\r\n    if (!topDownMapping) {\r\n      topDownMapping = new Map()\r\n      topDownByContext.set(parentContextId, topDownMapping)\r\n    }\r\n\r\n    let topDown = topDownMapping.get(formula)\r\n    if (topDown) return topDown\r\n    let topDownContextId: number\r\n    [topDown, topDownContextId] = topDownMap(formula, parentContextId)\r\n\r\n    if (visiting.has(topDown)) {\r\n      console.error(\"Found cyclical dependency during formula mapping\")\r\n      return constant(NaN)\r\n    }\r\n\r\n    let bottomUpMapping = bottomUpByContext.get(topDownContextId)\r\n    if (!bottomUpMapping) {\r\n      bottomUpMapping = new Map()\r\n      bottomUpByContext.set(topDownContextId, bottomUpMapping)\r\n    }\r\n\r\n    let bottomUp = bottomUpMapping.get(topDown)\r\n    if (bottomUp) return bottomUp\r\n\r\n    visiting.add(topDown)\r\n    bottomUp = bottomUpMap(traverse(topDown, topDownContextId), formula, topDownContextId, parentContextId)\r\n    visiting.delete(topDown)\r\n\r\n    bottomUpMapping.set(topDown, bottomUp)\r\n    topDownMapping.set(formula, bottomUp)\r\n    return bottomUp\r\n  }\r\n\r\n  function traverse(formula: AnyNode, contextId: ContextID): AnyNode {\r\n    const operands = formula.operands.map(f => check(f, contextId))\r\n    return arrayEqual(operands, formula.operands) ? formula : { ...formula, operands }\r\n  }\r\n\r\n  const result = formulas.map(f => check(f, baseContextId))\r\n  return arrayEqual(formulas, result) ? formulas : result\r\n}\r\n\r\ntype ContextID = number\r\n\r\nfunction arrayEqual<T>(a: readonly T[] | undefined, b: readonly T[] | undefined): boolean {\r\n  if (a === undefined) return b === undefined\r\n  if (b === undefined) return false\r\n\r\n  return a.length === b.length && a.every((value, i) => value === b[i])\r\n}\r\n","import type { ArtifactBuildData } from \"../PageCharacter/CharacterDisplay/Tabs/TabOptimize/common\"\r\nimport { assertUnreachable, objPathValue } from \"../Util/Util\"\r\nimport { forEachNodes, mapFormulas } from \"./internal\"\r\nimport { CommutativeMonoidOperation, ComputeNode, ConstantNode, Data, NumNode, Operation, ReadNode, StrNode, StrPrioNode } from \"./type\"\r\nimport { constant } from \"./utils\"\r\n\r\nconst allCommutativeMonoidOperations: StrictDict<CommutativeMonoidOperation, (_: number[]) => number> = {\r\n  min: (x: number[]): number => Math.min(...x),\r\n  max: (x: number[]): number => Math.max(...x),\r\n  add: (x: number[]): number => x.reduce((a, b) => a + b, 0),\r\n  mul: (x: number[]): number => x.reduce((a, b) => a * b, 1),\r\n}\r\nexport const allOperations: StrictDict<Operation | \"threshold\", (_: number[]) => number> = {\r\n  ...allCommutativeMonoidOperations,\r\n  res: ([res]: number[]): number => {\r\n    if (res < 0) return 1 - res / 2\r\n    else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n    return 1 - res\r\n  },\r\n  sum_frac: (x: number[]): number => x[0] / x.reduce((a, b) => a + b),\r\n  threshold: ([value, threshold, pass, fail]: number[]): number => value >= threshold ? pass : fail,\r\n}\r\n\r\nconst commutativeMonoidOperationSet = new Set(Object.keys(allCommutativeMonoidOperations) as (NumNode[\"operation\"])[])\r\n\r\nexport function optimize(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  formulas = constantFold(formulas, topLevelData, shouldFold)\r\n  formulas = flatten(formulas)\r\n  formulas = deduplicate(formulas)\r\n  return formulas\r\n}\r\nexport function precompute(formulas: NumNode[], initial: ArtifactBuildData[\"values\"], binding: (readNode: ReadNode<number> | ReadNode<string | undefined>) => string, slotCount: number): (_: ArtifactBuildData[]) => number[] {\r\n  let body = `\r\n\"use strict\";\r\n// copied from the code above\r\nfunction res(res) {\r\n  if (res < 0) return 1 - res / 2\r\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\r\n  return 1 - res\r\n}\r\nconst x0=0`; // making sure `const` has at least one entry\r\n\r\n  let i = 1;\r\n  const names = new Map<NumNode | StrNode, string>()\r\n  forEachNodes(formulas, _ => { }, f => {\r\n    const { operation, operands } = f, name = `x${i++}`, operandNames = operands.map(x => names.get(x)!)\r\n    names.set(f, name)\r\n    switch (operation) {\r\n      case \"read\": {\r\n        const key = binding(f)\r\n        let arr = new Array(slotCount).fill(null).map((x, i) => `(b[${i}].values[\"${key}\"] ?? 0)`)\r\n        if (initial[key] && initial[key] !== 0) {\r\n          arr = [initial[key].toString(), ...arr]\r\n        }\r\n        body += `,${name}=${arr.join('+')}`\r\n        break\r\n      }\r\n      case \"const\": names.set(f, `(${f.value})`); break\r\n      case \"add\": case \"mul\": body += `,${name}=${operandNames.join(operation === \"add\" ? \"+\" : \"*\")}`; break\r\n      case \"min\": case \"max\": body += `,${name}=Math.${operation}(${operandNames})`; break\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = operandNames\r\n        body += `,${name}=(${value}>=${threshold})?${pass}:${fail}`\r\n        break\r\n      }\r\n      case \"res\": body += `,${name}=res(${operandNames[0]})`; break\r\n      case \"sum_frac\": body += `,${name}=${operandNames[0]}/(${operandNames[0]}+${operandNames[1]})`; break\r\n\r\n      case \"match\": case \"lookup\": case \"subscript\":\r\n      case \"prio\": case \"small\":\r\n      case \"data\": throw new Error(`Unsupported ${operation} node in precompute`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n  body += `;\\nreturn [${formulas.map(f => names.get(f)!)}]`\r\n  return new (Function as any)(`b`, body)\r\n}\r\n\r\nfunction flatten(formulas: NumNode[]): NumNode[] {\r\n  return mapFormulas(formulas, f => f, _formula => {\r\n    let result = _formula\r\n    if (commutativeMonoidOperationSet.has(_formula.operation as any)) {\r\n      const formula = _formula as ComputeNode\r\n      const { operation } = formula\r\n\r\n      let flattened = false\r\n      const operands = formula.operands.flatMap(dep =>\r\n        (dep.operation === operation) ? (flattened = true, dep.operands) : [dep])\r\n      result = flattened ? { ...formula, operands } : formula\r\n    }\r\n\r\n    return result\r\n  })\r\n}\r\nfunction deduplicate(formulas: NumNode[]): NumNode[] {\r\n  function elementCounts<T>(array: readonly T[]): Map<T, number> {\r\n    const result = new Map<T, number>()\r\n    for (const value of array) result.set(value, (result.get(value) ?? 0) + 1)\r\n    return result\r\n  }\r\n  function arrayFromCounts<T>(counts: Map<T, number>): T[] {\r\n    return [...counts].flatMap(([dep, count]) => Array(count).fill(dep))\r\n  }\r\n\r\n  const wrap = {\r\n    common: {\r\n      counts: new Map<NumNode, number>(),\r\n      formulas: new Set<NumNode>(),\r\n      operation: \"add\" as Operation\r\n    }\r\n  }\r\n\r\n  while (true) {\r\n    let next: typeof wrap.common | undefined\r\n\r\n    const factored: ComputeNode = { operation: wrap.common.operation, operands: arrayFromCounts(wrap.common.counts) }\r\n\r\n    let candidatesByOperation = new Map<Operation, [ComputeNode, Map<NumNode, number>][]>()\r\n    for (const operation of Object.keys(allCommutativeMonoidOperations))\r\n      candidatesByOperation.set(operation, [])\r\n\r\n    formulas = mapFormulas(formulas, _formula => {\r\n      if (wrap.common.formulas.has(_formula as NumNode)) {\r\n        const formula = _formula as ComputeNode\r\n        const remainingCounts = new Map(wrap.common.counts)\r\n        const operands = formula.operands.filter(dep => {\r\n          const count = remainingCounts.get(dep)\r\n          if (count) {\r\n            remainingCounts.set(dep, count - 1)\r\n            return false\r\n          }\r\n          return true\r\n        })\r\n\r\n        if (!operands.length)\r\n          return factored\r\n        operands.push(factored)\r\n        return { ...formula, operands }\r\n      }\r\n      return _formula\r\n    }, _formula => {\r\n      if (!commutativeMonoidOperationSet.has(_formula.operation as any)) return _formula\r\n      const formula = _formula as ComputeNode\r\n\r\n      if (next) {\r\n        if (next.operation === formula.operation) {\r\n          const currentCounts = elementCounts(formula.operands), commonCounts = new Map<NumNode, number>()\r\n          const nextCounts = next.counts\r\n          let total = 0\r\n\r\n          for (const [dependency, currentCount] of currentCounts.entries()) {\r\n            const commonCount = Math.min(currentCount, nextCounts.get(dependency) ?? 0)\r\n            if (commonCount) {\r\n              commonCounts.set(dependency, commonCount)\r\n              total += commonCount\r\n            } else commonCounts.delete(dependency)\r\n          }\r\n          if (total > 1) {\r\n            next.counts = commonCounts\r\n            next.formulas.add(formula)\r\n          }\r\n        }\r\n      } else {\r\n        const candidates = candidatesByOperation.get(formula.operation)!\r\n        const counts = elementCounts(formula.operands)\r\n\r\n        for (const [candidate, candidateCounts] of candidates) {\r\n          let total = 0\r\n\r\n          const commonCounts = new Map<NumNode, number>()\r\n          for (const [dependency, candidateCount] of candidateCounts.entries()) {\r\n            const count = Math.min(candidateCount, counts.get(dependency) ?? 0)\r\n            if (count) {\r\n              commonCounts.set(dependency, count)\r\n              total += count\r\n            }\r\n          }\r\n          if (total > 1) {\r\n            next = {\r\n              counts: commonCounts,\r\n              formulas: new Set([formula, candidate]),\r\n              operation: formula.operation\r\n            }\r\n            candidatesByOperation.clear()\r\n            break\r\n          }\r\n        }\r\n        if (!next) candidates.push([formula, counts])\r\n      }\r\n\r\n      return formula\r\n    })\r\n\r\n    if (next) wrap.common = next\r\n    else break\r\n  }\r\n\r\n  return formulas\r\n}\r\n\r\n/**\r\n * Replace nodes with known values with appropriate constants,\r\n * avoiding removal of any nodes that pass `isFixed` predicate\r\n */\r\nexport function constantFold(formulas: NumNode[], topLevelData: Data, shouldFold = (_formula: ReadNode<number | string | undefined>) => false): NumNode[] {\r\n  type Context = { data: Data[], processed: Map<NumNode | StrNode, NumNode | StrNode> }\r\n  const origin: Context = { data: [], processed: new Map() }\r\n  const nextContextMap = new Map([[origin, new Map<Data, Context>()]])\r\n\r\n  function fold(formula: StrNode, context: Context): StrNode\r\n  function fold(formula: NumNode, context: Context): NumNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode\r\n  function fold(formula: NumNode | StrNode, context: Context): NumNode | StrNode {\r\n    const old = context.processed.get(formula)\r\n    if (old) return old\r\n\r\n    const { operation } = formula\r\n    let result: NumNode | StrNode\r\n    switch (operation) {\r\n      case \"const\": return formula\r\n      case \"add\": case \"mul\": case \"max\": case \"min\":\r\n        const f = allOperations[operation]\r\n        const numericOperands: number[] = []\r\n        const formulaOperands: NumNode[] = formula.operands.filter(formula => {\r\n          const folded = fold(formula, context)\r\n          return (folded.operation === \"const\")\r\n            ? (numericOperands.push(folded.value), false)\r\n            : true\r\n        }).map(x => fold(x, context))\r\n        const numericValue = f(numericOperands)\r\n\r\n        // Fold degenerate cases. This may incorrectly compute NaN\r\n        // results, which shouldn't appear under expected usage.\r\n        // - zero\r\n        //   - 0 * ... = 0\r\n        // - infinity\r\n        //   - max(infinity, ...) = infinity\r\n        //   - infinity + ... = infinity\r\n        // - (-infinity)\r\n        //   - min(-infinity, ...) - infinity\r\n        //   - (-infinity) + ... = -infinity\r\n        // - NaN\r\n        //   - operation(NaN, ...) = NaN\r\n        if (!isFinite(numericValue)) {\r\n          if ((operation !== \"mul\") &&\r\n            (operation !== \"max\" || numericValue > 0) &&\r\n            (operation !== \"min\" || numericValue < 0)) {\r\n            result = constant(numericValue)\r\n            break\r\n          }\r\n        } else if (operation === \"mul\" && numericValue === 0) {\r\n          result = constant(numericValue)\r\n          break\r\n        }\r\n\r\n        if (numericValue !== f([])) // Skip vacuous values\r\n          formulaOperands.push(constant(numericValue))\r\n        if (formulaOperands.length <= 1) result = formulaOperands[0] ?? constant(f([]))\r\n        else result = { operation, operands: formulaOperands }\r\n        break\r\n      case \"res\": case \"sum_frac\": {\r\n        const operands = formula.operands.map(x => fold(x, context))\r\n        const f = allOperations[operation]\r\n        if (operands.every(x => x.operation === \"const\"))\r\n          result = constant(f(operands.map(x => (x as ConstantNode<number>).value)))\r\n        else result = { ...formula, operands }\r\n        break\r\n      }\r\n      case \"lookup\": {\r\n        const index = fold(formula.operands[0], context)\r\n        if (index.operation === \"const\") {\r\n          const selected = formula.table[index.value!] ?? formula.operands[1]\r\n          if (selected) {\r\n            result = fold(selected, context)\r\n            break\r\n          }\r\n        }\r\n        throw new Error(`Unsupported ${operation} node while folding`)\r\n      }\r\n      case \"prio\": {\r\n        const first = formula.operands.find(op => {\r\n          const folded = fold(op, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          return folded.value !== undefined\r\n        })\r\n        result = first ? fold(first, context) : constant(undefined)\r\n        break\r\n      }\r\n      case \"small\": {\r\n        let smallest = undefined as ConstantNode<string | undefined> | undefined\r\n        for (const operand of formula.operands) {\r\n          const folded = fold(operand, context)\r\n          if (folded.operation !== \"const\")\r\n            throw new Error(`Unsupported ${operation} node while folding`)\r\n          if (smallest?.value === undefined || (folded.value !== undefined && folded.value < smallest.value))\r\n            smallest = folded\r\n        }\r\n        result = smallest ?? constant(undefined)\r\n        break\r\n      }\r\n      case \"match\": {\r\n        const [v1, v2, match, unmatch] = formula.operands.map((x: NumNode | StrNode) => fold(x, context))\r\n        if (v1.operation !== \"const\" || v2.operation !== \"const\")\r\n          throw new Error(`Unsupported ${operation} node while folding`)\r\n        result = (v1.value === v2.value) ? match : unmatch\r\n        break\r\n      }\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = formula.operands.map(x => fold(x, context))\r\n        if (pass.operation === \"const\" && fail.operation === \"const\" && pass.value === fail.value)\r\n          result = pass\r\n        else if (value.operation === \"const\" && threshold.operation === \"const\")\r\n          result = value.value >= threshold.value ? pass : fail\r\n        else\r\n          result = { ...formula, operands: [value, threshold, pass, fail] }\r\n        break\r\n      }\r\n      case \"subscript\": {\r\n        const [index] = formula.operands.map(x => fold(x, context))\r\n        result = (index.operation === \"const\")\r\n          ? constant(formula.list[index.value])\r\n          : { ...formula, operands: [index] }\r\n        break\r\n      }\r\n      case \"read\": {\r\n        const operands = context.data\r\n          .map(x => objPathValue(x, formula.path) as (NumNode | StrNode))\r\n          .filter(x => x)\r\n\r\n        if (operands.length === 0) {\r\n          if (shouldFold(formula)) {\r\n            const { accu } = formula\r\n            if (accu === undefined || accu === \"small\")\r\n              result = formula.type === \"string\" ? constant(undefined) : constant(NaN)\r\n            else result = constant(allOperations[accu]([]))\r\n          } else result = formula\r\n        } else if (formula.accu === undefined || operands.length === 1)\r\n          result = fold(operands[operands.length - 1], context)\r\n        else\r\n          result = fold({ operation: formula.accu, operands } as ComputeNode | StrPrioNode, context)\r\n        break\r\n      }\r\n      case \"data\":\r\n        if (formula.reset) context = origin\r\n        const map = nextContextMap.get(context)!\r\n        let nextContext = map.get(formula.data)\r\n        if (!nextContext) {\r\n          nextContext = { data: [...context.data, formula.data], processed: new Map() }\r\n          nextContextMap.set(nextContext, new Map())\r\n          map.set(formula.data, nextContext)\r\n        }\r\n        result = fold(formula.operands[0], nextContext)\r\n        break\r\n      default: assertUnreachable(operation)\r\n    }\r\n\r\n    context.processed.set(formula, result)\r\n    return result\r\n  }\r\n\r\n  const context = { data: [topLevelData], processed: new Map() }\r\n  nextContextMap.set(context, new Map())\r\n  nextContextMap.get(origin)!.set(topLevelData, context)\r\n  return formulas.map(x => fold(x, context))\r\n}\r\n\r\nexport const testing = {\r\n  constantFold, flatten, deduplicate\r\n}\r\n","export const allHitModes = [\"hit\", \"avgHit\", \"critHit\"] as const\r\nexport const allRegions = [\"mondstadt\", \"liyue\", \"inazuma\", \"sumeru\", \"fontaine\", \"natlan\", \"snezhnaya\", \"khaenriah\"] as const\r\nexport const allAmpReactions = [\"vaporize\", \"melt\",] as const\r\nexport const allAdditiveReactions = [\"spread\", \"aggravate\"] as const\r\nexport const allArtifactSetCount = [1, 2, 3, 4, 5] as const\r\nexport const allRarities = [5, 4, 3, 2, 1] as const\r\nexport const allArtifactRarities = [5, 4, 3] as const\r\nexport const allSlotKeys = [\"flower\", \"plume\", \"sands\", \"goblet\", \"circlet\"] as const\r\nexport const allElements = ['anemo', 'geo', 'electro', 'hydro', 'pyro', 'cryo', 'dendro'] as const\r\nexport const allElementsWithPhy = [\"physical\", ...allElements] as const\r\nexport const allInfusionAuraElements = [\"pyro\", 'cryo'] as const\r\nexport const allWeaponTypeKeys = ['sword', 'claymore', 'polearm', 'bow', 'catalyst'] as const\r\nexport const allRollColorKeys = ['roll1', 'roll2', 'roll3', 'roll4', 'roll5', 'roll6'] as const\r\nexport const allAscension = [0, 1, 2, 3, 4, 5, 6] as const\r\nexport const allRefinement = [1, 2, 3, 4, 5] as const\r\nexport const substatType = [\"max\", \"mid\", \"min\"] as const\r\nexport const genderKeys = [\"F\", \"M\"] as const\r\nexport type Gender = typeof genderKeys[number]\r\n\r\n\r\nexport const allArtifactSets = [\r\n  \"Adventurer\",\r\n  \"ArchaicPetra\",\r\n  \"Berserker\",\r\n  \"BlizzardStrayer\",\r\n  \"BloodstainedChivalry\",\r\n  \"BraveHeart\",\r\n  \"CrimsonWitchOfFlames\",\r\n  \"DeepwoodMemories\",\r\n  \"DefendersWill\",\r\n  \"EchoesOfAnOffering\",\r\n  \"EmblemOfSeveredFate\",\r\n  \"Gambler\",\r\n  \"GildedDreams\",\r\n  \"GladiatorsFinale\",\r\n  \"HeartOfDepth\",\r\n  \"HuskOfOpulentDreams\",\r\n  \"Instructor\",\r\n  \"Lavawalker\",\r\n  \"LuckyDog\",\r\n  \"MaidenBeloved\",\r\n  \"MartialArtist\",\r\n  \"NoblesseOblige\",\r\n  \"OceanHuedClam\",\r\n  \"PaleFlame\",\r\n  \"PrayersForDestiny\",\r\n  \"PrayersForIllumination\",\r\n  \"PrayersForWisdom\",\r\n  \"PrayersToSpringtime\",\r\n  \"ResolutionOfSojourner\",\r\n  \"RetracingBolide\",\r\n  \"Scholar\",\r\n  \"ShimenawasReminiscence\",\r\n  \"TenacityOfTheMillelith\",\r\n  \"TheExile\",\r\n  \"ThunderingFury\",\r\n  \"Thundersoother\",\r\n  \"TinyMiracle\",\r\n  \"TravelingDoctor\",\r\n  \"VermillionHereafter\",\r\n  \"ViridescentVenerer\",\r\n  \"WanderersTroupe\",\r\n] as const\r\nexport const nonTravelerCharacterKeys = [\r\n  \"Albedo\",\r\n  \"Amber\",\r\n  \"Barbara\",\r\n  \"Beidou\",\r\n  \"Bennett\",\r\n  \"Chongyun\",\r\n  \"Diluc\",\r\n  \"Diona\",\r\n  \"Fischl\",\r\n  \"Ganyu\",\r\n  \"HuTao\",\r\n  \"Jean\",\r\n  \"Kaeya\",\r\n  \"Keqing\",\r\n  \"Klee\",\r\n  \"KujouSara\",\r\n  \"KukiShinobu\",\r\n  \"Lisa\",\r\n  \"Mona\",\r\n  \"Ningguang\",\r\n  \"Noelle\",\r\n  \"Qiqi\",\r\n  \"Razor\",\r\n  \"Sucrose\",\r\n  \"Tartaglia\",\r\n  \"RaidenShogun\",\r\n  \"Venti\",\r\n  \"Xiangling\",\r\n  \"Xiao\",\r\n  \"Xingqiu\",\r\n  \"Xinyan\",\r\n  \"Rosaria\",\r\n  \"Yanfei\",\r\n  \"Eula\",\r\n  \"KaedeharaKazuha\",\r\n  \"KamisatoAyaka\",\r\n  \"Sayu\",\r\n  \"Shenhe\",\r\n  \"Yoimiya\",\r\n  \"Aloy\",\r\n  \"SangonomiyaKokomi\",\r\n  \"Thoma\",\r\n  \"Gorou\",\r\n  \"AratakiItto\",\r\n  \"YaeMiko\",\r\n  \"YunJin\",\r\n  \"Zhongli\",\r\n  \"KamisatoAyato\",\r\n  \"Yelan\",\r\n  \"ShikanoinHeizou\",\r\n  \"Collei\",\r\n  \"Dori\",\r\n  \"Tighnari\",\r\n] as const\r\nexport const locationCharacterKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  \"Traveler\",\r\n] as const\r\nexport const travelerElements = [\r\n  \"anemo\",\r\n  \"geo\",\r\n  \"electro\",\r\n  \"dendro\"\r\n] as const\r\nexport const travelerFKeys = [\r\n  \"TravelerAnemoF\",\r\n  \"TravelerGeoF\",\r\n  \"TravelerElectroF\",\r\n  \"TravelerDendroF\",\r\n] as const\r\nexport const travelerMKeys = [\r\n  \"TravelerAnemoM\",\r\n  \"TravelerGeoM\",\r\n  \"TravelerElectroM\",\r\n  \"TravelerDendroM\",\r\n] as const\r\nexport const travelerKeys = [\r\n  \"TravelerAnemo\",\r\n  \"TravelerGeo\",\r\n  \"TravelerElectro\",\r\n  \"TravelerDendro\",\r\n] as const\r\nexport const allCharacterKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  ...travelerKeys\r\n] as const\r\n\r\nexport const allCharacterSheetKeys = [\r\n  ...nonTravelerCharacterKeys,\r\n  ...travelerFKeys,\r\n  ...travelerMKeys,\r\n]\r\n\r\nexport const allWeaponSwordKeys = [\r\n  \"AmenomaKageuchi\",\r\n  \"AquilaFavonia\",\r\n  \"BlackcliffLongsword\",\r\n  \"CinnabarSpindle\",\r\n  \"CoolSteel\",\r\n  \"KagotsurubeIsshin\",\r\n  \"DarkIronSword\",\r\n  \"DullBlade\",\r\n  \"FavoniusSword\",\r\n  \"FesteringDesire\",\r\n  \"FilletBlade\",\r\n  \"FreedomSworn\",\r\n  \"HaranGeppakuFutsu\",\r\n  \"HarbingerOfDawn\",\r\n  \"IronSting\",\r\n  \"LionsRoar\",\r\n  \"MistsplitterReforged\",\r\n  \"PrimordialJadeCutter\",\r\n  \"PrototypeRancour\",\r\n  \"RoyalLongsword\",\r\n  \"SacrificialSword\",\r\n  \"SapwoodBlade\",\r\n  \"SilverSword\",\r\n  \"SkyriderSword\",\r\n  \"SkywardBlade\",\r\n  \"SummitShaper\",\r\n  \"SwordOfDescension\",\r\n  \"TheAlleyFlash\",\r\n  \"TheBlackSword\",\r\n  \"TheFlute\",\r\n  \"TravelersHandySword\",\r\n] as const\r\nexport type WeaponSwordKey = typeof allWeaponSwordKeys[number]\r\n\r\nexport const allWeaponClaymoreKeys = [\r\n  \"Akuoumaru\",\r\n  \"BlackcliffSlasher\",\r\n  \"BloodtaintedGreatsword\",\r\n  \"DebateClub\",\r\n  \"FavoniusGreatsword\",\r\n  \"FerrousShadow\",\r\n  \"ForestRegalia\",\r\n  \"KatsuragikiriNagamasa\",\r\n  \"LithicBlade\",\r\n  \"LuxuriousSeaLord\",\r\n  \"OldMercsPal\",\r\n  \"PrototypeArchaic\",\r\n  \"Rainslasher\",\r\n  \"RedhornStonethresher\",\r\n  \"RoyalGreatsword\",\r\n  \"SacrificialGreatsword\",\r\n  \"SerpentSpine\",\r\n  \"SkyriderGreatsword\",\r\n  \"SkywardPride\",\r\n  \"SnowTombedStarsilver\",\r\n  \"SongOfBrokenPines\",\r\n  \"TheBell\",\r\n  \"TheUnforged\",\r\n  \"WasterGreatsword\",\r\n  \"Whiteblind\",\r\n  \"WhiteIronGreatsword\",\r\n  \"WolfsGravestone\",\r\n] as const\r\nexport type WeaponClaymoreKey = typeof allWeaponClaymoreKeys[number]\r\n\r\nexport const allWeaponPolearmKeys = [\r\n  \"BeginnersProtector\",\r\n  \"BlackcliffPole\",\r\n  \"BlackTassel\",\r\n  \"CalamityQueller\",\r\n  \"CrescentPike\",\r\n  \"Deathmatch\",\r\n  \"DragonsBane\",\r\n  \"DragonspineSpear\",\r\n  \"EngulfingLightning\",\r\n  \"FavoniusLance\",\r\n  \"Halberd\",\r\n  \"IronPoint\",\r\n  \"KitainCrossSpear\",\r\n  \"LithicSpear\",\r\n  \"Moonpiercer\",\r\n  \"PrimordialJadeWingedSpear\",\r\n  \"PrototypeStarglitter\",\r\n  \"RoyalSpear\",\r\n  \"SkywardSpine\",\r\n  \"StaffOfHoma\",\r\n  \"TheCatch\",\r\n  \"VortexVanquisher\",\r\n  \"WavebreakersFin\",\r\n  \"WhiteTassel\",\r\n] as const\r\nexport type WeaponPoleArmKey = typeof allWeaponPolearmKeys[number]\r\n\r\nexport const allWeaponBowKeys = [\r\n  \"AlleyHunter\",\r\n  \"AmosBow\",\r\n  \"AquaSimulacra\",\r\n  \"BlackcliffWarbow\",\r\n  \"CompoundBow\",\r\n  \"ElegyForTheEnd\",\r\n  \"FadingTwilight\",\r\n  \"FavoniusWarbow\",\r\n  \"Hamayumi\",\r\n  \"HuntersBow\",\r\n  \"HuntersPath\",\r\n  \"KingsSquire\",\r\n  \"Messenger\",\r\n  \"MitternachtsWaltz\",\r\n  \"MouunsMoon\",\r\n  \"PolarStar\",\r\n  \"Predator\",\r\n  \"PrototypeCrescent\",\r\n  \"RavenBow\",\r\n  \"RecurveBow\",\r\n  \"RoyalBow\",\r\n  \"Rust\",\r\n  \"SacrificialBow\",\r\n  \"SeasonedHuntersBow\",\r\n  \"SharpshootersOath\",\r\n  \"SkywardHarp\",\r\n  \"Slingshot\",\r\n  \"TheStringless\",\r\n  \"TheViridescentHunt\",\r\n  \"ThunderingPulse\",\r\n  \"EndOfTheLine\",\r\n  \"WindblumeOde\",\r\n] as const\r\nexport type WeaponBowKey = typeof allWeaponBowKeys[number]\r\n\r\nexport const allWeaponCatalystKeys = [\r\n  \"ApprenticesNotes\",\r\n  \"BlackcliffAgate\",\r\n  \"DodocoTales\",\r\n  \"EmeraldOrb\",\r\n  \"EverlastingMoonglow\",\r\n  \"EyeOfPerception\",\r\n  \"FavoniusCodex\",\r\n  \"Frostbearer\",\r\n  \"FruitOfFulfillment\",\r\n  \"HakushinRing\",\r\n  \"KagurasVerity\",\r\n  \"LostPrayerToTheSacredWinds\",\r\n  \"MagicGuide\",\r\n  \"MappaMare\",\r\n  \"MemoryOfDust\",\r\n  \"OathswornEye\",\r\n  \"OtherworldlyStory\",\r\n  \"PocketGrimoire\",\r\n  \"PrototypeAmber\",\r\n  \"RoyalGrimoire\",\r\n  \"SacrificialFragments\",\r\n  \"SkywardAtlas\",\r\n  \"SolarPearl\",\r\n  \"TheWidsith\",\r\n  \"ThrillingTalesOfDragonSlayers\",\r\n  \"TwinNephrite\",\r\n  \"WineAndSong\",\r\n] as const\r\nexport type WeaponCatalystKey = typeof allWeaponCatalystKeys[number]\r\n\r\nexport const allWeaponKeys = [\r\n  ...allWeaponSwordKeys,\r\n  ...allWeaponClaymoreKeys,\r\n  ...allWeaponPolearmKeys,\r\n  ...allWeaponBowKeys,\r\n  ...allWeaponCatalystKeys,\r\n] as const\r\nexport type WeaponKey = WeaponSwordKey | WeaponClaymoreKey | WeaponPoleArmKey | WeaponBowKey | WeaponCatalystKey\r\n\r\nexport const characterSpecializedStatKeys = [\"hp_\", \"atk_\", \"def_\", \"eleMas\", \"enerRech_\", \"heal_\", \"critRate_\", \"critDMG_\", \"physical_dmg_\", \"anemo_dmg_\", \"geo_dmg_\", \"electro_dmg_\", \"hydro_dmg_\", \"pyro_dmg_\", \"cryo_dmg_\", \"dendro_dmg_\"] as const\r\n\r\nexport type HitModeKey = typeof allHitModes[number]\r\nexport type Region = typeof allRegions[number]\r\nexport type AmpReactionKey = typeof allAmpReactions[number]\r\nexport type AdditiveReactionKey = typeof allAdditiveReactions[number]\r\nexport type SetNum = typeof allArtifactSetCount[number]\r\nexport type Rarity = typeof allRarities[number]\r\nexport type ArtifactRarity = typeof allArtifactRarities[number]\r\nexport type SlotKey = typeof allSlotKeys[number]\r\nexport type ElementKey = typeof allElements[number]\r\nexport type ElementKeyWithPhy = typeof allElementsWithPhy[number]\r\nexport type InfusionAuraElements = typeof allInfusionAuraElements[number]\r\nexport type ArtifactSetKey = typeof allArtifactSets[number]\r\nexport type NonTravelerCharacterKey = typeof nonTravelerCharacterKeys[number]\r\nexport type CharacterKey = typeof allCharacterKeys[number]\r\nexport type CharacterSheetKey = typeof allCharacterSheetKeys[number]\r\nexport type LocationCharacterKey = typeof locationCharacterKeys[number]\r\nexport type TravelerKey = typeof travelerKeys[number]\r\nexport type TravelerElementKey = typeof travelerElements[number]\r\nexport type WeaponTypeKey = typeof allWeaponTypeKeys[number]\r\nexport type RollColorKey = typeof allRollColorKeys[number]\r\nexport type Ascension = typeof allAscension[number]\r\nexport type Refinement = typeof allRefinement[number]\r\nexport type CharacterSpecializedStatKey = typeof characterSpecializedStatKeys[number]\r\nexport const absorbableEle = [\"hydro\", \"pyro\", \"cryo\", \"electro\"] as ElementKey[]\r\nexport const allowedAmpReactions: Dict<ElementKey, AmpReactionKey[]> = {\r\n  pyro: [\"vaporize\", \"melt\"],\r\n  hydro: [\"vaporize\"],\r\n  cryo: [\"melt\"],\r\n  anemo: [\"vaporize\", \"melt\"],\r\n}\r\nexport const allowedAdditiveReactions: Dict<ElementKey, AdditiveReactionKey[]> = {\r\n  dendro: [\"spread\"],\r\n  electro: [\"aggravate\"],\r\n  anemo: [\"aggravate\"],\r\n}\r\n\r\nexport type SubstatType = typeof substatType[number]\r\n\r\nexport function charKeyToLocCharKey(charKey: CharacterKey): LocationCharacterKey {\r\n  if (travelerKeys.includes(charKey as TravelerKey)) return \"Traveler\"\r\n  return charKey as LocationCharacterKey\r\n}\r\n\r\nexport function TravelerToElement(key: TravelerKey, element: TravelerElementKey): TravelerKey {\r\n  return \"Traveler\" + element.toUpperCase().slice(0, 1) + element.slice(1) as TravelerKey\r\n}\r\n\r\nexport type LocationKey = LocationCharacterKey | \"\"\r\n\r\nexport function charKeyToCharName(ck: CharacterKey, gender: Gender): string {\r\n  return ck.startsWith(\"Traveler\") ? \"Traveler\" + gender : ck\r\n}\r\n","import { ArtSetExclusion } from \"../../../../Database/DataManagers/BuildsettingData\";\r\nimport { forEachNodes, mapFormulas } from \"../../../../Formula/internal\";\r\nimport { allOperations, constantFold } from \"../../../../Formula/optimization\";\r\nimport { ConstantNode, NumNode } from \"../../../../Formula/type\";\r\nimport { constant, customRead, max, min } from \"../../../../Formula/utils\";\r\nimport { allSlotKeys, ArtifactSetKey, SlotKey } from \"../../../../Types/consts\";\r\nimport { assertUnreachable, objectKeyMap, objectMap, range } from \"../../../../Util/Util\";\r\n\r\ntype DynMinMax = { [key in string]: MinMax }\r\ntype MinMax = { min: number, max: number }\r\n\r\ntype MicropassOperation = \"reaffine\" | \"pruneArtRange\" | \"pruneNodeRange\" | \"pruneOrder\"\r\nexport function pruneAll(nodes: NumNode[], minimum: number[], arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion, forced: Dict<MicropassOperation, boolean>): { nodes: NumNode[], arts: ArtifactsBySlot } {\r\n  let should = forced\r\n  /** If `key` makes progress, all operations in `value` should be performed */\r\n  const deps: StrictDict<MicropassOperation, Dict<MicropassOperation, true>> = {\r\n    pruneOrder: { pruneNodeRange: true },\r\n    pruneArtRange: { pruneNodeRange: true },\r\n    pruneNodeRange: { reaffine: true },\r\n    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }\r\n  }\r\n  let count = 0\r\n  while (Object.values(should).some(x => x) && count++ < 20) {\r\n    if (should.pruneOrder) {\r\n      delete should.pruneOrder\r\n      const newArts = pruneOrder(arts, numTop, exclusion)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneOrder }\r\n      }\r\n    }\r\n    if (should.pruneArtRange) {\r\n      delete should.pruneArtRange\r\n      const newArts = pruneArtRange(nodes, arts, minimum)\r\n      if (arts !== newArts) {\r\n        arts = newArts\r\n        should = { ...should, ...deps.pruneArtRange }\r\n      }\r\n    }\r\n    if (should.pruneNodeRange) {\r\n      delete should.pruneNodeRange\r\n      const newNodes = pruneNodeRange(nodes, arts)\r\n      if (nodes !== newNodes) {\r\n        nodes = newNodes\r\n        should = { ...should, ...deps.pruneNodeRange }\r\n      }\r\n    }\r\n    if (should.reaffine) {\r\n      delete should.reaffine\r\n      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts)\r\n      if (nodes !== newNodes || arts !== newArts) {\r\n        nodes = newNodes\r\n        arts = newArts\r\n        should = { ...should, ...deps.reaffine }\r\n      }\r\n    }\r\n  }\r\n  return { nodes, arts }\r\n}\r\n\r\nfunction reaffine(nodes: NumNode[], arts: ArtifactsBySlot, forceRename: boolean = false): { nodes: NumNode[], arts: ArtifactsBySlot } {\r\n  const affineNodes = new Set<NumNode>(), topLevelAffine = new Set<NumNode>()\r\n\r\n  function visit(node: NumNode, isAffine: boolean) {\r\n    if (isAffine) affineNodes.add(node)\r\n    else node.operands.forEach(_op => {\r\n      const op = _op as NumNode\r\n      affineNodes.has(op) && topLevelAffine.add(op)\r\n    })\r\n  }\r\n\r\n  const dynKeys = new Set<string>()\r\n\r\n  forEachNodes(nodes, _ => { }, f => {\r\n    const operation = f.operation\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.type !== \"number\" || f.path[0] !== \"dyn\" || f.accu !== \"add\")\r\n          throw new Error(`Found unsupported ${operation} node at path ${f.path} when computing affine nodes`)\r\n        dynKeys.add(f.path[1])\r\n        visit(f, true)\r\n        break\r\n      case \"add\": visit(f, f.operands.every(op => affineNodes.has(op))); break\r\n      case \"mul\": {\r\n        const nonConst = f.operands.filter(op => op.operation !== \"const\")\r\n        visit(f, nonConst.length === 0 || (nonConst.length === 1 && affineNodes.has(nonConst[0])))\r\n        break\r\n      }\r\n      case \"const\":\r\n        if (typeof f.value === \"string\" || f.value === undefined)\r\n          throw new Error(`Found constant ${f.value} while compacting`)\r\n        visit(f as NumNode, true); break\r\n      case \"res\": case \"threshold\": case \"sum_frac\":\r\n      case \"max\": case \"min\": visit(f, false); break\r\n      case \"data\": case \"subscript\": case \"lookup\": case \"match\": case \"prio\": case \"small\":\r\n        throw new Error(`Found unsupported ${operation} node when computing affine nodes`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n  })\r\n\r\n  if ([...topLevelAffine].every(({ operation }) => operation === \"read\" || operation === \"const\") &&\r\n    Object.keys(arts.base).length === dynKeys.size)\r\n    return { nodes, arts }\r\n\r\n  let current = -1\r\n  function nextDynKey(): string {\r\n    while (dynKeys.has(`${++current}`));\r\n    return `${current}`\r\n  }\r\n\r\n  nodes.forEach(node => affineNodes.has(node) && topLevelAffine.add(node))\r\n  const affine = [...topLevelAffine].filter(f => f.operation !== \"const\")\r\n  const affineMap = new Map(affine.map(node => [node,\r\n    !forceRename && node.operation === \"read\" && node.path[0] === \"dyn\"\r\n      ? node\r\n      : { ...customRead([\"dyn\", `${nextDynKey()}`]), accu: \"add\" as const }]))\r\n  nodes = mapFormulas(nodes, f => affineMap.get(f as NumNode) ?? f, f => f)\r\n\r\n  function reaffineArt(stat: DynStat): DynStat {\r\n    const values = constantFold([...affineMap.keys()], {\r\n      dyn: objectMap(stat, (value) => constant(value))\r\n    } as any, _ => true)\r\n    return Object.fromEntries([...affineMap.values()].map((v, i) => [v.path[1], (values[i] as ConstantNode<number>).value]))\r\n  }\r\n  const result = {\r\n    nodes, arts: {\r\n      base: reaffineArt(arts.base),\r\n      values: objectKeyMap(allSlotKeys, slot =>\r\n        arts.values[slot].map(({ id, set, values }) => ({ id, set, values: reaffineArt(values) })))\r\n    }\r\n  }\r\n  const offsets = Object.entries(reaffineArt({}))\r\n  for (const arts of Object.values(result.arts.values))\r\n    for (const { values } of arts)\r\n      for (const [key, baseValue] of offsets)\r\n        values[key] -= baseValue\r\n  return result\r\n}\r\n/** Remove artifacts that cannot be in top `numTop` builds */\r\nexport function pruneOrder(arts: ArtifactsBySlot, numTop: number, exclusion: ArtSetExclusion): ArtifactsBySlot {\r\n  let progress = false\r\n  const noRainbow = !exclusion.rainbow?.length\r\n  const noSwitchIn = new Set(Object.entries(exclusion).filter(([_, v]) => v.length).map(([k]) => k) as ArtifactSetKey[])\r\n  const noSwitchOut = new Set(Object.entries(exclusion).filter(([_, v]) => v.includes(2) && !v.includes(4)).map(([k]) => k) as ArtifactSetKey[])\r\n  const values = objectKeyMap(allSlotKeys, slot => {\r\n    const list = arts.values[slot]\r\n    const newList = list.filter(art => {\r\n      let count = 0\r\n      return list.every(other => {\r\n        const greaterEqual = Object.entries(other.values).every(([k, o]) => o >= art.values[k])\r\n        const greater = Object.entries(other.values).some(([k, o]) => o > art.values[k])\r\n        if (greaterEqual && (greater || other.id > art.id) &&\r\n          ((noRainbow && !noSwitchIn.has(other.set!) && !noSwitchOut.has(art.set!)) || art.set === other.set))\r\n          count++\r\n        return count < numTop\r\n      })\r\n    })\r\n    if (newList.length !== list.length) progress = true\r\n    return newList\r\n  })\r\n  return progress ? { base: arts.base, values } : arts\r\n}\r\n/** Remove artifacts that cannot reach `minimum` in any build */\r\nfunction pruneArtRange(nodes: NumNode[], arts: ArtifactsBySlot, minimum: number[]): ArtifactsBySlot {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const wrap = { arts }\r\n  while (true) {\r\n    const artRanges = objectKeyMap(allSlotKeys, slot => computeArtRange(wrap.arts.values[slot]))\r\n    const otherArtRanges = objectKeyMap(allSlotKeys, key =>\r\n      addArtRange(Object.entries(artRanges).map(a => a[0] === key ? baseRange : a[1]).filter(x => x)))\r\n\r\n    let progress = false\r\n    const values = objectKeyMap(allSlotKeys, slot => {\r\n      const result = wrap.arts.values[slot].filter(art => {\r\n        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]])\r\n        const newRange = computeNodeRange(nodes, read)\r\n        return nodes.every((node, i) => newRange.get(node)!.max >= (minimum[i] ?? -Infinity))\r\n      })\r\n      if (result.length !== wrap.arts.values[slot].length)\r\n        progress = true\r\n      return result\r\n    })\r\n    if (!progress) break\r\n    wrap.arts = { base: wrap.arts.base, values }\r\n  }\r\n  return wrap.arts\r\n}\r\nfunction pruneNodeRange(nodes: NumNode[], arts: ArtifactsBySlot): NumNode[] {\r\n  const baseRange = Object.fromEntries(Object.entries(arts.base).map(([key, x]) => [key, { min: x, max: x }]))\r\n  const reads = addArtRange([baseRange, ...Object.values(arts.values).map(values => computeArtRange(values))])\r\n  const nodeRange = computeNodeRange(nodes, reads)\r\n\r\n  return mapFormulas(nodes, f => {\r\n    const { operation } = f\r\n    const operandRanges = f.operands.map(x => nodeRange.get(x)!)\r\n    switch (operation) {\r\n      case \"threshold\": {\r\n        const [value, threshold, pass, fail] = operandRanges\r\n        if (value.min >= threshold.max) return f.operands[2]\r\n        else if (value.max < threshold.min) return f.operands[3]\r\n        if (pass.max === pass.min &&\r\n          fail.max === fail.min &&\r\n          pass.min === fail.min && isFinite(pass.min))\r\n          return constant(pass.max)\r\n        break\r\n      }\r\n      case \"min\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every((op2, j) => op1.min <= op2.max)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return min(...newOperands)\r\n        break\r\n      }\r\n      case \"max\": {\r\n        const newOperands = f.operands.filter((_, i) => {\r\n          const op1 = operandRanges[i]\r\n          return operandRanges.every(op2 => op1.max >= op2.min)\r\n        })\r\n        if (newOperands.length < operandRanges.length) return max(...newOperands)\r\n        break\r\n      }\r\n    }\r\n    return f\r\n  }, f => f)\r\n}\r\nfunction addArtRange(ranges: DynMinMax[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  ranges.forEach(range => {\r\n    Object.entries(range).forEach(([key, value]) => {\r\n      if (result[key]) {\r\n        result[key].min += value.min\r\n        result[key].max += value.max\r\n      } else result[key] = { ...value }\r\n    })\r\n  })\r\n  return result\r\n}\r\nfunction computeArtRange(arts: ArtifactBuildData[]): DynMinMax {\r\n  const result: DynMinMax = {}\r\n  if (arts.length) {\r\n    Object.keys(arts[0].values)\r\n      .filter(key => arts.every(art => art.values[key]))\r\n      .forEach(key => result[key] = { min: arts[0].values[key], max: arts[0].values[key] })\r\n    arts.forEach(({ values }) => {\r\n      for (const [key, value] of Object.entries(values)) {\r\n        if (!result[key]) result[key] = { min: 0, max: value }\r\n        else {\r\n          if (result[key].max < value) result[key].max = value\r\n          if (result[key].min > value) result[key].min = value\r\n        }\r\n      }\r\n    })\r\n  }\r\n  return result\r\n}\r\nfunction computeNodeRange(nodes: NumNode[], reads: DynMinMax): Map<NumNode, MinMax> {\r\n  const range = new Map<NumNode, MinMax>()\r\n\r\n  forEachNodes(nodes, _ => { }, _f => {\r\n    const f = _f as NumNode\r\n    const { operation } = f\r\n    const operands = f.operands.map(op => range.get(op)!)\r\n    let current: MinMax\r\n    switch (operation) {\r\n      case \"read\":\r\n        if (f.path[0] !== \"dyn\")\r\n          throw new Error(`Found non-dyn path ${f.path} while computing range`)\r\n        current = reads[f.path[1]] ?? { min: 0, max: 0 }\r\n        break\r\n      case \"const\": current = computeMinMax([f.value]); break\r\n      case \"subscript\": current = computeMinMax(f.list); break\r\n      case \"add\": case \"min\": case \"max\":\r\n        current = {\r\n          min: allOperations[operation](operands.map(x => x.min)),\r\n          max: allOperations[operation](operands.map(x => x.max)),\r\n        }; break\r\n      case \"res\": current = {\r\n        min: allOperations[operation]([operands[0].max]),\r\n        max: allOperations[operation]([operands[0].min]),\r\n      }; break\r\n      case \"mul\": current = operands.reduce((accu, current) => computeMinMax([\r\n        accu.min * current.min, accu.min * current.max,\r\n        accu.max * current.min, accu.max * current.max,\r\n      ])); break\r\n      case \"threshold\":\r\n        if (operands[0].min >= operands[1].max) current = operands[2]\r\n        else if (operands[0].max < operands[1].min) current = operands[3]\r\n        else current = computeMinMax([], [operands[2], operands[3]])\r\n        break\r\n      case \"sum_frac\": {\r\n        const [x, c] = operands, sum = { min: x.min + c.min, max: x.max + c.max }\r\n        if (sum.min <= 0 && sum.max >= 0)\r\n          current = (x.min <= 0 && x.max >= 0) ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity }\r\n        else\r\n          // TODO: Check this\r\n          current = computeMinMax([\r\n            x.min / sum.min, x.min / sum.max,\r\n            x.max / sum.min, x.max / sum.max\r\n          ])\r\n        break\r\n      }\r\n      case \"data\": case \"lookup\": case \"match\":\r\n        throw new Error(`Unsupported ${operation} node`)\r\n      default: assertUnreachable(operation)\r\n    }\r\n    range.set(f, current)\r\n  })\r\n  return range\r\n}\r\nfunction computeMinMax(values: readonly number[], minMaxes: readonly MinMax[] = []): MinMax {\r\n  const max = Math.max(...values, ...minMaxes.map(x => x.max))\r\n  const min = Math.min(...values, ...minMaxes.map(x => x.min))\r\n  return { min, max }\r\n}\r\n\r\nexport function filterArts(arts: ArtifactsBySlot, filters: RequestFilter): ArtifactsBySlot {\r\n  return {\r\n    base: arts.base,\r\n    values: objectKeyMap(allSlotKeys, slot => {\r\n      const filter = filters[slot]\r\n      switch (filter.kind) {\r\n        case \"id\": return arts.values[slot].filter(art => filter.ids.has(art.id))\r\n        case \"exclude\": return arts.values[slot].filter(art => !filter.sets.has(art.set!))\r\n        case \"required\": return arts.values[slot].filter(art => filter.sets.has(art.set!))\r\n      }\r\n    })\r\n  }\r\n}\r\n\r\nexport function mergeBuilds(builds: Build[][], maxNum: number): Build[] {\r\n  return builds.flatMap(x => x).sort((a, b) => b.value - a.value).slice(0, maxNum)\r\n}\r\nexport function mergePlot(plots: PlotData[]): PlotData {\r\n  let scale = 0.01, reductionScaling = 2, maxCount = 1500\r\n  let keys = new Set(plots.flatMap(x => Object.values(x).map(v => Math.round(v.plot! / scale))))\r\n  while (keys.size > maxCount) {\r\n    scale *= reductionScaling\r\n    keys = new Set([...keys].map(key => Math.round(key / reductionScaling)))\r\n  }\r\n  const result: PlotData = {}\r\n  for (const plot of plots)\r\n    for (const build of Object.values(plot)) {\r\n      const x = Math.round(build.plot! / scale) * scale\r\n      if (!result[x] || result[x]!.value < build.value)\r\n        result[x] = build\r\n    }\r\n  return result\r\n}\r\n\r\nexport function countBuilds(arts: ArtifactsBySlot): number {\r\n  return allSlotKeys.reduce((_count, slot) => _count * arts.values[slot].length, 1)\r\n}\r\n\r\n\r\nexport function* filterFeasiblePerm(filters: Iterable<RequestFilter>, _artSets: ArtifactsBySlot): Iterable<RequestFilter> {\r\n  const artSets = objectMap(_artSets.values, values => new Set(values.map(v => v.set)))\r\n  filter_loop: for (const filter of filters) {\r\n    for (const [slot, f] of Object.entries(filter)) {\r\n      const available = artSets[slot]!\r\n      switch (f.kind) {\r\n        case \"required\": if ([...f.sets].every(s => !available.has(s))) continue filter_loop; break\r\n        case \"exclude\": if ([...available].every(s => f.sets.has(s!))) continue filter_loop; break\r\n        case \"id\": break\r\n      }\r\n    }\r\n    yield filter\r\n  }\r\n}\r\nexport function exclusionToAllowed(exclusion: number[] | undefined): Set<number> {\r\n  return new Set(exclusion?.includes(2)\r\n    ? exclusion.includes(4) ? [0, 1] : [0, 1, 4, 5]\r\n    : exclusion?.includes(4) ? [0, 1, 2, 3] : [0, 1, 2, 3, 4, 5])\r\n}\r\n/** A *disjoint* set of `RequestFilter` satisfying the exclusion rules */\r\nexport function* artSetPerm(exclusion: ArtSetExclusion, _artSets: ArtifactSetKey[]): Iterable<RequestFilter> {\r\n  /**\r\n   * This generation algorithm is separated into two parts:\r\n   * - \"Shape\" generation\r\n   *   - It first generates all build \"shapes\", e.g., AABBC, ABBCD\r\n   *   - It then filters the generated shapes according to the rainbow exclusion, e.g., removes ABBCD if excluding 3 rainbows\r\n   *   - It then merges the remaining shapes into wildcards, e.g. AABAA + AABAB + AABAC => AABA*\r\n   * - Shape filling\r\n   *   - From the given shapes, it tries to fill in all non-rainbow slots, e.g., slots A and B of AABBC, with actual artifacts\r\n   *   - It then fills the rainbow slots, e.g., slot C of AABBC while ensuring the exclusion rule of each sets\r\n   */\r\n  const artSets = [...new Set(_artSets)], allowedRainbows = exclusionToAllowed(exclusion.rainbow)\r\n  let shapes: number[][] = []\r\n  function populateShapes(current: number[], list: Set<number>, rainbows: number[]) {\r\n    if (current.length === 5) {\r\n      if (allowedRainbows.has(rainbows.length))\r\n        shapes.push(current)\r\n      return\r\n    }\r\n    for (const i of list) populateShapes([...current, i], list, rainbows.filter(j => j !== i))\r\n    populateShapes([...current, current.length], new Set([...list, current.length]), [...rainbows, current.length])\r\n  }\r\n  populateShapes([0], new Set([0]), [0])\r\n  function indexOfShape(shape: number[], replacing: number) {\r\n    if (range(replacing + 1, 4).some(i => shape[i] !== 5))\r\n      return undefined\r\n    shape = [...shape]\r\n    shape[replacing] = 5\r\n    return shape.reduce((a, b) => a * 6 + b, 0)\r\n  }\r\n  for (let replacing = 4; replacing >= 0; replacing--) {\r\n    const required: Map<number, number> = new Map()\r\n    for (const shape of shapes) {\r\n      const id = indexOfShape(shape, replacing)\r\n      if (id === undefined) continue\r\n      required.set(id, (required.get(id) ?? new Set(shape.slice(0, replacing)).size + 1) - 1)\r\n    }\r\n    for (const [id, remaining] of required.entries()) {\r\n      if (remaining === 0) {\r\n        const shape = [...shapes.find(shape => indexOfShape(shape, replacing) === id)!]\r\n        shape[replacing] = 5\r\n        shapes = shapes.filter(shape => indexOfShape(shape, replacing) !== id)\r\n        shapes.push(shape)\r\n      }\r\n    }\r\n  }\r\n\r\n  // Shapes are now calculated and merged, proceed to fill in the sets\r\n\r\n  const noFilter = { kind: \"exclude\" as const, sets: new Set<ArtifactSetKey>() }\r\n  const result: RequestFilter = objectKeyMap(allSlotKeys, _ => noFilter)\r\n\r\n  const counts = { ...objectMap(exclusion, _ => 0), ...objectKeyMap(artSets, _ => 0) }\r\n  const allowedCounts = objectMap(exclusion, exclusionToAllowed)\r\n\r\n  function* check(shape: number[]) {\r\n    const used: Set<ArtifactSetKey> = new Set()\r\n    let groupped: number[][] = [], rainbows: number[] = []\r\n    for (const i of shape) {\r\n      groupped.push([])\r\n      if (i === 5) rainbows.push(groupped.length - 1)\r\n      else groupped[i].push(groupped.length - 1)\r\n    }\r\n    groupped = groupped.filter(v => v.length).sort((a, b) => b.length - a.length)\r\n    let usableRainbows = rainbows.length\r\n\r\n    // Inception.. because js doesn't like functions inside a for-loop\r\n    function* check(i: number) {\r\n      if (i === groupped.length)\r\n        return yield* check_free(0)\r\n\r\n      for (const set of artSets) {\r\n        if (used.has(set)) continue\r\n        const length = groupped[i].length, allowedSet = allowedCounts[set]\r\n        let requiredRainbows = 0\r\n\r\n        if (allowedSet && !allowedSet.has(length)) {\r\n          // Look ahead and see if we have enough rainbows to fill to the next `allowedSet` if we use the current set\r\n          requiredRainbows = (range(length + 1, 5).find(l => allowedSet.has(l)) ?? 6) - length\r\n          if (requiredRainbows > usableRainbows) continue // Not enough rainbows. Next..\r\n        }\r\n\r\n        used.add(set)\r\n        counts[set] = groupped[i].length\r\n        groupped[i].forEach(j => result[allSlotKeys[j]] = { kind: \"required\", sets: new Set([set]) })\r\n        usableRainbows -= requiredRainbows\r\n\r\n        yield* check(i + 1)\r\n\r\n        usableRainbows += requiredRainbows\r\n        counts[set] = 0\r\n        used.delete(set)\r\n      }\r\n    }\r\n    // We separate filling rainbow slots from groupped slots because it has an entirely\r\n    // different set of rules regarding what can be filled and what states to be kept.\r\n    function* check_free(i: number) {\r\n      const remaining = rainbows.length - i, isolated: ArtifactSetKey[] = [], missing: ArtifactSetKey[] = [], rejected: ArtifactSetKey[] = []\r\n      let required = 0\r\n      for (const set of artSets) {\r\n        const allowedSet = allowedCounts[set], count = counts[set]\r\n        if (!allowedSet) continue\r\n        if (range(1, remaining).every(j => !allowedSet.has(count + j))) rejected.push(set)\r\n        else if (!allowedSet.has(count)) {\r\n          required += [...allowedSet].find(x => x > count)! - count\r\n          missing.push(set)\r\n        }\r\n        else if (range(0, remaining).some(j => !allowedSet.has(count + j))) isolated.push(set)\r\n      }\r\n      if (required > remaining) return\r\n      if (i === rainbows.length) {\r\n        yield { ...result }\r\n        return\r\n      }\r\n      if (required === remaining) {\r\n        for (const set of missing) {\r\n          counts[set]++\r\n          result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\r\n          yield* check_free(i + 1)\r\n          counts[set]--\r\n        }\r\n        return\r\n      }\r\n      for (const set of [...isolated, ...missing]) {\r\n        counts[set]++\r\n        result[allSlotKeys[rainbows[i]]] = { kind: \"required\", sets: new Set([set]) }\r\n        yield* check_free(i + 1)\r\n        counts[set]--\r\n      }\r\n      result[allSlotKeys[rainbows[i]]] = { kind: \"exclude\", sets: new Set([...missing, ...rejected, ...isolated]) }\r\n      yield* check_free(i + 1)\r\n    }\r\n    yield* check(0)\r\n  }\r\n  for (const shape of shapes) yield* check(shape)\r\n}\r\n\r\nexport type RequestFilter = StrictDict<SlotKey,\r\n  { kind: \"required\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"exclude\", sets: Set<ArtifactSetKey> } |\r\n  { kind: \"id\", ids: Set<string> }\r\n>\r\n\r\nexport type DynStat = { [key in string]: number }\r\nexport type ArtifactBuildData = {\r\n  id: string\r\n  set?: ArtifactSetKey\r\n  values: DynStat\r\n}\r\nexport type ArtifactsBySlot = { base: DynStat, values: StrictDict<SlotKey, ArtifactBuildData[]> }\r\n\r\nexport type PlotData = Dict<number, Build>\r\nexport interface Build {\r\n  value: number\r\n  plot?: number\r\n  artifactIds: string[]\r\n}\r\n","import { ArtSetExclusion } from '../../../../Database/DataManagers/BuildsettingData'\r\nimport { NumNode } from '../../../../Formula/type'\r\nimport { assertUnreachable } from '../../../../Util/Util'\r\nimport { ArtifactsBySlot, artSetPerm, Build, countBuilds, filterArts, filterFeasiblePerm, PlotData, RequestFilter } from \"./common\"\r\nimport { ComputeWorker } from \"./ComputeWorker\"\r\nimport { SplitWorker } from \"./SplitWorker\"\r\n\r\nlet id: number, splitWorker: SplitWorker, computeWorker: ComputeWorker\r\n\r\nonmessage = ({ data }: { data: WorkerCommand }) => {\r\n  const command = data.command\r\n  let result: WorkerResult\r\n  switch (command) {\r\n    case \"setup\":\r\n      id = data.id\r\n      const splitID = `split${id}`, computeID = `compute${id}`\r\n      splitWorker = new SplitWorker(data, interim => postMessage({ id, source: splitID, ...interim }))\r\n      computeWorker = new ComputeWorker(data, interim => postMessage({ id, source: computeID, ...interim }))\r\n      result = { command: \"iterate\" }\r\n      break\r\n    case \"split\":\r\n      if (data.filter) splitWorker.addFilter(data.filter)\r\n      let total = 0, split = splitWorker.split(data.threshold, data.minCount)\r\n      while (split && split.count <= 50_000 && total <= 500_000) {\r\n        total += split.count\r\n        computeWorker.compute(-Infinity, split.filter)\r\n        split = splitWorker.split(-Infinity, data.minCount)\r\n      }\r\n      result = { command: \"split\", filter: split?.filter }\r\n      break\r\n    case \"iterate\":\r\n      const { threshold, filter } = data\r\n      computeWorker.compute(threshold, filter)\r\n      result = { command: \"iterate\" }\r\n      break\r\n    case \"finalize\":\r\n      computeWorker.refresh(true)\r\n      const { builds, plotData } = computeWorker\r\n      result = { command: \"finalize\", builds, plotData }\r\n      break\r\n    case \"count\":\r\n      {\r\n        const { exclusion } = data, arts = computeWorker.arts\r\n        const setPerm = filterFeasiblePerm(artSetPerm(exclusion, [...new Set(Object.values(arts.values).flatMap(x => x.map(x => x.set!)))]), arts)\r\n        let counts = data.arts.map(_ => 0)\r\n        for (const perm of setPerm)\r\n          data.arts.forEach((arts, i) => counts[i] += countBuilds(filterArts(arts, perm)));\r\n        result = { command: \"count\", counts }\r\n        break\r\n      }\r\n    default: assertUnreachable(command)\r\n  }\r\n  postMessage({ id, ...result });\r\n}\r\n\r\nexport type WorkerCommand = Setup | Split | Iterate | Finalize | Count\r\nexport type WorkerResult = SourcedInterimResult | SplitResult | IterateResult | FinalizeResult | CountResult\r\n\r\nexport interface Setup {\r\n  command: \"setup\"\r\n\r\n  id: number\r\n  arts: ArtifactsBySlot\r\n\r\n  optimizationTarget: NumNode\r\n  filters: { value: NumNode, min: number }[]\r\n  plotBase: NumNode | undefined,\r\n  maxBuilds: number\r\n}\r\nexport interface Split {\r\n  command: \"split\"\r\n  threshold: number\r\n  minCount: number\r\n  filter?: RequestFilter\r\n}\r\nexport interface Iterate {\r\n  command: \"iterate\"\r\n  threshold: number\r\n  filter: RequestFilter\r\n}\r\n\r\nexport interface Finalize {\r\n  command: \"finalize\"\r\n}\r\nexport interface Count {\r\n  command: \"count\"\r\n  arts: ArtifactsBySlot[]\r\n  exclusion: ArtSetExclusion\r\n}\r\nexport interface SplitResult {\r\n  command: \"split\"\r\n  filter: RequestFilter | undefined\r\n}\r\nexport interface IterateResult {\r\n  command: \"iterate\"\r\n}\r\nexport interface FinalizeResult {\r\n  command: \"finalize\"\r\n  builds: Build[]\r\n  plotData?: PlotData\r\n}\r\nexport interface CountResult {\r\n  command: \"count\"\r\n  counts: number[]\r\n}\r\nexport interface InterimResult {\r\n  command: \"interim\"\r\n  buildValues: number[] | undefined\r\n  /** The number of builds since last report, including failed builds */\r\n  tested: number\r\n  /** The number of builds that does not meet the min-filter requirement since last report */\r\n  failed: number\r\n  skipped: number\r\n}\r\nexport interface SourcedInterimResult extends InterimResult {\r\n  /** the source of the message, must be unique for each source of `buildValues` */\r\n  source: string\r\n}\r\n","import { optimize, precompute } from '../../../../Formula/optimization';\r\nimport type { NumNode } from '../../../../Formula/type';\r\nimport type { InterimResult, Setup } from './BackgroundWorker';\r\nimport { ArtifactBuildData, ArtifactsBySlot, Build, countBuilds, filterArts, mergePlot, PlotData, pruneAll, RequestFilter } from './common';\r\n\r\nexport class ComputeWorker {\r\n  builds: Build[] = []\r\n  buildValues: number[] | undefined = undefined\r\n  plotData: PlotData | undefined\r\n  threshold: number = -Infinity\r\n  maxBuilds: number\r\n  min: number[]\r\n\r\n  arts: ArtifactsBySlot\r\n  nodes: NumNode[]\r\n\r\n  callback: (interim: InterimResult) => void\r\n\r\n  constructor({ arts, optimizationTarget, filters, plotBase, maxBuilds }: Setup, callback: (interim: InterimResult) => void) {\r\n    this.arts = arts\r\n    this.min = filters.map(x => x.min)\r\n    this.maxBuilds = maxBuilds\r\n    this.callback = callback\r\n    this.nodes = filters.map(x => x.value)\r\n    this.nodes.push(optimizationTarget)\r\n    if (plotBase) {\r\n      this.plotData = {}\r\n      this.nodes.push(plotBase)\r\n    }\r\n    this.nodes = optimize(this.nodes, {}, _ => false)\r\n  }\r\n\r\n  compute(newThreshold: number, filter: RequestFilter) {\r\n    if (this.threshold > newThreshold) this.threshold = newThreshold\r\n    const { min, interimReport } = this, self = this // `this` in nested functions means different things\r\n    let preArts = filterArts(this.arts, filter)\r\n    const totalCount = countBuilds(preArts)\r\n\r\n    let nodes = this.nodes;\r\n    ({ nodes, arts: preArts } = pruneAll(nodes, min, preArts, this.maxBuilds, {}, {\r\n      pruneArtRange: true, pruneNodeRange: true,\r\n    }))\r\n    const arts = Object.values(preArts.values).sort((a, b) => a.length - b.length)\r\n    const compute = precompute(nodes, preArts.base, f => f.path[1], arts.length)\r\n\r\n    const buffer = Array<ArtifactBuildData>(arts.length)\r\n    const count = { tested: 0, failed: 0, skipped: totalCount - countBuilds(preArts) }\r\n\r\n    function permute(i: number) {\r\n      if (i < 0) {\r\n        const result = compute(buffer)\r\n        if (min.every((m, i) => (m <= result[i]))) {\r\n          const value = result[min.length], { builds, plotData } = self\r\n          let build: Build | undefined\r\n          if (value >= self.threshold) {\r\n            build = { value, artifactIds: buffer.map(x => x.id) }\r\n            builds.push(build)\r\n          }\r\n          if (plotData) {\r\n            const x = result[min.length + 1]\r\n            if (!plotData[x] || plotData[x]!.value < value) {\r\n              if (!build) build = { value, artifactIds: buffer.map(x => x.id) }\r\n              build.plot = x\r\n              plotData[x] = build\r\n            }\r\n          }\r\n        }\r\n        else count.failed += 1\r\n        return\r\n      }\r\n      arts[i].forEach(art => {\r\n        buffer[i] = art\r\n        permute(i - 1)\r\n      })\r\n      if (i === 0) {\r\n        count.tested += arts[0].length\r\n        if (count.tested > 1 << 16)\r\n          interimReport(count)\r\n      }\r\n    }\r\n\r\n    permute(arts.length - 1)\r\n    this.interimReport(count)\r\n  }\r\n\r\n  refresh(force: boolean): void {\r\n    const { maxBuilds } = this\r\n    if (Object.keys(this.plotData ?? {}).length >= 100000)\r\n      this.plotData = mergePlot([this.plotData!])\r\n\r\n    if (this.builds.length >= 1000 || force) {\r\n      this.builds = this.builds\r\n        .sort((a, b) => b.value - a.value)\r\n        .slice(0, maxBuilds)\r\n      this.buildValues = this.builds.map(x => x.value)\r\n      this.threshold = Math.max(this.threshold, this.buildValues[maxBuilds - 1] ?? -Infinity)\r\n    }\r\n  }\r\n  interimReport = (count: { tested: number, failed: number, skipped: number }) => {\r\n    this.refresh(false)\r\n    this.callback({ command: \"interim\", buildValues: this.buildValues, ...count })\r\n    this.buildValues = undefined\r\n    count.tested = 0\r\n    count.failed = 0\r\n    count.skipped = 0\r\n  }\r\n}\r\n","import type { NumNode } from '../../../../Formula/type';\r\nimport { allSlotKeys } from '../../../../Types/consts';\r\nimport type { InterimResult, Setup } from './BackgroundWorker';\r\nimport { ArtifactsBySlot, countBuilds, filterArts, RequestFilter } from './common';\r\n\r\nexport class SplitWorker {\r\n  min: number[]\r\n\r\n  arts: ArtifactsBySlot\r\n  nodes: NumNode[]\r\n\r\n  filters: { count: number, filter: RequestFilter }[] = []\r\n\r\n  callback: (interim: InterimResult) => void\r\n\r\n  constructor({ arts, optimizationTarget, filters }: Setup, callback: (interim: InterimResult) => void) {\r\n    this.arts = arts\r\n    this.min = filters.map(x => x.min)\r\n    this.nodes = filters.map(x => x.value)\r\n    this.callback = callback\r\n\r\n    this.min.push(-Infinity)\r\n    this.nodes.push(optimizationTarget)\r\n  }\r\n  addFilter(filter: RequestFilter) {\r\n    const count = countBuilds(filterArts(this.arts, filter))\r\n    this.filters.push({ count, filter })\r\n  }\r\n  split(newThreshold: number, minCount: number) {\r\n    if (this.min[this.min.length - 1] > newThreshold) this.min[this.min.length - 1] = newThreshold\r\n\r\n    while (this.filters.length) {\r\n      const { count, filter } = this.filters.pop()!\r\n      if (count <= minCount) return { count, filter }\r\n      splitBySetOrID(this.arts, filter, minCount).forEach(filter => this.addFilter(filter))\r\n    }\r\n  }\r\n}\r\n\r\nfunction splitBySetOrID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\r\n  const arts = filterArts(_arts, filter)\r\n\r\n  const candidates = allSlotKeys\r\n    .map(slot => ({ slot, sets: new Set(arts.values[slot].map(x => x.set)) }))\r\n    .filter(({ sets }) => sets.size > 1)\r\n  if (!candidates.length)\r\n    return splitByID(arts, filter, limit)\r\n  const { sets, slot } = candidates.reduce((a, b) => a.sets.size < b.sets.size ? a : b)\r\n  return [...sets].map(set => ({ ...filter, [slot]: { kind: \"required\", sets: new Set([set]) } }))\r\n}\r\nfunction splitByID(_arts: ArtifactsBySlot, filter: RequestFilter, limit: number): RequestFilter[] {\r\n  const arts = filterArts(_arts, filter)\r\n  const count = countBuilds(arts)\r\n\r\n  const candidates = allSlotKeys\r\n    .map(slot => ({ slot, length: arts.values[slot].length }))\r\n    .filter(x => x.length > 1)\r\n  const { slot, length } = candidates.reduce((a, b) => a.length < b.length ? a : b)\r\n\r\n  const numChunks = Math.ceil(count / limit)\r\n  const boundedNumChunks = Math.min(numChunks, length)\r\n  const chunk = Array(boundedNumChunks).fill(0).map(_ => new Set<string>())\r\n  arts.values[slot].forEach(({ id }, i) => chunk[i % boundedNumChunks].add(id))\r\n  return chunk.map(ids => ({ ...filter, [slot]: { kind: \"id\", ids } }))\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n// the startup function\n__webpack_require__.x = function() {\n\t// Load entry module and return exports\n\t// This entry module depends on other loaded chunks and execution need to be delayed\n\tvar __webpack_exports__ = __webpack_require__.O(undefined, [221], function() { return __webpack_require__(71184); })\n\t__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n\treturn __webpack_exports__;\n};\n\n","var deferred = [];\n__webpack_require__.O = function(result, chunkIds, fn, priority) {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar chunkIds = deferred[i][0];\n\t\tvar fn = deferred[i][1];\n\t\tvar priority = deferred[i][2];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every(function(key) { return __webpack_require__.O[key](chunkIds[j]); })) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.f = {};\n// This file contains only the entry chunk.\n// The chunk loading function for additional chunks\n__webpack_require__.e = function(chunkId) {\n\treturn Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {\n\t\t__webpack_require__.f[key](chunkId, promises);\n\t\treturn promises;\n\t}, []));\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.u = function(chunkId) {\n\t// return url for filenames based on template\n\treturn \"static/js/\" + chunkId + \".\" + \"45b11d4b\" + \".chunk.js\";\n};","// This function allow to reference async chunks and sibling chunks for the entrypoint\n__webpack_require__.miniCssF = function(chunkId) {\n\t// return url for filenames based on template\n\treturn undefined;\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","__webpack_require__.p = \"/genshin-optimizer/\";","// no baseURI\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t184: 1\n};\n\n// importScripts chunk loading\nvar installChunk = function(data) {\n\tvar chunkIds = data[0];\n\tvar moreModules = data[1];\n\tvar runtime = data[2];\n\tfor(var moduleId in moreModules) {\n\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t}\n\t}\n\tif(runtime) runtime(__webpack_require__);\n\twhile(chunkIds.length)\n\t\tinstalledChunks[chunkIds.pop()] = 1;\n\tparentChunkLoadingFunction(data);\n};\n__webpack_require__.f.i = function(chunkId, promises) {\n\t// \"1\" is the signal for \"already loaded\"\n\tif(!installedChunks[chunkId]) {\n\t\tif(true) { // all chunks have JS\n\t\t\timportScripts(__webpack_require__.p + __webpack_require__.u(chunkId));\n\t\t}\n\t}\n};\n\nvar chunkLoadingGlobal = self[\"webpackChunkgenshin_optimizer\"] = self[\"webpackChunkgenshin_optimizer\"] || [];\nvar parentChunkLoadingFunction = chunkLoadingGlobal.push.bind(chunkLoadingGlobal);\nchunkLoadingGlobal.push = installChunk;\n\n// no HMR\n\n// no HMR manifest","var next = __webpack_require__.x;\n__webpack_require__.x = function() {\n\treturn __webpack_require__.e(221).then(next);\n};","// run startup\nvar __webpack_exports__ = __webpack_require__.x();\n"],"names":["objPathValue","obj","keys","Array","isArray","console","error","reduce","a","k","objectKeyMap","map","Object","fromEntries","i","objectMap","fn","entries","v","rangeGen","from","to","range","assertUnreachable","value","Error","constant","NaN","key","percent","info","operation","operands","Number","MAX_VALUE","Infinity","min","values","intoOps","max","customRead","path","type","forEachNodes","formulas","topDown","bottomUp","visiting","Set","visited","forEach","traverse","formula","has","add","delete","mapFormulas","topDownMap","bottomUpMap","topDownMapped","Map","bottomUpMapped","check","get","arrayEqual","set","result","b","undefined","length","every","allCommutativeMonoidOperations","x","Math","mul","allOperations","res","sum_frac","threshold","pass","fail","commutativeMonoidOperationSet","flatten","f","_formula","flattened","flatMap","dep","deduplicate","elementCounts","array","wrap","common","counts","next","factored","count","fill","candidatesByOperation","remainingCounts","filter","push","currentCounts","commonCounts","nextCounts","total","dependency","currentCount","commonCount","candidates","candidate","candidateCounts","candidateCount","clear","constantFold","topLevelData","shouldFold","origin","data","processed","nextContextMap","fold","context","old","numericOperands","formulaOperands","folded","numericValue","isFinite","index","selected","table","first","find","op","smallest","v1","v2","match","unmatch","list","accu","reset","nextContext","allSlotKeys","nonTravelerCharacterKeys","travelerKeys","filterFeasiblePerm","artSetPerm","reaffine","nodes","arts","forceRename","affineNodes","topLevelAffine","visit","node","isAffine","_op","dynKeys","_","nonConst","base","size","current","nextDynKey","affine","affineMap","reaffineArt","stat","dyn","slot","id","offsets","baseValue","pruneOrder","numTop","exclusion","progress","noRainbow","rainbow","noSwitchIn","noSwitchOut","includes","newList","art","other","greaterEqual","greater","some","pruneArtRange","minimum","baseRange","artRanges","computeArtRange","otherArtRanges","addArtRange","read","newRange","computeNodeRange","pruneNodeRange","nodeRange","operandRanges","newOperands","op1","op2","j","ranges","reads","_f","computeMinMax","c","sum","minMaxes","filterArts","filters","kind","ids","sets","countBuilds","_count","_artSets","artSets","available","s","exclusionToAllowed","populateShapes","indexOfShape","shape","check_free","remaining","rainbows","isolated","missing","rejected","required","allowedSet","allowedCounts","groupped","used","requiredRainbows","l","usableRainbows","sort","replacing","allowedRainbows","shapes","slice","noFilter","splitWorker","computeWorker","ComputeWorker","callback","optimizationTarget","plotBase","maxBuilds","builds","buildValues","plotData","interimReport","refresh","command","tested","failed","skipped","this","optimize","newThreshold","self","preArts","totalCount","forced","should","deps","newArts","newNodes","pruneAll","compute","initial","binding","slotCount","body","names","name","operandNames","arr","toString","join","Function","precompute","buffer","permute","m","build","artifactIds","plot","force","plots","scale","round","mergePlot","SplitWorker","minCount","pop","splitBySetOrID","addFilter","_arts","limit","numChunks","ceil","boundedNumChunks","chunk","splitByID","onmessage","splitID","computeID","interim","postMessage","source","split","setPerm","perm","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","exports","module","__webpack_modules__","__webpack_exports__","O","deferred","chunkIds","priority","notFulfilled","fulfilled","splice","r","d","definition","o","defineProperty","enumerable","e","chunkId","Promise","all","promises","u","miniCssF","prop","prototype","hasOwnProperty","call","p","installedChunks","importScripts","chunkLoadingGlobal","parentChunkLoadingFunction","bind","moreModules","runtime","then"],"sourceRoot":""}