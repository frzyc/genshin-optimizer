(()=>{"use strict";function e(e,t){if(e&&t)return!Array.isArray(t)&&console.error(t),t.reduce(((e,t)=>null==e?void 0:e[t]),e)}function t(e,t){return Object.fromEntries(e.map(((e,n)=>[e,t(e,n)])))}function n(e,t){return Object.fromEntries(e.map(((e,n)=>t(e,n))))}function r(e,t){return Object.fromEntries(Object.entries(e).map((([e,n],r)=>[e,t(n,e,r)])))}const a=function*(e,t){for(let n=e;n<=t;n++)yield n};function s(e,t){return[...a(e,t)]}function o(e){throw new Error(`Should not reach this with value ${e}`)}function i(...e){return e.reduce(((e,t)=>e.flatMap((e=>t.map((t=>[e,[t]].flat()))))),[[]])}l(NaN,{name:"TODO"}),c(1),c(0),l("none");function l(e,t){return"number"==typeof e?{operation:"const",operands:[],type:"number",value:e,info:t}:{operation:"const",operands:[],type:"string",value:e,info:t}}function c(e,t){return e>=Number.MAX_VALUE/100&&(e=1/0),e<=-Number.MAX_VALUE/100&&(e=-1/0),l(e,Object.assign({unit:"%"},t))}function u(e){return e.map((e=>"object"==typeof e?e:l(e)))}function d(e){return"object"!=typeof e?l(e):e}function h(e,t,n){const r=new Set,a=new Set;e.forEach((function e(s){a.has(s)||(r.has(s)?console.error("Found cyclical dependency during formula traversal"):(r.add(s),t(s),s.operands.forEach(e),n(s),r.delete(s),a.add(s)))}))}function p(e,t,n){const r=new Set,a=new Map,s=new Map;function o(e){let i=a.get(e);if(i)return i;i=t(e);let c=s.get(i);return c||(r.has(i)?(console.error("Found cyclical dependency during formula mapping"),l(NaN)):(r.add(i),c=n(function(e){const t=e.operands.map(o);return m(t,e.operands)?e:Object.assign({},e,{operands:t})}(i),e),r.delete(i),a.set(e,c),s.set(i,c),c))}const i=e.map(o);return m(i,e)?e:i}function f(e,t,n){const r=new Map;function a(e,t){let s=r.get(t);s||r.set(t,s=[new Set,new Map]);const[o,i]=s,l=i.get(e);if(l)return l;if(o.has(e))throw new Error("Found cyclical dependency during formula mapping");o.add(e);const c=n(e,t,a);return i.set(e,c),o.delete(e),c}return e.map((e=>a(e,t)))}function m(e,t){return void 0===e?void 0===t:void 0!==t&&(e.length===t.length&&e.every(((e,n)=>e===t[n])))}const g={min:e=>Math.min(...e),max:e=>Math.max(...e),add:e=>e.reduce(((e,t)=>e+t),0),mul:e=>e.reduce(((e,t)=>e*t),1)},b=Object.assign({},g,{res:([e])=>e<0?1-e/2:e>=.75?1/(4*e+1):1-e,sum_frac:e=>e[0]/e.reduce(((e,t)=>e+t)),threshold:([e,t,n,r])=>e>=t?n:r}),v=new Set(Object.keys(g));function w(e){return p(e,(e=>e),(e=>{let t=e;if(v.has(e.operation)){const n=e,{operation:r}=n;let a=!1;const s=n.operands.flatMap((e=>e.operation===r?(a=!0,e.operands):[e]));t=a?Object.assign({},n,{operands:s}):n}return t}))}function y(e){function t(e){const t=new Map;for(const r of e){var n;t.set(r,(null!=(n=t.get(r))?n:0)+1)}return t}const n={common:{counts:new Map,formulas:new Set,operation:"add"}};for(;;){let a;const s={operation:n.common.operation,operands:(r=n.common.counts,[...r].flatMap((([e,t])=>Array(t).fill(e))))},o=new Map;for(const e of Object.keys(g))o.set(e,[]);if(e=p(e,(e=>{if(n.common.formulas.has(e)){const t=e,r=new Map(n.common.counts),a=t.operands.filter((e=>{const t=r.get(e);return!t||(r.set(e,t-1),!1)}));return a.length?(a.push(s),Object.assign({},t,{operands:a})):s}return e}),(e=>{if(!v.has(e.operation))return e;const n=e;if(a){if(a.operation===n.operation){const e=t(n.operands),s=new Map,o=a.counts;let i=0;for(const[t,n]of e.entries()){var r;const e=Math.min(n,null!=(r=o.get(t))?r:0);e?(s.set(t,e),i+=e):s.delete(t)}i>1&&(a.counts=s,a.formulas.add(n))}}else{const e=o.get(n.operation),r=t(n.operands);for(const[t,i]of e){let e=0;const l=new Map;for(const[t,n]of i.entries()){var s;const a=Math.min(n,null!=(s=r.get(t))?s:0);a&&(l.set(t,a),e+=a)}if(e>1){a={counts:l,formulas:new Set([n,t]),operation:n.operation},o.clear();break}}a||e.push([n,r])}return n})),!a)break;n.common=a}var r;return e}function k(t,n,r=(e=>!1)){const a={data:[],processed:new Map},s=new Map([[a,new Map]]),i={data:[n],processed:new Map};return s.set(i,new Map),s.get(a).set(n,i),f(t,i,((t,n,i)=>{const{operation:c}=t,u=(e,t)=>i(e,t),d=(e,t)=>i(e,t);let h;switch(c){case"const":h=t;break;case"add":case"mul":case"max":case"min":{var p;const e=b[c],r=[],a=t.operands.filter((e=>{const t=u(e,n);return"const"!==t.operation||(r.push(t.value),!1)})).map((e=>u(e,n))),s=e(r);if(isFinite(s)){if("mul"===c&&0===s){h=l(s);break}}else if("mul"!==c&&("max"!==c||s>0)&&("min"!==c||s<0)){h=l(s);break}s!==e([])&&a.push(l(s)),h=a.length<=1?null!=(p=a[0])?p:l(e([])):{operation:c,operands:a};break}case"res":case"sum_frac":{const e=t.operands.map((e=>u(e,n))),r=b[c];h=e.every((e=>"const"===e.operation))?l(r(e.map((e=>e.value)))):Object.assign({},t,{operands:e});break}case"lookup":{const e=d(t.operands[0],n);if("const"===e.operation){var f;const r=null!=(f=t.table[e.value])?f:t.operands[1];if(r){h=i(r,n);break}}throw new Error(`Unsupported ${c} node while folding`)}case"prio":{const e=t.operands.find((e=>{const t=d(e,n);if("const"!==t.operation)throw new Error(`Unsupported ${c} node while folding`);return void 0!==t.value}));h=e?d(e,n):l(void 0);break}case"small":{var m;let e;for(const r of t.operands){var g;const t=d(r,n);if("const"!==t.operation)throw new Error(`Unsupported ${c} node while folding`);(void 0===(null==(g=e)?void 0:g.value)||void 0!==t.value&&t.value<e.value)&&(e=t)}h=null!=(m=e)?m:l(void 0);break}case"match":{const[e,r,a,s]=t.operands.map((e=>i(e,n)));if("const"!==e.operation||"const"!==r.operation)throw new Error(`Unsupported ${c} node while folding`);h=e.value===r.value?a:s;break}case"threshold":{const[e,r,a,s]=t.operands.map((e=>i(e,n)));h="const"===a.operation&&"const"===s.operation&&a.value===s.value?a:"const"===e.operation&&"const"===r.operation?e.value>=r.value?a:s:Object.assign({},t,{operands:[e,r,a,s]});break}case"subscript":{const e=u(t.operands[0],n);if("const"!==e.operation)throw new Error("Found non-constant subscript node while folding");h=l(t.list[e.value]);break}case"read":{const a=n.data.map((n=>e(n,t.path))).filter((e=>e));if(0===a.length)if(r(t)){const{accu:e}=t;h=void 0===e||"small"===e?"string"===t.type?l(void 0):l(NaN):l(b[e]([]))}else h=t;else h=void 0===t.accu||1===a.length?i(a[a.length-1],n):i({operation:t.accu,operands:a},n);break}case"data":{t.reset&&(n=a);const e=s.get(n);let r=e.get(t.data);r||(r={data:[...n.data,t.data],processed:new Map},s.set(r,new Map),e.set(t.data,r)),h=i(t.operands[0],r);break}default:o(c)}return h.info&&(h=Object.assign({},h),delete h.info),h}))}const x=["Albedo","Alhaitham","Aloy","Amber","AratakiItto","Barbara","Beidou","Bennett","Candace","Chongyun","Collei","Cyno","Dehya","Diluc","Diona","Dori","Eula","Faruzan","Fischl","Ganyu","Gorou","HuTao","Jean","KaedeharaKazuha","Kaeya","KamisatoAyaka","KamisatoAyato","Keqing","Klee","KujouSara","KukiShinobu","Layla","Lisa","Mika","Mona","Nahida","Nilou","Ningguang","Noelle","Qiqi","RaidenShogun","Razor","Rosaria","SangonomiyaKokomi","Sayu","Shenhe","ShikanoinHeizou","Somnia","Sucrose","Tartaglia","Thoma","Tighnari","Venti","Wanderer","Xiangling","Xiao","Xingqiu","Xinyan","YaeMiko","Yanfei","Yaoyao","Yelan","Yoimiya","YunJin","Zhongli"],S=["TravelerAnemo","TravelerGeo","TravelerElectro","TravelerDendro"];const O=["flower","plume","sands","goblet","circlet"],M=["AmenomaKageuchi","AquilaFavonia","BlackcliffLongsword","CinnabarSpindle","CoolSteel","KagotsurubeIsshin","DarkIronSword","DullBlade","FavoniusSword","FesteringDesire","FilletBlade","FreedomSworn","HaranGeppakuFutsu","HarbingerOfDawn","IronSting","KeyOfKhajNisut","LightOfFoliarIncision","LionsRoar","MistsplitterReforged","PrimordialJadeCutter","PrototypeRancour","RoyalLongsword","SacrificialSword","SapwoodBlade","SilverSword","SkyriderSword","SkywardBlade","SummitShaper","SwordOfDescension","TheAlleyFlash","TheBlackSword","TheFlute","ToukabouShigure","TravelersHandySword","XiphosMoonlight"],j=["Akuoumaru","BeaconOfTheReedSea","BlackcliffSlasher","BloodtaintedGreatsword","DebateClub","FavoniusGreatsword","FerrousShadow","ForestRegalia","KatsuragikiriNagamasa","LithicBlade","LuxuriousSeaLord","MailedFlower","MakhairaAquamarine","OldMercsPal","PrototypeArchaic","Rainslasher","RedhornStonethresher","RoyalGreatsword","SacrificialGreatsword","SerpentSpine","SkyriderGreatsword","SkywardPride","SnowTombedStarsilver","SongOfBrokenPines","TheBell","TheUnforged","WasterGreatsword","Whiteblind","WhiteIronGreatsword","WolfsGravestone"],E=["BeginnersProtector","BlackcliffPole","BlackTassel","CalamityQueller","CrescentPike","Deathmatch","DragonsBane","DragonspineSpear","EngulfingLightning","FavoniusLance","Halberd","IronPoint","KitainCrossSpear","LithicSpear","MissiveWindspear","Moonpiercer","PrimordialJadeWingedSpear","PrototypeStarglitter","RoyalSpear","SkywardSpine","StaffOfHoma","StaffOfTheScarletSands","TheCatch","VortexVanquisher","WavebreakersFin","WhiteTassel"],T=["AlleyHunter","AmosBow","AquaSimulacra","BlackcliffWarbow","CompoundBow","ElegyForTheEnd","EndOfTheLine","FadingTwilight","FavoniusWarbow","Hamayumi","HuntersBow","HuntersPath","KingsSquire","Messenger","MitternachtsWaltz","MouunsMoon","PolarStar","Predator","PrototypeCrescent","RavenBow","RecurveBow","RoyalBow","Rust","SacrificialBow","SeasonedHuntersBow","SharpshootersOath","SkywardHarp","Slingshot","TheStringless","TheViridescentHunt","ThunderingPulse","WindblumeOde"],$=["ApprenticesNotes","AThousandFloatingDreams","BlackcliffAgate","DodocoTales","EmeraldOrb","EverlastingMoonglow","EyeOfPerception","FavoniusCodex","Frostbearer","FruitOfFulfillment","HakushinRing","KagurasVerity","LostPrayerToTheSacredWinds","MagicGuide","MappaMare","MemoryOfDust","OathswornEye","OtherworldlyStory","PocketGrimoire","PrototypeAmber","QuantumCatalyst","RoyalGrimoire","SacrificialFragments","SkywardAtlas","SolarPearl","TheWidsith","ThrillingTalesOfDragonSlayers","TulaytullahsRemembrance","TwinNephrite","WanderingEvenstar","WineAndSong"],N=["flower","plume","sands","goblet","circlet"],F=["TravelerAnemo","TravelerGeo","TravelerElectro","TravelerDendro"];function A(e,t,n,r,a,s){let o=s;const i={pruneNodeRange:!0},l={pruneNodeRange:!0},c={reaffine:!0},u={pruneOrder:!0,pruneArtRange:!0,pruneNodeRange:!0};let d=0;for(;Object.values(o).some((e=>e))&&d++<20;){if(o.pruneOrder){delete o.pruneOrder;const e=R(n,r,a);n!==e&&(n=e,o=Object.assign({},o,i))}if(o.pruneArtRange){delete o.pruneArtRange;const r=D(e,n,t);n!==r&&(n=r,o=Object.assign({},o,l))}if(o.pruneNodeRange){delete o.pruneNodeRange;const t=C(e,n);e!==t&&(e=t,o=Object.assign({},o,c))}if(o.reaffine){delete o.reaffine;const{nodes:t,arts:r}=B(e,n);e===t&&n===r||(e=t,n=r,o=Object.assign({},o,u))}}return{nodes:e,arts:n}}function B(e,n,a=!1){const s=new Set,i=new Set;function c(e,t){t?s.add(e):e.operands.forEach((e=>s.has(e)&&i.add(e)))}const u=new Set;if(h(e,(e=>{}),(e=>{const{operation:t}=e;switch(t){case"read":u.add(e.path[1]),c(e,!0);break;case"add":c(e,e.operands.every((e=>s.has(e))));break;case"mul":{const t=e.operands.filter((e=>"const"!==e.operation));c(e,0===t.length||1===t.length&&s.has(t[0]));break}case"const":c(e,!0);break;case"res":case"threshold":case"sum_frac":case"max":case"min":c(e,!1);break;default:o(t)}})),[...i].every((({operation:e})=>"read"===e||"const"===e))&&Object.keys(n.base).length===u.size)return{nodes:e,arts:n};let d=-1;function f(){for(;u.has(""+ ++d););return`${d}`}e.forEach((e=>s.has(e)&&i.add(e)));const m=[...i].filter((e=>"const"!==e.operation)),g=new Map(m.map((e=>{return[e,a||"read"!==e.operation||"dyn"!==e.path[0]?Object.assign({},(t=["dyn",`${f()}`],{operation:"read",operands:[],path:t,info:n,type:"number"}),{accu:"add"}):e];var t,n})));function b(e){const t=k([...g.keys()],{dyn:r(e,(e=>l(e)))},(e=>!0));return Object.fromEntries([...g.values()].map(((e,n)=>[e.path[1],t[n].value])))}const v={nodes:e=p(e,(e=>{var t;return null!=(t=g.get(e))?t:e}),(e=>e)),arts:{base:b(n.base),values:t(N,(e=>n.values[e].map((({id:e,set:t,values:n})=>({id:e,set:t,values:b(n)})))))}},w=Object.entries(b({}));for(const e of Object.values(v.arts.values))for(const{values:t}of e)for(const[e,n]of w)t[e]-=n;return v}function R(e,n,r){var a;let s=!1;const o=!(null!=(a=r.rainbow)&&a.length),i=Object.keys(e.base),l=new Set(Object.entries(r).filter((([e,t])=>t.length)).map((([e])=>e))),c=new Set(Object.entries(r).filter((([e,t])=>t.includes(2)&&!t.includes(4))).map((([e])=>e))),u=t(N,(t=>{const r=e.values[t],a=r.filter((e=>{let t=0;return r.every((r=>{const a=i.every((t=>{var n,a;return(null!=(n=r.values[t])?n:0)>=(null!=(a=e.values[t])?a:0)})),s=i.some((t=>{var n,a;return(null!=(n=r.values[t])?n:0)>(null!=(a=e.values[t])?a:0)})),u=a&&(s||r.id>e.id),d=o&&!l.has(r.set)&&!c.has(e.set)||e.set===r.set;return u&&d&&t++,t<n}))}));return a.length!==r.length&&(s=!0),a}));return s?{base:e.base,values:u}:e}function D(e,n,r){const a=Object.fromEntries(Object.entries(n.base).map((([e,t])=>[e,{min:t,max:t}]))),s={arts:n};for(;;){const n=t(N,(e=>I(s.arts.values[e]))),o=t(N,(e=>P(Object.entries(n).map((t=>t[0]===e?a:t[1])).filter((e=>e)))));let i=!1;const l=t(N,(t=>{const n=s.arts.values[t].filter((n=>{const a=P([I([n]),o[t]]),s=L(e,a);return e.every(((e,t)=>{var n;return s.get(e).max>=(null!=(n=r[t])?n:-1/0)}))}));return n.length!==s.arts.values[t].length&&(i=!0),n}));if(!i)break;s.arts={base:s.arts.base,values:l}}return s.arts}function C(e,t){const n=L(e,P([Object.fromEntries(Object.entries(t.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(t.values).map((e=>I(e)))]));return p(e,(e=>{{const{min:t,max:r}=n.get(e);if(t===r)return l(t)}const{operation:t}=e,r=e.operands.map((e=>n.get(e)));switch(t){case"threshold":{const[t,n,a,s]=r;if(t.min>=n.max)return e.operands[2];if(t.max<n.min)return e.operands[3];if(a.max===a.min&&s.max===s.min&&a.min===s.min&&isFinite(a.min))return l(a.max);break}case"min":{const t=e.operands.filter(((e,t)=>{const n=r[t];return r.every((e=>n.min<=e.max))}));if(t.length<r.length)return function(...e){return{operation:"min",operands:u(e)}}(...t);break}case"max":{const t=e.operands.filter(((e,t)=>{const n=r[t];return r.every((e=>n.max>=e.min))}));if(t.length<r.length)return function(...e){return{operation:"max",operands:u(e)}}(...t);break}}return e}),(e=>e))}function P(e){const t={};return e.forEach((e=>{Object.entries(e).forEach((([e,n])=>{t[e]?(t[e].min+=n.min,t[e].max+=n.max):t[e]=Object.assign({},n)}))})),t}function I(e){const t={};return e.length&&(Object.keys(e[0].values).filter((t=>e.every((e=>e.values[t])))).forEach((n=>t[n]={min:e[0].values[n],max:e[0].values[n]})),e.forEach((({values:e})=>{for(const[n,r]of Object.entries(e))t[n]?(t[n].max<r&&(t[n].max=r),t[n].min>r&&(t[n].min=r)):t[n]={min:0,max:r}}))),t}function U(e){return P([Object.fromEntries(Object.entries(e.base).map((([e,t])=>[e,{min:t,max:t}]))),...Object.values(e.values).map((e=>I(e)))])}function L(e,t){const n=new Map;return h(e,(e=>{}),(e=>{var r;const{operation:a}=e,s=e.operands.map((e=>n.get(e)));let i;switch(a){case"read":if("dyn"!==e.path[0])throw new Error(`Found non-dyn path ${e.path} while computing range`);i=null!=(r=t[e.path[1]])?r:{min:0,max:0};break;case"const":i=K([e.value]);break;case"add":case"min":case"max":i={min:b[a](s.map((e=>e.min))),max:b[a](s.map((e=>e.max)))};break;case"res":i={min:b[a]([s[0].max]),max:b[a]([s[0].min])};break;case"mul":i=s.reduce(((e,t)=>K([e.min*t.min,e.min*t.max,e.max*t.min,e.max*t.max])));break;case"threshold":i=s[0].min>=s[1].max?s[2]:s[0].max<s[1].min?s[3]:K([],[s[2],s[3]]);break;case"sum_frac":{const[e,t]=s,n={min:e.min+t.min,max:e.max+t.max};i=n.min<=0&&n.max>=0?e.min<=0&&e.max>=0?{min:NaN,max:NaN}:{min:-1/0,max:1/0}:K([e.min/n.min,e.min/n.max,e.max/n.min,e.max/n.max]);break}default:o(a)}n.set(e,i)})),n}function K(e,t=[]){const n=Math.max(...e,...t.map((e=>e.max)));return{min:Math.min(...e,...t.map((e=>e.min))),max:n}}function W(e,n){return{base:e.base,values:t(N,(t=>{const r=n[t];switch(r.kind){case"id":return e.values[t].filter((e=>r.ids.has(e.id)));case"exclude":return e.values[t].filter((e=>!r.sets.has(e.set)));case"required":return e.values[t].filter((e=>r.sets.has(e.set)))}}))}}function z(e){return N.reduce(((t,n)=>t*e.values[n].length),1)}function G(e){return new Set(null!=e&&e.includes(2)?e.includes(4)?[0,1]:[0,1,4,5]:null!=e&&e.includes(4)?[0,1,2,3]:[0,1,2,3,4,5])}function*V(e,n){const a=[...new Set(n)],o=G(e.rainbow);let i=[];function l(e,t){if(!s(t+1,4).some((t=>5!==e[t])))return(e=[...e])[t]=5,e.reduce(((e,t)=>6*e+t),0)}!function e(t,n,r){if(5!==t.length){for(const a of n)e([...t,a],n,r.filter((e=>e!==a)));e([...t,t.length],new Set([...n,t.length]),[...r,t.length])}else o.has(r.length)&&i.push(t)}([0],new Set([0]),[0]);for(let e=4;e>=0;e--){const t=new Map;for(const n of i){var c;const r=l(n,e);void 0!==r&&t.set(r,(null!=(c=t.get(r))?c:new Set(n.slice(0,e)).size+1)-1)}for(const[n,r]of t.entries())if(0===r){const t=[...i.find((t=>l(t,e)===n))];t[e]=5,i=i.filter((t=>l(t,e)!==n)),i.push(t)}}const u={kind:"exclude",sets:new Set},d=t(N,(e=>u)),h=Object.assign({},r(e,(e=>0)),t(a,(e=>0))),p=r(e,G);function*f(e){const t=new Set,n=[];let r=[];for(const t of e)r.push([]),5===t?n.push(r.length-1):r[t].push(r.length-1);r=r.filter((e=>e.length)).sort(((e,t)=>t.length-e.length));let o=n.length;function*i(e){const t=n.length-e,r=[],o=[],l=[];let c=0;for(const e of a){const n=p[e],a=h[e];n&&(s(1,t).every((e=>!n.has(a+e)))?l.push(e):n.has(a)?s(0,t).some((e=>!n.has(a+e)))&&r.push(e):(c+=[...n].find((e=>e>a))-a,o.push(e)))}if(!(c>t))if(e!==n.length)if(c!==t){for(const t of[...r,...o])h[t]++,d[N[n[e]]]={kind:"required",sets:new Set([t])},yield*i(e+1),h[t]--;d[N[n[e]]]={kind:"exclude",sets:new Set([...o,...l,...r])},yield*i(e+1)}else for(const t of o)h[t]++,d[N[n[e]]]={kind:"required",sets:new Set([t])},yield*i(e+1),h[t]--;else yield Object.assign({},d)}yield*function*e(n){if(n===r.length)return yield*i(0);for(const i of a){if(t.has(i))continue;const a=r[n].length,c=p[i];let u=0;var l;if(c&&!c.has(a))if(u=(null!=(l=s(a+1,5).find((e=>c.has(e))))?l:6)-a,u>o)continue;t.add(i),h[i]=r[n].length,r[n].forEach((e=>d[N[e]]={kind:"required",sets:new Set([i])})),o-=u,yield*e(n+1),o+=u,h[i]=0,t.delete(i)}}(0)}for(const e of i)yield*f(e)}function q(e){return{type:"lin",lin:{$c:e},min:e,max:e}}function H(...e){const t=e.filter((e=>"number"==typeof e)).reduce(((e,t)=>e+t),0),n=e.filter((e=>"number"!=typeof e));return{type:"sum",terms:n,$c:t,min:n.reduce(((e,{min:t})=>e+t),t),max:n.reduce(((e,{max:t})=>e+t),t)}}function _(...e){const t=e.filter((e=>"number"==typeof e)).reduce(((e,t)=>e*t),1),n=e.filter((e=>"number"!=typeof e)),r=n.reduce((({min:e,max:t},{min:n,max:r})=>({min:Math.min(e*n,e*r,t*n,t*r),max:Math.max(e*n,e*r,t*n,t*r)})),{min:t,max:t});return Object.assign({type:"prod",terms:n,$k:t},r)}function X(e,t,n,r){return H(n-e*t,_(e,r))}function Y(e,t,n,r,a,s){return Math.abs(e-n)<1e-10?q(s?Math.max(t,r):Math.min(t,r)):X((r-t)/(n-e),e,t,a)}function J(e,t){const n=new Map;h(e,(e=>{const{operation:t}=e;switch("mul"===t&&n.set(e,{min:NaN,max:NaN}),t){case"mul":case"min":case"max":case"threshold":case"res":case"sum_frac":e.operands.forEach((e=>n.set(e,{min:NaN,max:NaN})))}}),(e=>e));const r=U(t),a=L([...n.keys()],r);for(const[e,t]of a.entries())n.set(e,t);const s="u",l="l",c="e",p=f(e,s,((e,t,r)=>{const{operation:a}=e,i=(e,n=t)=>r(e,n),h=t===s?l:s;switch(a){case"const":return q(e.value);case"read":return v=e.path[1],w=n.get(e),Object.assign({type:"lin",lin:{[v]:1,$c:0}},w);case"add":return H(...e.operands.map((e=>i(e))));case"mul":{if(t===c)return _(...e.operands.map((e=>i(e))));const{min:r,max:o}=n.get(e);if(r===o)return q(r);const u=r*o<0||e.operands.some((e=>{const{min:t,max:r}=n.get(e);return t*r<0}));if(u)return i(e,c);const d=0===r?o:r,p=(0,b[a])(e.operands.filter((e=>"const"===e.operation)).map((e=>e.value))),f=e.operands.filter((e=>"const"!==e.operation)).map((e=>{const{min:r,max:o}=n.get(e),c=d*(0===r?o:r)>0?t:h,u=i(e,c);if(c===l&&o>0&&u.min<-r||c===s&&r<0&&u.max>-o)throw new Z("Unallowed large crossing post approximation",a);return u}));return _(p,...f)}case"min":case"max":{if(t===c)throw new Z("Cannot be exactly represented",a);const r=b[a],o=e.operands.filter((e=>"const"!==e.operation)),[u]=o;if(1!==o.length)throw new Z("Multivariate",a);const d=i(u),h=r(e.operands.filter((e=>"const"===e.operation)).map((e=>e.value)));if("max"===a&&t===l||"min"===a&&t===s)return d;const{min:p,max:f}=n.get(u);return Y(p,r([p,h]),f,r([f,h]),d,t===s)}case"res":{if(t===c)throw new Z("Cannot be exactly represented",a);if(t===l)throw new Z("Unsupported direction",a);const r=b[a],[o]=e.operands,{min:u,max:d}=n.get(o),p=i(o,h);return u<0&&d<1.75?H(1,_(-.5,p)):Y(u,r([u]),d,r([d]),p,t===s)}case"sum_frac":{if(t===c)throw new Z("Cannot be exactly represented",a);if(t===l)throw new Z("Unsupported direction",a);const[r,s]=e.operands;if("const"!==s.operation)throw new Z("Non-constant node",a);const o=i(r),u=s.value,{min:d,max:h}=n.get(r);if(d<=-u)throw new Z("Unallowed negative argument",a);const p=Math.sqrt((d+u)*(h+u));return X(u/(p+u)/(p+u),p,p/(p+u),o)}case"threshold":{if(t===c)throw new Z("Cannot be exactly represented",a);const[r,o,h,b]=e.operands;if("const"!==o.operation)throw new Z("Non-constant node",a);const{min:v,max:w}=n.get(r);if(v>=o.value)return i(h);if(w<o.value)return i(b);if("const"!==b.operation)throw new Z("Non-constant node",a);if("const"!==h.operation){if(0!==b.value)throw new Z("Unsupported pattern",a);const e=(p=o,f=1,m=b,{operation:"threshold",operands:[d(r),d(p),d(f),d(m)],info:g}),t=function(...e){return{operation:"mul",operands:u(e)}}(e,h),{min:s,max:l}=n.get(h);return n.set(e,{min:0,max:1}),n.set(t,{min:Math.min(s,0),max:Math.max(l,0)}),i(t)}const y=o.value,k=h.value,x=b.value,S=k>x==(t===s),O=i(r,S?s:l);if(S){return X((k-x)/(y-v),y,k,O)}return q(x)}default:o(a)}var p,f,m,g,v,w}));return p.map((e=>function(e){function t(e){switch(e.type){case"lin":return Object.entries(e.lin).filter((([e,t])=>0!==t)).map((([e,t])=>"$c"===e?Q(t):function(e,t){return{$k:t,terms:[e]}}(e,t)));case"sum":return function(...e){return e.flat()}(...e.terms.map((e=>t(e))),[Q(e.$c)]);case"prod":return function(...e){return i(...e).map((e=>e.reduce(((e,t)=>(e.$k*=t.$k,e.terms.push(...t.terms),e)),{$k:1,terms:[]})))}(...e.terms.map((e=>t(e))),[Q(e.$k)])}}return function(e){e.forEach((e=>e.terms.sort())),e.sort((({terms:e},{terms:t})=>{if(e.length!==t.length)return e.length-t.length;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return e[n]<t[n]?-1:1;return 0}));for(let t=e.length-2;t>=0;t--){if(0===e[t].$k){e.splice(t,1);continue}const n=e[t].terms,r=e[t+1].terms;n.length===r.length&&(n.every(((e,t)=>e===r[t]))&&(e[t].$k=e[t].$k+e[t+1].$k,e.splice(t+1,1)))}return e}(t(e))}(e)))}function Q(e){return{$k:e,terms:[]}}class Z extends Error{constructor(e,t){super(`Found ${e} in ${t} node when generating polynomial upper bound`)}}const ee=1e-8;function te(e,t){const n=t.length+1,r=t[0].length,a=Array(n).fill(0).map((e=>Array(r).fill(0)));t.forEach(((e,t)=>e.forEach(((e,n)=>a[t][n]=e)))),e.forEach(((e,t)=>a[n-1][t]=e));const s=[];for(;a.some(((e,t)=>t<n-1&&e[r-1]<-1e-8));){const e=ae(a);s.push(e),ne(a,e)}for(;a[n-1].some(((e,t)=>t<r-1&&e<-1e-8));){const e=re(a);s.push(e),ne(a,e)}const o=e.map(((e,t)=>function(e,t,n){let r=1;t.forEach((({i:e,j:t})=>{1===r&&t===n?(n=e,r=0):0===r&&e===n&&(n=t,r=1)}));const a=e[0].length;return 0===r?e[n][a-1]:0}(a,s,t)));if(!function(e,t){const n=t.length;return e.every((e=>t.reduce(((t,n,r)=>t+n*e[r]),0)<=e[n]+ee))}(t,o))throw Error("COMPUTED SOLUTION IS NOT FEASIBLE");return o}function ne(e,{i:t,j:n}){const r=e[t][n];for(let a=0;a<e.length;a++)if(a!==t)for(let s=0;s<e[0].length;s++)s!==n&&(e[a][s]-=e[t][s]*e[a][n]/r);for(let a=0;a<e.length;a++)a!==t&&(e[a][n]=-e[a][n]/r);for(let a=0;a<e[0].length;a++)a!==n&&(e[t][a]=e[t][a]/r);e[t][n]=1/r}function re(e){const t=e.length,n=e[0].length;let r={i:-1,j:-1,cmp:1/0};for(let a=0;a<n-1;a++)if(!(e[t-1][a]>=-1e-8)){for(let s=0;s<t-1;s++)if(e[s][a]>ee){const t=e[s][n-1]/e[s][a];t<r.cmp&&(r={i:s,j:a,cmp:t})}if(r.i<0)throw Error("UNBOUNDED FEASIBLE")}if(r.i<0)throw Error("NO PIVOTS (done)");return{i:r.i,j:r.j}}function ae(e){const t=e.length,n=e[0].length;let r={i:-1,j:-1,cmp:1/0};for(let a=0;a<t-1;a++)if(!(e[a][n-1]>=-1e-8)){for(let t=0;t<n-1;t++)if(e[a][t]<-1e-8){const s=e[a][n-1]/e[a][t];s<r.cmp&&(r={i:a,j:t,cmp:s})}if(r.i<0)throw Error("INFEASIBLE");return{i:r.i,j:r.j}}throw Error("NO PIVOTS (done)")}function se(e,t){const n=J(e,t),r=U(t);return n.map((e=>function(...e){const t={$c:0};for(const[r,a]of e)for(const[e,s]of Object.entries(a)){var n;t[e]=(null!=(n=t[e])?n:0)+r*s}return t}(...e.map((e=>{const t=e.terms.map((e=>r[e])),{w:n,$c:a}=function(e,t="upper"){if(0===e.length)return{w:[],$c:1,err:0};const n=e.length,r=e.map((({min:e,max:t})=>Math.max(-e,t))),a=r.reduce(((e,t)=>e*t),1);e=e.map((({min:e,max:t},n)=>({min:e/r[n],max:t/r[n]})));const s=i(...e.map((({min:e,max:t})=>[e,t]))).flatMap((e=>{const r=e.reduce(((e,t)=>e*t),1),a=e.reduce(((e,t)=>e+t),0);switch(t){case"upper":return[[...e,-1,0,a-r-n],[...e.map((e=>-e)),1,-1,n+r-a]];case"lower":return[[...e.map((e=>-e)),-1,0,r-a-n],[...e,1,-1,n+a-r]];default:o(t)}})),l=[...e.map((e=>0)),0,1];try{const e=te(l,s);switch(t){case"upper":return{w:e.slice(0,n).map(((e,t)=>(1-e)*a/r[t])),$c:a*(e[n]-n),err:a*e[n+1]};case"lower":return{w:e.slice(0,n).map(((e,t)=>(1-e)*a/r[t])),$c:a*(n-e[n]),err:a*e[n+1]};default:o(t)}}catch(t){throw console.log("ERROR on bounds",e),console.log("Possibly numerical instability issue."),console.log(t),t}}(t,e.$k>=0?"upper":"lower"),s={$c:a};return e.terms.forEach(((e,t)=>{var r;return s[e]=n[t]+(null!=(r=s[e])?r:0)})),[e.$k,s]})))))}class oe{constructor({arts:e,optTarget:t,constraints:n,topN:r},a){this.min=void 0,this.nodes=void 0,this.arts=void 0,this.topN=void 0,this.filters=[],this.interim=void 0,this.firstUncalculated=0,this.callback=void 0,this.arts=e,this.min=[-1/0,...n.map((e=>e.min))],this.nodes=[t,...n.map((e=>e.value))],this.callback=a,this.topN=r,se(this.nodes,e)}addFilter(e){const t=W(this.arts,e),n=z(t);n&&this.filters.push({nodes:this.nodes,arts:t,maxConts:[],approxs:[],age:0,count:n})}setThreshold(e){e>this.min[0]&&(this.min[0]=e,this.firstUncalculated=0,this.filters.forEach((e=>delete e.calculated)))}*split(e,t){for(this.addFilter(e);this.filters.length;){const e=this.getApproxFilter(),{arts:n,count:a}=e;if(a<=t){if(!a)continue;this.firstUncalculated<this.filters.length&&this.calculateFilter(this.firstUncalculated++),this.reportInterim(!1),yield r(n.values,(e=>({kind:"id",ids:new Set(e.map((e=>e.id)))})))}else this.splitOldFilter(e)}this.reportInterim(!0)}reportInterim(e=!1){this.interim&&(this.interim.skipped>1e6||!0===e)&&(this.callback(this.interim),this.interim=void 0)}splitOldFilter({nodes:e,arts:t,approxs:n,age:a}){const s=r(t.values,(e=>{var t,r;const a=e.map((e=>({art:e,cont:n[0].conts[e.id]}))).sort((({cont:e},{cont:t})=>t-e)),s=null!=(t=null==(r=a[a.length-1])?void 0:r.cont)?t:0;let o=a.reduce(((e,{cont:t})=>e+t),-s*a.length)/3;const i=Math.max(1,a.findIndex((({cont:e})=>(o-=e-s)<=0))),l=a.splice(i).map((({art:e})=>e)),c=a.map((({art:e})=>e));return{high:{arts:c,maxConts:n.map((e=>ie(c,e)))},low:{arts:l,maxConts:n.map((e=>ie(l,e)))}}})),o=Object.keys(s),{filters:i}=this,l={},c={};!function u(d){if(!o.length){const s=n.map(((e,t)=>r(c,(e=>e[t])))),o={base:t.base,values:Object.assign({},l)};return void i.push({nodes:e,arts:o,maxConts:s,approxs:n,age:a+1,count:d})}const h=o.pop(),{high:p,low:f}=s[h];f.arts.length&&(l[h]=f.arts,c[h]=f.maxConts,u(d*f.arts.length)),p.arts.length&&(l[h]=p.arts,c[h]=p.maxConts,u(d*p.arts.length)),o.push(h)}(1)}getApproxFilter(){return this.calculateFilter(this.filters.length-1),this.firstUncalculated>this.filters.length&&(this.firstUncalculated=this.filters.length),this.filters.pop()}calculateFilter(e){let{nodes:t,arts:a,maxConts:s,approxs:o}=this.filters[e];const{age:i,count:l,calculated:c}=this.filters[e];if(c)return;(i<3||i%5==2)&&(({nodes:t,arts:a}=A(t,this.min,a,this.topN,{},{pruneNodeRange:!0})),Object.values(a.values).every((e=>e.length))&&(o=function(e,t){return se(e,t).map((e=>({base:le(t.base,e,e.$c),conts:n(Object.values(t.values).flat(),(t=>[t.id,le(t.values,e,0)]))})))}(t,a),s=o.map((e=>r(a.values,(t=>ie(t,e)))))));const u=s.map(((e,t)=>Object.values(e).reduce(((e,t)=>e+t),o[t].base-this.min[t]))),d=r(a.values,((e,t)=>{const n=u.map(((e,n)=>s[n][t]-e));return e.filter((({id:e})=>o.every((({conts:t},r)=>t[e]>=n[r]))))}));a={base:a.base,values:d};const h=z(a);h!==l&&(this.interim?this.interim.skipped+=l-h:this.interim={resultType:"interim",buildValues:void 0,tested:0,failed:0,skipped:l-h}),this.filters[e]={nodes:t,arts:a,maxConts:s,approxs:o,age:i,count:h,calculated:!0}}}function ie(e,t){return Math.max(...e.map((({id:e})=>t.conts[e])))}function le(e,t,n){return Object.entries(e).reduce(((e,[n,r])=>{var a;return e+(null!=(a=t[n])?a:0)*r}),n)}class ce{constructor({arts:e,optTarget:t,constraints:n,plotBase:r,topN:a},s){this.builds=[],this.buildValues=void 0,this.plotData=void 0,this.threshold=-1/0,this.topN=void 0,this.min=void 0,this.arts=void 0,this.nodes=void 0,this.callback=void 0,this.arts=e,this.min=n.map((e=>e.min)),this.topN=a,this.callback=s,this.nodes=n.map((e=>e.value)),this.nodes.push(t),r&&(this.plotData={},this.nodes.push(r)),this.nodes=function(e,t,n=(e=>!1)){let r=k(e,t,n);return r=w(r),y(r)}(this.nodes,{},(e=>!1))}setThreshold(e){this.threshold>e&&(this.threshold=e)}compute(e){const{min:t}=this;let n=W(this.arts,e);const r=z(n),a=this.builds.length;let s=this.nodes;({nodes:s,arts:n}=A(s,t,n,this.topN,{},{pruneArtRange:!0,pruneNodeRange:!0}));const i=Object.values(n.values).sort(((e,t)=>e.length-t.length)),l=function(e,t,n,r){let a='\n"use strict";\n// copied from the code above\nfunction res(res) {\n  if (res < 0) return 1 - res / 2\n  else if (res >= 0.75) return 1 / (res * 4 + 1)\n  return 1 - res\n}\nconst x0=0',s=1;const i=new Map;return h(e,(e=>{}),(e=>{const{operation:l,operands:c}=e,u="x"+s++,d=c.map((e=>i.get(e)));switch(i.set(e,u),l){case"read":{const s=n(e);let o=new Array(r).fill(null).map(((e,t)=>`(b[${t}].values["${s}"] ?? 0)`));t[s]&&0!==t[s]&&(o=[t[s].toString(),...o]),a+=`,${u}=${o.join("+")}`;break}case"const":i.set(e,`(${e.value})`);break;case"add":case"mul":a+=`,${u}=${d.join("add"===l?"+":"*")}`;break;case"min":case"max":a+=`,${u}=Math.${l}(${d})`;break;case"threshold":{const[e,t,n,r]=d;a+=`,${u}=(${e}>=${t})?${n}:${r}`;break}case"res":a+=`,${u}=res(${d[0]})`;break;case"sum_frac":a+=`,${u}=${d[0]}/(${d[0]}+${d[1]})`;break;default:o(l)}})),a+=`;\nreturn [${e.map((e=>i.get(e)))}]`,new Function("b",a)}(s,n.base,(e=>e.path[1]),i.length),c=Array(i.length),u={tested:0,failed:0,skipped:r-z(n)},d=e=>{if(e<0){const e=l(c);if(t.every(((t,n)=>t<=e[n]))){const n=e[t.length],{builds:r,plotData:a}=this;let s;if(n>=this.threshold&&(s={value:n,artifactIds:c.map((e=>e.id)).filter((e=>e))},r.push(s)),a){const r=e[t.length+1];(!a[r]||a[r].value<n)&&(s||(s={value:n,artifactIds:c.map((e=>e.id)).filter((e=>e))}),s.plot=r,a[r]=s)}}else u.failed+=1}else i[e].forEach((t=>{c[e]=t,d(e-1)})),0===e&&(u.tested+=i[0].length,u.tested>65536&&this.interimReport(u))};d(i.length-1),this.interimReport(u,this.builds.length>a)}refresh(e){var t;const{topN:n}=this;var r;(Object.keys(null!=(t=this.plotData)?t:{}).length>=1e5&&(this.plotData=function(e){let t=.01,n=new Set(e.flatMap((e=>Object.values(e).map((e=>Math.round(e.plot/t))))));for(;n.size>1500;)t*=2,n=new Set([...n].map((e=>Math.round(e/2))));const r={};for(const n of e)for(const e of Object.values(n)){const n=Math.round(e.plot/t)*t;(!r[n]||r[n].value<e.value)&&(r[n]=e)}return r}([this.plotData])),this.builds.length>=1e3||e)&&(this.builds=this.builds.sort(((e,t)=>t.value-e.value)).slice(0,n),this.buildValues=this.builds.map((e=>e.value)),this.threshold=Math.max(this.threshold,null!=(r=this.buildValues[n-1])?r:-1/0))}interimReport(e,t=!1){this.refresh(t),this.callback(Object.assign({resultType:"interim",buildValues:this.buildValues},e)),this.buildValues=void 0,e.tested=0,e.failed=0,e.skipped=0}}class ue{constructor({arts:e},t){this.arts=void 0,this.stack=[],this.arts=e}setThreshold(e){}add(e,t){this.stack.push({filter:e,count:z(W(this.arts,e)),splittedBy:t})}*split(e,t){this.add(e,"set");for(let e=this.stack.pop();e;e=this.stack.pop()){const{filter:n,count:r,splittedBy:a}=e;if(r<=t)yield n;else switch(a){case"set":this.splitBySet(n);break;case"id":this.splitByID(n,r,t);break;default:o(a)}}}splitBySet(e){const t=W(this.arts,e),n=O.map((e=>({slot:e,sets:new Set(t.values[e].map((e=>e.set)))}))).filter((({sets:e})=>e.size>1));if(!n.length)return this.add(e,"id");const{sets:r,slot:a}=n.reduce(((e,t)=>e.sets.size<t.sets.size?e:t));r.forEach((t=>this.add(Object.assign({},e,{[a]:{kind:"required",sets:new Set([t])}}),"set")))}splitByID(e,t,n){const r=W(this.arts,e),{slot:a,length:s}=O.map((e=>({slot:e,length:r.values[e].length}))).filter((e=>e.length>1)).reduce(((e,t)=>e.length<t.length?e:t)),o=Math.ceil(t/n),i=Math.min(o,s),l=Array(i).fill(0).map((e=>new Set));r.values[a].forEach((({id:e},t)=>l[t%i].add(e))),l.forEach((t=>this.add(Object.assign({},e,{[a]:{kind:"id",ids:t}}),"id")))}}let de,he;async function pe(e){const{data:t}=e,{command:n}=t;switch(n){case"split":for(const e of de.split(t.filter,t.maxIterateSize))postMessage({command:"iterate",filter:e}),await new Promise((e=>setTimeout(e)));break;case"iterate":he.compute(t.filter);break;case"threshold":return de.setThreshold(t.threshold),void he.setThreshold(t.threshold);case"finalize":{he.refresh(!0);const{builds:e,plotData:t}=he;postMessage({resultType:"finalize",builds:e,plotData:t});break}case"count":{const{exclusion:e,maxIterateSize:n}=t,a=he.arts,s=function*(e,t){const n=r(t.values,(e=>new Set(e.map((e=>e.set)))));e:for(const t of e){for(const[e,r]of Object.entries(t)){const t=n[e];switch(r.kind){case"required":if([...r.sets].every((e=>!t.has(e))))continue e;break;case"exclude":if([...t].every((e=>r.sets.has(e))))continue e}}yield t}}(V(e,[...new Set(Object.values(a.values).flatMap((e=>e.map((e=>e.set)))))]),a);let o=0;for(const e of s)postMessage({command:"split",filter:e,maxIterateSize:n}),o+=z(W(a,e));postMessage({resultType:"count",count:o});break}case"setup":try{de=new oe(t,(e=>postMessage(e)))}catch(e){de=new ue(t,(e=>postMessage(e)))}he=new ce(t,(e=>postMessage(e)));break;default:o(n)}postMessage({resultType:"done"})}onmessage=async e=>{try{await pe(e)}catch(e){postMessage({resultType:"err",message:e.message})}}})();