(function(){"use strict";function ye(t,e){if(!(!t||!e))return!Array.isArray(e)&&console.error(e),e.reduce((s,n)=>s==null?void 0:s[n],t)}function ke(t,e){return Object.fromEntries(t.map((s,n)=>e(s,n)))}function Q(t,e){return Object.fromEntries(Object.entries(t).map(([s,n],r)=>[s,e(n,s,r)]))}function C(t){throw new Error(`Should not reach this with value ${t}`)}function Y(...t){return t.reduce((e,s)=>e.flatMap(n=>s.map(r=>[n,[r]].flat())),[[]])}function ie(t){throw new Error(`Should not reach this with value ${t}`)}function B(t,e){return Object.fromEntries(Object.entries(t).map(([s,n],r)=>[s,e(n,s,r)]))}function I(t,e){return Object.fromEntries(t.map((s,n)=>[s,e(s,n)]))}const Me=function*(t,e,s){for(let n=t;n<=e;n+=s)yield n};function A(t,e,s=1){return[...Me(t,e,s)]}const Oe=["Adventurer","ArchaicPetra","Berserker","BlizzardStrayer","BloodstainedChivalry","BraveHeart","CrimsonWitchOfFlames","DeepwoodMemories","DefendersWill","DesertPavilionChronicle","EchoesOfAnOffering","EmblemOfSeveredFate","FlowerOfParadiseLost","Gambler","GildedDreams","GladiatorsFinale","GoldenTroupe","HeartOfDepth","HuskOfOpulentDreams","Instructor","Lavawalker","LuckyDog","MaidenBeloved","MarechausseeHunter","MartialArtist","NighttimeWhispersInTheEchoingWoods","NoblesseOblige","NymphsDream","OceanHuedClam","PaleFlame","PrayersForDestiny","PrayersForIllumination","PrayersForWisdom","PrayersToSpringtime","ResolutionOfSojourner","RetracingBolide","Scholar","ShimenawasReminiscence","SongOfDaysPast","TenacityOfTheMillelith","TheExile","ThunderingFury","Thundersoother","TinyMiracle","TravelingDoctor","VermillionHereafter","ViridescentVenerer","VourukashasGlow","WanderersTroupe"],S=["flower","plume","sands","goblet","circlet"];oe(1),oe(0);function E(t,e){return typeof t=="number"?{operation:"const",operands:[],type:"number",value:t,info:e}:{operation:"const",operands:[],type:"string",value:t,info:e}}function oe(t,e){return t>=Number.MAX_VALUE/100&&(t=1/0),t<=-Number.MAX_VALUE/100&&(t=-1/0),E(t,{unit:"%",...e})}function xe(...t){return{operation:"min",operands:z(t)}}function Se(...t){return{operation:"max",operands:z(t)}}function ce(...t){return{operation:"add",operands:z(t)}}function Ee(...t){return{operation:"mul",operands:z(t)}}function $e(t,e,s,n,r){return{operation:"threshold",operands:[q(t),q(e),q(s),q(n)],info:r}}function je(t,e="add",s){return{operation:"read",operands:[],path:["dyn",t],accu:e,type:"number",info:s}}function z(t){return t.map(e=>typeof e=="object"?e:E(e))}function q(t){return typeof t!="object"?E(t):t}function H(t,e,s){const n=new Set,r=new Set;function i(o){if(!r.has(o)){if(n.has(o)){console.error("Found cyclical dependency during formula traversal");return}n.add(o),e(o),o.operands.forEach(i),s(o),n.delete(o),r.add(o)}}t.forEach(i)}function D(t,e,s){const n=new Set,r=new Map,i=new Map;function o(c){let l=r.get(c);if(l)return l;l=e(c);let g=i.get(l);return g||(n.has(l)?(console.error("Found cyclical dependency during formula mapping"),E(NaN)):(n.add(l),g=s(a(l),c),n.delete(l),r.set(c,g),i.set(l,g),g))}function a(c){const l=c.operands.map(o);return ue(l,c.operands)?c:{...c,operands:l}}const p=t.map(o);return ue(p,t)?t:p}function le(t,e,s){const n=new Map;function r(i,o){let a=n.get(o);a||n.set(o,a=[new Set,new Map]);const[p,c]=a,l=c.get(i);if(l)return l;if(p.has(i))throw new Error("Found cyclical dependency during formula mapping");p.add(i);const g=s(i,o,r);return c.set(i,g),p.delete(i),g}return t.map(i=>r(i,e))}function ue(t,e){return t===void 0?e===void 0:e===void 0?!1:t.length===e.length&&t.every((s,n)=>s===e[n])}const pe={min:t=>Math.min(...t),max:t=>Math.max(...t),add:t=>t.reduce((e,s)=>e+s,0),mul:t=>t.reduce((e,s)=>e*s,1)},F={...pe,res:([t])=>t<0?1-t/2:t>=.75?1/(t*4+1):1-t,sum_frac:t=>t[0]/t.reduce((e,s)=>e+s),threshold:([t,e,s,n])=>t>=e?s:n},Ne=new Set(Object.keys(pe));function de(t,e,s=n=>!1){let n=ee(t,e,s);return n=Fe(n),n=ee(n,{}),_e(n)}function Re(t,e,s,n){let r=`
"use strict";
function res(res) {
  if (res < 0) return 1 - res / 2
  else if (res >= 0.75) return 1 / (res * 4 + 1)
  return 1 - res
}
const x0=0`,i=1;const o=new Map;return H(t,a=>{},a=>{const{operation:p,operands:c}=a,l=`x${i++}`,g=c.map(d=>o.get(d));switch(o.set(a,l),p){case"read":{const d=s(a);let h=n?new Array(n).fill(null).map((u,f)=>`(b[${f}].values["${d}"] ?? 0)`):["0"];e[d]&&e[d]!==0&&(h=[e[d].toString(),...h]),r+=`,${l}=${h.join("+")}
`;break}case"const":o.set(a,`(${a.value})`);break;case"add":case"mul":r+=`,${l}=${g.join(p==="add"?"+":"*")}
`;break;case"min":case"max":r+=`,${l}=Math.${p}(${g})
`;break;case"threshold":{const[d,h,u,f]=g;r+=`,${l}=(${d}>=${h})?${u}:${f}
`;break}case"res":r+=`,${l}=res(${g[0]})
`;break;case"sum_frac":r+=`,${l}=${g[0]}/(${g[0]}+${g[1]})
`;break;default:C(p)}}),r+=`;
return [${t.map(a=>o.get(a))}]`,new Function("b",r)}function Fe(t){return D(t,e=>e,e=>{let s=e;if(Ne.has(e.operation)){const n=e,{operation:r}=n;let i=!1;const o=n.operands.flatMap(a=>a.operation===r?(i=!0,a.operands):[a]);s=i?{...n,operands:o}:n}return s})}function Z(t,e,s){if(t.length!==e.length)return t.length-e.length;for(let n=0;n<t.length;n++){const r=s(t[n],e[n]);if(r!==0)return r}return 0}function _e(t){const e=new Map,s=[[]];H(t,a=>{},a=>{switch(a.operation){case"const":case"read":s[0].push(a),e.set(a,0);break;default:{const p=Math.max(...a.operands.map(c=>e.get(c)))+1;s.length<=p&&s.push([]),s[p].push(a),e.set(a,p);break}}});function n(a,p){const c=e.get(a),l=e.get(p);if(c!==l)return c-l;const g=a.operation,d=p.operation;if(g!==d)return g.localeCompare(d);switch(g){case"const":if(g!==d)throw Error("ily jslint");return a.value-p.value;case"read":if(g!==d)throw Error("ily jslint");return Z(a.path,p.path,(h,u)=>h.localeCompare(u));case"res":case"threshold":case"sum_frac":{if(g!==d)throw Error("ily jslint");const h=a.operands.map(f=>i.get(f)),u=p.operands.map(f=>i.get(f));return Z(h,u,(f,m)=>f-m)}case"add":case"mul":case"min":case"max":{if(g!==d)throw Error("ily jslint");const h=a.operands.map(f=>i.get(f)),u=p.operands.map(f=>i.get(f));return h.sort((f,m)=>f-m),u.sort((f,m)=>f-m),Z(h,u,(f,m)=>f-m)}}}let r=0;const i=new Map,o=[];return s.forEach(a=>{a.sort(n),o.push(a[0]),i.set(a[0],r++);for(let p=1;p<a.length;p++)n(a[p-1],a[p])===0?i.set(a[p],i.get(a[p-1])):(o.push(a[p]),i.set(a[p],r++))}),o.forEach((a,p)=>{switch(a.operation){case"add":case"mul":case"min":case"max":o[p]={...a,operands:[...a.operands].sort((c,l)=>i.get(c)-i.get(l))}}}),D(t,a=>o[i.get(a)],a=>a)}function ee(t,e,s=n=>!1){const n={data:[],processed:new Map},r=new Map([[n,new Map]]),i={data:[e],processed:new Map};return r.set(i,new Map),r.get(n).set(e,i),le(t,i,(o,a,p)=>{const{operation:c}=o,l=(h,u)=>p(h,u),g=(h,u)=>p(h,u);let d;switch(c){case"const":d=o;break;case"add":case"mul":case"max":case"min":{const h=F[c],u=[],f=o.operands.filter(w=>{const b=l(w,a);return b.operation==="const"?(u.push(b.value),!1):!0}).map(w=>l(w,a)),m=h(u);if(isFinite(m)){if(c==="mul"&&m===0){d=E(m);break}}else if(c!=="mul"&&(c!=="max"||m>0)&&(c!=="min"||m<0)){d=E(m);break}m!==h([])&&f.push(E(m)),f.length<=1?d=f[0]??E(h([])):d={operation:c,operands:f};break}case"res":case"sum_frac":{const h=o.operands.map(f=>l(f,a)),u=F[c];h.every(f=>f.operation==="const")?d=E(u(h.map(f=>f.value))):d={...o,operands:h};break}case"lookup":{const h=g(o.operands[0],a);if(h.operation==="const"){const u=o.table[h.value]??o.operands[1];if(u){d=p(u,a);break}}throw new Error(`Unsupported ${c} node while folding`)}case"prio":{const h=o.operands.find(u=>{const f=g(u,a);if(f.operation!=="const")throw new Error(`Unsupported ${c} node while folding`);return f.value!==void 0});d=h?g(h,a):E(void 0);break}case"small":{let h;for(const u of o.operands){const f=g(u,a);if(f.operation!=="const")throw new Error(`Unsupported ${c} node while folding`);((h==null?void 0:h.value)===void 0||f.value!==void 0&&f.value<h.value)&&(h=f)}d=h??E(void 0);break}case"match":{const[h,u,f,m]=o.operands.map(w=>p(w,a));if(h.operation!=="const"||u.operation!=="const")throw new Error(`Unsupported ${c} node while folding`);d=h.value===u.value?f:m;break}case"threshold":{const[h,u,f,m]=o.operands.map(w=>p(w,a));f.operation==="const"&&m.operation==="const"&&f.value===m.value?d=f:h.operation==="const"&&u.operation==="const"?d=h.value>=u.value?f:m:d={...o,operands:[h,u,f,m]};break}case"subscript":{const h=l(o.operands[0],a);if(h.operation!=="const")throw new Error("Found non-constant subscript node while folding");d=E(o.list[h.value]);break}case"read":{const h=a.data.map(u=>ye(u,o.path)).filter(u=>u);if(h.length===0)if(s(o)){const{accu:u}=o;u===void 0||u==="small"?d=o.type==="string"?E(void 0):E(NaN):d=E(F[u]([]))}else d=o;else o.accu===void 0||h.length===1?d=p(h[h.length-1],a):d=p({operation:o.accu,operands:h},a);break}case"data":{o.reset&&(a=n);const h=r.get(a);let u=h.get(o.data);u||(u={data:[...a.data,o.data],processed:new Map},r.set(u,new Map),h.set(o.data,u)),d=p(o.operands[0],u);break}default:C(c)}return d.info&&(d={...d},delete d.info),d})}function fe(t,e,s,n,r,i){let o=i;const a={pruneOrder:{pruneNodeRange:!0},pruneArtRange:{pruneNodeRange:!0},pruneNodeRange:{reaffine:!0},reaffine:{pruneOrder:!0,pruneArtRange:!0,pruneNodeRange:!0}};let p=0;for(;Object.values(o).some(c=>c)&&p++<20;){if(o.pruneOrder){delete o.pruneOrder;const c=Ce(s,n,r);s!==c&&(s=c,o={...o,...a.pruneOrder})}if(o.pruneArtRange){delete o.pruneArtRange;const c=Pe(t,s,e);s!==c&&(s=c,o={...o,...a.pruneArtRange})}if(o.pruneNodeRange){delete o.pruneNodeRange;const c=Te(t,s);t!==c&&(t=c,o={...o,...a.pruneNodeRange})}if(o.reaffine){delete o.reaffine;const{nodes:c,arts:l}=Ie(t,s);(t!==c||s!==l)&&(t=c,s=l,o={...o,...a.reaffine})}}return{nodes:t,arts:s}}function Ie(t,e,s=!1){const n=new Set,r=new Set;function i(u,f){return f?n.add(u):u.operands.forEach(m=>n.has(m)&&r.add(m)),u}const o=new Set;if(t=D(t,u=>u,u=>{const{operation:f}=u;switch(f){case"read":return o.add(u.path[1]),i(u,!0);case"add":{const m=u.operands.filter(v=>n.has(v)),w=u.operands.filter(v=>!n.has(v));if(w.length===0)return i(u,!0);if(m.length<=1)return i(u,!1);const b=i(ce(...m),!0);return i(ce(b,...w),!1)}case"mul":{const m=u.operands.filter(w=>w.operation!=="const");return i(u,m.length===0||m.length===1&&n.has(m[0]))}case"const":return i(u,!0);case"res":case"threshold":case"sum_frac":case"max":case"min":return i(u,!1);default:ie(f)}}),t.filter(u=>n.has(u)).forEach(u=>r.add(u)),[...r].every(({operation:u})=>u==="read"||u==="const")&&Object.keys(e.base).length===o.size)return{nodes:t,arts:e};let a=-1;function p(){for(;o.has(`${++a}`););return`${a}`}const c=[...r].filter(u=>u.operation!=="const"),l=new Map(c.map(u=>[u,!s&&u.operation==="read"&&u.path[0]==="dyn"?u:je(p())]));t=D(t,u=>l.get(u)??u,u=>u);function g(u){const f=ee([...l.keys()],{dyn:B(u,m=>E(m))},m=>!0);return Object.fromEntries([...l.values()].map((m,w)=>[m.path[1],f[w].value]))}const d={nodes:t,arts:{base:g(e.base),values:I(S,u=>e.values[u].map(({id:f,set:m,values:w})=>({id:f,set:m,values:g(w)})))}},h=Object.entries(g({}));for(const u of Object.values(d.arts.values))for(const{values:f}of u)for(const[m,w]of h)f[m]-=w;return d}function Ce(t,e,s){var c;let n=!1;const r=!((c=s.rainbow)!=null&&c.length),i=Object.keys(t.base),o=new Set(Object.entries(s).filter(([l,g])=>g.length).map(([l])=>l)),a=new Set(Object.entries(s).filter(([l,g])=>g.includes(2)&&!g.includes(4)).map(([l])=>l)),p=I(S,l=>{const g=t.values[l],d=g.filter(h=>{let u=0;return g.every(f=>{const m=i.every(y=>(f.values[y]??0)>=(h.values[y]??0)),w=i.some(y=>(f.values[y]??0)>(h.values[y]??0)),b=m&&(w||f.id>h.id),v=r&&!o.has(f.set)&&!a.has(h.set)||h.set===f.set;return b&&v&&u++,u<e})});return d.length!==g.length&&(n=!0),d});return n?{base:t.base,values:p}:t}function Pe(t,e,s){const n=Object.fromEntries(Object.entries(e.base).map(([i,o])=>[i,{min:o,max:o}])),r={arts:e};for(;;){const i=I(S,c=>L(r.arts.values[c])),o=I(S,c=>K(Object.entries(i).map(l=>l[0]===c?n:l[1]).filter(l=>l)));let a=!1;const p=I(S,c=>{const l=r.arts.values[c].filter(g=>{const d=K([L([g]),o[c]]),h=ne(t,d);return t.every((u,f)=>h.get(u).max>=(s[f]??-1/0))});return l.length!==r.arts.values[c].length&&(a=!0),l});if(!a)break;r.arts={base:r.arts.base,values:p}}return r.arts}function Te(t,e){const s=Object.fromEntries(Object.entries(e.base).map(([i,o])=>[i,{min:o,max:o}])),n=K([s,...Object.values(e.values).map(i=>L(i))]),r=ne(t,n);return D(t,i=>{{const{min:p,max:c}=r.get(i);if(p===c)return E(p)}const{operation:o}=i,a=i.operands.map(p=>r.get(p));switch(o){case"threshold":{const[p,c,l,g]=a;if(p.min>=c.max)return i.operands[2];if(p.max<c.min)return i.operands[3];if(l.max===l.min&&g.max===g.min&&l.min===g.min&&isFinite(l.min))return E(l.max);break}case"min":{const p=i.operands.filter((c,l)=>{const g=a[l];return a.every(d=>g.min<=d.max)});if(p.length<a.length)return xe(...p);break}case"max":{const p=i.operands.filter((c,l)=>{const g=a[l];return a.every(d=>g.max>=d.min)});if(p.length<a.length)return Se(...p);break}}return i},i=>i)}function K(t){const e={};return t.forEach(s=>{Object.entries(s).forEach(([n,r])=>{e[n]?(e[n].min+=r.min,e[n].max+=r.max):e[n]={...r}})}),e}function L(t){const e={};return t.length&&(Object.keys(t[0].values).filter(s=>t.every(n=>n.values[s])).forEach(s=>e[s]={min:t[0].values[s],max:t[0].values[s]}),t.forEach(({values:s})=>{for(const[n,r]of Object.entries(s))e[n]?(e[n].max<r&&(e[n].max=r),e[n].min>r&&(e[n].min=r)):e[n]={min:0,max:r}})),e}function te(t){const e=Object.fromEntries(Object.entries(t.base).map(([s,n])=>[s,{min:n,max:n}]));return K([e,...Object.values(t.values).map(s=>L(s))])}function ne(t,e){const s=new Map;return H(t,n=>{},n=>{const{operation:r}=n,i=n.operands.map(a=>s.get(a));let o;switch(r){case"read":if(n.path[0]!=="dyn")throw new Error(`Found non-dyn path ${n.path} while computing range`);o=e[n.path[1]]??{min:0,max:0};break;case"const":o=W([n.value]);break;case"add":case"min":case"max":o={min:F[r](i.map(a=>a.min)),max:F[r](i.map(a=>a.max))};break;case"res":o={min:F[r]([i[0].max]),max:F[r]([i[0].min])};break;case"mul":o=i.reduce((a,p)=>W([a.min*p.min,a.min*p.max,a.max*p.min,a.max*p.max]));break;case"threshold":i[0].min>=i[1].max?o=i[2]:i[0].max<i[1].min?o=i[3]:o=W([],[i[2],i[3]]);break;case"sum_frac":{const[a,p]=i,c={min:a.min+p.min,max:a.max+p.max};c.min<=0&&c.max>=0?o=a.min<=0&&a.max>=0?{min:NaN,max:NaN}:{min:-1/0,max:1/0}:o=W([a.min/c.min,a.min/c.max,a.max/c.min,a.max/c.max]);break}default:ie(r)}s.set(n,o)}),s}function W(t,e=[]){const s=Math.max(...t,...e.map(r=>r.max));return{min:Math.min(...t,...e.map(r=>r.min)),max:s}}function U(t,e){return{base:t.base,values:I(S,s=>{const n=e[s];switch(n.kind){case"id":return t.values[s].filter(r=>n.ids.has(r.id));case"exclude":return t.values[s].filter(r=>!n.sets.has(r.set));case"required":return t.values[s].filter(r=>n.sets.has(r.set))}})}}function Ue(t){let e=.01;const s=2,n=1500;let r=new Set(t.flatMap(o=>Object.values(o).map(a=>Math.round(a.plot/e))));for(;r.size>n;)e*=s,r=new Set([...r].map(o=>Math.round(o/s)));const i={};for(const o of t)for(const a of Object.values(o)){const p=Math.round(a.plot/e)*e;(!i[p]||i[p].value<a.value)&&(i[p]=a)}return i}function _(t){return S.reduce((e,s)=>e*t.values[s].length,1)}function*Ve(t,e){const s=B(e.values,n=>new Set(n.map(r=>r.set)));e:for(const n of t){for(const[r,i]of Object.entries(n)){const o=s[r];switch(i.kind){case"required":if([...i.sets].every(a=>!o.has(a)))continue e;break;case"exclude":if([...o].every(a=>i.sets.has(a)))continue e;break}}yield n}}function he(t){return new Set(t!=null&&t.includes(2)?t.includes(4)?[0,1]:[0,1,4,5]:t!=null&&t.includes(4)?[0,1,2,3]:[0,1,2,3,4,5])}function*De(t,e){const s=[...new Set(e)],n=he(t.rainbow);let r=[];function i(d,h,u){if(d.length===5){n.has(u.length)&&r.push(d);return}for(const f of h)i([...d,f],h,u.filter(m=>m!==f));i([...d,d.length],new Set([...h,d.length]),[...u,d.length])}i([0],new Set([0]),[0]);function o(d,h){if(!A(h+1,4).some(u=>d[u]!==5))return d=[...d],d[h]=5,d.reduce((u,f)=>u*6+f,0)}for(let d=4;d>=0;d--){const h=new Map;for(const u of r){const f=o(u,d);f!==void 0&&h.set(f,(h.get(f)??new Set(u.slice(0,d)).size+1)-1)}for(const[u,f]of h.entries())if(f===0){const m=[...r.find(w=>o(w,d)===u)];m[d]=5,r=r.filter(w=>o(w,d)!==u),r.push(m)}}const a={kind:"exclude",sets:new Set},p=I(S,d=>a),c={...B(t,d=>0),...I(s,d=>0)},l=B(t,he);function*g(d){const h=new Set,u=[];let f=[];for(const v of d)f.push([]),v===5?u.push(f.length-1):f[v].push(f.length-1);f=f.filter(v=>v.length).sort((v,y)=>y.length-v.length);let m=u.length;function*w(v){if(v===f.length)return yield*b(0);for(const y of s){if(h.has(y))continue;const O=f[v].length,k=l[y];let x=0;k&&!k.has(O)&&(x=(A(O+1,5).find(M=>k.has(M))??6)-O,x>m)||(h.add(y),c[y]=f[v].length,f[v].forEach(M=>p[S[M]]={kind:"required",sets:new Set([y])}),m-=x,yield*w(v+1),m+=x,c[y]=0,h.delete(y))}}function*b(v){const y=u.length-v,O=[],k=[],x=[];let M=0;for(const $ of s){const j=l[$],R=c[$];j&&(A(1,y).every(T=>!j.has(R+T))?x.push($):j.has(R)?A(0,y).some(T=>!j.has(R+T))&&O.push($):(M+=[...j].find(T=>T>R)-R,k.push($)))}if(!(M>y)){if(v===u.length){yield{...p};return}if(M===y){for(const $ of k)c[$]++,p[S[u[v]]]={kind:"required",sets:new Set([$])},yield*b(v+1),c[$]--;return}for(const $ of[...O,...k])c[$]++,p[S[u[v]]]={kind:"required",sets:new Set([$])},yield*b(v+1),c[$]--;p[S[u[v]]]={kind:"exclude",sets:new Set([...k,...x,...O])},yield*b(v+1)}}yield*w(0)}for(const d of r)yield*g(d)}function G(t){return{type:"lin",lin:{$c:t},min:t,max:t}}function Be(t,e){return{type:"lin",lin:{[t]:1,$c:0},...e}}function se(...t){const e=t.filter(n=>typeof n=="number").reduce((n,r)=>n+r,0),s=t.filter(n=>typeof n!="number");return{type:"sum",terms:s,$c:e,min:s.reduce((n,{min:r})=>n+r,e),max:s.reduce((n,{max:r})=>n+r,e)}}function X(...t){const e=t.filter(r=>typeof r=="number").reduce((r,i)=>r*i,1),s=t.filter(r=>typeof r!="number"),n=s.reduce(({min:r,max:i},{min:o,max:a})=>({min:Math.min(r*o,r*a,i*o,i*a),max:Math.max(r*o,r*a,i*o,i*a)}),{min:e,max:e});return{type:"prod",terms:s,$k:e,...n}}function re(t,e,s,n){return se(s-t*e,X(t,n))}function me(t,e,s,n,r,i){return Math.abs(t-s)<1e-10?G(i?Math.max(e,n):Math.min(e,n)):re((n-e)/(s-t),t,e,r)}function Ae(t,e){const s=new Map;H(t,c=>{const{operation:l}=c;switch(l==="mul"&&s.set(c,{min:NaN,max:NaN}),l){case"mul":case"min":case"max":case"threshold":case"res":case"sum_frac":c.operands.forEach(g=>s.set(g,{min:NaN,max:NaN}))}},c=>c);const n=te(e),r=ne([...s.keys()],n);for(const[c,l]of r.entries())s.set(c,l);const i="u",o="l",a="e";return le(t,i,(c,l,g)=>{const{operation:d}=c,h=(f,m=l)=>g(f,m),u=l===i?o:i;switch(d){case"const":return G(c.value);case"read":return Be(c.path[1],s.get(c));case"add":return se(...c.operands.map(f=>h(f)));case"mul":{if(l===a)return X(...c.operands.map(k=>h(k)));const{min:f,max:m}=s.get(c);if(f===m)return G(f);if(f*m<0||c.operands.some(k=>{const{min:x,max:M}=s.get(k);return x*M<0}))return h(c,a);const b=f===0?m:f,v=F[d],y=v(c.operands.filter(k=>k.operation==="const").map(k=>k.value)),O=c.operands.filter(k=>k.operation!=="const").map(k=>{const{min:x,max:M}=s.get(k),j=b*(x===0?M:x)>0?l:u,R=h(k,j);if(j===o&&M>0&&R.min<-x||j===i&&x<0&&R.max>-M)throw new N("Unallowed large crossing post approximation",d);return R});return X(y,...O)}case"min":case"max":{if(l===a)throw new N("Cannot be exactly represented",d);const f=F[d],m=c.operands.filter(M=>M.operation!=="const"),[w]=m;if(m.length!==1)throw new N("Multivariate",d);const b=h(w),v=f(c.operands.filter(M=>M.operation==="const").map(M=>M.value));if(d==="max"&&l===o||d==="min"&&l===i)return b;const{min:y,max:O}=s.get(w),k=f([y,v]),x=f([O,v]);return me(y,k,O,x,b,l===i)}case"res":{if(l===a)throw new N("Cannot be exactly represented",d);if(l===o)throw new N("Unsupported direction",d);const f=F[d],[m]=c.operands,{min:w,max:b}=s.get(m),v=h(m,u);return w<0&&b<1.75?se(1,X(-.5,v)):me(w,f([w]),b,f([b]),v,l===i)}case"sum_frac":{if(l===a)throw new N("Cannot be exactly represented",d);if(l===o)throw new N("Unsupported direction",d);const[f,m]=c.operands;if(m.operation!=="const")throw new N("Non-constant node",d);const w=h(f),b=m.value,{min:v,max:y}=s.get(f);if(v<=-b)throw new N("Unallowed negative argument",d);const O=Math.sqrt((v+b)*(y+b));return re(b/(O+b)/(O+b),O,O/(O+b),w)}case"threshold":{if(l===a)throw new N("Cannot be exactly represented",d);const[f,m,w,b]=c.operands;if(m.operation!=="const")throw new N("Non-constant node",d);const{min:v,max:y}=s.get(f);if(v>=m.value)return h(w);if(y<m.value)return h(b);if(b.operation!=="const")throw new N("Non-constant node",d);if(w.operation!=="const"){if(b.value!==0)throw new N("Unsupported pattern",d);const j=$e(f,m,1,b),R=Ee(j,w),{min:T,max:lt}=s.get(w);return s.set(j,{min:0,max:1}),s.set(R,{min:Math.min(T,0),max:Math.max(lt,0)}),h(R)}const O=m.value,k=w.value,x=b.value,M=k>x==(l===i),$=h(f,M?i:o);if(M){const j=(k-x)/(O-v);return re(j,O,k,$)}return G(x)}default:C(d)}}).map(c=>Le(c))}function ae(t){return{$k:t,terms:[]}}function ze(t,e){return{$k:e,terms:[t]}}function qe(...t){return t.flat()}function He(...t){return Y(...t).map(e=>e.reduce((s,n)=>(s.$k*=n.$k,s.terms.push(...n.terms),s),{$k:1,terms:[]}))}function Ke(t){t.forEach(e=>e.terms.sort()),t.sort(({terms:e},{terms:s})=>{if(e.length!==s.length)return e.length-s.length;for(let n=0;n<e.length;n++)if(e[n]!==s[n])return e[n]<s[n]?-1:1;return 0});for(let e=t.length-2;e>=0;e--){if(t[e].$k===0){t.splice(e,1);continue}const s=t[e].terms,n=t[e+1].terms;s.length===n.length&&s.every((r,i)=>r===n[i])&&(t[e].$k=t[e].$k+t[e+1].$k,t.splice(e+1,1))}return t}function Le(t){function e(s){switch(s.type){case"lin":return Object.entries(s.lin).filter(([n,r])=>r!==0).map(([n,r])=>n==="$c"?ae(r):ze(n,r));case"sum":return qe(...s.terms.map(n=>e(n)),[ae(s.$c)]);case"prod":return He(...s.terms.map(n=>e(n)),[ae(s.$k)])}}return Ke(e(t))}class N extends Error{constructor(e,s){super(`Found ${e} in ${s} node when generating polynomial upper bound`)}}const P=1e-8;function We(t,e){const s=e.length;return t.every(n=>e.reduce((r,i,o)=>r+i*n[o],0)<=n[s]+P)}function Ge(t,e){const s=e.length+1,n=e[0].length,r=Array(s).fill(0).map(a=>Array(n).fill(0));e.forEach((a,p)=>a.forEach((c,l)=>r[p][l]=c)),t.forEach((a,p)=>r[s-1][p]=a);const i=[];for(;r.some((a,p)=>p<s-1&&a[n-1]<-P);){const a=Je(r);i.push(a),ge(r,a)}for(;r[s-1].some((a,p)=>p<n-1&&a<-P);){const a=Xe(r);i.push(a),ge(r,a)}const o=t.map((a,p)=>Qe(r,i,p));if(!We(e,o))throw Error("COMPUTED SOLUTION IS NOT FEASIBLE");return o}function ge(t,{i:e,j:s}){const n=t[e][s];for(let r=0;r<t.length;r++)if(r!==e)for(let i=0;i<t[0].length;i++)i!==s&&(t[r][i]-=t[e][i]*t[r][s]/n);for(let r=0;r<t.length;r++)r!==e&&(t[r][s]=-t[r][s]/n);for(let r=0;r<t[0].length;r++)r!==s&&(t[e][r]=t[e][r]/n);t[e][s]=1/n}function Xe(t){const e=t.length,s=t[0].length;let n={i:-1,j:-1,cmp:1/0};for(let r=0;r<s-1;r++)if(!(t[e-1][r]>=-P)){for(let i=0;i<e-1;i++)if(t[i][r]>P){const o=t[i][s-1]/t[i][r];o<n.cmp&&(n={i,j:r,cmp:o})}if(n.i<0)throw Error("UNBOUNDED FEASIBLE")}if(n.i<0)throw Error("NO PIVOTS (done)");return{i:n.i,j:n.j}}function Je(t){const e=t.length,s=t[0].length;let n={i:-1,j:-1,cmp:1/0};for(let r=0;r<e-1;r++)if(!(t[r][s-1]>=-P)){for(let i=0;i<s-1;i++)if(t[r][i]<-P){const o=t[r][s-1]/t[r][i];o<n.cmp&&(n={i:r,j:i,cmp:o})}if(n.i<0)throw Error("INFEASIBLE");return{i:n.i,j:n.j}}throw Error("NO PIVOTS (done)")}function Qe(t,e,s){let n=1;e.forEach(({i,j:o})=>{n===1&&o===s?(s=i,n=0):n===0&&i===s&&(s=o,n=1)});const r=t[0].length;return n===0?t[s][r-1]:0}function Ye(...t){const e={$c:0};for(const[s,n]of t)for(const[r,i]of Object.entries(n))e[r]=(e[r]??0)+s*i;return e}function we(t,e){const s=Ae(t,e),n=te(e);return s.map(r=>Ye(...r.map(i=>{const o=i.terms.map(l=>n[l]),{w:a,$c:p}=Ze(o,i.$k>=0?"upper":"lower"),c={$c:p};return i.terms.forEach((l,g)=>c[l]=a[g]+(c[l]??0)),[i.$k,c]})))}function Ze(t,e="upper"){if(t.length===0)return{w:[],$c:1,err:0};const s=t.length,n=t.map(({min:a,max:p})=>Math.max(-a,p));if(n.some(a=>a===0))return{w:t.map(a=>0),$c:0,err:0};const r=n.reduce((a,p)=>a*p,1);t=t.map(({min:a,max:p},c)=>({min:a/n[c],max:p/n[c]}));const i=Y(...t.map(({min:a,max:p})=>[a,p])).flatMap(a=>{const p=a.reduce((l,g)=>l*g,1),c=a.reduce((l,g)=>l+g,0);switch(e){case"upper":return[[...a,-1,0,c-p-s],[...a.map(l=>-l),1,-1,s+p-c]];case"lower":return[[...a.map(l=>-l),-1,0,p-c-s],[...a,1,-1,s+c-p]];default:C(e)}}),o=[...t.map(a=>0),0,1];try{const a=Ge(o,i);switch(e){case"upper":return{w:a.slice(0,s).map((p,c)=>(1-p)*r/n[c]),$c:r*(a[s]-s),err:r*a[s+1]};case"lower":return{w:a.slice(0,s).map((p,c)=>(1-p)*r/n[c]),$c:r*(s-a[s]),err:r*a[s+1]};default:C(e)}}catch(a){throw console.log("ERROR on bounds",t),console.log("Possibly numerical instability issue."),console.log(a),a}}function et(t,e){const s=te(e),n=[...new Set(t.flatMap(i=>Object.keys(i).filter(o=>o!=="$c")))],{bestKey:r}=n.reduce(({bestKey:i,minHeur:o},a)=>{const{min:p,max:c}=s[a],l=t.reduce((f,m)=>f+((c-p)*(m[a]??0))**2,0),{lowerRange:g,upperRange:d}=S.reduce(({lowerRange:f,upperRange:m},w)=>{const b=e.values[w].map(M=>M.values[a]),v=Math.min(...b),y=Math.max(...b),O=(v+y)/2,k=Math.max(...b.filter(M=>M<=O)),x=Math.min(...b.filter(M=>M>=O));return{lowerRange:f+(k-v),upperRange:m+(y-x)}},{lowerRange:0,upperRange:0}),u=t.reduce((f,m)=>f+(g*(m[a]??0))**2+(d*(m[a]??0))**2,0)/2-l;return u<o?{bestKey:a,minHeur:u}:{bestKey:i,minHeur:o}},{bestKey:"",minHeur:1/0});return{splitOn:r,splitVal:(s[r].min+s[r].max)/2}}function tt(t,e){return be(e,s=>s.map(n=>n.set===t))}function nt(t,e,s){e-=s.base[t];const n=S.map(c=>s.values[c].map(l=>({art:l,val:l.values[t]})).sort((l,g)=>l.val-g.val)),r=n.map(([c])=>c.val),i=n.map(c=>c[c.length-1].val-c[0].val),o=i.reduce((c,l)=>c+l),a=(e-r.reduce((c,l)=>c+l))/Math.max(o,1e-9),p=n.map((c,l)=>{const g=r[l]+a*i[l];let d=0,h=c.length;for(;d!==h;){const u=Math.floor((d+h)/2);g>c[u].val?d=u+1:h=u}return h});return be(s,(c,l)=>{const g=new Set(n[l].slice(p[l]).map(d=>d.art));return c.map(d=>g.has(d))})}function be({base:t,values:e},s){const n=S.map((r,i)=>{const o=e[r],a=s(o,i);return[o.filter((p,c)=>a[c]),o.filter((p,c)=>!a[c])].filter(p=>p.length)});return Y(...n).map(r=>({base:t,values:I(S,(i,o)=>r[o])})).sort((r,i)=>_(i)-_(r))}class st{constructor({arts:e,optTarget:s,constraints:n,topN:r},i){this.filters=[],this.firstUncalculated=0,this.arts=e,this.min=[-1/0,...n.map(o=>o.min)],this.nodes=[s,...n.map(o=>o.value)],this.callback=i,this.topN=r,we(this.nodes,e)}addFilter(e){const s=U(this.arts,e),n=_(s);n&&this.filters.push({nodes:this.nodes,arts:s,maxConts:[],lins:[],approxs:[],count:n})}setThreshold(e){e>this.min[0]&&(this.min[0]=e,this.firstUncalculated=0,this.filters.forEach(s=>delete s.calculated))}*split(e,s){for(this.addFilter(e);this.filters.length;){const n=this.getApproxFilter(),{arts:r,count:i}=n;if(i<=s||Object.keys(r.base).length===0){if(!i)continue;this.firstUncalculated<this.filters.length&&this.calculateFilter(this.firstUncalculated++),this.reportInterim(!1),yield Q(r.values,o=>({kind:"id",ids:new Set(o.map(a=>a.id))}))}else this.splitOldFilter(n)}this.reportInterim(!0)}reportInterim(e=!1){this.interim&&(this.interim.skipped>1e6||e===!0)&&(this.callback(this.interim),this.interim=void 0)}splitOldFilter(e){const{nodes:s,arts:n,lins:r}=e;if(_(n)===0)return;const{splitOn:i,splitVal:o}=et(r,n),a=Oe.includes(i)?tt(i,n):nt(i,o,n);for(const p of a){const c=_(p);this.filters.push({nodes:s,arts:p,maxConts:[],lins:[],approxs:[],count:c})}}getApproxFilter(){return this.calculateFilter(this.filters.length-1),this.firstUncalculated>this.filters.length&&(this.firstUncalculated=this.filters.length),this.filters.pop()}calculateFilter(e){let{nodes:s,arts:n,maxConts:r,lins:i,approxs:o}=this.filters[e];const{count:a,calculated:p}=this.filters[e];if(p)return;({nodes:s,arts:n}=fe(s,this.min,n,this.topN,{},{pruneNodeRange:!0})),s=de(s,{},d=>!1),Object.values(n.values).every(d=>d.length)&&({lins:i,approxs:o}=at(s,n),r=o.map(d=>Q(n.values,h=>rt(h,d))));const c=r.map((d,h)=>Object.values(d).reduce((u,f)=>u+f,o[h].base-this.min[h])),l=Q(n.values,(d,h)=>{const u=c.map((f,m)=>r[m][h]-f);return d.filter(({id:f})=>o.every(({conts:m},w)=>m[f]>=u[w]))});n={base:n.base,values:l};const g=_(n);g!==a&&(this.interim?this.interim.skipped+=a-g:this.interim={resultType:"interim",buildValues:void 0,tested:0,failed:0,skipped:a-g}),this.filters[e]={nodes:s,arts:n,maxConts:r,lins:i,approxs:o,count:g,calculated:!0}}}function rt(t,e){return Math.max(...t.map(({id:s})=>e.conts[s]))}function at(t,e){const s=we(t,e);return{lins:s,approxs:s.map(n=>({base:ve(e.base,n,n.$c),conts:ke(Object.values(e.values).flat(),r=>[r.id,ve(r.values,n,0)])}))}}function ve(t,e,s){return Object.entries(t).reduce((n,[r,i])=>n+(e[r]??0)*i,s)}class it{constructor({arts:e,optTarget:s,constraints:n,plotBase:r,topN:i},o){this.builds=[],this.buildValues=void 0,this.threshold=-1/0,this.arts=e,this.min=n.map(a=>a.min),this.topN=i,this.callback=o,this.nodes=n.map(a=>a.value),this.nodes.push(s),r&&(this.plotData={},this.nodes.push(r)),this.nodes=de(this.nodes,{},a=>!1)}setThreshold(e){this.threshold>e&&(this.threshold=e)}compute(e){const{min:s}=this;let n=U(this.arts,e);const r=_(n),i=this.builds.length;let o=this.nodes;({nodes:o,arts:n}=fe(o,s,n,this.topN,{},{pruneArtRange:!0,pruneNodeRange:!0}));const a=Object.values(n.values).sort((d,h)=>d.length-h.length),p=Re(o,n.base,d=>d.path[1],a.length),c=Array(a.length),l={tested:0,failed:0,skipped:r-_(n)},g=d=>{if(d<0){const h=p(c);if(s.every((u,f)=>u<=h[f])){const u=h[s.length],{builds:f,plotData:m}=this;let w;if(u>=this.threshold&&(w={value:u,artifactIds:c.map(b=>b.id).filter(b=>b)},f.push(w)),m){const b=h[s.length+1];(!m[b]||m[b].value<u)&&(w||(w={value:u,artifactIds:c.map(v=>v.id).filter(v=>v)}),w.plot=b,m[b]=w)}}else l.failed+=1;return}a[d].forEach(h=>{c[d]=h,g(d-1)}),d===0&&(l.tested+=a[0].length,l.tested>65536&&this.interimReport(l))};g(a.length-1),this.interimReport(l,this.builds.length>i)}refresh(e){const{topN:s}=this;Object.keys(this.plotData??{}).length>=1e5&&(this.plotData=Ue([this.plotData])),(this.builds.length>=1e3||e)&&(this.builds=this.builds.sort((n,r)=>r.value-n.value).slice(0,s),this.buildValues=this.builds.map(n=>n.value),this.threshold=Math.max(this.threshold,this.buildValues[s-1]??-1/0))}interimReport(e,s=!1){this.refresh(s),this.callback({resultType:"interim",buildValues:this.buildValues,...e}),this.buildValues=void 0,e.tested=0,e.failed=0,e.skipped=0}}class ot{constructor({arts:e},s){this.stack=[],this.arts=e}setThreshold(e){}add(e,s){this.stack.push({filter:e,count:_(U(this.arts,e)),splittedBy:s})}*split(e,s){this.add(e,"set");for(let n=this.stack.pop();n;n=this.stack.pop()){const{filter:r,count:i,splittedBy:o}=n;if(i<=s){yield r;continue}switch(o){case"set":this.splitBySet(r);break;case"id":this.splitByID(r,i,s);break;default:C(o)}}}splitBySet(e){const s=U(this.arts,e),n=S.map(o=>({slot:o,sets:new Set(s.values[o].map(a=>a.set))})).filter(({sets:o})=>o.size>1);if(!n.length)return this.add(e,"id");const{sets:r,slot:i}=n.reduce((o,a)=>o.sets.size<a.sets.size?o:a);r.forEach(o=>this.add({...e,[i]:{kind:"required",sets:new Set([o])}},"set"))}splitByID(e,s,n){const r=U(this.arts,e),{slot:i,length:o}=S.map(l=>({slot:l,length:r.values[l].length})).filter(l=>l.length>1).reduce((l,g)=>l.length<g.length?l:g),a=Math.ceil(s/n),p=Math.min(a,o),c=Array(p).fill(0).map(l=>new Set);r.values[i].forEach(({id:l},g)=>c[g%p].add(l)),c.forEach(l=>this.add({...e,[i]:{kind:"id",ids:l}},"id"))}}let J,V;async function ct(t){const{data:e}=t,{command:s}=e;switch(s){case"split":for(const n of J.split(e.filter,e.maxIterateSize))postMessage({command:"iterate",filter:n}),await new Promise(r=>setTimeout(r));break;case"iterate":V.compute(e.filter);break;case"threshold":{J.setThreshold(e.threshold),V.setThreshold(e.threshold);return}case"finalize":{V.refresh(!0);const{builds:n,plotData:r}=V;postMessage({resultType:"finalize",builds:n,plotData:r});break}case"count":{const{exclusion:n,maxIterateSize:r}=e,i=V.arts,o=Ve(De(n,[...new Set(Object.values(i.values).flatMap(p=>p.map(c=>c.set)))]),i);let a=0;for(const p of o)postMessage({command:"split",filter:p,maxIterateSize:r}),a+=_(U(i,p));postMessage({resultType:"count",count:a});break}case"setup":try{J=new st(e,n=>postMessage(n))}catch{J=new ot(e,n=>postMessage(n))}V=new it(e,n=>postMessage(n));break;default:C(s)}postMessage({resultType:"done"})}onmessage=async t=>{try{await ct(t)}catch(e){postMessage({resultType:"err",message:e.message})}}})();
