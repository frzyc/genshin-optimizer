import { r as reactExports, br as generateUtilityClasses, bq as generateUtilityClass, bs as styled, c$ as Paper, bv as _objectWithoutPropertiesLoose$g, d0 as useControlled, bt as _extends$p, d1 as useSlot, d2 as Collapse, j as jsxRuntimeExports, bw as clsx, d3 as createUseThemeProps, bx as composeClasses, bC as ButtonBase, d4 as Backdrop, d5 as Modal, by as capitalize, bu as useThemeProps$3, K as useTheme, d6 as useId, d7 as Fade, T as Typography, d8 as rootShouldForwardProp, d9 as listItemButtonClasses, bA as alpha_1, da as ListContext, db as useEnhancedEffect, dc as useForkRef, dd as getListItemButtonUtilityClass, c as createSvgIcon, de as useRtl, a as useDatabase, at as useForceUpdate, df as TeamCharacterContext, cT as notEmpty, dg as forEachNodes, dh as assertUnreachable, di as threshold$1, dj as min$2, dk as max$2, dl as sum, dm as prod, dn as frac, dp as constant$4, z as useTranslation, b as jsx, d as jsxs, P as Link$1, ad as Trans, av as Alert, dq as allMainStatKeys, dr as allSubstatKeys, cl as statPercent, cE as KeyMap, ck as Fragment, L as useMediaQuery, cw as getUnitStr, cx as List, f as Box, ds as ListSubheader, c_ as StatIcon, dt as Popper, du as GeneralAutocomplete, aQ as CustomNumberInput, aP as CustomNumberInputButtonGroupWrapper, aq as default_1$9, ag as Button, aN as ButtonGroup, aR as clamp, c5 as getWeaponSheet, c4 as computeUIData, c6 as dataObjForWeapon, I as getWeaponStat, bQ as NextImage, bV as weaponAsset, bX as WeaponName, ap as SqBadge, bY as getLevelString, cY as weaponHasRefinement, c0 as uiInput, h as CardThemed, c8 as resolveInfo, c9 as getCalcDisplay, bR as DocumentDisplay, dv as getArtSheet, v as requireCreateSvgIcon, w as interopRequireDefaultExports, dw as FormulaDataContext, M as CardHeader, aj as IconButton, ak as default_1$a, O as CardContent, al as ModalWrapper, D as DataContext, dx as getDisplaySections, S as Skeleton, dy as getDisplayHeader, dz as CardHeaderCustom, N as Divider, dA as default_1$b, dB as allAmpReactionKeys, dC as AmpReactionModeText, bL as useDBMeta, ae as useBoolState, bP as CharacterName, bj as TextField, aY as DropdownButton, o as default_1$c, aX as MenuItem, t as CharacterContext, bS as getCharStat, cq as WeaponCardNano, G as Grid, cr as ArtifactCardNano, dD as useEquippedInTeam, dE as EquipBuildModal, dF as TeammateEquippedAlert, cI as charKeyToLocCharKey, Q as Chip, cs as WeaponCardNanoObj, X as ImgIcon, ct as artifactAsset, bJ as ArtifactSetName, _ as SlotIcon, cu as StatWithUnit, cv as artDisplayValue, dG as Masonry, dH as MenuList, dI as NodeFieldDisplayText, dJ as objPathValue, aw as Stack$3, C as CardActionArea, cD as default_1$d, cp as Tooltip$1, b0 as Avatar, dK as AdditiveReactionModeText, dL as isCharMelee, dM as default_1$e, dN as default_1$f, bH as InputAdornment, dO as allMultiOptHitModeKeys, dP as infusionVals, dQ as allInputPremodKeys, dR as allowedAmpReactions, dS as allowedAdditiveReactions, dT as initCustomTarget, dU as arrayMove, dV as deepClone, dW as InfoTooltip, dX as default_1$h, aI as default_1$i, dY as validateCustomMultiTarget, dZ as initCustomMultiTarget, d_ as UIData, cy as default_1$k, d$ as allEleDmgKeys, e0 as allEleResKeys, g as getCharEle, c3 as ListItem, aS as ColorText, c2 as NodeFieldDisplay, c1 as FieldDisplayList, p as default_1$l, e1 as mapFormulas, e2 as dynRead, E as objKeyMap, J as allArtifactSlotKeys, e3 as constantFold, aT as objMap, e4 as allOperations, e5 as optimize, e6 as setReadNodeKeys, c7 as input, e7 as getMainStatValue, e8 as artMaxLevel, e9 as mergeData, ea as precompute, eb as getSubstatValue, ec as artSubstatRollData, k as getBuildTcArtifactData, ed as getTeamDataCalc, b1 as default_1$m, b2 as default_1$n, cA as useOptConfig, ee as setKeysByRarities, b6 as bulkCatTotal, bE as allArtifactSetKeys, az as iconInlineProps, ef as default_1$o, eg as default_1$p, eh as Replay, ei as handleArtSetExclusion, ej as CheckBoxOutlineBlank, ek as CheckBox, bK as getArtSetStat, bI as artifactDefIcon, ay as default_1$r, el as InfoTooltipInline, ai as Translate, em as allArtifactSetExclusionKeys, en as SetInclusionButton, eo as LinearProgress, ep as timeStringMs, x as getDefaultExportFromCjs, eq as commonjsGlobal$1, R as React, er as reactDomExports, es as commonjsRequire, et as ArtifactSetBadges, eu as WeaponCardPico, ev as ArtifactCardPico, ew as valueString, B as BootstrapTooltip, ex as ClickAwayListener, cJ as GraphContext, co as Download, ey as ReadOnlyTextArea, ez as Slider, eA as initialArtifactFilterOption, aC as useMediaQueryUp, aE as artifactFilterConfigs, aH as useInfScroll, ao as ArtifactFilterDisplay, au as ArtifactCard, eB as ExcludeIcon, cC as OptimizationIcon, aF as filterFunction, Z as FlowerIcon, eC as HpIcon, eD as PlumeIcon, eE as AtkIcon, bf as handleMultiSelect, eF as allElementWithPhyKeys, eG as StatColoredWithUnit, eH as artSlotMainKeys, m as CharacterCardHeader, n as CharacterCardHeaderContent, s as CharacterCardEquipmentRow, cG as CharacterCardStats, a$ as SillyContext, F as allElementKeys, H as allWeaponTypeKeys, cR as allCharacterRarityKeys, cP as characterFilterConfigs, b8 as WeaponToggle, cL as ElementToggle, cM as CharacterRarityToggle, cN as CharacterCard, bO as CharIconSide, e as default_1$s, eI as useTeamData, eJ as ArtifactLevelSlider, eK as BuildDisplayItem, eL as getTeamData, eM as uiDataForTeam, eN as maxBuildsToShowList, aA as range$3, eO as HitModeToggle, eP as ReactionToggle, eQ as OptimizationTargetContext, bM as getCharSheet, eR as CheckIcon, eS as UnCheckIcon, cF as LevelSelect, cH as CharacterConstellationName, eT as dataSetEffects, eU as StatDisplayComponent, bN as maxConstellationCount, eV as ConditionalWrapper, eW as artifactLevelVariant, eX as NumberInputLazy, eY as getMainStatDisplayValue, eZ as ArtifactSetTooltip, e_ as ArtifactSetAutocomplete, e$ as substatTypeKeys, f0 as ArtifactRarityDropdown, f1 as minTotalStatKeys, f2 as ListItemIcon, f3 as ListItemText, f4 as ArtifactStatWithUnit, f5 as toDecimal$1, f6 as ascensionMaxLevel, cj as CodeBlock, bo as WeaponSelectionModal, f7 as RefinementDropdown, f8 as initialBuildStatus, f9 as isDev, fa as BuildAlert$1, fb as getBuildTcWeaponData, fc as toPercent, fd as getRollsRemaining, fe as cartesian, ff as linspace, fg as Stack$4, aK as ArtifactEditor, ch as Route, ci as Navigate, cg as Routes, cX as characterAsset, a0 as LoadoutIcon, ce as Tab, fh as default_1$u, cf as Tabs, A as useNavigate, u as useTeam, $ as TeamIcon, ab as default_1$v, fi as resonanceSheets, i as useCharacter, fj as defLoadoutExportSetting, l as useCharData, fk as CustomMultiTargetIcon, fl as toggleInArr, fm as Checkbox, a1 as BuildIcon, fn as EnemyExpandCard, cS as CharacterSelectionModal, fo as useParams, cd as useMatch, cV as useTitle, cm as charKeyToLocGenderedCharKey, fp as useTeamDataNoContext, fq as FormulaDataWrapper } from "./index-B8aczfSH.js";
import { c as colorToRgbaString, h as hexToColor, u as useTeamChar } from "./useTeamChar-BvbCmyyu.js";
import { B as BuildCard, u as useBuild, E as EquippedGrid, a as useBuildTc, T as TextFieldLazy, d as default_1$g, L as LoadoutInfoAlert, h as EquippedBuildInfoAlert, b as BuildInfoAlert, c as TCBuildInfoAlert, C as CharacterCoverArea, g as TalentDropdown, f as CharacterCompactConstSelector, i as CharacterCompactTalent, j as default_1$t, e as TeamInfoAlert } from "./LoadoutInfoAlert-CVI2bUVf.js";
import { A as AdResponsive, P as PropTypes, C as CharacterCardPico } from "./CharacterCardPico-CjDQB8PL.js";
import { d as default_1$j } from "./Upload-DM5I2lC5.js";
import { L as Link } from "./Link-BpROEXu0.js";
import { d as default_1$q } from "./Settings-ctf56yjV.js";
import { A as AddArtInfo } from "./AddArtInfo-CpFskg2y.js";
import { O as OptimizationTargetDisplay$1, T as TeamDelModal } from "./TeamDelModal-uSLv0Wq8.js";
class FIFO {
  constructor() {
    this.head = [];
    this.tail = [];
  }
  get length() {
    return this.head.length + this.tail.length;
  }
  push(t2) {
    this.tail.push(t2);
  }
  pop() {
    if (!this.head.length && this.tail.length)
      [this.head, this.tail] = [this.tail.reverse(), this.head];
    return this.head.pop();
  }
}
const AccordionContext = /* @__PURE__ */ reactExports.createContext({});
const AccordionContext$1 = AccordionContext;
function getAccordionUtilityClass(slot) {
  return generateUtilityClass("MuiAccordion", slot);
}
const accordionClasses = generateUtilityClasses("MuiAccordion", ["root", "rounded", "expanded", "disabled", "gutters", "region"]);
const accordionClasses$1 = accordionClasses;
const _excluded$q = ["children", "className", "defaultExpanded", "disabled", "disableGutters", "expanded", "onChange", "square", "slots", "slotProps", "TransitionComponent", "TransitionProps"];
const useThemeProps$2 = createUseThemeProps();
const useUtilityClasses$a = (ownerState) => {
  const {
    classes,
    square: square2,
    expanded,
    disabled,
    disableGutters
  } = ownerState;
  const slots = {
    root: ["root", !square2 && "rounded", expanded && "expanded", disabled && "disabled", !disableGutters && "gutters"],
    region: ["region"]
  };
  return composeClasses(slots, getAccordionUtilityClass, classes);
};
const AccordionRoot = styled(Paper, {
  name: "MuiAccordion",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [{
      [`& .${accordionClasses$1.region}`]: styles.region
    }, styles.root, !ownerState.square && styles.rounded, !ownerState.disableGutters && styles.gutters];
  }
})(({
  theme
}) => {
  const transition = {
    duration: theme.transitions.duration.shortest
  };
  return {
    position: "relative",
    transition: theme.transitions.create(["margin"], transition),
    overflowAnchor: "none",
    // Keep the same scrolling position
    "&::before": {
      position: "absolute",
      left: 0,
      top: -1,
      right: 0,
      height: 1,
      content: '""',
      opacity: 1,
      backgroundColor: (theme.vars || theme).palette.divider,
      transition: theme.transitions.create(["opacity", "background-color"], transition)
    },
    "&:first-of-type": {
      "&::before": {
        display: "none"
      }
    },
    [`&.${accordionClasses$1.expanded}`]: {
      "&::before": {
        opacity: 0
      },
      "&:first-of-type": {
        marginTop: 0
      },
      "&:last-of-type": {
        marginBottom: 0
      },
      "& + &": {
        "&::before": {
          display: "none"
        }
      }
    },
    [`&.${accordionClasses$1.disabled}`]: {
      backgroundColor: (theme.vars || theme).palette.action.disabledBackground
    }
  };
}, ({
  theme
}) => ({
  variants: [{
    props: (props) => !props.square,
    style: {
      borderRadius: 0,
      "&:first-of-type": {
        borderTopLeftRadius: (theme.vars || theme).shape.borderRadius,
        borderTopRightRadius: (theme.vars || theme).shape.borderRadius
      },
      "&:last-of-type": {
        borderBottomLeftRadius: (theme.vars || theme).shape.borderRadius,
        borderBottomRightRadius: (theme.vars || theme).shape.borderRadius,
        // Fix a rendering issue on Edge
        "@supports (-ms-ime-align: auto)": {
          borderBottomLeftRadius: 0,
          borderBottomRightRadius: 0
        }
      }
    }
  }, {
    props: (props) => !props.disableGutters,
    style: {
      [`&.${accordionClasses$1.expanded}`]: {
        margin: "16px 0"
      }
    }
  }]
}));
const Accordion = /* @__PURE__ */ reactExports.forwardRef(function Accordion2(inProps, ref) {
  const props = useThemeProps$2({
    props: inProps,
    name: "MuiAccordion"
  });
  const {
    children: childrenProp,
    className,
    defaultExpanded = false,
    disabled = false,
    disableGutters = false,
    expanded: expandedProp,
    onChange,
    square: square2 = false,
    slots = {},
    slotProps = {},
    TransitionComponent: TransitionComponentProp,
    TransitionProps: TransitionPropsProp
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$q);
  const [expanded, setExpandedState] = useControlled({
    controlled: expandedProp,
    default: defaultExpanded,
    name: "Accordion",
    state: "expanded"
  });
  const handleChange = reactExports.useCallback((event) => {
    setExpandedState(!expanded);
    if (onChange) {
      onChange(event, !expanded);
    }
  }, [expanded, onChange, setExpandedState]);
  const [summary, ...children] = reactExports.Children.toArray(childrenProp);
  const contextValue = reactExports.useMemo(() => ({
    expanded,
    disabled,
    disableGutters,
    toggle: handleChange
  }), [expanded, disabled, disableGutters, handleChange]);
  const ownerState = _extends$p({}, props, {
    square: square2,
    disabled,
    disableGutters,
    expanded
  });
  const classes = useUtilityClasses$a(ownerState);
  const backwardCompatibleSlots = _extends$p({
    transition: TransitionComponentProp
  }, slots);
  const backwardCompatibleSlotProps = _extends$p({
    transition: TransitionPropsProp
  }, slotProps);
  const [TransitionSlot, transitionProps] = useSlot("transition", {
    elementType: Collapse,
    externalForwardedProps: {
      slots: backwardCompatibleSlots,
      slotProps: backwardCompatibleSlotProps
    },
    ownerState
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(AccordionRoot, _extends$p({
    className: clsx(classes.root, className),
    ref,
    ownerState,
    square: square2
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AccordionContext$1.Provider, {
      value: contextValue,
      children: summary
    }), /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionSlot, _extends$p({
      in: expanded,
      timeout: "auto"
    }, transitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", {
        "aria-labelledby": summary.props.id,
        id: summary.props["aria-controls"],
        role: "region",
        className: classes.region,
        children
      })
    }))]
  }));
});
const Accordion$1 = Accordion;
function getAccordionDetailsUtilityClass(slot) {
  return generateUtilityClass("MuiAccordionDetails", slot);
}
generateUtilityClasses("MuiAccordionDetails", ["root"]);
const _excluded$p = ["className"];
const useThemeProps$1 = createUseThemeProps();
const useUtilityClasses$9 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getAccordionDetailsUtilityClass, classes);
};
const AccordionDetailsRoot = styled("div", {
  name: "MuiAccordionDetails",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => ({
  padding: theme.spacing(1, 2, 2)
}));
const AccordionDetails = /* @__PURE__ */ reactExports.forwardRef(function AccordionDetails2(inProps, ref) {
  const props = useThemeProps$1({
    props: inProps,
    name: "MuiAccordionDetails"
  });
  const {
    className
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$p);
  const ownerState = props;
  const classes = useUtilityClasses$9(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionDetailsRoot, _extends$p({
    className: clsx(classes.root, className),
    ref,
    ownerState
  }, other));
});
const AccordionDetails$1 = AccordionDetails;
function getAccordionSummaryUtilityClass(slot) {
  return generateUtilityClass("MuiAccordionSummary", slot);
}
const accordionSummaryClasses = generateUtilityClasses("MuiAccordionSummary", ["root", "expanded", "focusVisible", "disabled", "gutters", "contentGutters", "content", "expandIconWrapper"]);
const accordionSummaryClasses$1 = accordionSummaryClasses;
const _excluded$o = ["children", "className", "expandIcon", "focusVisibleClassName", "onClick"];
const useThemeProps = createUseThemeProps();
const useUtilityClasses$8 = (ownerState) => {
  const {
    classes,
    expanded,
    disabled,
    disableGutters
  } = ownerState;
  const slots = {
    root: ["root", expanded && "expanded", disabled && "disabled", !disableGutters && "gutters"],
    focusVisible: ["focusVisible"],
    content: ["content", expanded && "expanded", !disableGutters && "contentGutters"],
    expandIconWrapper: ["expandIconWrapper", expanded && "expanded"]
  };
  return composeClasses(slots, getAccordionSummaryUtilityClass, classes);
};
const AccordionSummaryRoot = styled(ButtonBase, {
  name: "MuiAccordionSummary",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})(({
  theme
}) => {
  const transition = {
    duration: theme.transitions.duration.shortest
  };
  return {
    display: "flex",
    minHeight: 48,
    padding: theme.spacing(0, 2),
    transition: theme.transitions.create(["min-height", "background-color"], transition),
    [`&.${accordionSummaryClasses$1.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette.action.focus
    },
    [`&.${accordionSummaryClasses$1.disabled}`]: {
      opacity: (theme.vars || theme).palette.action.disabledOpacity
    },
    [`&:hover:not(.${accordionSummaryClasses$1.disabled})`]: {
      cursor: "pointer"
    },
    variants: [{
      props: (props) => !props.disableGutters,
      style: {
        [`&.${accordionSummaryClasses$1.expanded}`]: {
          minHeight: 64
        }
      }
    }]
  };
});
const AccordionSummaryContent = styled("div", {
  name: "MuiAccordionSummary",
  slot: "Content",
  overridesResolver: (props, styles) => styles.content
})(({
  theme
}) => ({
  display: "flex",
  flexGrow: 1,
  margin: "12px 0",
  variants: [{
    props: (props) => !props.disableGutters,
    style: {
      transition: theme.transitions.create(["margin"], {
        duration: theme.transitions.duration.shortest
      }),
      [`&.${accordionSummaryClasses$1.expanded}`]: {
        margin: "20px 0"
      }
    }
  }]
}));
const AccordionSummaryExpandIconWrapper = styled("div", {
  name: "MuiAccordionSummary",
  slot: "ExpandIconWrapper",
  overridesResolver: (props, styles) => styles.expandIconWrapper
})(({
  theme
}) => ({
  display: "flex",
  color: (theme.vars || theme).palette.action.active,
  transform: "rotate(0deg)",
  transition: theme.transitions.create("transform", {
    duration: theme.transitions.duration.shortest
  }),
  [`&.${accordionSummaryClasses$1.expanded}`]: {
    transform: "rotate(180deg)"
  }
}));
const AccordionSummary = /* @__PURE__ */ reactExports.forwardRef(function AccordionSummary2(inProps, ref) {
  const props = useThemeProps({
    props: inProps,
    name: "MuiAccordionSummary"
  });
  const {
    children,
    className,
    expandIcon,
    focusVisibleClassName,
    onClick
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$o);
  const {
    disabled = false,
    disableGutters,
    expanded,
    toggle
  } = reactExports.useContext(AccordionContext$1);
  const handleChange = (event) => {
    if (toggle) {
      toggle(event);
    }
    if (onClick) {
      onClick(event);
    }
  };
  const ownerState = _extends$p({}, props, {
    expanded,
    disabled,
    disableGutters
  });
  const classes = useUtilityClasses$8(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(AccordionSummaryRoot, _extends$p({
    focusRipple: false,
    disableRipple: true,
    disabled,
    component: "div",
    "aria-expanded": expanded,
    className: clsx(classes.root, className),
    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
    onClick: handleChange,
    ref,
    ownerState
  }, other, {
    children: [/* @__PURE__ */ jsxRuntimeExports.jsx(AccordionSummaryContent, {
      className: classes.content,
      ownerState,
      children
    }), expandIcon && /* @__PURE__ */ jsxRuntimeExports.jsx(AccordionSummaryExpandIconWrapper, {
      className: classes.expandIconWrapper,
      ownerState,
      children: expandIcon
    })]
  }));
});
const AccordionSummary$1 = AccordionSummary;
function getDialogUtilityClass(slot) {
  return generateUtilityClass("MuiDialog", slot);
}
const dialogClasses = generateUtilityClasses("MuiDialog", ["root", "scrollPaper", "scrollBody", "container", "paper", "paperScrollPaper", "paperScrollBody", "paperWidthFalse", "paperWidthXs", "paperWidthSm", "paperWidthMd", "paperWidthLg", "paperWidthXl", "paperFullWidth", "paperFullScreen"]);
const dialogClasses$1 = dialogClasses;
const DialogContext = /* @__PURE__ */ reactExports.createContext({});
const DialogContext$1 = DialogContext;
const _excluded$n = ["aria-describedby", "aria-labelledby", "BackdropComponent", "BackdropProps", "children", "className", "disableEscapeKeyDown", "fullScreen", "fullWidth", "maxWidth", "onBackdropClick", "onClick", "onClose", "open", "PaperComponent", "PaperProps", "scroll", "TransitionComponent", "transitionDuration", "TransitionProps"];
const DialogBackdrop = styled(Backdrop, {
  name: "MuiDialog",
  slot: "Backdrop",
  overrides: (props, styles) => styles.backdrop
})({
  // Improve scrollable dialog support.
  zIndex: -1
});
const useUtilityClasses$7 = (ownerState) => {
  const {
    classes,
    scroll,
    maxWidth,
    fullWidth,
    fullScreen
  } = ownerState;
  const slots = {
    root: ["root"],
    container: ["container", `scroll${capitalize(scroll)}`],
    paper: ["paper", `paperScroll${capitalize(scroll)}`, `paperWidth${capitalize(String(maxWidth))}`, fullWidth && "paperFullWidth", fullScreen && "paperFullScreen"]
  };
  return composeClasses(slots, getDialogUtilityClass, classes);
};
const DialogRoot = styled(Modal, {
  name: "MuiDialog",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  "@media print": {
    // Use !important to override the Modal inline-style.
    position: "absolute !important"
  }
});
const DialogContainer = styled("div", {
  name: "MuiDialog",
  slot: "Container",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.container, styles[`scroll${capitalize(ownerState.scroll)}`]];
  }
})(({
  ownerState
}) => _extends$p({
  height: "100%",
  "@media print": {
    height: "auto"
  },
  // We disable the focus ring for mouse, touch and keyboard users.
  outline: 0
}, ownerState.scroll === "paper" && {
  display: "flex",
  justifyContent: "center",
  alignItems: "center"
}, ownerState.scroll === "body" && {
  overflowY: "auto",
  overflowX: "hidden",
  textAlign: "center",
  "&::after": {
    content: '""',
    display: "inline-block",
    verticalAlign: "middle",
    height: "100%",
    width: "0"
  }
}));
const DialogPaper = styled(Paper, {
  name: "MuiDialog",
  slot: "Paper",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.paper, styles[`scrollPaper${capitalize(ownerState.scroll)}`], styles[`paperWidth${capitalize(String(ownerState.maxWidth))}`], ownerState.fullWidth && styles.paperFullWidth, ownerState.fullScreen && styles.paperFullScreen];
  }
})(({
  theme,
  ownerState
}) => _extends$p({
  margin: 32,
  position: "relative",
  overflowY: "auto",
  // Fix IE11 issue, to remove at some point.
  "@media print": {
    overflowY: "visible",
    boxShadow: "none"
  }
}, ownerState.scroll === "paper" && {
  display: "flex",
  flexDirection: "column",
  maxHeight: "calc(100% - 64px)"
}, ownerState.scroll === "body" && {
  display: "inline-block",
  verticalAlign: "middle",
  textAlign: "left"
  // 'initial' doesn't work on IE11
}, !ownerState.maxWidth && {
  maxWidth: "calc(100% - 64px)"
}, ownerState.maxWidth === "xs" && {
  maxWidth: theme.breakpoints.unit === "px" ? Math.max(theme.breakpoints.values.xs, 444) : `max(${theme.breakpoints.values.xs}${theme.breakpoints.unit}, 444px)`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme.breakpoints.down(Math.max(theme.breakpoints.values.xs, 444) + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.maxWidth && ownerState.maxWidth !== "xs" && {
  maxWidth: `${theme.breakpoints.values[ownerState.maxWidth]}${theme.breakpoints.unit}`,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    [theme.breakpoints.down(theme.breakpoints.values[ownerState.maxWidth] + 32 * 2)]: {
      maxWidth: "calc(100% - 64px)"
    }
  }
}, ownerState.fullWidth && {
  width: "calc(100% - 64px)"
}, ownerState.fullScreen && {
  margin: 0,
  width: "100%",
  maxWidth: "100%",
  height: "100%",
  maxHeight: "none",
  borderRadius: 0,
  [`&.${dialogClasses$1.paperScrollBody}`]: {
    margin: 0,
    maxWidth: "100%"
  }
}));
const Dialog = /* @__PURE__ */ reactExports.forwardRef(function Dialog2(inProps, ref) {
  const props = useThemeProps$3({
    props: inProps,
    name: "MuiDialog"
  });
  const theme = useTheme();
  const defaultTransitionDuration = {
    enter: theme.transitions.duration.enteringScreen,
    exit: theme.transitions.duration.leavingScreen
  };
  const {
    "aria-describedby": ariaDescribedby,
    "aria-labelledby": ariaLabelledbyProp,
    BackdropComponent,
    BackdropProps,
    children,
    className,
    disableEscapeKeyDown = false,
    fullScreen = false,
    fullWidth = false,
    maxWidth = "sm",
    onBackdropClick,
    onClick,
    onClose,
    open,
    PaperComponent = Paper,
    PaperProps = {},
    scroll = "paper",
    TransitionComponent = Fade,
    transitionDuration = defaultTransitionDuration,
    TransitionProps
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$n);
  const ownerState = _extends$p({}, props, {
    disableEscapeKeyDown,
    fullScreen,
    fullWidth,
    maxWidth,
    scroll
  });
  const classes = useUtilityClasses$7(ownerState);
  const backdropClick = reactExports.useRef();
  const handleMouseDown = (event) => {
    backdropClick.current = event.target === event.currentTarget;
  };
  const handleBackdropClick = (event) => {
    if (onClick) {
      onClick(event);
    }
    if (!backdropClick.current) {
      return;
    }
    backdropClick.current = null;
    if (onBackdropClick) {
      onBackdropClick(event);
    }
    if (onClose) {
      onClose(event, "backdropClick");
    }
  };
  const ariaLabelledby = useId(ariaLabelledbyProp);
  const dialogContextValue = reactExports.useMemo(() => {
    return {
      titleId: ariaLabelledby
    };
  }, [ariaLabelledby]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogRoot, _extends$p({
    className: clsx(classes.root, className),
    closeAfterTransition: true,
    components: {
      Backdrop: DialogBackdrop
    },
    componentsProps: {
      backdrop: _extends$p({
        transitionDuration,
        as: BackdropComponent
      }, BackdropProps)
    },
    disableEscapeKeyDown,
    onClose,
    open,
    ref,
    onClick: handleBackdropClick,
    ownerState
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(TransitionComponent, _extends$p({
      appear: true,
      in: open,
      timeout: transitionDuration,
      role: "presentation"
    }, TransitionProps, {
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContainer, {
        className: clsx(classes.container),
        onMouseDown: handleMouseDown,
        ownerState,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogPaper, _extends$p({
          as: PaperComponent,
          elevation: 24,
          role: "dialog",
          "aria-describedby": ariaDescribedby,
          "aria-labelledby": ariaLabelledby
        }, PaperProps, {
          className: clsx(classes.paper, PaperProps.className),
          ownerState,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContext$1.Provider, {
            value: dialogContextValue,
            children
          })
        }))
      })
    }))
  }));
});
const Dialog$1 = Dialog;
function getDialogActionsUtilityClass(slot) {
  return generateUtilityClass("MuiDialogActions", slot);
}
generateUtilityClasses("MuiDialogActions", ["root", "spacing"]);
const _excluded$m = ["className", "disableSpacing"];
const useUtilityClasses$6 = (ownerState) => {
  const {
    classes,
    disableSpacing
  } = ownerState;
  const slots = {
    root: ["root", !disableSpacing && "spacing"]
  };
  return composeClasses(slots, getDialogActionsUtilityClass, classes);
};
const DialogActionsRoot = styled("div", {
  name: "MuiDialogActions",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, !ownerState.disableSpacing && styles.spacing];
  }
})(({
  ownerState
}) => _extends$p({
  display: "flex",
  alignItems: "center",
  padding: 8,
  justifyContent: "flex-end",
  flex: "0 0 auto"
}, !ownerState.disableSpacing && {
  "& > :not(style) ~ :not(style)": {
    marginLeft: 8
  }
}));
const DialogActions = /* @__PURE__ */ reactExports.forwardRef(function DialogActions2(inProps, ref) {
  const props = useThemeProps$3({
    props: inProps,
    name: "MuiDialogActions"
  });
  const {
    className,
    disableSpacing = false
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$m);
  const ownerState = _extends$p({}, props, {
    disableSpacing
  });
  const classes = useUtilityClasses$6(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogActionsRoot, _extends$p({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const DialogActions$1 = DialogActions;
function getDialogContentUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContent", slot);
}
generateUtilityClasses("MuiDialogContent", ["root", "dividers"]);
function getDialogTitleUtilityClass(slot) {
  return generateUtilityClass("MuiDialogTitle", slot);
}
const dialogTitleClasses = generateUtilityClasses("MuiDialogTitle", ["root"]);
const dialogTitleClasses$1 = dialogTitleClasses;
const _excluded$l = ["className", "dividers"];
const useUtilityClasses$5 = (ownerState) => {
  const {
    classes,
    dividers
  } = ownerState;
  const slots = {
    root: ["root", dividers && "dividers"]
  };
  return composeClasses(slots, getDialogContentUtilityClass, classes);
};
const DialogContentRoot = styled("div", {
  name: "MuiDialogContent",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, ownerState.dividers && styles.dividers];
  }
})(({
  theme,
  ownerState
}) => _extends$p({
  flex: "1 1 auto",
  // Add iOS momentum scrolling for iOS < 13.0
  WebkitOverflowScrolling: "touch",
  overflowY: "auto",
  padding: "20px 24px"
}, ownerState.dividers ? {
  padding: "16px 24px",
  borderTop: `1px solid ${(theme.vars || theme).palette.divider}`,
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`
} : {
  [`.${dialogTitleClasses$1.root} + &`]: {
    paddingTop: 0
  }
}));
const DialogContent = /* @__PURE__ */ reactExports.forwardRef(function DialogContent2(inProps, ref) {
  const props = useThemeProps$3({
    props: inProps,
    name: "MuiDialogContent"
  });
  const {
    className,
    dividers = false
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$l);
  const ownerState = _extends$p({}, props, {
    dividers
  });
  const classes = useUtilityClasses$5(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentRoot, _extends$p({
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other));
});
const DialogContent$1 = DialogContent;
function getDialogContentTextUtilityClass(slot) {
  return generateUtilityClass("MuiDialogContentText", slot);
}
generateUtilityClasses("MuiDialogContentText", ["root"]);
const _excluded$k = ["children", "className"];
const useUtilityClasses$4 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  const composedClasses = composeClasses(slots, getDialogContentTextUtilityClass, classes);
  return _extends$p({}, classes, composedClasses);
};
const DialogContentTextRoot = styled(Typography, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiDialogContentText",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({});
const DialogContentText = /* @__PURE__ */ reactExports.forwardRef(function DialogContentText2(inProps, ref) {
  const props = useThemeProps$3({
    props: inProps,
    name: "MuiDialogContentText"
  });
  const {
    className
  } = props, ownerState = _objectWithoutPropertiesLoose$g(props, _excluded$k);
  const classes = useUtilityClasses$4(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentTextRoot, _extends$p({
    component: "p",
    variant: "body1",
    color: "text.secondary",
    ref,
    ownerState,
    className: clsx(classes.root, className)
  }, props, {
    classes
  }));
});
const DialogContentText$1 = DialogContentText;
const _excluded$j = ["className", "id"];
const useUtilityClasses$3 = (ownerState) => {
  const {
    classes
  } = ownerState;
  const slots = {
    root: ["root"]
  };
  return composeClasses(slots, getDialogTitleUtilityClass, classes);
};
const DialogTitleRoot = styled(Typography, {
  name: "MuiDialogTitle",
  slot: "Root",
  overridesResolver: (props, styles) => styles.root
})({
  padding: "16px 24px",
  flex: "0 0 auto"
});
const DialogTitle = /* @__PURE__ */ reactExports.forwardRef(function DialogTitle2(inProps, ref) {
  const props = useThemeProps$3({
    props: inProps,
    name: "MuiDialogTitle"
  });
  const {
    className,
    id: idProp
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$j);
  const ownerState = props;
  const classes = useUtilityClasses$3(ownerState);
  const {
    titleId = idProp
  } = reactExports.useContext(DialogContext$1);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitleRoot, _extends$p({
    component: "h2",
    className: clsx(classes.root, className),
    ownerState,
    ref,
    variant: "h6",
    id: idProp != null ? idProp : titleId
  }, other));
});
const DialogTitle$1 = DialogTitle;
const _excluded$i = ["alignItems", "autoFocus", "component", "children", "dense", "disableGutters", "divider", "focusVisibleClassName", "selected", "className"];
const overridesResolver$1 = (props, styles) => {
  const {
    ownerState
  } = props;
  return [styles.root, ownerState.dense && styles.dense, ownerState.alignItems === "flex-start" && styles.alignItemsFlexStart, ownerState.divider && styles.divider, !ownerState.disableGutters && styles.gutters];
};
const useUtilityClasses$2 = (ownerState) => {
  const {
    alignItems,
    classes,
    dense,
    disabled,
    disableGutters,
    divider,
    selected
  } = ownerState;
  const slots = {
    root: ["root", dense && "dense", !disableGutters && "gutters", divider && "divider", disabled && "disabled", alignItems === "flex-start" && "alignItemsFlexStart", selected && "selected"]
  };
  const composedClasses = composeClasses(slots, getListItemButtonUtilityClass, classes);
  return _extends$p({}, classes, composedClasses);
};
const ListItemButtonRoot = styled(ButtonBase, {
  shouldForwardProp: (prop) => rootShouldForwardProp(prop) || prop === "classes",
  name: "MuiListItemButton",
  slot: "Root",
  overridesResolver: overridesResolver$1
})(({
  theme,
  ownerState
}) => _extends$p({
  display: "flex",
  flexGrow: 1,
  justifyContent: "flex-start",
  alignItems: "center",
  position: "relative",
  textDecoration: "none",
  minWidth: 0,
  boxSizing: "border-box",
  textAlign: "left",
  paddingTop: 8,
  paddingBottom: 8,
  transition: theme.transitions.create("background-color", {
    duration: theme.transitions.duration.shortest
  }),
  "&:hover": {
    textDecoration: "none",
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${listItemButtonClasses.selected}`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity),
    [`&.${listItemButtonClasses.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    }
  },
  [`&.${listItemButtonClasses.selected}:hover`]: {
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.primary.mainChannel} / ${theme.vars.palette.action.selectedOpacity})` : alpha_1(theme.palette.primary.main, theme.palette.action.selectedOpacity)
    }
  },
  [`&.${listItemButtonClasses.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`&.${listItemButtonClasses.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  }
}, ownerState.divider && {
  borderBottom: `1px solid ${(theme.vars || theme).palette.divider}`,
  backgroundClip: "padding-box"
}, ownerState.alignItems === "flex-start" && {
  alignItems: "flex-start"
}, !ownerState.disableGutters && {
  paddingLeft: 16,
  paddingRight: 16
}, ownerState.dense && {
  paddingTop: 4,
  paddingBottom: 4
}));
const ListItemButton = /* @__PURE__ */ reactExports.forwardRef(function ListItemButton2(inProps, ref) {
  const props = useThemeProps$3({
    props: inProps,
    name: "MuiListItemButton"
  });
  const {
    alignItems = "center",
    autoFocus = false,
    component = "div",
    children,
    dense = false,
    disableGutters = false,
    divider = false,
    focusVisibleClassName,
    selected = false,
    className
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$i);
  const context = reactExports.useContext(ListContext);
  const childContext = reactExports.useMemo(() => ({
    dense: dense || context.dense || false,
    alignItems,
    disableGutters
  }), [alignItems, context.dense, dense, disableGutters]);
  const listItemRef = reactExports.useRef(null);
  useEnhancedEffect(() => {
    if (autoFocus) {
      if (listItemRef.current) {
        listItemRef.current.focus();
      }
    }
  }, [autoFocus]);
  const ownerState = _extends$p({}, props, {
    alignItems,
    dense: childContext.dense,
    disableGutters,
    divider,
    selected
  });
  const classes = useUtilityClasses$2(ownerState);
  const handleRef = useForkRef(listItemRef, ref);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ListContext.Provider, {
    value: childContext,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ListItemButtonRoot, _extends$p({
      ref: handleRef,
      href: other.href || other.to,
      component: (other.href || other.to) && component === "div" ? "button" : component,
      focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),
      ownerState,
      className: clsx(classes.root, className)
    }, other, {
      classes,
      children
    }))
  });
});
const ListItemButton$1 = ListItemButton;
function getPaginationUtilityClass(slot) {
  return generateUtilityClass("MuiPagination", slot);
}
generateUtilityClasses("MuiPagination", ["root", "ul", "outlined", "text"]);
const _excluded$h = ["boundaryCount", "componentName", "count", "defaultPage", "disabled", "hideNextButton", "hidePrevButton", "onChange", "page", "showFirstButton", "showLastButton", "siblingCount"];
function usePagination(props = {}) {
  const {
    boundaryCount = 1,
    componentName = "usePagination",
    count = 1,
    defaultPage = 1,
    disabled = false,
    hideNextButton = false,
    hidePrevButton = false,
    onChange: handleChange,
    page: pageProp,
    showFirstButton = false,
    showLastButton = false,
    siblingCount = 1
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$h);
  const [page, setPageState] = useControlled({
    controlled: pageProp,
    default: defaultPage,
    name: componentName,
    state: "page"
  });
  const handleClick = (event, value) => {
    if (!pageProp) {
      setPageState(value);
    }
    if (handleChange) {
      handleChange(event, value);
    }
  };
  const range3 = (start, end) => {
    const length = end - start + 1;
    return Array.from({
      length
    }, (_, i) => start + i);
  };
  const startPages = range3(1, Math.min(boundaryCount, count));
  const endPages = range3(Math.max(count - boundaryCount + 1, boundaryCount + 1), count);
  const siblingsStart = Math.max(
    Math.min(
      // Natural start
      page - siblingCount,
      // Lower boundary when page is high
      count - boundaryCount - siblingCount * 2 - 1
    ),
    // Greater than startPages
    boundaryCount + 2
  );
  const siblingsEnd = Math.min(
    Math.max(
      // Natural end
      page + siblingCount,
      // Upper boundary when page is low
      boundaryCount + siblingCount * 2 + 2
    ),
    // Less than endPages
    endPages.length > 0 ? endPages[0] - 2 : count - 1
  );
  const itemList = [
    ...showFirstButton ? ["first"] : [],
    ...hidePrevButton ? [] : ["previous"],
    ...startPages,
    // Start ellipsis
    // eslint-disable-next-line no-nested-ternary
    ...siblingsStart > boundaryCount + 2 ? ["start-ellipsis"] : boundaryCount + 1 < count - boundaryCount ? [boundaryCount + 1] : [],
    // Sibling pages
    ...range3(siblingsStart, siblingsEnd),
    // End ellipsis
    // eslint-disable-next-line no-nested-ternary
    ...siblingsEnd < count - boundaryCount - 1 ? ["end-ellipsis"] : count - boundaryCount > boundaryCount ? [count - boundaryCount] : [],
    ...endPages,
    ...hideNextButton ? [] : ["next"],
    ...showLastButton ? ["last"] : []
  ];
  const buttonPage = (type) => {
    switch (type) {
      case "first":
        return 1;
      case "previous":
        return page - 1;
      case "next":
        return page + 1;
      case "last":
        return count;
      default:
        return null;
    }
  };
  const items = itemList.map((item) => {
    return typeof item === "number" ? {
      onClick: (event) => {
        handleClick(event, item);
      },
      type: "page",
      page: item,
      selected: item === page,
      disabled,
      "aria-current": item === page ? "true" : void 0
    } : {
      onClick: (event) => {
        handleClick(event, buttonPage(item));
      },
      type: item,
      page: buttonPage(item),
      selected: false,
      disabled: disabled || item.indexOf("ellipsis") === -1 && (item === "next" || item === "last" ? page >= count : page <= 1)
    };
  });
  return _extends$p({
    items
  }, other);
}
function getPaginationItemUtilityClass(slot) {
  return generateUtilityClass("MuiPaginationItem", slot);
}
const paginationItemClasses = generateUtilityClasses("MuiPaginationItem", ["root", "page", "sizeSmall", "sizeLarge", "text", "textPrimary", "textSecondary", "outlined", "outlinedPrimary", "outlinedSecondary", "rounded", "ellipsis", "firstLast", "previousNext", "focusVisible", "disabled", "selected", "icon", "colorPrimary", "colorSecondary"]);
const paginationItemClasses$1 = paginationItemClasses;
const FirstPageIconDefault = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M18.41 16.59L13.82 12l4.59-4.59L17 6l-6 6 6 6zM6 6h2v12H6z"
}), "FirstPage");
const LastPageIconDefault = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M5.59 7.41L10.18 12l-4.59 4.59L7 18l6-6-6-6zM16 6h2v12h-2z"
}), "LastPage");
const NavigateBeforeIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M15.41 7.41L14 6l-6 6 6 6 1.41-1.41L10.83 12z"
}), "NavigateBefore");
const NavigateNextIcon = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M10 6L8.59 7.41 13.17 12l-4.58 4.59L10 18l6-6z"
}), "NavigateNext");
const _excluded$g = ["className", "color", "component", "components", "disabled", "page", "selected", "shape", "size", "slots", "type", "variant"];
const overridesResolver = (props, styles) => {
  const {
    ownerState
  } = props;
  return [styles.root, styles[ownerState.variant], styles[`size${capitalize(ownerState.size)}`], ownerState.variant === "text" && styles[`text${capitalize(ownerState.color)}`], ownerState.variant === "outlined" && styles[`outlined${capitalize(ownerState.color)}`], ownerState.shape === "rounded" && styles.rounded, ownerState.type === "page" && styles.page, (ownerState.type === "start-ellipsis" || ownerState.type === "end-ellipsis") && styles.ellipsis, (ownerState.type === "previous" || ownerState.type === "next") && styles.previousNext, (ownerState.type === "first" || ownerState.type === "last") && styles.firstLast];
};
const useUtilityClasses$1 = (ownerState) => {
  const {
    classes,
    color: color2,
    disabled,
    selected,
    size,
    shape,
    type,
    variant
  } = ownerState;
  const slots = {
    root: ["root", `size${capitalize(size)}`, variant, shape, color2 !== "standard" && `color${capitalize(color2)}`, color2 !== "standard" && `${variant}${capitalize(color2)}`, disabled && "disabled", selected && "selected", {
      page: "page",
      first: "firstLast",
      last: "firstLast",
      "start-ellipsis": "ellipsis",
      "end-ellipsis": "ellipsis",
      previous: "previousNext",
      next: "previousNext"
    }[type]],
    icon: ["icon"]
  };
  return composeClasses(slots, getPaginationItemUtilityClass, classes);
};
const PaginationItemEllipsis = styled("div", {
  name: "MuiPaginationItem",
  slot: "Root",
  overridesResolver
})(({
  theme,
  ownerState
}) => _extends$p({}, theme.typography.body2, {
  borderRadius: 32 / 2,
  textAlign: "center",
  boxSizing: "border-box",
  minWidth: 32,
  padding: "0 6px",
  margin: "0 3px",
  color: (theme.vars || theme).palette.text.primary,
  height: "auto",
  [`&.${paginationItemClasses$1.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  }
}, ownerState.size === "small" && {
  minWidth: 26,
  borderRadius: 26 / 2,
  margin: "0 1px",
  padding: "0 4px"
}, ownerState.size === "large" && {
  minWidth: 40,
  borderRadius: 40 / 2,
  padding: "0 10px",
  fontSize: theme.typography.pxToRem(15)
}));
const PaginationItemPage = styled(ButtonBase, {
  name: "MuiPaginationItem",
  slot: "Root",
  overridesResolver
})(({
  theme,
  ownerState
}) => _extends$p({}, theme.typography.body2, {
  borderRadius: 32 / 2,
  textAlign: "center",
  boxSizing: "border-box",
  minWidth: 32,
  height: 32,
  padding: "0 6px",
  margin: "0 3px",
  color: (theme.vars || theme).palette.text.primary,
  [`&.${paginationItemClasses$1.focusVisible}`]: {
    backgroundColor: (theme.vars || theme).palette.action.focus
  },
  [`&.${paginationItemClasses$1.disabled}`]: {
    opacity: (theme.vars || theme).palette.action.disabledOpacity
  },
  transition: theme.transitions.create(["color", "background-color"], {
    duration: theme.transitions.duration.short
  }),
  "&:hover": {
    backgroundColor: (theme.vars || theme).palette.action.hover,
    // Reset on touch devices, it doesn't add specificity
    "@media (hover: none)": {
      backgroundColor: "transparent"
    }
  },
  [`&.${paginationItemClasses$1.selected}`]: {
    backgroundColor: (theme.vars || theme).palette.action.selected,
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.hoverOpacity}))` : alpha_1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.hoverOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette.action.selected
      }
    },
    [`&.${paginationItemClasses$1.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette.action.selectedChannel} / calc(${theme.vars.palette.action.selectedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette.action.selected, theme.palette.action.selectedOpacity + theme.palette.action.focusOpacity)
    },
    [`&.${paginationItemClasses$1.disabled}`]: {
      opacity: 1,
      color: (theme.vars || theme).palette.action.disabled,
      backgroundColor: (theme.vars || theme).palette.action.selected
    }
  }
}, ownerState.size === "small" && {
  minWidth: 26,
  height: 26,
  borderRadius: 26 / 2,
  margin: "0 1px",
  padding: "0 4px"
}, ownerState.size === "large" && {
  minWidth: 40,
  height: 40,
  borderRadius: 40 / 2,
  padding: "0 10px",
  fontSize: theme.typography.pxToRem(15)
}, ownerState.shape === "rounded" && {
  borderRadius: (theme.vars || theme).shape.borderRadius
}), ({
  theme,
  ownerState
}) => _extends$p({}, ownerState.variant === "text" && {
  [`&.${paginationItemClasses$1.selected}`]: _extends$p({}, ownerState.color !== "standard" && {
    color: (theme.vars || theme).palette[ownerState.color].contrastText,
    backgroundColor: (theme.vars || theme).palette[ownerState.color].main,
    "&:hover": {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark,
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: (theme.vars || theme).palette[ownerState.color].main
      }
    },
    [`&.${paginationItemClasses$1.focusVisible}`]: {
      backgroundColor: (theme.vars || theme).palette[ownerState.color].dark
    }
  }, {
    [`&.${paginationItemClasses$1.disabled}`]: {
      color: (theme.vars || theme).palette.action.disabled
    }
  })
}, ownerState.variant === "outlined" && {
  border: theme.vars ? `1px solid rgba(${theme.vars.palette.common.onBackgroundChannel} / 0.23)` : `1px solid ${theme.palette.mode === "light" ? "rgba(0, 0, 0, 0.23)" : "rgba(255, 255, 255, 0.23)"}`,
  [`&.${paginationItemClasses$1.selected}`]: _extends$p({}, ownerState.color !== "standard" && {
    color: (theme.vars || theme).palette[ownerState.color].main,
    border: `1px solid ${theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / 0.5)` : alpha_1(theme.palette[ownerState.color].main, 0.5)}`,
    backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / ${theme.vars.palette.action.activatedOpacity})` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.activatedOpacity),
    "&:hover": {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / calc(${theme.vars.palette.action.activatedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.activatedOpacity + theme.palette.action.focusOpacity),
      // Reset on touch devices, it doesn't add specificity
      "@media (hover: none)": {
        backgroundColor: "transparent"
      }
    },
    [`&.${paginationItemClasses$1.focusVisible}`]: {
      backgroundColor: theme.vars ? `rgba(${theme.vars.palette[ownerState.color].mainChannel} / calc(${theme.vars.palette.action.activatedOpacity} + ${theme.vars.palette.action.focusOpacity}))` : alpha_1(theme.palette[ownerState.color].main, theme.palette.action.activatedOpacity + theme.palette.action.focusOpacity)
    }
  }, {
    [`&.${paginationItemClasses$1.disabled}`]: {
      borderColor: (theme.vars || theme).palette.action.disabledBackground,
      color: (theme.vars || theme).palette.action.disabled
    }
  })
}));
const PaginationItemPageIcon = styled("div", {
  name: "MuiPaginationItem",
  slot: "Icon",
  overridesResolver: (props, styles) => styles.icon
})(({
  theme,
  ownerState
}) => _extends$p({
  fontSize: theme.typography.pxToRem(20),
  margin: "0 -8px"
}, ownerState.size === "small" && {
  fontSize: theme.typography.pxToRem(18)
}, ownerState.size === "large" && {
  fontSize: theme.typography.pxToRem(22)
}));
const PaginationItem = /* @__PURE__ */ reactExports.forwardRef(function PaginationItem2(inProps, ref) {
  const props = useThemeProps$3({
    props: inProps,
    name: "MuiPaginationItem"
  });
  const {
    className,
    color: color2 = "standard",
    component,
    components = {},
    disabled = false,
    page,
    selected = false,
    shape = "circular",
    size = "medium",
    slots = {},
    type = "page",
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$g);
  const ownerState = _extends$p({}, props, {
    color: color2,
    disabled,
    selected,
    shape,
    size,
    type,
    variant
  });
  const isRtl = useRtl();
  const classes = useUtilityClasses$1(ownerState);
  const normalizedIcons = isRtl ? {
    previous: slots.next || components.next || NavigateNextIcon,
    next: slots.previous || components.previous || NavigateBeforeIcon,
    last: slots.first || components.first || FirstPageIconDefault,
    first: slots.last || components.last || LastPageIconDefault
  } : {
    previous: slots.previous || components.previous || NavigateBeforeIcon,
    next: slots.next || components.next || NavigateNextIcon,
    first: slots.first || components.first || FirstPageIconDefault,
    last: slots.last || components.last || LastPageIconDefault
  };
  const Icon = normalizedIcons[type];
  return type === "start-ellipsis" || type === "end-ellipsis" ? /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationItemEllipsis, {
    ref,
    ownerState,
    className: clsx(classes.root, className),
    children: "…"
  }) : /* @__PURE__ */ jsxRuntimeExports.jsxs(PaginationItemPage, _extends$p({
    ref,
    ownerState,
    component,
    disabled,
    className: clsx(classes.root, className)
  }, other, {
    children: [type === "page" && page, Icon ? /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationItemPageIcon, {
      as: Icon,
      ownerState,
      className: classes.icon
    }) : null]
  }));
});
const PaginationItem$1 = PaginationItem;
const _excluded$f = ["boundaryCount", "className", "color", "count", "defaultPage", "disabled", "getItemAriaLabel", "hideNextButton", "hidePrevButton", "onChange", "page", "renderItem", "shape", "showFirstButton", "showLastButton", "siblingCount", "size", "variant"];
const useUtilityClasses = (ownerState) => {
  const {
    classes,
    variant
  } = ownerState;
  const slots = {
    root: ["root", variant],
    ul: ["ul"]
  };
  return composeClasses(slots, getPaginationUtilityClass, classes);
};
const PaginationRoot = styled("nav", {
  name: "MuiPagination",
  slot: "Root",
  overridesResolver: (props, styles) => {
    const {
      ownerState
    } = props;
    return [styles.root, styles[ownerState.variant]];
  }
})({});
const PaginationUl = styled("ul", {
  name: "MuiPagination",
  slot: "Ul",
  overridesResolver: (props, styles) => styles.ul
})({
  display: "flex",
  flexWrap: "wrap",
  alignItems: "center",
  padding: 0,
  margin: 0,
  listStyle: "none"
});
function defaultGetAriaLabel(type, page, selected) {
  if (type === "page") {
    return `${selected ? "" : "Go to "}page ${page}`;
  }
  return `Go to ${type} page`;
}
const Pagination = /* @__PURE__ */ reactExports.forwardRef(function Pagination2(inProps, ref) {
  const props = useThemeProps$3({
    props: inProps,
    name: "MuiPagination"
  });
  const {
    boundaryCount = 1,
    className,
    color: color2 = "standard",
    count = 1,
    defaultPage = 1,
    disabled = false,
    getItemAriaLabel = defaultGetAriaLabel,
    hideNextButton = false,
    hidePrevButton = false,
    renderItem = (item) => /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationItem$1, _extends$p({}, item)),
    shape = "circular",
    showFirstButton = false,
    showLastButton = false,
    siblingCount = 1,
    size = "medium",
    variant = "text"
  } = props, other = _objectWithoutPropertiesLoose$g(props, _excluded$f);
  const {
    items
  } = usePagination(_extends$p({}, props, {
    componentName: "Pagination"
  }));
  const ownerState = _extends$p({}, props, {
    boundaryCount,
    color: color2,
    count,
    defaultPage,
    disabled,
    getItemAriaLabel,
    hideNextButton,
    hidePrevButton,
    renderItem,
    shape,
    showFirstButton,
    showLastButton,
    siblingCount,
    size,
    variant
  });
  const classes = useUtilityClasses(ownerState);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationRoot, _extends$p({
    "aria-label": "pagination navigation",
    className: clsx(classes.root, className),
    ownerState,
    ref
  }, other, {
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(PaginationUl, {
      className: classes.ul,
      ownerState,
      children: items.map((item, index) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", {
        children: renderItem(_extends$p({}, item, {
          color: color2,
          "aria-label": getItemAriaLabel(item.type, item.page, item.selected),
          shape,
          size,
          variant
        }))
      }, index))
    })
  }));
});
const Pagination$1 = Pagination;
function useConstObj(objInput) {
  const [obj, setobj] = reactExports.useState(objInput);
  const objStr = JSON.stringify(obj);
  reactExports.useEffect(() => {
    if (JSON.stringify(objInput) !== objStr)
      setobj(objInput);
  }, [objInput, objStr]);
  return obj;
}
function useIsMount() {
  const isMountRef = reactExports.useRef(true);
  reactExports.useEffect(() => {
    isMountRef.current = false;
  }, []);
  return isMountRef.current;
}
function useBuildArtifacts(loadoutDatum) {
  const database = useDatabase();
  const [dbDirty, setDbDirty] = useForceUpdate();
  const arts = reactExports.useMemo(
    () => dbDirty && database.teams.getLoadoutArtifacts(loadoutDatum),
    [dbDirty, database.teams, loadoutDatum]
  );
  reactExports.useEffect(() => {
    const unfollows = Object.values(arts).map(
      (art) => (art == null ? void 0 : art.id) ? database.arts.follow(
        art.id,
        (_k, r2) => (r2 === "update" || r2 === "remove") && setDbDirty()
      ) : () => {
      }
    );
    const unfollowBuild = database.builds.follow(
      loadoutDatum.buildId,
      (_, r2) => r2 === "update" && setDbDirty()
    );
    return () => {
      unfollows.forEach((unfollow) => unfollow());
      unfollowBuild();
    };
  }, [arts, database, loadoutDatum, setDbDirty]);
  return arts;
}
function useTeammateArtifactIds() {
  const {
    teamCharId,
    team: { loadoutData }
  } = reactExports.useContext(TeamCharacterContext);
  const database = useDatabase();
  return reactExports.useMemo(
    () => Array.from(
      new Set(
        loadoutData.filter(notEmpty).filter((loadoutDatum) => loadoutDatum.teamCharId !== teamCharId).map(
          (loadoutDatum) => database.teams.getLoadoutArtifacts(loadoutDatum)
        ).flatMap((arts) => Object.values(arts)).filter(notEmpty).map(({ id }) => id)
      )
    ),
    [database, loadoutData, teamCharId]
  );
}
function zero_deriv(f2, binding, x2) {
  let ret = true;
  forEachNodes(
    [f2],
    (_) => {
    },
    (f22) => {
      const { operation } = f22;
      switch (operation) {
        case "read":
          if (f22.type !== "number" || f22.accu && f22.accu !== "add")
            throw new Error(`Unsupported [${operation}] node in zero_deriv`);
          if (binding(f22) === x2)
            ret = false;
      }
    }
  );
  return ret;
}
function ddx(f2, binding, x2) {
  const { operation } = f2;
  switch (operation) {
    case "read": {
      if (f2.type !== "number" || f2.accu && f2.accu !== "add")
        throw new Error(`Unsupported [${operation}] node in d/dx`);
      const name = binding(f2);
      if (name === x2)
        return constant$4(1);
      return constant$4(0);
    }
    case "const":
      return constant$4(0);
    case "res":
      if (!zero_deriv(f2, binding, x2))
        throw new Error(`[${operation}] node takes only constant inputs. ${f2}`);
      return constant$4(0);
    case "add":
      return sum(...f2.operands.map((fi) => ddx(fi, binding, x2)));
    case "mul": {
      const ops = f2.operands.map(
        (fi, i) => prod(ddx(fi, binding, x2), ...f2.operands.filter((_, ix) => ix !== i))
      );
      return sum(...ops);
    }
    case "sum_frac": {
      const a2 = f2.operands[0];
      const da = ddx(a2, binding, x2);
      const b2 = sum(...f2.operands.slice(1));
      const db = ddx(b2, binding, x2);
      const denom = prod(sum(...f2.operands), sum(...f2.operands));
      const numerator = sum(prod(b2, da), prod(-1, a2, db));
      return frac(numerator, sum(prod(-1, numerator), denom));
    }
    case "min":
    case "max": {
      let out = ddx(f2.operands[0], binding, x2);
      for (let i = 1; i < f2.operands.length; i++) {
        const op_i = f2.operands[i];
        if (operation === "min") {
          const cmp_i = min$2(...f2.operands.slice(0, i));
          out = threshold$1(op_i, cmp_i, out, ddx(op_i, binding, x2));
        } else if (operation === "max") {
          const cmp_i = max$2(...f2.operands.slice(0, i));
          out = threshold$1(op_i, cmp_i, ddx(op_i, binding, x2), out);
        }
      }
      return out;
    }
    case "threshold": {
      const [value, thr, pass, fail] = f2.operands;
      if (!zero_deriv(value, binding, x2) || !zero_deriv(thr, binding, x2))
        throw new Error(
          `[${operation}] node must branch on constant inputs. ${f2}`
        );
      return threshold$1(value, thr, ddx(pass, binding, x2), ddx(fail, binding, x2));
    }
    default:
      assertUnreachable(operation);
  }
}
function NoArtWarning() {
  const { t: t2 } = useTranslation("page_character_optimize");
  return /* @__PURE__ */ jsx(Alert, { severity: "warning", variant: "filled", children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "noArtis", children: [
    "Oops! It looks like you haven't added any artifacts to GO yet! You should go to the",
    /* @__PURE__ */ jsx(Link, { component: Link$1, to: "/artifacts", children: "Artifacts" }),
    "page and add some!"
  ] }) });
}
function StatEditorList({
  statKeys,
  statFilters,
  setStatFilters,
  disabled = false,
  wrapperFunc: wrapperFunc2 = (ele) => ele,
  label
}) {
  const { t: tk } = useTranslation("statKey_gen");
  const statOptions = reactExports.useMemo(
    () => statKeys.map(
      (statKey) => ({
        key: statKey,
        grouper: inputPremodKeyToGroupMap[statKey],
        label: [...allMainStatKeys, ...allSubstatKeys].includes(statKey) ? `${tk(statKey)}${statPercent(
          statKey
        )}` : KeyMap.getStr(statKey) ?? "ERROR",
        color: KeyMap.getVariant(statKey)
      })
    ).sort(
      (a2, b2) => allGroupKeys.indexOf(a2.grouper) - allGroupKeys.indexOf(b2.grouper)
    ),
    [tk, statKeys]
  );
  const getOptionDiabled = reactExports.useCallback(
    (option) => Object.keys(statFilters).includes(option.key),
    [statFilters]
  );
  const setKey = reactExports.useCallback(
    (newk, oldk) => {
      if (oldk)
        setStatFilters(
          Object.fromEntries(
            Object.entries(statFilters).map(([k2, v2]) => [
              k2 === oldk ? newk : k2,
              v2
            ])
          )
        );
      else {
        const statFilters_ = { ...statFilters };
        statFilters_[newk] = 0;
        setStatFilters({ ...statFilters_ });
      }
    },
    [statFilters, setStatFilters]
  );
  const setFilter = reactExports.useCallback(
    (sKey, min2) => {
      const statFilters_ = { ...statFilters };
      statFilters_[sKey] = min2;
      setStatFilters({ ...statFilters_ });
    },
    [statFilters, setStatFilters]
  );
  const delKey = reactExports.useCallback(
    (statKey) => {
      const statFilters_ = { ...statFilters };
      delete statFilters_[statKey];
      setStatFilters({ ...statFilters_ });
    },
    [statFilters, setStatFilters]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    Object.entries(statFilters).map(
      ([statKey, min2]) => wrapperFunc2(
        /* @__PURE__ */ jsx(
          StatFilterItem,
          {
            statKey,
            statKeyOptions: statOptions,
            disabled,
            value: min2,
            setValue: setFilter,
            setKey,
            delKey,
            getOptionDisabled: getOptionDiabled
          },
          statKey
        ),
        statKey
      )
    ),
    wrapperFunc2(
      /* @__PURE__ */ jsx(
        StatFilterItem,
        {
          statKey: null,
          statKeyOptions: statOptions,
          setValue: setFilter,
          setKey,
          delKey,
          disabled,
          getOptionDisabled: getOptionDiabled,
          label
        },
        Object.entries(statFilters).length
      )
    )
  ] });
}
function StatFilterItem({
  statKey,
  statKeyOptions = [],
  value = 0,
  delKey,
  setKey,
  setValue,
  disabled = false,
  getOptionDisabled,
  label
}) {
  const theme = useTheme();
  const { t: t2 } = useTranslation("ui");
  const isThreeCol = useMediaQuery(theme.breakpoints.up("lg"));
  const isOneCol = useMediaQuery(theme.breakpoints.down("md"));
  const isFloat = statKey ? getUnitStr(statKey) === "%" : false;
  const onValueChange = reactExports.useCallback(
    (value2) => statKey && setValue(statKey, value2 ?? 0),
    [setValue, statKey]
  );
  const onKeyChange = reactExports.useCallback(
    (newKey) => {
      if (newKey) {
        setKey(newKey, statKey);
      } else if (statKey) {
        delKey(statKey);
      }
    },
    [statKey, setKey, delKey]
  );
  const onDeleteKey = reactExports.useCallback(
    () => statKey && delKey(statKey),
    [delKey, statKey]
  );
  const buttonStyle = { p: 1, flexBasis: 30, flexGrow: 0, flexShrink: 0 };
  return /* @__PURE__ */ jsxs(ButtonGroup, { sx: { width: "100%" }, children: [
    /* @__PURE__ */ jsx(
      GeneralAutocomplete,
      {
        size: "small",
        options: statKeyOptions,
        onChange: onKeyChange,
        valueKey: statKey,
        getOptionDisabled,
        groupBy: (option) => inputPremodKeyToGroupMap[option.key],
        renderGroup: (params) => /* @__PURE__ */ jsxs(
          List,
          {
            component: Box,
            sx: { paddingTop: 0, marginTop: 0 },
            children: [
              /* @__PURE__ */ jsx(ListSubheader, { sx: { top: "-1em" }, children: /* @__PURE__ */ jsx("strong", { children: t2(`statGroupKey.${params.group}`) }) }, `${params.group}Header`),
              params.children
            ]
          },
          params.key
        ),
        toImg: (sKey) => /* @__PURE__ */ jsx(
          StatIcon,
          {
            statKey: sKey,
            iconProps: { color: KeyMap.getVariant(sKey) }
          }
        ),
        ListboxProps: {
          style: {
            display: "grid",
            gridTemplateColumns: isOneCol ? "100%" : isThreeCol ? "33% 33% 33%" : "50% 50%"
          }
        },
        PopperComponent: (props) => /* @__PURE__ */ jsx(Popper, { ...props, style: { width: "60%" } }),
        sx: { flexGrow: 1, flexBasis: 150 },
        textFieldProps: {
          sx: { "& .MuiInputBase-root": { borderRadius: "4px 0 0 4px" } }
        },
        label
      }
    ),
    /* @__PURE__ */ jsx(
      CustomNumberInputButtonGroupWrapper,
      {
        sx: { flexBasis: 30, flexGrow: 1, borderRadius: "0 4px 4px 0" },
        children: /* @__PURE__ */ jsx(
          CustomNumberInput,
          {
            disabled: !statKey || disabled,
            float: isFloat,
            value,
            placeholder: "Stat Value",
            onChange: onValueChange,
            sx: { px: 1 },
            inputProps: { sx: { textAlign: "right" } },
            endAdornment: statKey ? getUnitStr(statKey) : void 0
          }
        )
      }
    ),
    !!statKey && /* @__PURE__ */ jsx(
      Button,
      {
        sx: buttonStyle,
        color: "error",
        onClick: onDeleteKey,
        disabled,
        children: /* @__PURE__ */ jsx(default_1$9, { fontSize: "small" })
      }
    )
  ] });
}
const allGroupKeys = [
  "basic_stats",
  "elem_dmg_bonus",
  "enemy_debuffs",
  "self_res",
  "reaction_dmg_bonus",
  "reaction_crit",
  "elem_dmgInc",
  "talent_dmgInc",
  "elem_crit",
  "talent_dmg_bonus",
  "talent_crit",
  "talent_level_boost",
  "base_stat_mod",
  "stamina_buffs",
  "misc"
];
const inputPremodKeyToGroupMap = {
  hp: "basic_stats",
  hp_: "basic_stats",
  atk: "basic_stats",
  atk_: "basic_stats",
  def: "basic_stats",
  def_: "basic_stats",
  eleMas: "basic_stats",
  enerRech_: "basic_stats",
  critRate_: "basic_stats",
  critDMG_: "basic_stats",
  electro_dmg_: "elem_dmg_bonus",
  hydro_dmg_: "elem_dmg_bonus",
  pyro_dmg_: "elem_dmg_bonus",
  cryo_dmg_: "elem_dmg_bonus",
  physical_dmg_: "elem_dmg_bonus",
  anemo_dmg_: "elem_dmg_bonus",
  geo_dmg_: "elem_dmg_bonus",
  dendro_dmg_: "elem_dmg_bonus",
  heal_: "basic_stats",
  all_dmg_: "elem_dmg_bonus",
  overloaded_dmg_: "reaction_dmg_bonus",
  shattered_dmg_: "reaction_dmg_bonus",
  electrocharged_dmg_: "reaction_dmg_bonus",
  superconduct_dmg_: "reaction_dmg_bonus",
  swirl_dmg_: "reaction_dmg_bonus",
  burning_dmg_: "reaction_dmg_bonus",
  bloom_dmg_: "reaction_dmg_bonus",
  burgeon_dmg_: "reaction_dmg_bonus",
  hyperbloom_dmg_: "reaction_dmg_bonus",
  vaporize_dmg_: "reaction_dmg_bonus",
  melt_dmg_: "reaction_dmg_bonus",
  spread_dmg_: "reaction_dmg_bonus",
  aggravate_dmg_: "reaction_dmg_bonus",
  normal_dmg_: "talent_dmg_bonus",
  charged_dmg_: "talent_dmg_bonus",
  plunging_dmg_: "talent_dmg_bonus",
  plunging_collision_dmg_: "talent_dmg_bonus",
  plunging_impact_dmg_: "talent_dmg_bonus",
  skill_dmg_: "talent_dmg_bonus",
  burst_dmg_: "talent_dmg_bonus",
  elemental_dmg_: "talent_dmg_bonus",
  normalEle_dmg_: "talent_dmg_bonus",
  physical_dmgInc: "elem_dmgInc",
  physical_critDMG_: "elem_crit",
  physical_res_: "self_res",
  anemo_dmgInc: "elem_dmgInc",
  anemo_critDMG_: "elem_crit",
  anemo_res_: "self_res",
  geo_dmgInc: "elem_dmgInc",
  geo_critDMG_: "elem_crit",
  geo_res_: "self_res",
  electro_dmgInc: "elem_dmgInc",
  electro_critDMG_: "elem_crit",
  electro_res_: "self_res",
  hydro_dmgInc: "elem_dmgInc",
  hydro_critDMG_: "elem_crit",
  hydro_res_: "self_res",
  pyro_dmgInc: "elem_dmgInc",
  pyro_critDMG_: "elem_crit",
  pyro_res_: "self_res",
  cryo_dmgInc: "elem_dmgInc",
  cryo_critDMG_: "elem_crit",
  cryo_res_: "self_res",
  dendro_dmgInc: "elem_dmgInc",
  dendro_critDMG_: "elem_crit",
  dendro_res_: "self_res",
  autoBoost: "talent_level_boost",
  skillBoost: "talent_level_boost",
  burstBoost: "talent_level_boost",
  normal_dmgInc: "talent_dmgInc",
  normal_critDMG_: "talent_crit",
  normal_critRate_: "talent_crit",
  charged_dmgInc: "talent_dmgInc",
  charged_critDMG_: "talent_crit",
  charged_critRate_: "talent_crit",
  plunging_dmgInc: "talent_dmgInc",
  plunging_critDMG_: "talent_crit",
  plunging_critRate_: "talent_crit",
  plunging_collision_dmgInc: "talent_dmgInc",
  plunging_collision_critDMG_: "talent_crit",
  plunging_collision_critRate_: "talent_crit",
  plunging_impact_dmgInc: "talent_dmgInc",
  plunging_impact_critDMG_: "talent_crit",
  plunging_impact_critRate_: "talent_crit",
  skill_dmgInc: "talent_dmgInc",
  skill_critDMG_: "talent_crit",
  skill_critRate_: "talent_crit",
  burst_dmgInc: "talent_dmgInc",
  burst_critDMG_: "talent_crit",
  burst_critRate_: "talent_crit",
  elemental_dmgInc: "talent_dmgInc",
  elemental_critDMG_: "talent_crit",
  elemental_critRate_: "talent_crit",
  burning_critRate_: "reaction_crit",
  burning_critDMG_: "reaction_crit",
  bloom_critRate_: "reaction_crit",
  bloom_critDMG_: "reaction_crit",
  burgeon_critRate_: "reaction_crit",
  burgeon_critDMG_: "reaction_crit",
  hyperbloom_critRate_: "reaction_crit",
  hyperbloom_critDMG_: "reaction_crit",
  all_dmgInc: "elem_dmgInc",
  physical_enemyRes_: "enemy_debuffs",
  anemo_enemyRes_: "enemy_debuffs",
  geo_enemyRes_: "enemy_debuffs",
  electro_enemyRes_: "enemy_debuffs",
  hydro_enemyRes_: "enemy_debuffs",
  pyro_enemyRes_: "enemy_debuffs",
  cryo_enemyRes_: "enemy_debuffs",
  dendro_enemyRes_: "enemy_debuffs",
  enemyDefRed_: "enemy_debuffs",
  enemyDefIgn_: "misc",
  stamina: "stamina_buffs",
  staminaDec_: "stamina_buffs",
  staminaSprintDec_: "stamina_buffs",
  staminaGlidingDec_: "stamina_buffs",
  staminaChargedDec_: "stamina_buffs",
  incHeal_: "misc",
  shield_: "misc",
  cdRed_: "misc",
  moveSPD_: "misc",
  atkSPD_: "misc",
  weakspotDMG_: "misc",
  dmgRed_: "misc",
  healInc: "misc",
  base_atk: "base_stat_mod",
  base_hp: "base_stat_mod",
  base_def: "base_stat_mod"
};
const Close = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Close");
const DeleteForever = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M6 19c0 1.1.9 2 2 2h8c1.1 0 2-.9 2-2V7H6v12zm2.46-7.12 1.41-1.41L12 12.59l2.12-2.12 1.41 1.41L13.41 14l2.12 2.12-1.41 1.41L12 15.41l-2.12 2.12-1.41-1.41L10.59 14l-2.13-2.12zM15.5 4l-1-1h-5l-1 1H5v2h14V4z"
}), "DeleteForever");
const Science = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "M19.8 18.4 14 10.67V6.5l1.35-1.69c.26-.33.03-.81-.39-.81H9.04c-.42 0-.65.48-.39.81L10 6.5v4.17L4.2 18.4c-.49.66-.02 1.6.8 1.6h14c.82 0 1.29-.94.8-1.6z"
}), "Science");
const TrendingUp = createSvgIcon(/* @__PURE__ */ jsxRuntimeExports.jsx("path", {
  d: "m16 6 2.29 2.29-4.88 4.88-4-4L2 16.59 3.41 18l6-6 4 4 6.3-6.29L22 12V6z"
}), "TrendingUp");
function useGlobalError() {
  const [, setError] = reactExports.useState();
  return reactExports.useCallback((e3) => {
    setError(() => {
      throw e3;
    });
  }, []);
}
const LS_KEY = "num_opt_workers";
function useNumWorkers() {
  const nativeThreads = (navigator == null ? void 0 : navigator.hardwareConcurrency) || 8;
  const [numWorkers, setNumWorkers] = reactExports.useState(() => {
    const lsItem = localStorage.getItem(LS_KEY);
    if (!lsItem)
      return nativeThreads;
    const numWorkers2 = parseInt(lsItem);
    if (!Number.isInteger(numWorkers2))
      return nativeThreads;
    return numWorkers2;
  });
  const clampedNumWOrkers = clamp(numWorkers, 1, nativeThreads);
  reactExports.useEffect(() => {
    localStorage.setItem(LS_KEY, clampedNumWOrkers.toFixed());
  }, [clampedNumWOrkers]);
  return [
    clampedNumWOrkers,
    nativeThreads,
    reactExports.useCallback(
      (num) => {
        setNumWorkers(clamp(Math.round(num), 1, nativeThreads));
      },
      [nativeThreads]
    )
  ];
}
function WeaponFullCardObj({
  weapon,
  bgt = "normal"
}) {
  const weaponSheet = (weapon == null ? void 0 : weapon.key) && getWeaponSheet(weapon.key);
  const UIData2 = reactExports.useMemo(
    () => weaponSheet && weapon && computeUIData([
      weaponSheet.data,
      dataObjForWeapon(weapon)
    ]),
    [weaponSheet, weapon]
  );
  if (!weapon || !weaponSheet || !UIData2)
    return null;
  return /* @__PURE__ */ jsx(CardThemed, { bgt, children: /* @__PURE__ */ jsxs(Box, { display: "flex", children: [
    /* @__PURE__ */ jsx(
      Box,
      {
        flexShrink: 1,
        maxWidth: "35%",
        display: "flex",
        flexDirection: "column",
        alignContent: "flex-end",
        className: `grad-${getWeaponStat(weapon.key).rarity}star`,
        children: /* @__PURE__ */ jsx(
          Box,
          {
            component: NextImage ? NextImage : "img",
            src: weaponAsset(weapon.key, weapon.ascension >= 2),
            width: "100%",
            height: "auto",
            sx: { mt: "auto" }
          }
        )
      }
    ),
    /* @__PURE__ */ jsxs(Box, { flexGrow: 1, sx: { p: 1 }, children: [
      /* @__PURE__ */ jsx(Typography, { variant: "body2", gutterBottom: true, children: /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsx(WeaponName, { weaponKey: weapon.key }) }) }),
      /* @__PURE__ */ jsxs(
        Typography,
        {
          variant: "subtitle1",
          sx: { display: "flex", gap: 1 },
          gutterBottom: true,
          children: [
            /* @__PURE__ */ jsxs(SqBadge, { color: "primary", children: [
              "Lv. ",
              getLevelString(weapon.level, weapon.ascension)
            ] }),
            weaponHasRefinement(weapon.key) && /* @__PURE__ */ jsxs(SqBadge, { color: "info", children: [
              "R",
              weapon.refinement
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsxs(Typography, { variant: "subtitle1", sx: { display: "flex", gap: 1 }, children: [
        /* @__PURE__ */ jsx(WeaponStat, { node: UIData2.get(uiInput.weapon.main) }),
        /* @__PURE__ */ jsx(WeaponStat, { node: UIData2.get(uiInput.weapon.sub) })
      ] })
    ] })
  ] }) });
}
function WeaponStat({ node }) {
  const { icon } = resolveInfo(node.info);
  return Number.isNaN(node.value) ? null : /* @__PURE__ */ jsxs(SqBadge, { color: "secondary", children: [
    icon,
    " ",
    getCalcDisplay(node).valueString
  ] });
}
function SetEffectDisplay({
  setKey,
  setNumKey,
  hideHeader = false,
  conditionalsOnly = false,
  disabled = false
}) {
  var _a;
  const sheet = getArtSheet(setKey);
  const document2 = conditionalsOnly ? (_a = sheet.setEffectDocument(setNumKey)) == null ? void 0 : _a.filter((section) => "states" in section) : sheet.setEffectDocument(setNumKey);
  return /* @__PURE__ */ jsx(Box, { display: "flex", flexDirection: "column", children: document2 ? /* @__PURE__ */ jsx(
    DocumentDisplay,
    {
      sections: document2,
      hideHeader,
      disabled
    }
  ) : null });
}
const BuildTcContext = reactExports.createContext({});
var BorderColor = {};
var _interopRequireDefault$9 = interopRequireDefaultExports;
Object.defineProperty(BorderColor, "__esModule", {
  value: true
});
var default_1$8 = BorderColor.default = void 0;
var _createSvgIcon$8 = _interopRequireDefault$9(requireCreateSvgIcon());
var _jsxRuntime$8 = jsxRuntimeExports;
var _default$8 = (0, _createSvgIcon$8.default)(/* @__PURE__ */ (0, _jsxRuntime$8.jsx)("path", {
  d: "M22 24H2v-4h20v4zM13.06 5.19l3.75 3.75L7.75 18H4v-3.75l9.06-9.06zm4.82 2.68-3.75-3.75 1.83-1.83c.39-.39 1.02-.39 1.41 0l2.34 2.34c.39.39.39 1.02 0 1.41l-1.83 1.83z"
}), "BorderColor");
default_1$8 = BorderColor.default = _default$8;
var FactCheck = {};
var _interopRequireDefault$8 = interopRequireDefaultExports;
Object.defineProperty(FactCheck, "__esModule", {
  value: true
});
var default_1$7 = FactCheck.default = void 0;
var _createSvgIcon$7 = _interopRequireDefault$8(requireCreateSvgIcon());
var _jsxRuntime$7 = jsxRuntimeExports;
var _default$7 = (0, _createSvgIcon$7.default)(/* @__PURE__ */ (0, _jsxRuntime$7.jsx)("path", {
  fillRule: "evenodd",
  d: "M20 3H4c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zM10 17H5v-2h5v2zm0-4H5v-2h5v2zm0-4H5V7h5v2zm4.82 6L12 12.16l1.41-1.41 1.41 1.42L17.99 9l1.42 1.42L14.82 15z"
}), "FactCheck");
default_1$7 = FactCheck.default = _default$7;
var Upgrade = {};
var _interopRequireDefault$7 = interopRequireDefaultExports;
Object.defineProperty(Upgrade, "__esModule", {
  value: true
});
var default_1$6 = Upgrade.default = void 0;
var _createSvgIcon$6 = _interopRequireDefault$7(requireCreateSvgIcon());
var _jsxRuntime$6 = jsxRuntimeExports;
var _default$6 = (0, _createSvgIcon$6.default)(/* @__PURE__ */ (0, _jsxRuntime$6.jsx)("path", {
  d: "M16 18v2H8v-2h8zM11 7.99V16h2V7.99h3L12 4 8 7.99h3z"
}), "Upgrade");
default_1$6 = Upgrade.default = _default$6;
function FormulaModal() {
  const { modalOpen } = reactExports.useContext(FormulaDataContext);
  const { setFormulaData } = reactExports.useContext(FormulaDataContext);
  const onCloseHandler = reactExports.useCallback(
    () => setFormulaData == null ? void 0 : setFormulaData(void 0, void 0),
    [setFormulaData]
  );
  return /* @__PURE__ */ jsx(ModalWrapper, { open: !!modalOpen, onClose: onCloseHandler, children: /* @__PURE__ */ jsxs(CardThemed, { children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: "Formulas & Calculations",
        action: /* @__PURE__ */ jsx(IconButton, { onClick: onCloseHandler, children: /* @__PURE__ */ jsx(default_1$a, {}) })
      }
    ),
    /* @__PURE__ */ jsx(CardContent, { sx: { pt: 0 }, children: /* @__PURE__ */ jsx(CalculationDisplay, {}) })
  ] }) });
}
function CalculationDisplay() {
  const { data } = reactExports.useContext(DataContext);
  const { data: contextData } = reactExports.useContext(FormulaDataContext);
  const sections = getDisplaySections(contextData ?? data);
  return /* @__PURE__ */ jsx(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 1e3 }),
      children: /* @__PURE__ */ jsx(Box, { sx: { mr: -1, mb: -1 }, children: sections.map(([key, Nodes]) => /* @__PURE__ */ jsx(FormulaCalc, { displayNs: Nodes, sectionKey: key }, key)) })
    }
  );
}
function FormulaCalc({
  sectionKey,
  displayNs
}) {
  const { data } = reactExports.useContext(DataContext);
  const database = useDatabase();
  const { data: contextData } = reactExports.useContext(FormulaDataContext);
  const header = reactExports.useMemo(
    () => getDisplayHeader(contextData ?? data, sectionKey, database),
    [database, contextData, data, sectionKey]
  );
  if (!header)
    return null;
  if (Object.entries(displayNs).every(([_, node]) => node.isEmpty))
    return null;
  const { title, icon, action } = header;
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", sx: { mb: 1 }, children: [
    /* @__PURE__ */ jsx(
      CardHeaderCustom,
      {
        avatar: icon,
        title,
        action: action && /* @__PURE__ */ jsx(SqBadge, { children: action })
      }
    ),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(CardContent, { children: Object.entries(displayNs).map(
      ([key, node]) => !node.isEmpty && /* @__PURE__ */ jsx(FormulaAccordian, { node }, key)
    ) })
  ] });
}
function FormulaAccordian({ node }) {
  const { node: contextNode } = reactExports.useContext(FormulaDataContext);
  const [expanded, setExpanded] = reactExports.useState(false);
  const handleChange = reactExports.useCallback(
    (e3, isExpanded) => setExpanded(isExpanded),
    []
  );
  const scrollRef = reactExports.useRef();
  reactExports.useEffect(() => {
    if (node === contextNode)
      setTimeout(
        () => {
          var _a, _b;
          return (_b = (_a = scrollRef == null ? void 0 : scrollRef.current) == null ? void 0 : _a.scrollIntoView) == null ? void 0 : _b.call(_a, { behavior: "smooth" });
        },
        300
      );
  }, [scrollRef, node, contextNode]);
  const { variant, subVariant } = resolveInfo(node.info);
  const calcDisplay = getCalcDisplay(node);
  return /* @__PURE__ */ jsxs(
    Accordion$1,
    {
      sx: { bgcolor: "contentNormal.main" },
      expanded: node === contextNode || expanded,
      onChange: handleChange,
      ref: scrollRef,
      children: [
        /* @__PURE__ */ jsxs(AccordionSummary$1, { expandIcon: /* @__PURE__ */ jsx(default_1$b, {}), children: [
          /* @__PURE__ */ jsxs(Typography, { children: [
            calcDisplay.name,
            /* @__PURE__ */ jsx("strong", { children: calcDisplay.valueString })
          ] }),
          allAmpReactionKeys.includes(variant) && /* @__PURE__ */ jsx(Box, { sx: { display: "inline-block", ml: "auto", mr: 2 }, children: /* @__PURE__ */ jsx(
            AmpReactionModeText,
            {
              reaction: variant,
              trigger: subVariant
            }
          ) })
        ] }),
        /* @__PURE__ */ jsxs(AccordionDetails$1, { children: [
          calcDisplay.assignment,
          calcDisplay.formulas.map((subform, i) => /* @__PURE__ */ jsx(Typography, { component: "div", children: subform }, i))
        ] })
      ]
    }
  );
}
var Calculate = {};
var _interopRequireDefault$6 = interopRequireDefaultExports;
Object.defineProperty(Calculate, "__esModule", {
  value: true
});
var default_1$5 = Calculate.default = void 0;
var _createSvgIcon$5 = _interopRequireDefault$6(requireCreateSvgIcon());
var _jsxRuntime$5 = jsxRuntimeExports;
var _default$5 = (0, _createSvgIcon$5.default)(/* @__PURE__ */ (0, _jsxRuntime$5.jsx)("path", {
  d: "M19 3H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2V5c0-1.1-.9-2-2-2zm-5.97 4.06L14.09 6l1.41 1.41L16.91 6l1.06 1.06-1.41 1.41 1.41 1.41-1.06 1.06-1.41-1.4-1.41 1.41-1.06-1.06 1.41-1.41-1.41-1.42zm-6.78.66h5v1.5h-5v-1.5zM11.5 16h-2v2H8v-2H6v-1.5h2v-2h1.5v2h2V16zm6.5 1.25h-5v-1.5h5v1.5zm0-2.5h-5v-1.5h5v1.5z"
}), "Calculate");
default_1$5 = Calculate.default = _default$5;
function LoadoutDropdown({
  teamCharId,
  onChangeTeamCharId,
  dropdownBtnProps = {},
  label = false
}) {
  const database = useDatabase();
  const { key: characterKey, name } = database.teamChars.get(teamCharId);
  const { gender } = useDBMeta();
  const teamCharIds = database.teamChars.keys.filter(
    (teamCharId2) => database.teamChars.get(teamCharId2).key === characterKey
  );
  const [show, onShow, onHide] = useBoolState();
  const [newName, setNewName] = reactExports.useState("");
  const [newDesc, setNewDesc] = reactExports.useState("");
  const newLoadout = () => {
    const teamCharId2 = database.teamChars.new(characterKey, {
      name: newName,
      description: newDesc
    });
    if (teamCharId2)
      onChangeTeamCharId(teamCharId2);
    onHide();
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(ModalWrapper, { open: show, onClose: onHide, children: /* @__PURE__ */ jsxs(CardThemed, { children: [
      /* @__PURE__ */ jsx(
        CardHeader,
        {
          title: /* @__PURE__ */ jsxs(Fragment, { children: [
            "Create a new Loadout For",
            " ",
            /* @__PURE__ */ jsx(CharacterName, { characterKey, gender })
          ] })
        }
      ),
      /* @__PURE__ */ jsx(Divider, {}),
      /* @__PURE__ */ jsxs(
        CardContent,
        {
          sx: { display: "flex", flexDirection: "column", gap: 2 },
          children: [
            /* @__PURE__ */ jsx(
              TextField,
              {
                fullWidth: true,
                label: "New Loadout Name",
                placeholder: "New Loadout Name",
                value: newName,
                onChange: (e3) => setNewName(e3.target.value)
              }
            ),
            /* @__PURE__ */ jsx(
              TextField,
              {
                fullWidth: true,
                label: "New Loadout Description",
                value: newDesc,
                onChange: (e3) => setNewDesc(e3.target.value),
                multiline: true,
                minRows: 2
              }
            ),
            /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 2 }, children: [
              /* @__PURE__ */ jsx(Button, { color: "error", fullWidth: true, onClick: onHide, children: "Cancel" }),
              /* @__PURE__ */ jsx(
                Button,
                {
                  color: "success",
                  fullWidth: true,
                  onClick: newLoadout,
                  disabled: !newName,
                  children: "Confirm"
                }
              )
            ] })
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsxs(
      DropdownButton,
      {
        startIcon: /* @__PURE__ */ jsx(default_1$c, {}),
        title: /* @__PURE__ */ jsx(
          Box,
          {
            sx: {
              display: "flex",
              gap: 1,
              flexWrap: "wrap",
              justifyContent: "center"
            },
            children: label ? /* @__PURE__ */ jsxs("span", { children: [
              "Loadout: ",
              /* @__PURE__ */ jsx("strong", { children: name })
            ] }) : /* @__PURE__ */ jsx("span", { children: name })
          }
        ),
        ...dropdownBtnProps,
        children: [
          /* @__PURE__ */ jsx(MenuItem, { onClick: () => onShow(), children: "Create a new Loadout" }),
          teamCharIds.map((tcId) => {
            const { name: name2, buildIds, buildTcIds, customMultiTargets } = database.teamChars.get(tcId);
            return /* @__PURE__ */ jsxs(
              MenuItem,
              {
                disabled: tcId === teamCharId,
                onClick: () => onChangeTeamCharId(tcId),
                sx: { display: "flex", gap: 1 },
                children: [
                  /* @__PURE__ */ jsx("span", { children: name2 }),
                  /* @__PURE__ */ jsxs(
                    SqBadge,
                    {
                      color: buildIds.length ? "primary" : "secondary",
                      sx: { marginLeft: "auto" },
                      children: [
                        buildIds.length,
                        " Builds"
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsxs(SqBadge, { color: buildTcIds.length ? "primary" : "secondary", children: [
                    buildTcIds.length,
                    " TC Builds"
                  ] }),
                  /* @__PURE__ */ jsxs(
                    SqBadge,
                    {
                      color: customMultiTargets.length ? "success" : "secondary",
                      children: [
                        customMultiTargets.length,
                        " Multi-Opt"
                      ]
                    }
                  )
                ]
              },
              tcId
            );
          })
        ]
      }
    )
  ] });
}
function BuildEquipped({ active = false }) {
  const { teamId, teamCharId } = reactExports.useContext(TeamCharacterContext);
  const {
    character: { key: characterKey, equippedArtifacts, equippedWeapon }
  } = reactExports.useContext(CharacterContext);
  const database = useDatabase();
  const onActive = () => database.teams.setLoadoutDatum(teamId, teamCharId, {
    buildType: "equipped"
  });
  const onDupe = () => database.teamChars.newBuild(teamCharId, {
    name: "Duplicate of Equipped",
    artifactIds: equippedArtifacts,
    weaponId: equippedWeapon
  });
  const weaponTypeKey = getCharStat(characterKey).weaponType;
  const copyToTc = () => {
    const newBuildTcId = database.teamChars.newBuildTcFromBuild(
      teamCharId,
      weaponTypeKey,
      database.weapons.get(equippedWeapon),
      Object.values(equippedArtifacts).map((id) => database.arts.get(id))
    );
    if (!newBuildTcId)
      return;
    database.buildTcs.set(newBuildTcId, {
      name: `Equipped Build - Copied`,
      description: "Copied from Equipped Build"
    });
  };
  return /* @__PURE__ */ jsx(
    BuildCard,
    {
      name: "Equipped Build",
      active,
      onActive,
      onCopyToTc: copyToTc,
      onDupe,
      children: /* @__PURE__ */ jsx(BuildEquip, { weaponId: equippedWeapon, artifactIds: equippedArtifacts })
    }
  );
}
function BuildEquip({
  weaponId,
  artifactIds
}) {
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const weaponTypeKey = getCharStat(characterKey).weaponType;
  return /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, columns: { xs: 2, sm: 2, md: 2, lg: 3, xl: 3 }, children: [
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(CardThemed, { sx: { height: "100%", maxHeight: "8em" }, children: /* @__PURE__ */ jsx(WeaponCardNano, { weaponId, weaponTypeKey }) }) }),
    Object.entries(artifactIds).map(([slotKey, id]) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(CardThemed, { sx: { height: "100%", maxHeight: "8em" }, children: /* @__PURE__ */ jsx(ArtifactCardNano, { artifactId: id, slotKey }) }) }, id || slotKey))
  ] });
}
function BuildReal({
  buildId,
  active = false
}) {
  const [open, onOpen, onClose] = useBoolState();
  const {
    teamId,
    teamCharId,
    teamChar: { key: characterKey }
  } = reactExports.useContext(TeamCharacterContext);
  const {
    character: { equippedWeapon, equippedArtifacts }
  } = reactExports.useContext(CharacterContext);
  const database = useDatabase();
  const { name, description, weaponId, artifactIds } = useBuild(buildId);
  const onActive = () => database.teams.setLoadoutDatum(teamId, teamCharId, {
    buildType: "real",
    buildId
  });
  const onEquip = () => {
    if (!weaponId)
      return;
    const char = database.chars.get(characterKey);
    Object.entries(artifactIds).forEach(([slotKey, id]) => {
      if (id)
        database.arts.set(id, { location: charKeyToLocCharKey(characterKey) });
      else {
        const oldAid = char.equippedArtifacts[slotKey];
        if (oldAid && database.arts.get(oldAid))
          database.arts.set(oldAid, { location: "" });
      }
    });
    if (weaponId)
      database.weapons.set(weaponId, {
        location: charKeyToLocCharKey(characterKey)
      });
  };
  const onRemove = () => {
    database.builds.remove(buildId);
  };
  const weaponTypeKey = getCharStat(characterKey).weaponType;
  const copyToTc = () => {
    const newBuildTcId = database.teamChars.newBuildTcFromBuild(
      teamCharId,
      weaponTypeKey,
      database.weapons.get(weaponId),
      Object.values(artifactIds).map((id) => database.arts.get(id))
    );
    if (!newBuildTcId)
      return;
    database.buildTcs.set(newBuildTcId, {
      name: `${name} - Copied`,
      description
    });
  };
  const onDupe = () => database.teamChars.newBuild(teamCharId, {
    name: `Duplicate of ${name}`,
    artifactIds,
    weaponId
  });
  const { weaponUsedInTeamCharKey, artUsedInTeamCharKeys } = useEquippedInTeam(
    weaponId,
    artifactIds
  );
  const [show, onShow, onHide] = useBoolState();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(ModalWrapper, { open, onClose, children: /* @__PURE__ */ jsx(BuildEditor, { buildId, onClose }) }),
    /* @__PURE__ */ jsx(
      EquipBuildModal,
      {
        currentName: "Equipped",
        currentWeaponId: equippedWeapon,
        currentArtifactIds: equippedArtifacts,
        newWeaponId: weaponId,
        newArtifactIds: artifactIds,
        show,
        onEquip,
        onHide
      }
    ),
    /* @__PURE__ */ jsx(
      BuildCard,
      {
        name,
        description,
        active,
        onEdit: onOpen,
        onActive,
        onCopyToTc: copyToTc,
        onDupe,
        onEquip: weaponId ? onShow : void 0,
        onRemove,
        children: /* @__PURE__ */ jsxs(
          Box,
          {
            sx: {
              display: "flex",
              flexDirection: "column",
              gap: 1,
              alignItems: "stretch"
            },
            children: [
              /* @__PURE__ */ jsxs(
                Grid,
                {
                  container: true,
                  spacing: 1,
                  columns: { xs: 2, sm: 2, md: 2, lg: 3, xl: 3 },
                  children: [
                    /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                      CardThemed,
                      {
                        sx: {
                          height: "100%",
                          maxHeight: "8em",
                          boxShadow: weaponUsedInTeamCharKey ? "0px 0px 0px 2px yellow" : void 0
                        },
                        children: /* @__PURE__ */ jsx(
                          WeaponCardNano,
                          {
                            weaponId,
                            weaponTypeKey
                          }
                        )
                      }
                    ) }),
                    Object.entries(artifactIds).map(([slotKey, id]) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                      CardThemed,
                      {
                        sx: {
                          height: "100%",
                          maxHeight: "8em",
                          boxShadow: artUsedInTeamCharKeys[slotKey] ? "0px 0px 0px 2px yellow" : void 0
                        },
                        children: /* @__PURE__ */ jsx(ArtifactCardNano, { artifactId: id, slotKey })
                      }
                    ) }, id || slotKey))
                  ]
                }
              ),
              /* @__PURE__ */ jsx(
                TeammateEquippedAlert,
                {
                  weaponUsedInTeamCharKey,
                  artUsedInTeamCharKeys
                }
              )
            ]
          }
        )
      }
    )
  ] });
}
function BuildEditor({
  buildId,
  onClose
}) {
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const weaponTypeKey = getCharStat(characterKey).weaponType;
  const database = useDatabase();
  const build = useBuild(buildId);
  const [name, setName] = reactExports.useState(build.name);
  const nameDeferred = reactExports.useDeferredValue(name);
  const [desc, setDesc] = reactExports.useState(build.description);
  const descDeferred = reactExports.useDeferredValue(desc);
  reactExports.useEffect(() => {
    const newBuild = database.builds.get(buildId);
    if (!newBuild)
      return;
    const { name: name2, description } = newBuild;
    setName(name2);
    setDesc(description);
  }, [database, buildId]);
  reactExports.useEffect(() => {
    database.builds.set(buildId, (build2) => {
      build2.name = nameDeferred;
    });
  }, [database, nameDeferred]);
  reactExports.useEffect(() => {
    database.builds.set(buildId, (build2) => {
      build2.description = descDeferred;
    });
  }, [database, descDeferred]);
  return /* @__PURE__ */ jsxs(CardThemed, { children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: "Build Settings",
        action: /* @__PURE__ */ jsx(IconButton, { onClick: onClose, children: /* @__PURE__ */ jsx(default_1$a, {}) })
      }
    ),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", flexDirection: "column", gap: 2 }, children: [
      /* @__PURE__ */ jsx(
        TextField,
        {
          fullWidth: true,
          label: "Build Name",
          placeholder: "Build Name",
          value: name,
          onChange: (e3) => setName(e3.target.value)
        }
      ),
      /* @__PURE__ */ jsx(
        TextField,
        {
          fullWidth: true,
          label: "Build Description",
          value: desc,
          onChange: (e3) => setDesc(e3.target.value),
          multiline: true,
          minRows: 2
        }
      ),
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
        EquippedGrid,
        {
          weaponTypeKey,
          weaponId: build.weaponId,
          artifactIds: build.artifactIds,
          setWeapon: (id) => database.builds.set(buildId, { weaponId: id }),
          setArtifact: (slotKey, id) => database.builds.set(buildId, (build2) => {
            build2.artifactIds[slotKey] = id;
          })
        }
      ) })
    ] })
  ] });
}
function BuildTc({
  buildTcId,
  active = false
}) {
  const [open, onOpen, onClose] = useBoolState();
  const { teamId, teamCharId } = reactExports.useContext(TeamCharacterContext);
  const database = useDatabase();
  const buildTc = useBuildTc(buildTcId);
  const { name, description } = buildTc;
  const onActive = () => database.teams.setLoadoutDatum(teamId, teamCharId, {
    buildType: "tc",
    buildTcId
  });
  const onRemove = () => {
    database.buildTcs.remove(buildTcId);
  };
  const onDupe = () => database.teamChars.newBuildTc(teamCharId, {
    ...structuredClone(buildTc),
    name: `Duplicate of ${name}`
  });
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(ModalWrapper, { open, onClose, children: /* @__PURE__ */ jsx(BuildTcEditor, { buildTcId, onClose }) }),
    /* @__PURE__ */ jsx(
      BuildCard,
      {
        name,
        description,
        active,
        onActive,
        onEdit: onOpen,
        onDupe,
        onRemove,
        children: /* @__PURE__ */ jsx(TcEquip, { buildTcId })
      }
    )
  ] });
}
function TcEquip({ buildTcId }) {
  const {
    weapon,
    artifact: {
      slots,
      substats: { stats: substats },
      sets
    },
    character
  } = useBuildTc(buildTcId);
  const weaponSheet = getWeaponSheet(weapon.key);
  const substatsArr = Object.entries(substats);
  const substatsArr1 = substatsArr.slice(0, 5);
  const substatsArr2 = substatsArr.slice(5);
  return /* @__PURE__ */ jsxs(Box, { children: [
    !!character && /* @__PURE__ */ jsx(CardThemed, { sx: { mb: 1 }, children: /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", gap: 1 }, children: [
      /* @__PURE__ */ jsx(
        Chip,
        {
          size: "small",
          label: `Lv. ${getLevelString(
            character.level,
            character.ascension
          )}`,
          sx: { color: "yellow" }
        }
      ),
      /* @__PURE__ */ jsx(
        Chip,
        {
          size: "small",
          label: `C${character.constellation}`,
          sx: { color: "yellow" }
        }
      ),
      /* @__PURE__ */ jsx(Typography, { color: "yellow", children: "Character Overriden" })
    ] }) }),
    /* @__PURE__ */ jsxs(
      Grid,
      {
        container: true,
        spacing: 1,
        columns: { xs: 2, sm: 2, md: 2, lg: 2, xl: 2 },
        children: [
          /* @__PURE__ */ jsxs(
            Grid,
            {
              item: true,
              xs: 1,
              sx: { display: "flex", flexDirection: "column", gap: 1 },
              children: [
                /* @__PURE__ */ jsx(CardThemed, { sx: { height: "100%", maxHeight: "8em" }, children: /* @__PURE__ */ jsx(
                  WeaponCardNanoObj,
                  {
                    weapon,
                    weaponSheet
                  }
                ) }),
                !!Object.keys(sets).length && /* @__PURE__ */ jsx(CardThemed, { sx: { flexGrow: 1 }, children: /* @__PURE__ */ jsx(
                  Box,
                  {
                    sx: {
                      p: 1,
                      display: "flex",
                      flexDirection: "column",
                      gap: 1
                    },
                    children: Object.entries(sets).map(([setKey, number2]) => /* @__PURE__ */ jsxs(
                      Box,
                      {
                        sx: { display: "flex", alignItems: "center", gap: 1 },
                        children: [
                          /* @__PURE__ */ jsx(ImgIcon, { size: 2, src: artifactAsset(setKey, "flower") }),
                          /* @__PURE__ */ jsx("span", { children: /* @__PURE__ */ jsx(ArtifactSetName, { setKey }) }),
                          /* @__PURE__ */ jsxs(SqBadge, { children: [
                            "x",
                            number2
                          ] })
                        ]
                      },
                      setKey
                    ))
                  }
                ) })
              ]
            }
          ),
          /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
            CardThemed,
            {
              sx: {
                flexGrow: 1,
                height: "100%",
                p: 1,
                display: "flex",
                flexDirection: "column",
                gap: 1,
                justifyContent: "space-between"
              },
              children: Object.entries(slots).map(([sk, { level, statKey }]) => /* @__PURE__ */ jsxs(
                Box,
                {
                  sx: { display: "flex", alignItems: "center", gap: 1 },
                  children: [
                    /* @__PURE__ */ jsx(SlotIcon, { slotKey: sk }),
                    /* @__PURE__ */ jsxs(SqBadge, { children: [
                      "+",
                      level
                    ] }),
                    /* @__PURE__ */ jsx(StatWithUnit, { statKey })
                  ]
                },
                sk
              ))
            }
          ) }),
          [substatsArr1, substatsArr2].map((arr, i) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(CardThemed, { sx: { flexGrow: 1, height: "100%" }, children: /* @__PURE__ */ jsx(
            Box,
            {
              sx: {
                p: 1,
                height: "100%",
                display: "flex",
                flexDirection: "column",
                justifyContent: "space-between",
                gap: 1
              },
              children: arr.map(([sk, number2]) => /* @__PURE__ */ jsxs(
                Box,
                {
                  sx: {
                    display: "flex",
                    alignItems: "center",
                    gap: 1,
                    justifyContent: "space-between"
                  },
                  children: [
                    /* @__PURE__ */ jsx(StatWithUnit, { statKey: sk }),
                    /* @__PURE__ */ jsxs("span", { children: [
                      artDisplayValue(number2, getUnitStr(sk)),
                      getUnitStr(sk)
                    ] })
                  ]
                },
                sk
              ))
            }
          ) }) }, i))
        ]
      }
    )
  ] });
}
function BuildTcEditor({
  buildTcId,
  onClose
}) {
  const database = useDatabase();
  const build = useBuildTc(buildTcId);
  const [name, setName] = reactExports.useState(build.name);
  const nameDeferred = reactExports.useDeferredValue(name);
  const [desc, setDesc] = reactExports.useState(build.description);
  const descDeferred = reactExports.useDeferredValue(desc);
  reactExports.useEffect(() => {
    const newBuild = database.buildTcs.get(buildTcId);
    if (!newBuild)
      return;
    const { name: name2, description } = newBuild;
    setName(name2);
    setDesc(description);
  }, [database, buildTcId]);
  reactExports.useEffect(() => {
    database.buildTcs.set(buildTcId, (build2) => {
      build2.name = nameDeferred;
    });
  }, [database, nameDeferred]);
  reactExports.useEffect(() => {
    database.buildTcs.set(buildTcId, (build2) => {
      build2.description = descDeferred;
    });
  }, [database, descDeferred]);
  return /* @__PURE__ */ jsxs(CardThemed, { children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: "Build Settings",
        action: /* @__PURE__ */ jsx(IconButton, { onClick: onClose, children: /* @__PURE__ */ jsx(default_1$a, {}) })
      }
    ),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", flexDirection: "column", gap: 2 }, children: [
      /* @__PURE__ */ jsx(
        TextField,
        {
          fullWidth: true,
          label: "Build Name",
          placeholder: "Build Name",
          value: name,
          onChange: (e3) => setName(e3.target.value)
        }
      ),
      /* @__PURE__ */ jsx(
        TextField,
        {
          fullWidth: true,
          label: "Build Description",
          value: desc,
          onChange: (e3) => setDesc(e3.target.value),
          multiline: true,
          minRows: 2
        }
      )
    ] })
  ] });
}
function TargetSelectorModal({
  show,
  onClose,
  setTarget,
  showEmptyTargets = false,
  flatOnly = false,
  excludeSections = [],
  excludeHeal = false
}) {
  const { data } = reactExports.useContext(DataContext);
  const { t: t2 } = useTranslation("page_character_optimize");
  const sections = reactExports.useMemo(() => {
    return getDisplaySections(data).filter(([key]) => !excludeSections.includes(key)).map(
      ([key, sectionObj]) => [
        key,
        Object.fromEntries(
          Object.entries(sectionObj).filter(([_sectionKey, node]) => {
            const { unit: unit2, variant } = resolveInfo(node.info);
            if (flatOnly && unit2 === "%")
              return false;
            if (excludeHeal && variant === "heal")
              return false;
            if (!showEmptyTargets && node.isEmpty && key !== "basic")
              return false;
            return true;
          })
        )
      ]
    ).filter(([_key, sectionObj]) => Object.keys(sectionObj).length);
  }, [data, excludeSections, flatOnly, showEmptyTargets, excludeHeal]);
  return /* @__PURE__ */ jsx(ModalWrapper, { open: show, onClose, children: /* @__PURE__ */ jsxs(CardThemed, { children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: t2`targetSelectorTitle`,
        action: /* @__PURE__ */ jsx(IconButton, { onClick: onClose, children: /* @__PURE__ */ jsx(default_1$a, {}) })
      }
    ),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsx(Masonry, { columns: { xs: 1, sm: 2, md: 3 }, spacing: 1, children: sections.map(([key, Nodes]) => /* @__PURE__ */ jsx(
      SelectorSection,
      {
        displayNs: Nodes,
        sectionKey: key,
        setTarget
      },
      key
    )) }) })
  ] }) });
}
function SelectorSection({
  displayNs,
  sectionKey,
  setTarget
}) {
  const { data } = reactExports.useContext(DataContext);
  const database = useDatabase();
  const header = reactExports.useMemo(
    () => getDisplayHeader(data, sectionKey, database),
    [data, sectionKey, database]
  );
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    header && /* @__PURE__ */ jsx(
      CardHeader,
      {
        avatar: header.icon,
        title: header.title,
        action: header.action && /* @__PURE__ */ jsx(SqBadge, { children: header.action }),
        titleTypographyProps: { variant: "subtitle1" }
      }
    ),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(MenuList, { children: Object.entries(displayNs).map(([key, n2]) => /* @__PURE__ */ jsx(
      TargetSelectorMenuItem,
      {
        node: n2,
        onClick: () => setTarget([sectionKey, key], n2.info.multi)
      },
      key
    )) })
  ] }, sectionKey);
}
function TargetSelectorMenuItem({
  node,
  onClick
}) {
  return /* @__PURE__ */ jsx(MenuItem, { onClick, style: { whiteSpace: "normal" }, children: /* @__PURE__ */ jsx(NodeFieldDisplayText, { node }) });
}
var Comment = {};
var _interopRequireDefault$5 = interopRequireDefaultExports;
Object.defineProperty(Comment, "__esModule", {
  value: true
});
var default_1$4 = Comment.default = void 0;
var _createSvgIcon$4 = _interopRequireDefault$5(requireCreateSvgIcon());
var _jsxRuntime$4 = jsxRuntimeExports;
var _default$4 = (0, _createSvgIcon$4.default)(/* @__PURE__ */ (0, _jsxRuntime$4.jsx)("path", {
  d: "M21.99 4c0-1.1-.89-2-1.99-2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h14l4 4-.01-18zM18 14H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"
}), "Comment");
default_1$4 = Comment.default = _default$4;
function OptimizationTargetDisplay({
  optimizationTarget,
  defaultText
}) {
  const { t: t2 } = useTranslation("page_character_optimize");
  const { data } = reactExports.useContext(DataContext);
  const database = useDatabase();
  const displayHeader = reactExports.useMemo(
    () => optimizationTarget && getDisplayHeader(data, optimizationTarget[0], database),
    [data, optimizationTarget, database]
  );
  if (!defaultText)
    defaultText = t2("targetSelector.selectOptTarget");
  const { title, icon, action } = displayHeader ?? {};
  const node = optimizationTarget && objPathValue(data.getDisplay(), optimizationTarget);
  const invalidTarget = !optimizationTarget || !displayHeader || !node;
  const {
    name,
    textSuffix,
    icon: nodeIcon,
    variant = invalidTarget ? "secondary" : void 0
  } = ((node == null ? void 0 : node.info) && resolveInfo(node == null ? void 0 : node.info)) ?? {};
  const suffixDisplay = textSuffix && /* @__PURE__ */ jsxs("span", { children: [
    " ",
    textSuffix
  ] });
  const iconDisplay = icon ? icon : nodeIcon;
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));
  return invalidTarget ? /* @__PURE__ */ jsx("strong", { children: defaultText }) : /* @__PURE__ */ jsxs(
    Stack$3,
    {
      direction: "row",
      divider: /* @__PURE__ */ jsx(Divider, { orientation: "vertical", flexItem: true }),
      spacing: 1,
      children: [
        /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, alignItems: "center" }, children: [
          iconDisplay,
          !isMobile && /* @__PURE__ */ jsx("span", { children: title }),
          !!action && /* @__PURE__ */ jsx(SqBadge, { color: "success", sx: { whiteSpace: "normal" }, children: action })
        ] }),
        /* @__PURE__ */ jsx(Box, { sx: { display: "flex", alignItems: "center" }, children: /* @__PURE__ */ jsxs(
          SqBadge,
          {
            color: variant === "invalid" ? void 0 : variant,
            sx: { whiteSpace: "normal" },
            children: [
              /* @__PURE__ */ jsx("strong", { children: name }),
              suffixDisplay
            ]
          }
        ) })
      ]
    }
  );
}
function CustomTargetDisplay({
  selected,
  setSelect,
  customTarget,
  rank
}) {
  const { t: t2 } = useTranslation("page_character");
  const { data } = reactExports.useContext(DataContext);
  const {
    path,
    weight,
    hitMode,
    reaction,
    infusionAura,
    bonusStats,
    description
  } = customTarget;
  const node = objPathValue(data.getDisplay(), path);
  return /* @__PURE__ */ jsx(
    CardThemed,
    {
      bgt: "light",
      sx: { display: "flex", border: selected ? "2px solid green" : void 0 },
      children: /* @__PURE__ */ jsx(CardActionArea, { sx: { p: 1, flexGrow: 1 }, onClick: setSelect, children: /* @__PURE__ */ jsxs(
        Typography,
        {
          component: "div",
          sx: {
            display: "flex",
            gap: 1,
            flexWrap: "wrap",
            alignItems: "center"
          },
          children: [
            /* @__PURE__ */ jsx(Chip, { label: `#${rank}`, sx: { minWidth: "4em" } }),
            /* @__PURE__ */ jsx(Chip, { label: `x${weight}`, sx: { minWidth: "5em" } }),
            /* @__PURE__ */ jsx(
              OptimizationTargetDisplay,
              {
                optimizationTarget: path,
                showEmptyTargets: true
              }
            ),
            /* @__PURE__ */ jsx(Box, { sx: { flexGrow: 1 } }),
            node && /* @__PURE__ */ jsx(
              ReactionChip,
              {
                reaction,
                node,
                infusionAura
              }
            ),
            !!Object.values(bonusStats).length && /* @__PURE__ */ jsx(
              Chip,
              {
                avatar: /* @__PURE__ */ jsx(default_1$d, {}),
                label: /* @__PURE__ */ jsx("strong", { children: Object.values(bonusStats).length })
              }
            ),
            /* @__PURE__ */ jsx(Chip, { label: t2(`hitmode.${hitMode}`) }),
            description && /* @__PURE__ */ jsx(
              Tooltip$1,
              {
                arrow: true,
                title: description.length > 100 ? `${description.slice(0, 100)}...` : description,
                children: /* @__PURE__ */ jsx(Avatar, { style: { backgroundColor: "#4C566A" }, children: /* @__PURE__ */ jsx(default_1$4, { style: { color: "white" } }) })
              }
            )
          ]
        }
      ) })
    }
  );
}
function ReactionChip({
  node,
  reaction,
  infusionAura
}) {
  const ele = node.info.variant ?? "physical";
  if (!["pyro", "hydro", "cryo", "electro", "dendro"].some(
    (e3) => e3 === ele || e3 === infusionAura
  ))
    return null;
  const title = reaction && ([...allAmpReactionKeys].includes(reaction) ? /* @__PURE__ */ jsx(AmpReactionModeText, { reaction }) : /* @__PURE__ */ jsx(AdditiveReactionModeText, { reaction }));
  if (!title)
    return null;
  return /* @__PURE__ */ jsx(Chip, { label: title });
}
function JsonDescWarning() {
  const { t: t2 } = useTranslation("page_character");
  return /* @__PURE__ */ jsx(Alert, { severity: "warning", variant: "filled", children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "jsonDescWarning", children: [
    "It seems like you're trying to import a multi-opt config. This isn't the right place for that! Please go back one modal and press",
    " ",
    /* @__PURE__ */ jsx("strong", { children: "Import Multi-Opt." })
  ] }) });
}
function OptimizationTargetSelector({
  optimizationTarget,
  setTarget,
  disabled = false,
  showEmptyTargets = false,
  defaultText,
  targetSelectorModalProps = {},
  buttonProps = {}
}) {
  const [show, onShow, onClose] = useBoolState(false);
  const setTargetHandler = reactExports.useCallback(
    (target) => {
      onClose();
      setTarget(target);
    },
    [onClose, setTarget]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        color: "info",
        onClick: onShow,
        disabled,
        sx: { flexGrow: 1 },
        ...buttonProps,
        children: /* @__PURE__ */ jsx(
          OptimizationTargetDisplay,
          {
            optimizationTarget,
            showEmptyTargets,
            defaultText
          }
        )
      }
    ),
    /* @__PURE__ */ jsx(
      TargetSelectorModal,
      {
        show,
        onClose,
        setTarget: setTargetHandler,
        showEmptyTargets,
        ...targetSelectorModalProps
      }
    )
  ] });
}
const keys$7 = [...allInputPremodKeys];
const wrapperFunc$1 = (e3, key) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: e3 }, key);
function MTargetEditor({
  customTarget,
  setCustomTarget,
  deleteCustomTarget,
  rank,
  maxRank,
  setTargetIndex,
  onDup
}) {
  const { t: t2 } = useTranslation("page_character");
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const { data } = reactExports.useContext(DataContext);
  const {
    path,
    weight,
    hitMode,
    reaction,
    infusionAura,
    bonusStats,
    description
  } = customTarget;
  const [collapse, setcollapse] = reactExports.useState(true);
  const setWeight = reactExports.useCallback(
    (weight2) => setCustomTarget({ ...customTarget, weight: weight2 }),
    [customTarget, setCustomTarget]
  );
  const node = objPathValue(data.getDisplay(), path);
  const setFilter = reactExports.useCallback(
    (bonusStats2) => setCustomTarget({ ...customTarget, bonusStats: bonusStats2 }),
    [customTarget, setCustomTarget]
  );
  reactExports.useEffect(() => {
    setcollapse(false);
  }, [customTarget]);
  const statEditorList = reactExports.useMemo(
    () => /* @__PURE__ */ jsx(
      StatEditorList,
      {
        statKeys: keys$7,
        statFilters: bonusStats,
        setStatFilters: setFilter,
        wrapperFunc: wrapperFunc$1,
        label: t2("addStats.label")
      }
    ),
    [bonusStats, setFilter, t2]
  );
  const isMeleeAuto = isCharMelee(characterKey) && (path[0] === "normal" || path[0] === "charged" || path[0] === "plunging");
  const isTransformativeReaction = path[0] === "reaction";
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("sm"));
  return /* @__PURE__ */ jsxs(
    CardThemed,
    {
      bgt: "light",
      sx: {
        boxShadow: "0 0 10px black",
        position: "sticky",
        bottom: `10px`,
        zIndex: 1e3
      },
      children: [
        /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, alignItems: "center" }, children: [
          /* @__PURE__ */ jsxs(
            CardActionArea,
            {
              sx: {
                display: "flex",
                flexGrow: 1,
                gap: 1,
                height: "100%",
                py: 1,
                alignItems: "center"
              },
              onClick: () => setcollapse((c2) => !c2),
              children: [
                /* @__PURE__ */ jsx(Typography, { variant: "h6", children: "Target Editor" }),
                collapse ? /* @__PURE__ */ jsx(default_1$e, {}) : /* @__PURE__ */ jsx(default_1$f, {})
              ]
            }
          ),
          /* @__PURE__ */ jsx(
            TextFieldLazy,
            {
              InputProps: {
                startAdornment: /* @__PURE__ */ jsx(InputAdornment, { position: "start", children: isMobile ? "#" : "Rank #" })
              },
              inputProps: {
                sx: { width: "2em" },
                min: 1,
                max: maxRank
              },
              type: "number",
              value: rank.toString(),
              onChange: (v2) => setTargetIndex(parseInt(v2)),
              size: "small",
              sx: { minWidth: isMobile ? "4em" : "6em" }
            }
          ),
          /* @__PURE__ */ jsx(IconButton, { color: "info", onClick: onDup, children: /* @__PURE__ */ jsx(default_1$g, {}) }),
          /* @__PURE__ */ jsx(IconButton, { color: "error", onClick: deleteCustomTarget, children: /* @__PURE__ */ jsx(default_1$9, {}) })
        ] }),
        /* @__PURE__ */ jsx(Divider, {}),
        /* @__PURE__ */ jsx(Collapse, { in: !collapse, children: /* @__PURE__ */ jsx(Box, { display: "flex", children: /* @__PURE__ */ jsxs(Box, { sx: { p: 1, flexGrow: 1 }, children: [
          /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, flexWrap: "wrap" }, children: [
            /* @__PURE__ */ jsx(
              TextFieldLazy,
              {
                InputProps: {
                  startAdornment: /* @__PURE__ */ jsx(InputAdornment, { position: "start", children: "x" })
                },
                inputProps: {
                  sx: { width: "2em" }
                },
                type: "number",
                value: weight.toString(),
                onChange: (v2) => setWeight(parseFloat(v2)),
                size: "small"
              }
            ),
            /* @__PURE__ */ jsx(
              OptimizationTargetSelector,
              {
                optimizationTarget: path,
                setTarget: (path2) => setCustomTarget({
                  ...customTarget,
                  path: path2,
                  reaction: void 0,
                  infusionAura: void 0
                }),
                showEmptyTargets: true,
                targetSelectorModalProps: {
                  flatOnly: true,
                  excludeSections: [
                    "basic",
                    "bounsStats",
                    "custom",
                    "character",
                    "teamBuff"
                  ]
                }
              }
            ),
            node && /* @__PURE__ */ jsx(
              ReactionDropdown,
              {
                reaction,
                setReactionMode: (rm) => setCustomTarget({ ...customTarget, reaction: rm }),
                node,
                infusionAura
              }
            ),
            /* @__PURE__ */ jsx(DropdownButton, { title: t2(`hitmode.${hitMode}`), children: allMultiOptHitModeKeys.map((hm) => /* @__PURE__ */ jsx(
              MenuItem,
              {
                value: hm,
                disabled: hitMode === hm,
                onClick: () => setCustomTarget({ ...customTarget, hitMode: hm }),
                children: t2(`hitmode.${hm}`)
              },
              hm
            )) })
          ] }),
          /* @__PURE__ */ jsxs(Grid, { container: true, columns: { xs: 1, md: 2 }, spacing: 1, children: [
            /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(
              Grid,
              {
                container: true,
                columns: { xs: 1 },
                sx: { pt: 1 },
                spacing: 1,
                children: [
                  (isMeleeAuto || isTransformativeReaction) && /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                    DropdownButton,
                    {
                      title: infusionVals[infusionAura ?? ""],
                      color: infusionAura || "secondary",
                      disableElevation: true,
                      fullWidth: true,
                      children: Object.entries(infusionVals).map(([key, text]) => /* @__PURE__ */ jsx(
                        MenuItem,
                        {
                          sx: key ? { color: `${key}.main` } : void 0,
                          selected: key === infusionAura,
                          disabled: key === infusionAura,
                          onClick: () => setCustomTarget({
                            ...customTarget,
                            infusionAura: key ? key : void 0,
                            reaction: void 0
                          }),
                          children: text
                        },
                        key
                      ))
                    }
                  ) }),
                  statEditorList
                ]
              }
            ) }) }),
            /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
              TextFieldLazy,
              {
                fullWidth: true,
                label: "Target Description",
                value: description,
                onChange: (description2) => setCustomTarget({ ...customTarget, description: description2 }),
                multiline: true,
                minRows: 2,
                sx: { mt: 1 }
              }
            ) })
          ] })
        ] }) }) })
      ]
    }
  );
}
function ReactionDropdown({
  node,
  reaction,
  setReactionMode,
  infusionAura
}) {
  const ele = node.info.variant ?? "physical";
  const { t: t2 } = useTranslation("page_character");
  if (!["pyro", "hydro", "cryo", "electro", "dendro"].some(
    (e3) => e3 === ele || e3 === infusionAura
  ))
    return null;
  const reactions = [
    .../* @__PURE__ */ new Set([
      ...allowedAmpReactions[ele] ?? [],
      ...allowedAmpReactions[infusionAura ?? ""] ?? [],
      ...allowedAdditiveReactions[ele] ?? [],
      ...allowedAdditiveReactions[infusionAura ?? ""] ?? []
    ])
  ];
  const title = reaction ? [...allAmpReactionKeys].includes(reaction) ? /* @__PURE__ */ jsx(AmpReactionModeText, { reaction }) : /* @__PURE__ */ jsx(AdditiveReactionModeText, { reaction }) : t2`noReaction`;
  return /* @__PURE__ */ jsxs(DropdownButton, { title, sx: { ml: "auto" }, children: [
    /* @__PURE__ */ jsx(MenuItem, { value: "", disabled: !reaction, onClick: () => setReactionMode(), children: "No Reactions" }),
    reactions.map((rm) => /* @__PURE__ */ jsx(
      MenuItem,
      {
        disabled: reaction === rm,
        onClick: () => setReactionMode(rm),
        children: [...allAmpReactionKeys].includes(rm) ? /* @__PURE__ */ jsx(AmpReactionModeText, { reaction: rm }) : /* @__PURE__ */ jsx(AdditiveReactionModeText, { reaction: rm })
      },
      rm
    ))
  ] });
}
function CustomMultiTargetCard({
  customMultiTarget: targetProp,
  setTarget: setTargetProp,
  onDelete,
  onDup: onDupProp
}) {
  const { t: t2 } = useTranslation("page_character");
  const [target, setTarget] = reactExports.useState(structuredClone(targetProp));
  reactExports.useEffect(() => {
    if (JSON.stringify(targetProp) !== JSON.stringify(target))
      setTarget(structuredClone(targetProp));
  }, [targetProp]);
  const { name, description } = target;
  const [show, onShow, onHide] = useBoolState();
  const [descIsJson, setDescIsJson] = reactExports.useState(false);
  const onDup = () => {
    onDupProp();
    onHide();
  };
  const onSave = reactExports.useCallback(() => {
    onHide();
    setTargetProp(target);
  }, [onHide, setTargetProp, target]);
  const addTarget = reactExports.useCallback(
    (t22, multi) => {
      const target_ = { ...target };
      target_.targets = [...target_.targets, initCustomTarget(t22, multi)];
      setTarget(target_);
    },
    [target, setTarget]
  );
  const setCustomTarget = reactExports.useCallback(
    (index) => (ctarget) => {
      const targets = [...target.targets];
      targets[index] = ctarget;
      setTarget({ ...target, targets });
    },
    [target, setTarget]
  );
  const deleteCustomTarget = reactExports.useCallback(
    (index) => () => {
      if (Object.values(target.targets[index].bonusStats).length && !window.confirm(`Are you sure you want to delete this target?`))
        return;
      const targets = [...target.targets];
      targets.splice(index, 1);
      setTarget({ ...target, targets });
    },
    [target, setTarget]
  );
  const [selectedTarget, setSelectedTarget] = reactExports.useState(-1);
  const setTargetIndex = reactExports.useCallback(
    (oldInd) => (newRank) => {
      if (newRank === void 0 || newRank === 0)
        return;
      newRank = clamp(newRank, 1, target.targets.length);
      const newInd = newRank - 1;
      const targets = [...target.targets];
      arrayMove(targets, oldInd, newInd);
      setTarget({ ...target, targets });
      setSelectedTarget(newRank - 1);
    },
    [target, setTarget]
  );
  const dupCustomTarget = reactExports.useCallback(
    (index) => () => {
      const targets = [...target.targets];
      targets.splice(index, 0, deepClone(targets[index]));
      setTarget({ ...target, targets });
    },
    [target, setTarget]
  );
  const copyToClipboard = () => navigator.clipboard.writeText(JSON.stringify(target)).then(() => alert("Copied configuration to clipboard.")).catch(console.error);
  const customTargetDisplays = reactExports.useMemo(
    () => target.targets.map((t22, i) => /* @__PURE__ */ jsx(
      CustomTargetDisplay,
      {
        selected: selectedTarget === i,
        setSelect: () => selectedTarget === i ? setSelectedTarget(-1) : setSelectedTarget(i),
        customTarget: t22,
        rank: i + 1
      },
      t22.path.join() + i
    )),
    [selectedTarget, target.targets]
  );
  const selectedTargetValid = clamp(
    selectedTarget,
    -1,
    target.targets.length - 1
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(CardActionArea, { onClick: onShow, children: /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, alignItems: "center", children: [
          /* @__PURE__ */ jsx(
            Chip,
            {
              sx: { minWidth: "8em" },
              color: target.targets.length ? "success" : void 0,
              label: /* @__PURE__ */ jsxs(
                Trans,
                {
                  t: t2,
                  i18nKey: "multiTarget.target",
                  count: target.targets.length,
                  children: [
                    { count: target.targets.length },
                    " Targets"
                  ]
                }
              )
            }
          ),
          /* @__PURE__ */ jsx(Typography, { children: name }),
          target.description && /* @__PURE__ */ jsx(InfoTooltip, { title: /* @__PURE__ */ jsx(Typography, { children: description }) })
        ] })
      }
    ) }) }),
    /* @__PURE__ */ jsx(ModalWrapper, { open: show, onClose: onSave, children: /* @__PURE__ */ jsxs(CardThemed, { sx: { overflow: "visible" }, children: [
      /* @__PURE__ */ jsx(
        CardHeader,
        {
          title: name,
          action: /* @__PURE__ */ jsx(IconButton, { onClick: onSave, children: /* @__PURE__ */ jsx(default_1$a, {}) })
        }
      ),
      /* @__PURE__ */ jsx(Divider, {}),
      /* @__PURE__ */ jsxs(
        CardContent,
        {
          sx: { display: "flex", flexDirection: "column", gap: 2 },
          children: [
            /* @__PURE__ */ jsx(
              TextFieldLazy,
              {
                fullWidth: true,
                label: "Custom Multi-target Name",
                value: name,
                onChange: (name2) => setTarget((target2) => ({
                  ...target2,
                  name: name2
                }))
              }
            ),
            description && descIsJson && /* @__PURE__ */ jsx(JsonDescWarning, {}),
            /* @__PURE__ */ jsx(
              TextFieldLazy,
              {
                fullWidth: true,
                label: "Custom Multi-target Description",
                value: description,
                onChange: (description2) => {
                  setDescIsJson(
                    description2 ? (() => {
                      try {
                        JSON.parse(description2);
                        return true;
                      } catch (e3) {
                        return false;
                      }
                    })() : false
                  );
                  setTarget((target2) => ({
                    ...target2,
                    description: description2
                  }));
                },
                multiline: true,
                minRows: 2
              }
            ),
            /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 2, children: [
              /* @__PURE__ */ jsx(
                Button,
                {
                  onClick: onDup,
                  color: "info",
                  sx: { flexGrow: 1 },
                  startIcon: /* @__PURE__ */ jsx(default_1$g, {}),
                  children: t2("multiTarget.duplicate")
                }
              ),
              /* @__PURE__ */ jsx(
                Button,
                {
                  color: "info",
                  onClick: copyToClipboard,
                  startIcon: /* @__PURE__ */ jsx(default_1$h, {}),
                  sx: { flexGrow: 1 },
                  children: "Export"
                }
              ),
              /* @__PURE__ */ jsx(Button, { color: "error", onClick: onDelete, children: /* @__PURE__ */ jsx(default_1$9, {}) })
            ] })
          ]
        }
      ),
      /* @__PURE__ */ jsx(Divider, {}),
      /* @__PURE__ */ jsxs(
        CardContent,
        {
          sx: {
            display: "flex",
            flexDirection: "column",
            gap: 1,
            position: "relative"
          },
          children: [
            customTargetDisplays,
            /* @__PURE__ */ jsx(AddCustomTargetBtn, { setTarget: addTarget }),
            target.targets[selectedTargetValid] && /* @__PURE__ */ jsx(
              MTargetEditor,
              {
                customTarget: target.targets[selectedTargetValid],
                setCustomTarget: setCustomTarget(selectedTargetValid),
                deleteCustomTarget: deleteCustomTarget(selectedTargetValid),
                rank: selectedTargetValid + 1,
                maxRank: target.targets.length,
                setTargetIndex: setTargetIndex(selectedTargetValid),
                onDup: dupCustomTarget(selectedTargetValid)
              }
            )
          ]
        }
      )
    ] }) })
  ] });
}
function AddCustomTargetBtn({
  setTarget
}) {
  const { t: t2 } = useTranslation("page_character");
  const [show, onShow, onClose] = useBoolState(false);
  const setTargetHandler = reactExports.useCallback(
    (target, multi) => {
      onClose();
      setTarget(target, multi);
    },
    [onClose, setTarget]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        fullWidth: true,
        onClick: onShow,
        startIcon: /* @__PURE__ */ jsx(default_1$i, {}),
        sx: { mb: 1 },
        children: t2`multiTarget.addNewTarget`
      }
    ),
    /* @__PURE__ */ jsx(
      TargetSelectorModal,
      {
        showEmptyTargets: true,
        flatOnly: true,
        excludeHeal: true,
        show,
        onClose,
        setTarget: setTargetHandler,
        excludeSections: [
          "basic",
          "bounsStats",
          "custom",
          "character",
          "teamBuff"
        ]
      }
    )
  ] });
}
function CustomMultiTargetImportBtn({
  setCustomMultiTarget,
  btnProps = {}
}) {
  const [show, onShow, onHide] = useBoolState();
  const [data, setData] = reactExports.useState("");
  const importData = () => {
    try {
      const dataObj = JSON.parse(data);
      const validated = validateCustomMultiTarget(dataObj);
      if (!validated)
        window.alert("Invalid Multi-Optimization Config");
      else {
        setCustomMultiTarget(validated);
        onHide();
      }
    } catch (e3) {
      window.alert(`Data Import failed. ${e3}`);
      return;
    }
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(Button, { ...btnProps, onClick: onShow, children: "Import Multi-Opt" }),
    /* @__PURE__ */ jsx(ModalWrapper, { open: show, onClose: onHide, children: /* @__PURE__ */ jsxs(CardThemed, { children: [
      /* @__PURE__ */ jsx(CardHeader, { title: "Import Multi-Opt" }),
      /* @__PURE__ */ jsx(Divider, {}),
      /* @__PURE__ */ jsxs(
        CardContent,
        {
          sx: { display: "flex", flexDirection: "column", gap: 2 },
          children: [
            /* @__PURE__ */ jsx(Typography, { children: "Import a Multi-opt in JSON form below." }),
            /* @__PURE__ */ jsx(
              TextField,
              {
                fullWidth: true,
                label: "JSON Data",
                placeholder: "Paste your Team JSON here",
                value: data,
                onChange: (e3) => setData(e3.target.value),
                multiline: true,
                rows: 4
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                startIcon: /* @__PURE__ */ jsx(default_1$j, {}),
                disabled: !data,
                onClick: importData,
                children: "Import"
              }
            )
          ]
        }
      )
    ] }) })
  ] });
}
var define_process_env_default = { ACLOCAL_PATH: "/mingw64/share/aclocal:/usr/share/aclocal", ALLUSERSPROFILE: "C:\\ProgramData", APPDATA: "C:\\Users\\nguye\\AppData\\Roaming", BERRY_BIN_FOLDER: "C:\\Users\\nguye\\AppData\\Local\\Temp\\xfs-784063df", CHROME_CRASHPAD_PIPE_NAME: "\\\\.\\pipe\\crashpad_17588_OUJZIQANJWJSIJPB", COLORTERM: "truecolor", COMMONPROGRAMFILES: "C:\\Program Files\\Common Files", "CommonProgramFiles(x86)": "C:\\Program Files (x86)\\Common Files", CommonProgramW6432: "C:\\Program Files\\Common Files", COMPUTERNAME: "VANPC", COMSPEC: "C:\\WINDOWS\\system32\\cmd.exe", CONFIG_SITE: "/etc/config.site", DISPLAY: "needs-to-be-defined", DriverData: "C:\\Windows\\System32\\Drivers\\DriverData", EXEPATH: "C:\\Program Files\\Git\\bin", FORCE_COLOR: "true", GIT_ASKPASS: "c:\\Users\\nguye\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass.sh", HOME: "C:\\Users\\nguye", HOMEDRIVE: "C:", HOMEPATH: "\\Users\\nguye", HOSTNAME: "VanPC", INFOPATH: "/mingw64/local/info:/mingw64/share/info:/usr/local/info:/usr/share/info:/usr/info:/share/info", INIT_CWD: "D:\\GithubProjects\\genshin-optimizer", LANG: "en_US.UTF-8", LERNA_PACKAGE_NAME: "frontend", LOCALAPPDATA: "C:\\Users\\nguye\\AppData\\Local", LOGONSERVER: "\\\\VANPC", MANPATH: "/mingw64/local/man:/mingw64/share/man:/usr/local/man:/usr/share/man:/usr/man:/share/man", MINGW_CHOST: "x86_64-w64-mingw32", MINGW_PACKAGE_PREFIX: "mingw-w64-x86_64", MINGW_PREFIX: "/mingw64", MSYS: "disable_pcon", MSYSTEM: "MINGW64", MSYSTEM_CARCH: "x86_64", MSYSTEM_CHOST: "x86_64-w64-mingw32", MSYSTEM_PREFIX: "/mingw64", NODE_ENV: "production", npm_config_user_agent: "yarn/3.4.1 npm/? node/v21.6.1 win32 x64", npm_execpath: "C:\\Users\\nguye\\AppData\\Local\\Temp\\xfs-784063df\\yarn", npm_node_execpath: "C:\\Users\\nguye\\AppData\\Local\\Temp\\xfs-784063df\\node", npm_package_json: "D:\\GithubProjects\\genshin-optimizer\\package.json", npm_package_name: "genshin-optimizer", npm_package_version: "10.10.1", NUMBER_OF_PROCESSORS: "12", NX_CLI_SET: "true", NX_GA_TRACKINGID: "UA-000000-01", NX_LOAD_DOT_ENV_FILES: "true", NX_TASK_HASH: "14845748941812439306", NX_TASK_TARGET_PROJECT: "frontend", NX_TASK_TARGET_TARGET: "build", NX_URLS_GUIDES: "[]", NX_URL_DISCORD_GDEV: "https://discord.com/", NX_URL_DISCORD_GO: "https://discord.com/", NX_URL_GITHUB_API_GO_RELEASES: "https://api.github.com/repos///releases/tags/", NX_URL_GITHUB_FRZYC: "https://github.com/", NX_URL_GITHUB_GO: "https://github.com/", NX_URL_GITHUB_GO_CURRENT_VERSION: "", NX_URL_GITHUB_LANTUA: "https://github.com/", NX_URL_GITHUB_VAN: "https://github.com/", NX_URL_KQM_MULTI_GUIDE: "https://keqingmains.com/misc/multi-optimization/", NX_URL_PATREON_FRZYC: "https://www.patreon.com/", NX_URL_PAYPAL_FRZYC: "https://www.paypal.com/", NX_URL_TWITCH_FRZYC: "https://www.twitch.tv/", NX_URL_TWITTER_FRZYC: "https://twitter.com/frzyc", NX_URL_WEBSITE_KQM: "https://keqingmains.com/", NX_URL_YOUTUBE_TUTPL: "https://www.youtube.com/", NX_WORKSPACE_ROOT: "D:\\GithubProjects\\genshin-optimizer", OLDPWD: "/d/GithubProjects/genshin-optimizer/dist/apps/somnia", OneDrive: "C:\\Users\\nguye\\OneDrive", OneDriveConsumer: "C:\\Users\\nguye\\OneDrive", ORIGINAL_PATH: "C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\nguye\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\WINDOWS\\System32\\OpenSSH;C:\\Program Files\\nodejs;C:\\Program Files\\Git\\cmd;C:\\Program Files\\dotnet;C:\\Program Files\\PowerShell\\7;C:\\Users\\nguye\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\nguye\\AppData\\Roaming\\npm;C:\\Users\\nguye\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\nguye\\.dotnet\\tools", ORIGINAL_TEMP: "/tmp", ORIGINAL_TMP: "/tmp", ORIGINAL_XDG_CURRENT_DESKTOP: "undefined", OS: "Windows_NT", PATH: "D:\\GithubProjects\\genshin-optimizer\\apps\\frontend\\node_modules\\.bin;D:\\GithubProjects\\genshin-optimizer\\apps\\node_modules\\.bin;D:\\GithubProjects\\genshin-optimizer\\node_modules\\.bin;D:\\GithubProjects\\node_modules\\.bin;D:\\node_modules\\.bin;C:\\Program Files\\nodejs;C:\\Users\\nguye\\AppData\\Local\\Temp\\xfs-784063df;C:\\Users\\nguye\\.yarn\\bin;C:\\Users\\nguye\\.config\\yarn\\global\\node_modules\\.bin;C:\\Users\\nguye\\bin;C:\\Users\\nguye\\bin;C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\local\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Program Files\\Git\\mingw64\\bin;C:\\Program Files\\Git\\usr\\bin;C:\\Users\\nguye\\bin;C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0;C:\\WINDOWS\\System32\\OpenSSH;C:\\Program Files\\nodejs;C:\\Program Files\\Git\\cmd;C:\\Program Files\\dotnet;C:\\Program Files\\PowerShell\\7;C:\\Users\\nguye\\AppData\\Local\\Microsoft\\WindowsApps;C:\\Users\\nguye\\AppData\\Roaming\\npm;C:\\Users\\nguye\\AppData\\Local\\Programs\\Microsoft VS Code\\bin;C:\\Users\\nguye\\.dotnet\\tools;C:\\Program Files\\Git\\usr\\bin\\vendor_perl;C:\\Program Files\\Git\\usr\\bin\\core_perl", PATHEXT: ".COM;.EXE;.BAT;.CMD;.VBS;.VBE;.JSE;.WSF;.WSH;.MSC", PKG_CONFIG_PATH: "/mingw64/lib/pkgconfig:/mingw64/share/pkgconfig", PKG_CONFIG_SYSTEM_INCLUDE_PATH: "/mingw64/include", PKG_CONFIG_SYSTEM_LIBRARY_PATH: "/mingw64/lib", PLINK_PROTOCOL: "ssh", POWERSHELL_DISTRIBUTION_CHANNEL: "MSI:Windows 10 Pro", PROCESSOR_ARCHITECTURE: "AMD64", PROCESSOR_IDENTIFIER: "AMD64 Family 23 Model 8 Stepping 2, AuthenticAMD", PROCESSOR_LEVEL: "23", PROCESSOR_REVISION: "0802", ProgramData: "C:\\ProgramData", PROGRAMFILES: "C:\\Program Files", "ProgramFiles(x86)": "C:\\Program Files (x86)", ProgramW6432: "C:\\Program Files", PROJECT_CWD: "D:\\GithubProjects\\genshin-optimizer", PROMPT: "$P$G", PSModulePath: "C:\\Program Files\\WindowsPowerShell\\Modules;C:\\WINDOWS\\system32\\WindowsPowerShell\\v1.0\\Modules", PUBLIC: "C:\\Users\\Public", PWD: "D:\\GithubProjects\\genshin-optimizer", SESSIONNAME: "Console", SHELL: "C:\\Program Files\\Git\\usr\\bin\\bash.exe", SHLVL: "2", SSH_ASKPASS: "/mingw64/bin/git-askpass.exe", SYSTEMDRIVE: "C:", SYSTEMROOT: "C:\\WINDOWS", TEMP: "C:\\Users\\nguye\\AppData\\Local\\Temp", TERM_PROGRAM: "vscode", TERM_PROGRAM_VERSION: "1.91.1", TMP: "C:\\Users\\nguye\\AppData\\Local\\Temp", TMPDIR: "C:\\Users\\nguye\\AppData\\Local\\Temp", USERDOMAIN: "VANPC", USERDOMAIN_ROAMINGPROFILE: "VANPC", USERNAME: "nguye", USERPROFILE: "C:\\Users\\nguye", VSCODE_GIT_ASKPASS_EXTRA_ARGS: "", VSCODE_GIT_ASKPASS_MAIN: "c:\\Users\\nguye\\AppData\\Local\\Programs\\Microsoft VS Code\\resources\\app\\extensions\\git\\dist\\askpass-main.js", VSCODE_GIT_ASKPASS_NODE: "C:\\Users\\nguye\\AppData\\Local\\Programs\\Microsoft VS Code\\Code.exe", VSCODE_GIT_IPC_HANDLE: "\\\\.\\pipe\\vscode-git-2726f81895-sock", WINDIR: "C:\\WINDOWS", _: "/usr/bin/winpty" };
function CustomMultiTargetButton({
  buttonProps = {}
}) {
  const database = useDatabase();
  const { t: t2 } = useTranslation("page_character");
  const [show, onShow, onCloseModal] = useBoolState();
  const { teamChar, teamCharId } = reactExports.useContext(TeamCharacterContext);
  const [customMultiTargets, setCustomTargets] = reactExports.useState(
    () => teamChar.customMultiTargets
  );
  reactExports.useEffect(
    () => setCustomTargets(teamChar.customMultiTargets),
    [setCustomTargets, teamChar.customMultiTargets]
  );
  const addNewCustomMultiTarget = reactExports.useCallback(() => {
    setCustomTargets([initCustomMultiTarget(), ...customMultiTargets]);
  }, [customMultiTargets, setCustomTargets]);
  const setCustomMultiTarget = reactExports.useCallback(
    (ind) => (newTarget) => {
      const customTargets_ = [...customMultiTargets];
      customTargets_[ind] = newTarget;
      setCustomTargets(customTargets_);
    },
    [customMultiTargets, setCustomTargets]
  );
  const deleteCustomMultiTarget = reactExports.useCallback(
    (ind) => () => {
      if (customMultiTargets[ind].targets.length && !window.confirm(
        `Are you sure you want to delete "${customMultiTargets[ind].name}"?`
      ))
        return;
      const customTargets_ = [...customMultiTargets];
      customTargets_.splice(ind, 1);
      setCustomTargets(customTargets_);
    },
    [customMultiTargets, setCustomTargets]
  );
  const dupCustomMultiTarget = reactExports.useCallback(
    (ind) => () => {
      const customTargets_ = [...customMultiTargets];
      const newTarget = deepClone(customMultiTargets[ind]);
      newTarget.name = `${newTarget.name} (Duplicate)`;
      customTargets_.splice(ind, 0, newTarget);
      setCustomTargets(customTargets_);
    },
    [customMultiTargets, setCustomTargets]
  );
  const onClose = reactExports.useCallback(() => {
    onCloseModal();
    database.teamChars.set(teamCharId, {
      customMultiTargets
    });
  }, [database, teamCharId, customMultiTargets, onCloseModal]);
  const { data: origUIData, teamData } = reactExports.useContext(DataContext);
  const dataContextObj = reactExports.useMemo(() => {
    const origData = origUIData.data[0];
    const newData = {
      ...origData,
      hit: { ...origData.hit },
      infusion: { ...origData.infusion }
    };
    delete newData.hit.reaction;
    delete newData.infusion.team;
    return {
      data: new UIData(newData, void 0),
      teamData
    };
  }, [origUIData, teamData]);
  const customMultiTargetDisplays = reactExports.useMemo(
    () => customMultiTargets.map((ctar, i) => /* @__PURE__ */ jsx(
      Grid,
      {
        item: true,
        xs: 1,
        children: /* @__PURE__ */ jsx(
          CustomMultiTargetCard,
          {
            customMultiTarget: ctar,
            setTarget: setCustomMultiTarget(i),
            onDup: dupCustomMultiTarget(i),
            onDelete: deleteCustomMultiTarget(i)
          }
        )
      },
      `${i}${ctar.name}`
    )),
    [
      customMultiTargets,
      deleteCustomMultiTarget,
      dupCustomMultiTarget,
      setCustomMultiTarget
    ]
  );
  return /* @__PURE__ */ jsxs(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", height: "100%", width: 100 }),
      children: [
        /* @__PURE__ */ jsx(
          Button,
          {
            color: "info",
            onClick: onShow,
            startIcon: /* @__PURE__ */ jsx(default_1$k, {}),
            ...buttonProps,
            children: /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, children: [
              /* @__PURE__ */ jsx("span", { children: t2`multiTarget.title` }),
              /* @__PURE__ */ jsx(SqBadge, { color: customMultiTargets.length ? "success" : "secondary", children: customMultiTargets.length })
            ] })
          }
        ),
        /* @__PURE__ */ jsx(DataContext.Provider, { value: dataContextObj, children: /* @__PURE__ */ jsx(
          ModalWrapper,
          {
            open: show,
            onClose,
            containerProps: { sx: { overflow: "visible" } },
            children: /* @__PURE__ */ jsxs(CardThemed, { children: [
              /* @__PURE__ */ jsx(
                CardHeader,
                {
                  title: /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, alignItems: "center", children: [
                    /* @__PURE__ */ jsx(default_1$k, {}),
                    /* @__PURE__ */ jsx(Typography, { variant: "h6", children: t2`multiTarget.title` }),
                    /* @__PURE__ */ jsx(
                      InfoTooltip,
                      {
                        title: /* @__PURE__ */ jsxs(Typography, { children: [
                          /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "multiTarget.info1", children: [
                            "Note: Community created Multi-Optimization Targets can be found within the",
                            /* @__PURE__ */ jsx(
                              "a",
                              {
                                href: define_process_env_default.NX_URL_DISCORD_GO,
                                target: "_blank",
                                rel: "noreferrer",
                                children: "GO Discord"
                              }
                            ),
                            "or",
                            /* @__PURE__ */ jsx(
                              "a",
                              {
                                href: define_process_env_default.NX_URL_KQM_MULTI_GUIDE,
                                target: "_blank",
                                rel: "noreferrer",
                                children: "KQM Multi-Opt Guide"
                              }
                            ),
                            ", however the validity of such configurations cannot be guaranteed."
                          ] }),
                          /* @__PURE__ */ jsx("br", {}),
                          /* @__PURE__ */ jsx("br", {}),
                          t2("multiTarget.info2")
                        ] })
                      }
                    )
                  ] }),
                  action: /* @__PURE__ */ jsx(IconButton, { onClick: onClose, children: /* @__PURE__ */ jsx(default_1$a, {}) })
                }
              ),
              /* @__PURE__ */ jsx(Divider, {}),
              /* @__PURE__ */ jsx(
                CardContent,
                {
                  sx: { display: "flex", flexDirection: "column", gap: 1 },
                  children: /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Grid, { container: true, columns: { xs: 1, md: 2 }, spacing: 2, children: [
                    /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                      Button,
                      {
                        fullWidth: true,
                        onClick: addNewCustomMultiTarget,
                        startIcon: /* @__PURE__ */ jsx(default_1$i, {}),
                        children: t2`multiTarget.addNewMTarget`
                      }
                    ) }),
                    /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                      CustomMultiTargetImportBtn,
                      {
                        setCustomMultiTarget: setCustomMultiTarget(
                          customMultiTargets.length
                        ),
                        btnProps: { fullWidth: true }
                      }
                    ) }),
                    customMultiTargetDisplays
                  ] }) })
                }
              )
            ] })
          }
        ) })
      ]
    }
  );
}
const cols = {
  xs: 1,
  md: 2,
  lg: 3
};
function StatModal({ open, onClose }) {
  const { t: t2 } = useTranslation("page_character");
  return /* @__PURE__ */ jsx(ModalWrapper, { open, onClose, children: /* @__PURE__ */ jsxs(CardThemed, { children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, alignItems: "center" }, children: [
          /* @__PURE__ */ jsx(default_1$d, {}),
          /* @__PURE__ */ jsx("span", { children: t2`addStats.title` })
        ] }),
        action: /* @__PURE__ */ jsx(IconButton, { onClick: onClose, children: /* @__PURE__ */ jsx(default_1$a, {}) })
      }
    ),
    /* @__PURE__ */ jsx(CardContent, { sx: { pt: 0 }, children: /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, children: [
      /* @__PURE__ */ jsx(BonusStatsEditor, {}),
      /* @__PURE__ */ jsx(MainStatsCards, {})
    ] }) })
  ] }) });
}
const keys$6 = [...allInputPremodKeys];
const wrapperFunc = (e3, key) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: e3 }, key);
function BonusStatsEditor() {
  const { t: t2 } = useTranslation("page_character");
  const database = useDatabase();
  const {
    teamCharId,
    teamChar: { bonusStats }
  } = reactExports.useContext(TeamCharacterContext);
  const setFilter = (bonusStats2) => database.teamChars.set(teamCharId, { bonusStats: bonusStats2 });
  return /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(CardContent, { sx: { display: "flex" }, children: /* @__PURE__ */ jsxs(Grid, { container: true, columns: cols, sx: { pt: 1 }, spacing: 1, children: [
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsx(Alert, { severity: "info", variant: "filled", children: /* @__PURE__ */ jsxs(Trans, { i18nKey: "addStats.info", t: t2, children: [
      "You can use these fields to add buffs/debuffs not directly supported in GO, such as food buffs, abyss cards, or Superconduct. Please refer to the",
      /* @__PURE__ */ jsx("a", { href: "https://genshin-impact.fandom.com/wiki/Genshin_Impact_Wiki", children: "Genshin Impact Wiki" }),
      "for specific values."
    ] }) }) }),
    /* @__PURE__ */ jsx(
      StatEditorList,
      {
        statKeys: keys$6,
        statFilters: bonusStats,
        setStatFilters: setFilter,
        wrapperFunc,
        label: t2("addStats.label")
      }
    )
  ] }) }) });
}
const mainBaseKeys = ["hp", "atk", "def"];
const mainSubKeys = [
  "eleMas",
  "critRate_",
  "critDMG_",
  "enerRech_",
  "heal_"
];
const mainReadNodes = [...mainBaseKeys, ...mainSubKeys].map(
  (k2) => uiInput.total[k2]
);
const mainEditKeys = [
  "atk_",
  "atk",
  "hp_",
  "hp",
  "def_",
  "def",
  ...mainSubKeys
];
const otherStatKeys = [
  ...allEleDmgKeys,
  ...allEleResKeys,
  "stamina",
  "incHeal_",
  "shield_",
  "cdRed_"
];
const miscStatkeys = allInputPremodKeys.filter(
  (k2) => !mainEditKeys.includes(k2) && !otherStatKeys.includes(k2)
);
function StatDisplayContent({
  nodes,
  extra
}) {
  const { data, compareData } = reactExports.useContext(DataContext);
  return /* @__PURE__ */ jsxs(FieldDisplayList, { children: [
    nodes.map((rn) => /* @__PURE__ */ jsx(
      NodeFieldDisplay,
      {
        component: ListItem,
        calcRes: data.get(rn),
        compareCalcRes: compareData == null ? void 0 : compareData.get(rn)
      },
      JSON.stringify(rn.info)
    )),
    extra
  ] });
}
function MainStatsCards() {
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const { data } = reactExports.useContext(DataContext);
  const specialNode = data.get(uiInput.special);
  const charEle = getCharEle(characterKey);
  const isMelee = isCharMelee(characterKey);
  const otherStatReadNodes = reactExports.useMemo(() => {
    const nodes = otherStatKeys.filter((k2) => {
      if (k2.includes(charEle))
        return false;
      if (isMelee && k2.includes("physical"))
        return true;
      return true;
    }).map((k2) => uiInput.total[k2]);
    return nodes.filter((n2) => !!data.get(n2).value);
  }, [data, charEle, isMelee]);
  const miscStatReadNodes = reactExports.useMemo(
    () => miscStatkeys.map((k2) => uiInput.total[k2]).filter((n2) => data.get(n2).value),
    [data]
  );
  const { icon, variant, name } = (specialNode && resolveInfo(specialNode.info)) ?? {};
  return /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsxs(Grid, { container: true, columns: cols, spacing: 1, children: [
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(StatDisplayCard, { title: "Main Stats", children: /* @__PURE__ */ jsx(
      StatDisplayContent,
      {
        nodes: mainReadNodes,
        extra: specialNode && /* @__PURE__ */ jsxs(
          ListItem,
          {
            sx: { display: "flex", justifyContent: "space-between" },
            children: [
              /* @__PURE__ */ jsxs("span", { children: [
                /* @__PURE__ */ jsx("b", { children: "Special:" }),
                " ",
                /* @__PURE__ */ jsxs(
                  ColorText,
                  {
                    color: variant && variant === "invalid" ? void 0 : variant,
                    children: [
                      icon,
                      " ",
                      name
                    ]
                  }
                )
              ] }),
              /* @__PURE__ */ jsx("span", { children: getCalcDisplay(specialNode).valueString })
            ]
          }
        )
      }
    ) }) }),
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(StatDisplayCard, { title: "Other Stats", children: /* @__PURE__ */ jsx(StatDisplayContent, { nodes: otherStatReadNodes }) }) }),
    !!miscStatReadNodes.length && /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(StatDisplayCard, { title: "Misc Stats", children: /* @__PURE__ */ jsx(StatDisplayContent, { nodes: miscStatReadNodes }) }) })
  ] }) }) });
}
function StatDisplayCard({ title, children }) {
  return /* @__PURE__ */ jsxs(CardThemed, { children: [
    /* @__PURE__ */ jsx(CardContent, { sx: { py: 1 }, children: /* @__PURE__ */ jsx(Box, { display: "flex", justifyContent: "space-between", children: /* @__PURE__ */ jsx(Typography, { variant: "subtitle1", children: title }) }) }),
    children
  ] });
}
const columns = { xs: 1, sm: 1, md: 2, lg: 2 };
function LoadoutSettingElement() {
  const database = useDatabase();
  const { teamId, teamChar, teamCharId } = reactExports.useContext(TeamCharacterContext);
  const onChangeTeamCharId = (newTeamCharId) => {
    const index = database.teams.get(teamId).loadoutData.findIndex(
      (loadoutDatum) => (loadoutDatum == null ? void 0 : loadoutDatum.teamCharId) === teamCharId
    );
    if (index < 0)
      return;
    database.teams.set(teamId, (team) => {
      team.loadoutData[index] = { teamCharId: newTeamCharId };
    });
  };
  const elementKey = getCharEle(teamChar.key);
  return /* @__PURE__ */ jsxs(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 1e3 }),
      children: [
        /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", flexDirection: "column", gap: 2 }, children: [
          /* @__PURE__ */ jsx(LoadoutInfoAlert, {}),
          /* @__PURE__ */ jsx(
            LoadoutDropdown,
            {
              teamCharId,
              onChangeTeamCharId,
              dropdownBtnProps: {
                fullWidth: true,
                sx: { flexGrow: 1, backgroundColor: "contentLight.main" },
                color: elementKey ?? "info",
                variant: "outlined"
              },
              label: true
            }
          ),
          /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 2, flexWrap: "wrap", children: [
            /* @__PURE__ */ jsx(
              DetailStatButton,
              {
                buttonProps: {
                  sx: { backgroundColor: "contentLight.main", flexGrow: 1 },
                  color: elementKey ?? "info",
                  variant: "outlined"
                }
              }
            ),
            /* @__PURE__ */ jsx(
              CustomMultiTargetButton,
              {
                buttonProps: {
                  sx: { backgroundColor: "contentLight.main", flexGrow: 1 },
                  color: elementKey ?? "info",
                  variant: "outlined"
                }
              }
            ),
            /* @__PURE__ */ jsx(
              FormulasButton,
              {
                buttonProps: {
                  sx: { backgroundColor: "contentLight.main", flexGrow: 1 },
                  color: elementKey ?? "info",
                  variant: "outlined"
                }
              }
            )
          ] })
        ] }),
        /* @__PURE__ */ jsx(BuildManagementContent, {})
      ]
    }
  );
}
function BuildManagementContent() {
  const database = useDatabase();
  const {
    teamCharId,
    loadoutDatum,
    teamChar: { key: characterKey, buildIds, buildTcIds }
  } = reactExports.useContext(TeamCharacterContext);
  const weaponTypeKey = getCharStat(characterKey).weaponType;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, alignItems: "center" }, children: [
          /* @__PURE__ */ jsx(default_1$l, {}),
          /* @__PURE__ */ jsx("span", { children: "Build Management" })
        ] })
      }
    ),
    /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", flexDirection: "column", gap: 2 }, children: [
      /* @__PURE__ */ jsx(EquippedBuildInfoAlert, {}),
      /* @__PURE__ */ jsxs(Grid, { container: true, columns, spacing: 2, children: [
        /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(BuildEquipped, { active: (loadoutDatum == null ? void 0 : loadoutDatum.buildType) === "equipped" }) }),
        /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(AdResponsive, { dataAdSlot: "5385429639", bgt: "light" }) })
      ] }),
      /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 2 }, children: [
        /* @__PURE__ */ jsx(Typography, { variant: "h6", children: "Builds" }),
        /* @__PURE__ */ jsx(
          Button,
          {
            startIcon: /* @__PURE__ */ jsx(default_1$i, {}),
            color: "info",
            size: "small",
            onClick: () => database.teamChars.newBuild(teamCharId),
            children: "New Build"
          }
        )
      ] }),
      /* @__PURE__ */ jsx(BuildInfoAlert, {}),
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Grid, { container: true, columns, spacing: 2, children: buildIds.map((id) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
        BuildReal,
        {
          buildId: id,
          active: (loadoutDatum == null ? void 0 : loadoutDatum.buildType) === "real" && (loadoutDatum == null ? void 0 : loadoutDatum.buildId) === id
        }
      ) }, id)) }) }),
      /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 2 }, children: [
        /* @__PURE__ */ jsx(Typography, { variant: "h6", children: "TC Builds" }),
        /* @__PURE__ */ jsx(
          Button,
          {
            startIcon: /* @__PURE__ */ jsx(default_1$i, {}),
            color: "info",
            size: "small",
            onClick: () => database.teamChars.newBuildTcFromBuild(teamCharId, weaponTypeKey),
            children: "New TC Build"
          }
        )
      ] }),
      /* @__PURE__ */ jsx(TCBuildInfoAlert, {}),
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Grid, { container: true, columns, spacing: 2, children: buildTcIds.map((id) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
        BuildTc,
        {
          buildTcId: id,
          active: (loadoutDatum == null ? void 0 : loadoutDatum.buildType) === "tc" && (loadoutDatum == null ? void 0 : loadoutDatum.buildTcId) === id
        }
      ) }, id)) }) })
    ] })
  ] });
}
function DetailStatButton({ buttonProps = {} }) {
  const { t: t2 } = useTranslation("page_character");
  const [open, onOpen, onClose] = useBoolState();
  const {
    teamChar: { bonusStats }
  } = reactExports.useContext(TeamCharacterContext);
  const bStatsNum = Object.keys(bonusStats).length;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(
      Button,
      {
        color: "info",
        startIcon: /* @__PURE__ */ jsx(default_1$d, {}),
        onClick: onOpen,
        ...buttonProps,
        children: [
          t2`addStats.title`,
          !!bStatsNum && /* @__PURE__ */ jsx(SqBadge, { sx: { ml: 1 }, color: "success", children: bStatsNum })
        ]
      }
    ),
    /* @__PURE__ */ jsx(StatModal, { open, onClose })
  ] });
}
function FormulasButton({ buttonProps = {} }) {
  const { onModalOpen } = reactExports.useContext(FormulaDataContext);
  return /* @__PURE__ */ jsxs(
    Button,
    {
      color: "info",
      startIcon: /* @__PURE__ */ jsx(default_1$5, {}),
      onClick: onModalOpen,
      ...buttonProps,
      children: [
        "Show Formulas ",
        "&",
        " Calcs"
      ]
    }
  );
}
function pruneAll(nodes, minimum, arts, numTop, exclusion, forced) {
  let should = forced;
  const deps = {
    pruneOrder: { pruneNodeRange: true },
    pruneArtRange: { pruneNodeRange: true },
    pruneNodeRange: { reaffine: true },
    reaffine: { pruneOrder: true, pruneArtRange: true, pruneNodeRange: true }
  };
  let count = 0;
  while (Object.values(should).some((x2) => x2) && count++ < 20) {
    if (should.pruneOrder) {
      delete should.pruneOrder;
      const newArts = pruneOrder(arts, numTop, exclusion);
      if (arts !== newArts) {
        arts = newArts;
        should = { ...should, ...deps.pruneOrder };
      }
    }
    if (should.pruneArtRange) {
      delete should.pruneArtRange;
      const newArts = pruneArtRange(nodes, arts, minimum);
      if (arts !== newArts) {
        arts = newArts;
        should = { ...should, ...deps.pruneArtRange };
      }
    }
    if (should.pruneNodeRange) {
      delete should.pruneNodeRange;
      const newNodes = pruneNodeRange(nodes, arts);
      if (nodes !== newNodes) {
        nodes = newNodes;
        should = { ...should, ...deps.pruneNodeRange };
      }
    }
    if (should.reaffine) {
      delete should.reaffine;
      const { nodes: newNodes, arts: newArts } = reaffine(nodes, arts);
      if (nodes !== newNodes || arts !== newArts) {
        nodes = newNodes;
        arts = newArts;
        should = { ...should, ...deps.reaffine };
      }
    }
  }
  return { nodes, arts };
}
function pruneExclusion(nodes, exclusion) {
  const maxValues = {};
  for (const [key, e3] of Object.entries(exclusion)) {
    if (!e3.includes(4))
      continue;
    maxValues[key] = e3.includes(2) ? 1 : 3;
  }
  return mapFormulas(
    nodes,
    (f2) => f2,
    (f2) => {
      if (f2.operation !== "threshold")
        return f2;
      const [v2, t2, pass, fail] = f2.operands;
      if (v2.operation === "read" && t2.operation === "const") {
        const key = v2.path[v2.path.length - 1], thres = t2.value;
        if (key in maxValues) {
          const max2 = maxValues[key];
          if (max2 < thres)
            return fail;
          if (thres === 2 && exclusion[key].includes(2))
            return threshold$1(v2, 4, pass, fail);
        }
      }
      return f2;
    }
  );
}
function reaffine(nodes, arts, forceRename = false) {
  const affineNodes = /* @__PURE__ */ new Set(), topLevelAffine = /* @__PURE__ */ new Set();
  function visit(node, isAffine) {
    if (isAffine)
      affineNodes.add(node);
    else
      node.operands.forEach(
        (op) => affineNodes.has(op) && topLevelAffine.add(op)
      );
    return node;
  }
  const dynKeys = /* @__PURE__ */ new Set();
  nodes = mapFormulas(
    nodes,
    (_) => _,
    (f2) => {
      const { operation } = f2;
      switch (operation) {
        case "read":
          dynKeys.add(f2.path[1]);
          return visit(f2, true);
        case "add": {
          const affineOps = f2.operands.filter((op) => affineNodes.has(op));
          const nonAffineOps = f2.operands.filter((op) => !affineNodes.has(op));
          if (nonAffineOps.length === 0)
            return visit(f2, true);
          if (affineOps.length <= 1)
            return visit(f2, false);
          const affine2 = visit(sum(...affineOps), true);
          return visit(sum(affine2, ...nonAffineOps), false);
        }
        case "mul": {
          const nonConst = f2.operands.filter((op) => op.operation !== "const");
          return visit(
            f2,
            nonConst.length === 0 || nonConst.length === 1 && affineNodes.has(nonConst[0])
          );
        }
        case "const":
          return visit(f2, true);
        case "res":
        case "threshold":
        case "sum_frac":
        case "max":
        case "min":
          return visit(f2, false);
        default:
          assertUnreachable(operation);
      }
    }
  );
  nodes.filter((node) => affineNodes.has(node)).forEach((node) => topLevelAffine.add(node));
  if ([...topLevelAffine].every(
    ({ operation }) => operation === "read" || operation === "const"
  ) && Object.keys(arts.base).length === dynKeys.size)
    return { nodes, arts };
  let current = -1;
  function nextDynKey() {
    while (dynKeys.has(`${++current}`))
      ;
    return `${current}`;
  }
  const affine = [...topLevelAffine].filter((f2) => f2.operation !== "const");
  const affineMap = new Map(
    affine.map((node) => [
      node,
      !forceRename && node.operation === "read" && node.path[0] === "dyn" ? node : dynRead(nextDynKey())
    ])
  );
  nodes = mapFormulas(
    nodes,
    (f2) => affineMap.get(f2) ?? f2,
    (f2) => f2
  );
  function reaffineArt(stat) {
    const values = constantFold(
      [...affineMap.keys()],
      {
        dyn: objMap(stat, (value) => constant$4(value))
      },
      (_) => true
    );
    return Object.fromEntries(
      [...affineMap.values()].map((v2, i) => [
        v2.path[1],
        values[i].value
      ])
    );
  }
  const result = {
    nodes,
    arts: {
      base: reaffineArt(arts.base),
      values: objKeyMap(
        allArtifactSlotKeys,
        (slot) => arts.values[slot].map(({ id, set: set2, values }) => ({
          id,
          set: set2,
          values: reaffineArt(values)
        }))
      )
    }
  };
  const offsets = Object.entries(reaffineArt({}));
  for (const arts2 of Object.values(result.arts.values))
    for (const { values } of arts2)
      for (const [key, baseValue] of offsets)
        values[key] -= baseValue;
  return result;
}
function pruneOrder(arts, numTop, exclusion) {
  var _a;
  let progress = false;
  const allowRainbow = !((_a = exclusion.rainbow) == null ? void 0 : _a.length), keys2 = Object.keys(arts.base);
  const noSwitchIn = new Set(
    Object.entries(exclusion).filter(([_, v2]) => v2.length).map(([k2]) => k2)
  );
  const noSwitchOut = new Set(
    Object.entries(exclusion).filter(([_, v2]) => v2.includes(2) && !v2.includes(4)).map(([k2]) => k2)
  );
  const values = objKeyMap(allArtifactSlotKeys, (slot) => {
    const list = arts.values[slot];
    const newList = list.filter((art) => {
      let count = 0;
      return list.every((other) => {
        const otherBetterEqual = keys2.every(
          (k2) => (other.values[k2] ?? 0) >= (art.values[k2] ?? 0)
        );
        const otherMaybeBetter = keys2.some(
          (k2) => (other.values[k2] ?? 0) > (art.values[k2] ?? 0)
        );
        const otherBetter = otherBetterEqual && (otherMaybeBetter || other.id > art.id);
        const canSwitch = allowRainbow && !noSwitchIn.has(other.set) && !noSwitchOut.has(art.set) || art.set === other.set;
        if (otherBetter && canSwitch)
          count++;
        return count < numTop;
      });
    });
    if (newList.length !== list.length)
      progress = true;
    return newList;
  });
  return progress ? { base: arts.base, values } : arts;
}
function pruneArtRange(nodes, arts, minimum) {
  const baseRange2 = Object.fromEntries(
    Object.entries(arts.base).map(([key, x2]) => [key, { min: x2, max: x2 }])
  );
  const wrap = { arts };
  while (true) {
    const artRanges = objKeyMap(
      allArtifactSlotKeys,
      (slot) => computeArtRange(wrap.arts.values[slot])
    );
    const otherArtRanges = objKeyMap(
      allArtifactSlotKeys,
      (key) => addArtRange(
        Object.entries(artRanges).map((a2) => a2[0] === key ? baseRange2 : a2[1]).filter((x2) => x2)
      )
    );
    let progress = false;
    const values = objKeyMap(allArtifactSlotKeys, (slot) => {
      const result = wrap.arts.values[slot].filter((art) => {
        const read = addArtRange([computeArtRange([art]), otherArtRanges[slot]]);
        const newRange = computeNodeRange(nodes, read);
        return nodes.every(
          (node, i) => newRange.get(node).max >= (minimum[i] ?? -Infinity)
        );
      });
      if (result.length !== wrap.arts.values[slot].length)
        progress = true;
      return result;
    });
    if (!progress)
      break;
    wrap.arts = { base: wrap.arts.base, values };
  }
  return wrap.arts;
}
function pruneNodeRange(nodes, arts) {
  const baseRange2 = Object.fromEntries(
    Object.entries(arts.base).map(([key, x2]) => [key, { min: x2, max: x2 }])
  );
  const reads = addArtRange([
    baseRange2,
    ...Object.values(arts.values).map((values) => computeArtRange(values))
  ]);
  const nodeRange = computeNodeRange(nodes, reads);
  return mapFormulas(
    nodes,
    (f2) => {
      {
        const { min: min2, max: max2 } = nodeRange.get(f2);
        if (min2 === max2)
          return constant$4(min2);
      }
      const { operation } = f2;
      const operandRanges = f2.operands.map((x2) => nodeRange.get(x2));
      switch (operation) {
        case "threshold": {
          const [value, threshold2, pass, fail] = operandRanges;
          if (value.min >= threshold2.max)
            return f2.operands[2];
          else if (value.max < threshold2.min)
            return f2.operands[3];
          if (pass.max === pass.min && fail.max === fail.min && pass.min === fail.min && isFinite(pass.min))
            return constant$4(pass.max);
          break;
        }
        case "min": {
          const newOperands = f2.operands.filter((_, i) => {
            const op1 = operandRanges[i];
            return operandRanges.every((op2) => op1.min <= op2.max);
          });
          if (newOperands.length < operandRanges.length)
            return min$2(...newOperands);
          break;
        }
        case "max": {
          const newOperands = f2.operands.filter((_, i) => {
            const op1 = operandRanges[i];
            return operandRanges.every((op2) => op1.max >= op2.min);
          });
          if (newOperands.length < operandRanges.length)
            return max$2(...newOperands);
          break;
        }
      }
      return f2;
    },
    (f2) => f2
  );
}
function addArtRange(ranges) {
  const result = {};
  ranges.forEach((range22) => {
    Object.entries(range22).forEach(([key, value]) => {
      if (result[key]) {
        result[key].min += value.min;
        result[key].max += value.max;
      } else
        result[key] = { ...value };
    });
  });
  return result;
}
function computeArtRange(arts) {
  const result = {};
  if (arts.length) {
    Object.keys(arts[0].values).filter((key) => arts.every((art) => art.values[key])).forEach(
      (key) => result[key] = { min: arts[0].values[key], max: arts[0].values[key] }
    );
    arts.forEach(({ values }) => {
      for (const [key, value] of Object.entries(values)) {
        if (!result[key])
          result[key] = { min: 0, max: value };
        else {
          if (result[key].max < value)
            result[key].max = value;
          if (result[key].min > value)
            result[key].min = value;
        }
      }
    });
  }
  return result;
}
function computeNodeRange(nodes, reads) {
  const range22 = /* @__PURE__ */ new Map();
  forEachNodes(
    nodes,
    (_) => {
    },
    (f2) => {
      const { operation } = f2;
      const operands = f2.operands.map((op) => range22.get(op));
      let current;
      switch (operation) {
        case "read":
          if (f2.path[0] !== "dyn")
            throw new Error(
              `Found non-dyn path ${f2.path} while computing range`
            );
          current = reads[f2.path[1]] ?? { min: 0, max: 0 };
          break;
        case "const":
          current = computeMinMax([f2.value]);
          break;
        case "add":
        case "min":
        case "max":
          current = {
            min: allOperations[operation](operands.map((x2) => x2.min)),
            max: allOperations[operation](operands.map((x2) => x2.max))
          };
          break;
        case "res":
          current = {
            min: allOperations[operation]([operands[0].max]),
            max: allOperations[operation]([operands[0].min])
          };
          break;
        case "mul":
          current = operands.reduce(
            (accu, current2) => computeMinMax([
              accu.min * current2.min,
              accu.min * current2.max,
              accu.max * current2.min,
              accu.max * current2.max
            ])
          );
          break;
        case "threshold":
          if (operands[0].min >= operands[1].max)
            current = operands[2];
          else if (operands[0].max < operands[1].min)
            current = operands[3];
          else
            current = computeMinMax([], [operands[2], operands[3]]);
          break;
        case "sum_frac": {
          const [x2, c2] = operands, sum2 = { min: x2.min + c2.min, max: x2.max + c2.max };
          if (sum2.min <= 0 && sum2.max >= 0)
            current = x2.min <= 0 && x2.max >= 0 ? { min: NaN, max: NaN } : { min: -Infinity, max: Infinity };
          else
            current = computeMinMax([
              x2.min / sum2.min,
              x2.min / sum2.max,
              x2.max / sum2.min,
              x2.max / sum2.max
            ]);
          break;
        }
        default:
          assertUnreachable(operation);
      }
      range22.set(f2, current);
    }
  );
  return range22;
}
function computeMinMax(values, minMaxes = []) {
  const max2 = Math.max(...values, ...minMaxes.map((x2) => x2.max));
  const min2 = Math.min(...values, ...minMaxes.map((x2) => x2.min));
  return { min: min2, max: max2 };
}
function mergeBuilds(builds, maxNum) {
  return builds.flatMap((x2) => x2).sort((a2, b2) => b2.value - a2.value).slice(0, maxNum);
}
function mergePlot(plots) {
  let scale2 = 0.01;
  const reductionScaling = 2, maxCount = 1500;
  let keys2 = new Set(
    plots.flatMap(
      (x2) => Object.values(x2).map((v2) => v2 && Math.round(v2.plot / scale2))
    )
  );
  while (keys2.size > maxCount) {
    scale2 *= reductionScaling;
    keys2 = new Set(
      [...keys2].filter(notEmpty).map((key) => Math.round(key / reductionScaling))
    );
  }
  const result = {};
  for (const plot of plots)
    for (const build of Object.values(plot)) {
      if (!build)
        continue;
      const x2 = Math.round(build.plot / scale2) * scale2;
      if (!result[x2] || result[x2].value < build.value)
        result[x2] = build;
    }
  return result;
}
class WorkerCoordinator {
  constructor(workers, prio, callback) {
    this.workDone = /* @__PURE__ */ new Map();
    this.commands = prio.map((_) => new FIFO());
    this.prio = new Map(prio.map((p2, i) => [p2, i]));
    this.callback = callback;
    workers.forEach((worker) => {
      worker.onmessage = (x2) => this.onMessage(x2.data, worker);
      worker.onerror = (e3) => this.onError(e3);
    });
    this._workers = workers;
    this.workers = workers.map((w2) => Promise.resolve(w2));
    this.cancel = () => {
    };
    this.cancelled = new Promise((_, rej) => this.cancel = rej);
    this.cancelled.catch((_) => workers.forEach((w2) => w2.terminate()));
  }
  /**
   * Send `commands` to available workers. If a worker sends back a `Command`,
   * that command is further sent to an available worker (may be the same worker).
   * If a worker sends back a `Response`, `this.callback` is invoked.
   *
   * Note that `{ resultType: 'done' }` is a special type that the worker is
   * expected to send back when completing its `command`.
   */
  async execute(commands) {
    var _a;
    const processingInput = (async () => {
      for await (const command of commands)
        this.add(command);
    })();
    while (true) {
      const command = (_a = this.commands.find((x2) => x2.length)) == null ? void 0 : _a.pop();
      if (command === void 0) {
        const hasCommand = await Promise.race([
          new Promise(
            (res) => this.notifyNonEmpty = () => res(true)
          ),
          Promise.all([...this.workers, processingInput]).then((_) => false),
          this.cancelled
        ]);
        this.notifyNonEmpty = void 0;
        if (hasCommand)
          continue;
        break;
      }
      const { i, w: w2 } = await Promise.race([
        ...this.workers.map((w22, i2) => w22.then((w3) => ({ i: i2, w: w3 }))),
        this.cancelled
      ]);
      this.workers[i] = new Promise((res) => this.workDone.set(w2, () => res(w2)));
      w2.postMessage(command);
    }
  }
  onError(e3) {
    this.cancel(new Error(`Worker Error: ${e3.message}`));
  }
  onMessage(msg, worker) {
    if (msg.command !== void 0)
      this.add(msg);
    else if (msg.resultType === "done")
      this.workDone.get(worker)();
    else
      this.callback(msg, worker);
  }
  /** May be ignored after `execute` ends */
  add(command) {
    var _a;
    const prio = this.prio.get(command.command);
    this.commands[prio].push(command);
    (_a = this.notifyNonEmpty) == null ? void 0 : _a.call(this);
  }
  /** May be ignored after `execute` ends */
  broadcast(command) {
    this._workers.forEach((w2) => w2.postMessage(command));
  }
  /** MUST be followed by `execute` and cannot be called while `execute` is running */
  notifiedBroadcast(command) {
    this.workers = this.workers.map(
      (worker) => worker.then(
        (w2) => new Promise((res) => {
          this.workDone.set(w2, () => res(w2));
        })
      )
    );
    this._workers.forEach((w2) => w2.postMessage(command));
  }
}
class GOSolver extends WorkerCoordinator {
  constructor(problem, status, numWorker) {
    const workers = Array(numWorker).fill(NaN).map(
      (_) => new Worker(new URL("" + new URL("BackgroundWorker-EKKbLzgr.js", import.meta.url).href, import.meta.url), {
        type: "module"
      })
    );
    super(workers, ["iterate", "split", "count"], (r2, w2) => {
      switch (r2.resultType) {
        case "interim":
          this.interim(r2, w2);
          break;
        case "finalize":
          this.finalizedResults.push(r2);
          break;
        case "count":
          this.status.total = r2.count;
          break;
        case "err":
          this.onError(r2);
          break;
      }
    });
    this.maxIterateSize = 32e6;
    this.finalizedResults = [];
    const { exclusion, topN } = problem;
    this.status = status;
    this.exclusion = exclusion;
    this.topN = topN;
    this.status.total = NaN;
    this.buildValues = Array(topN).fill({ w: void 0, val: -Infinity });
    this.notifiedBroadcast(this.preprocess(problem));
  }
  async solve() {
    const { exclusion, maxIterateSize } = this;
    this.finalizedResults = [];
    await this.execute([{ command: "count", exclusion, maxIterateSize }]);
    this.notifiedBroadcast({ command: "finalize" });
    await this.execute([]);
    return this.finalizedResults;
  }
  preprocess({
    plotBase,
    optimizationTarget,
    arts,
    topN,
    exclusion,
    constraints
  }) {
    constraints = constraints.filter((x2) => x2.min > -Infinity);
    let nodes = [...constraints.map((x2) => x2.value), optimizationTarget];
    const minimums = [...constraints.map((x2) => x2.min), -Infinity];
    if (plotBase) {
      nodes.push(plotBase);
      minimums.push(-Infinity);
    }
    nodes = pruneExclusion(nodes, exclusion);
    nodes = optimize(nodes, {}, (_) => false);
    ({ nodes, arts } = pruneAll(nodes, minimums, arts, topN, exclusion, {
      reaffine: true,
      pruneArtRange: true,
      pruneNodeRange: true,
      pruneOrder: true
    }));
    nodes = optimize(nodes, {}, (_) => false);
    if (plotBase)
      plotBase = nodes.pop();
    const optTarget = nodes.pop();
    return {
      command: "setup",
      arts,
      optTarget,
      plotBase,
      topN,
      constraints: nodes.map((value, i) => ({ value, min: minimums[i] }))
    };
  }
  /** Returns a new `threshold` if altered */
  interim(r2, worker) {
    this.status.tested += r2.tested;
    this.status.failed += r2.failed;
    this.status.skipped += r2.skipped;
    if (r2.buildValues) {
      const { topN } = this, oldThreshold = this.buildValues[topN - 1].val ?? -Infinity;
      this.buildValues.filter(({ w: w2 }) => w2 !== worker);
      this.buildValues.push(
        ...r2.buildValues.map((val) => ({ w: worker, val }))
      );
      this.buildValues.sort((a2, b2) => b2.val - a2.val).splice(topN);
      const threshold2 = this.buildValues[topN - 1].val ?? -Infinity;
      if (oldThreshold !== threshold2)
        this.broadcast({ command: "threshold", threshold: threshold2 });
    }
  }
}
const dynamic = setReadNodeKeys(
  deepClone({ dyn: { ...input.art, ...input.artSet } })
);
const dynamicData = {
  art: objKeyMap(
    [...allMainStatKeys, ...allSubstatKeys],
    (key) => dynamic.dyn[key]
  ),
  artSet: objMap(input.artSet, (_, key) => dynamic.dyn[key])
};
function compactArtifacts(arts, mainStatAssumptionLevel, allowPartial) {
  const result = {
    base: {},
    values: { flower: [], plume: [], goblet: [], circlet: [], sands: [] }
  };
  const keys2 = /* @__PURE__ */ new Set();
  for (const art of arts) {
    const mainStatVal = getMainStatValue(
      art.mainStatKey,
      art.rarity,
      Math.max(
        Math.min(mainStatAssumptionLevel, artMaxLevel[art.rarity]),
        art.level
      )
    );
    const data = {
      id: art.id,
      set: art.setKey,
      values: {
        [art.setKey]: 1,
        [art.mainStatKey]: mainStatVal,
        ...Object.fromEntries(
          art.substats.map((substat) => [
            substat.key,
            substat.key.endsWith("_") ? substat.accurateValue / 100 : substat.accurateValue
          ])
        )
      }
    };
    delete data.values[""];
    result.values[art.slotKey].push(data);
    Object.keys(data.values).forEach((x2) => keys2.add(x2));
  }
  result.base = objKeyMap([...keys2], (_) => 0);
  if (allowPartial)
    for (const value of Object.values(result.values))
      value.push({ id: "", values: {} });
  return result;
}
function optimizeTcGetNodes(teamDataProp, characterKey, buildTc, optimizationTarget) {
  var _a;
  const {
    artifact: { sets: artSets },
    optimization: { minTotal }
  } = buildTc;
  if (!optimizationTarget)
    return {};
  const workerData = (_a = teamDataProp[characterKey]) == null ? void 0 : _a.target.data[0];
  if (!workerData)
    return {};
  Object.assign(workerData, mergeData([workerData, dynamicData]));
  const unoptimizedOptimizationTargetNode = objPathValue(
    workerData.display ?? {},
    optimizationTarget
  );
  if (!unoptimizedOptimizationTargetNode)
    return {};
  const constraints = Object.keys(minTotal).map((k2) => workerData.total[k2]).filter((n2) => n2);
  let nodes = optimize(
    [unoptimizedOptimizationTargetNode, ...constraints],
    workerData,
    ({ path: [p2] }) => p2 !== "dyn"
  );
  nodes = mapFormulas(
    nodes,
    (f2) => {
      if (f2.operation === "read" && f2.path[0] === "dyn") {
        const a2 = artSets[f2.path[1]];
        if (a2)
          return constant$4(a2);
        if (!allSubstatKeys.includes(f2.path[1]))
          return constant$4(0);
      }
      return f2;
    },
    (f2) => f2
  );
  nodes = optimize(nodes, {}, (_) => false);
  return {
    nodes
  };
}
function getScalesWith(nodes) {
  const scalesWith = /* @__PURE__ */ new Set();
  precompute(
    nodes,
    {},
    (f2) => {
      const val = f2.path[1];
      scalesWith.add(val);
      return val;
    },
    1
  );
  return scalesWith;
}
function getMinSubAndOtherRolls(charTC) {
  const {
    artifact: {
      slots,
      substats: { stats: substats, type: substatsType, rarity }
    }
  } = charTC;
  const existingRolls = objMap(
    substats,
    (v2, k2) => Math.ceil(substats[k2] / getSubstatValue(k2, rarity, substatsType))
  );
  const mainStatsCount = getMainStatsCount(slots);
  const minSubLines = getMinSubLines(slots);
  return {
    minSubLines,
    minOtherRolls: getMinOtherRolls(
      Object.entries(existingRolls),
      mainStatsCount,
      minSubLines
    )
  };
}
function getMinOtherRolls(subsRolls, mainStatsCount, minSublines = 4 * 5) {
  const maxSubSlots = subsRolls.reduce((accu, [k2, v2]) => {
    const maxStatSlot = 5 - (mainStatsCount[k2] ?? 0);
    return accu + Math.min(v2, maxStatSlot);
  }, 0);
  return minSublines - maxSubSlots;
}
function getMinSubLines(slots) {
  return Object.values(slots).reduce((minSubLines, { rarity, level }) => {
    const { high, low } = artSubstatRollData[rarity];
    return minSubLines + (level >= 4 ? high : low);
  }, 0);
}
function getMainStatsCount(slots) {
  const mainStatsCount = {};
  Object.values(slots).forEach(({ statKey }) => {
    mainStatsCount[statKey] = (mainStatsCount[statKey] ?? 0) + 1;
  }, 0);
  return mainStatsCount;
}
const TCWorker = () => new Worker(new URL("" + new URL("optimizeTcWorker-n9UISdw0.js", import.meta.url).href, import.meta.url), {
  type: "module"
});
var NotificationsActive = {};
var _interopRequireDefault$4 = interopRequireDefaultExports;
Object.defineProperty(NotificationsActive, "__esModule", {
  value: true
});
var default_1$3 = NotificationsActive.default = void 0;
var _createSvgIcon$3 = _interopRequireDefault$4(requireCreateSvgIcon());
var _jsxRuntime$3 = jsxRuntimeExports;
var _default$3 = (0, _createSvgIcon$3.default)(/* @__PURE__ */ (0, _jsxRuntime$3.jsx)("path", {
  d: "M7.58 4.08 6.15 2.65C3.75 4.48 2.17 7.3 2.03 10.5h2c.15-2.65 1.51-4.97 3.55-6.42zm12.39 6.42h2c-.15-3.2-1.73-6.02-4.12-7.85l-1.42 1.43c2.02 1.45 3.39 3.77 3.54 6.42zM18 11c0-3.07-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68C7.63 5.36 6 7.92 6 11v5l-2 2v1h16v-1l-2-2v-5zm-6 11c.14 0 .27-.01.4-.04.65-.14 1.18-.58 1.44-1.18.1-.24.15-.5.15-.78h-4c.01 1.1.9 2 2.01 2z"
}), "NotificationsActive");
default_1$3 = NotificationsActive.default = _default$3;
var NotificationsOff = {};
var _interopRequireDefault$3 = interopRequireDefaultExports;
Object.defineProperty(NotificationsOff, "__esModule", {
  value: true
});
var default_1$2 = NotificationsOff.default = void 0;
var _createSvgIcon$2 = _interopRequireDefault$3(requireCreateSvgIcon());
var _jsxRuntime$2 = jsxRuntimeExports;
var _default$2 = (0, _createSvgIcon$2.default)(/* @__PURE__ */ (0, _jsxRuntime$2.jsx)("path", {
  d: "M20 18.69 7.84 6.14 5.27 3.49 4 4.76l2.8 2.8v.01c-.52.99-.8 2.16-.8 3.42v5l-2 2v1h13.73l2 2L21 19.72l-1-1.03zM12 22c1.11 0 2-.89 2-2h-4c0 1.11.89 2 2 2zm6-7.32V11c0-3.08-1.64-5.64-4.5-6.32V4c0-.83-.67-1.5-1.5-1.5s-1.5.67-1.5 1.5v.68c-.15.03-.29.08-.42.12-.1.03-.2.07-.3.11h-.01c-.01 0-.01 0-.02.01-.23.09-.46.2-.68.31 0 0-.01 0-.01.01L18 14.68z"
}), "NotificationsOff");
default_1$2 = NotificationsOff.default = _default$2;
function useCompareData() {
  const database = useDatabase();
  const {
    teamId,
    teamCharId,
    loadoutDatum,
    team: { loadoutData },
    teamChar: { key: characterKey }
  } = reactExports.useContext(TeamCharacterContext);
  const { gender } = useDBMeta();
  const [dbDirty, setDbDirty] = useForceUpdate();
  const dbDirtyDeferred = reactExports.useDeferredValue(dbDirty);
  reactExports.useEffect(
    () => teamId ? database.teams.follow(teamId, setDbDirty) : void 0,
    [teamId, setDbDirty, database]
  );
  reactExports.useEffect(() => {
    if (!dbDirty)
      return () => {
      };
    const unfollowTeamChars = loadoutData.map((loadoutDatum2) => {
      if (!loadoutDatum2)
        return () => {
        };
      const unfollowTeamChar = loadoutDatum2 ? database.teamChars.follow(loadoutDatum2.teamCharId, setDbDirty) : () => {
      };
      const unfollowChar = loadoutDatum2 ? database.teamChars.followChar(loadoutDatum2.teamCharId, setDbDirty) : () => {
      };
      const unfollowBuild = loadoutDatum2 ? loadoutDatum2.teamCharId === teamCharId ? database.teams.followLoadoutDatumCompare(loadoutDatum2, setDbDirty) : database.teams.followLoadoutDatum(loadoutDatum2, setDbDirty) : () => {
      };
      return () => {
        unfollowTeamChar();
        unfollowChar();
        unfollowBuild();
      };
    });
    return () => {
      unfollowTeamChars.forEach((unfollow) => unfollow());
    };
  }, [dbDirty, teamCharId, database, loadoutData, setDbDirty]);
  return reactExports.useMemo(() => {
    if (!dbDirtyDeferred)
      return void 0;
    const { compare, compareType, compareBuildId, compareBuildTcId } = loadoutDatum;
    if (!compare)
      return void 0;
    const { overrideArt, overrideWeapon, overrideCharacter } = (() => {
      const char = database.chars.get(characterKey);
      switch (compareType) {
        case "equipped": {
          return {
            overrideArt: Object.values(char.equippedArtifacts).map((id) => database.arts.get(id)).filter((a2) => a2),
            overrideWeapon: database.weapons.get(char.equippedWeapon),
            overrideCharacter: char
          };
        }
        case "real": {
          const build = database.builds.get(compareBuildId);
          return {
            overrideArt: Object.values(build.artifactIds).map((id) => database.arts.get(id)).filter((a2) => a2),
            overrideWeapon: database.weapons.get(build.weaponId),
            overrideCharacter: char
          };
        }
        case "tc": {
          const buildTc = database.buildTcs.get(compareBuildTcId);
          return {
            overrideArt: getBuildTcArtifactData(buildTc),
            overrideWeapon: {
              ...buildTc.weapon,
              location: charKeyToLocCharKey(characterKey)
            },
            overrideCharacter: buildTc.character ?? char
          };
        }
      }
    })();
    const teamData = getTeamDataCalc(
      database,
      teamId,
      gender,
      teamCharId,
      0,
      overrideArt,
      overrideWeapon,
      overrideCharacter
    );
    if (!teamData)
      return void 0;
    const charUIData = teamData[characterKey].target;
    return charUIData;
  }, [
    dbDirtyDeferred,
    loadoutDatum,
    database,
    teamId,
    gender,
    teamCharId,
    characterKey
  ]);
}
function CompareBtn({
  buttonGroupProps = {}
}) {
  var _a, _b;
  const database = useDatabase();
  const {
    teamId,
    teamCharId,
    loadoutDatum,
    teamChar: { buildIds, buildTcIds }
  } = reactExports.useContext(TeamCharacterContext);
  const {
    buildType,
    buildId,
    buildTcId,
    compare,
    compareType,
    compareBuildId,
    compareBuildTcId
  } = loadoutDatum;
  const selectedLabel = compareType === "real" ? ((_a = database.builds.get(compareBuildId)) == null ? void 0 : _a.name) ?? "" : compareType === "tc" ? /* @__PURE__ */ jsxs("span", { children: [
    ((_b = database.buildTcs.get(compareBuildTcId)) == null ? void 0 : _b.name) ?? "",
    " ",
    /* @__PURE__ */ jsx(SqBadge, { color: "info", sx: { ml: 1 }, children: "TC" })
  ] }) : "Equipped";
  const current = compareType === "equipped" && buildType === "equipped" || compareType === "real" && buildType === "real" && buildId === compareBuildId || compareType === "tc" && buildType === "tc" && buildTcId === compareBuildTcId;
  return /* @__PURE__ */ jsxs(ButtonGroup, { ...buttonGroupProps, children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        startIcon: compare ? /* @__PURE__ */ jsx(default_1$m, {}) : /* @__PURE__ */ jsx(default_1$n, {}),
        color: compare ? "success" : "secondary",
        onClick: () => database.teams.setLoadoutDatum(teamId, teamCharId, {
          compare: !compare
        }),
        children: "Compare"
      }
    ),
    /* @__PURE__ */ jsxs(
      DropdownButton,
      {
        title: /* @__PURE__ */ jsxs(Fragment, { children: [
          selectedLabel,
          " ",
          current && /* @__PURE__ */ jsx(SqBadge, { color: "info", sx: { ml: 1 }, children: "Current" })
        ] }),
        disabled: !compare || !buildIds.length && !buildTcIds.length,
        children: [
          /* @__PURE__ */ jsxs(
            MenuItem,
            {
              onClick: () => database.teams.setLoadoutDatum(teamId, teamCharId, {
                compareType: "equipped"
              }),
              children: [
                "Equipped",
                " ",
                buildType === "equipped" && /* @__PURE__ */ jsx(SqBadge, { color: "info", sx: { ml: 1 }, children: "Current" })
              ]
            }
          ),
          buildIds.map((bId) => {
            var _a2;
            return /* @__PURE__ */ jsxs(
              MenuItem,
              {
                disabled: !((_a2 = database.builds.get(bId)) == null ? void 0 : _a2.weaponId),
                onClick: () => database.teams.setLoadoutDatum(teamId, teamCharId, {
                  compareType: "real",
                  compareBuildId: bId
                }),
                children: [
                  database.builds.get(bId).name,
                  " ",
                  buildType === "real" && bId === buildId && /* @__PURE__ */ jsx(SqBadge, { color: "info", sx: { ml: 1 }, children: "Current" })
                ]
              },
              bId
            );
          }),
          buildTcIds.map((bTcId) => {
            var _a2;
            return /* @__PURE__ */ jsxs(
              MenuItem,
              {
                onClick: () => database.teams.setLoadoutDatum(teamId, teamCharId, {
                  compareType: "tc",
                  compareBuildTcId: bTcId
                }),
                children: [
                  ((_a2 = database.buildTcs.get(bTcId)) == null ? void 0 : _a2.name) ?? "",
                  " ",
                  /* @__PURE__ */ jsx(SqBadge, { color: "info", sx: { ml: 1 }, children: "TC" }),
                  buildType === "tc" && bTcId === buildTcId && /* @__PURE__ */ jsx(SqBadge, { color: "info", sx: { ml: 1 }, children: "Current" })
                ]
              },
              bTcId
            );
          })
        ]
      }
    )
  ] });
}
function ArtifactSetConfig({
  disabled
}) {
  var _a, _b;
  const { t: t2 } = useTranslation(["page_character_optimize", "sheet"]);
  const dataContext = reactExports.useContext(DataContext);
  const database = useDatabase();
  const {
    teamChar: { conditional, optConfigId },
    teamCharId
  } = reactExports.useContext(TeamCharacterContext);
  const { artSetExclusion } = useOptConfig(optConfigId);
  const [open, setOpen] = reactExports.useState(false);
  const onOpen = reactExports.useCallback(() => setOpen(true), [setOpen]);
  const onClose = reactExports.useCallback(() => setOpen(false), [setOpen]);
  const [dbDirty, forceUpdate] = useForceUpdate();
  reactExports.useEffect(() => database.arts.followAny(forceUpdate), [database, forceUpdate]);
  const artKeysByRarity = reactExports.useMemo(
    () => Object.entries(setKeysByRarities).reverse().flatMap(([, sets]) => sets).filter((key) => !key.includes("Prayers")),
    []
  );
  const { artKeys, artSlotCount } = reactExports.useMemo(() => {
    const artSlotCount2 = objKeyMap(
      artKeysByRarity,
      (_) => objKeyMap(allArtifactSlotKeys, (_2) => 0)
    );
    database.arts.values.forEach(
      (art) => artSlotCount2[art.setKey] && artSlotCount2[art.setKey][art.slotKey]++
    );
    const artKeys2 = [...artKeysByRarity].sort(
      (a2, b2) => +(getNumSlots(artSlotCount2[a2]) < 2) - +(getNumSlots(artSlotCount2[b2]) < 2)
    );
    return dbDirty && { artKeys: artKeys2, artSlotCount: artSlotCount2 };
  }, [dbDirty, database, artKeysByRarity]);
  const allowRainbow2 = !((_a = artSetExclusion.rainbow) == null ? void 0 : _a.includes(2));
  const allowRainbow4 = !((_b = artSetExclusion.rainbow) == null ? void 0 : _b.includes(4));
  const { allowTotals } = reactExports.useMemo(() => {
    const catKeys = { allowTotals: ["2", "4"] };
    return bulkCatTotal(
      catKeys,
      (ctMap) => artKeysByRarity.forEach((setKey) => {
        var _a2, _b2;
        ctMap.allowTotals["2"].total++;
        if (!((_a2 = artSetExclusion[setKey]) == null ? void 0 : _a2.includes(2))) {
          ctMap.allowTotals["2"].current++;
        }
        ctMap.allowTotals["4"].total++;
        if (!((_b2 = artSetExclusion[setKey]) == null ? void 0 : _b2.includes(4))) {
          ctMap.allowTotals["4"].current++;
        }
      })
    );
  }, [artKeysByRarity, artSetExclusion]);
  const artifactCondCount = reactExports.useMemo(
    () => Object.keys(conditional).filter(
      (k2) => allArtifactSetKeys.includes(k2) && !!Object.keys(conditional[k2] ?? {}).length
    ).length,
    [conditional]
  );
  const fakeDataContextObj = reactExports.useMemo(
    () => ({
      ...dataContext,
      data: new UIData(
        {
          ...dataContext.data.data[0],
          artSet: objKeyMap(allArtifactSetKeys, (_) => constant$4(4))
        },
        void 0
      )
    }),
    [dataContext]
  );
  const resetArtConds = reactExports.useCallback(() => {
    const tconditional = Object.fromEntries(
      Object.entries(conditional).filter(
        ([k2]) => !allArtifactSetKeys.includes(k2)
      )
    );
    database.teamChars.set(teamCharId, (teamChar) => {
      teamChar.conditional = tconditional;
    });
  }, [database, teamCharId, conditional]);
  const setAllExclusion = reactExports.useCallback(
    (setnum, exclude = true) => {
      const artSetExclusion_ = deepClone(artSetExclusion);
      artKeysByRarity.forEach((k2) => {
        if (exclude)
          artSetExclusion_[k2] = [...artSetExclusion_[k2] ?? [], setnum];
        else if (artSetExclusion_[k2])
          artSetExclusion_[k2] = artSetExclusion_[k2].filter((n2) => n2 !== setnum);
      });
      database.optConfigs.set(optConfigId, {
        artSetExclusion: artSetExclusion_
      });
    },
    [artKeysByRarity, artSetExclusion, database, optConfigId]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", sx: { display: "flex", width: "100%" }, children: [
      /* @__PURE__ */ jsxs(CardContent, { sx: { flexGrow: 1 }, children: [
        /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx("strong", { children: t2`artSetConfig.title` }) }),
        /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, children: [
          /* @__PURE__ */ jsxs(Typography, { children: [
            t2`artSetConfig.setEffCond`,
            " ",
            /* @__PURE__ */ jsxs(SqBadge, { color: artifactCondCount ? "success" : "warning", children: [
              artifactCondCount,
              " ",
              t2("artSetConfig.enabled")
            ] })
          ] }),
          /* @__PURE__ */ jsxs(Typography, { children: [
            t2`sheet:2set`,
            " ",
            /* @__PURE__ */ jsxs(SqBadge, { color: "success", children: [
              allowTotals["2"],
              " ",
              /* @__PURE__ */ jsx(default_1$o, { ...iconInlineProps }),
              " ",
              t2("artSetConfig.allowed")
            ] })
          ] }),
          /* @__PURE__ */ jsxs(Typography, { children: [
            t2`sheet:4set`,
            " ",
            /* @__PURE__ */ jsxs(SqBadge, { color: "success", children: [
              allowTotals["4"],
              " ",
              /* @__PURE__ */ jsx(default_1$o, { ...iconInlineProps }),
              " ",
              t2("artSetConfig.allowed")
            ] })
          ] }),
          /* @__PURE__ */ jsxs(Typography, { children: [
            t2`artSetConfig.2rainbow`,
            " ",
            /* @__PURE__ */ jsxs(SqBadge, { color: allowRainbow2 ? "success" : "secondary", children: [
              allowRainbow2 ? /* @__PURE__ */ jsx(default_1$o, { ...iconInlineProps }) : /* @__PURE__ */ jsx(default_1$p, { ...iconInlineProps }),
              " ",
              allowRainbow2 ? t2("artSetConfig.allowed") : "Excluded"
            ] })
          ] }),
          /* @__PURE__ */ jsxs(Typography, { children: [
            t2`artSetConfig.4rainbow`,
            " ",
            /* @__PURE__ */ jsxs(SqBadge, { color: allowRainbow4 ? "success" : "secondary", children: [
              allowRainbow4 ? /* @__PURE__ */ jsx(default_1$o, { ...iconInlineProps }) : /* @__PURE__ */ jsx(default_1$p, { ...iconInlineProps }),
              " ",
              allowRainbow4 ? t2("artSetConfig.allowed") : "Excluded"
            ] })
          ] })
        ] })
      ] }),
      /* @__PURE__ */ jsx(
        Button,
        {
          onClick: onOpen,
          disabled,
          color: "info",
          sx: { borderRadius: 0, flexShrink: 1, minWidth: 40 },
          children: /* @__PURE__ */ jsx(default_1$q, {})
        }
      )
    ] }),
    /* @__PURE__ */ jsx(ModalWrapper, { open, onClose, children: /* @__PURE__ */ jsxs(CardThemed, { children: [
      /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", gap: 1 }, children: [
        /* @__PURE__ */ jsx(Typography, { variant: "h6", children: t2`artSetConfig.title` }),
        /* @__PURE__ */ jsx(IconButton, { onClick: onClose, sx: { ml: "auto" }, children: /* @__PURE__ */ jsx(default_1$a, {}) })
      ] }),
      /* @__PURE__ */ jsx(Divider, {}),
      /* @__PURE__ */ jsxs(CardContent, { children: [
        /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { mb: 1 }, children: /* @__PURE__ */ jsxs(CardContent, { children: [
          /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, children: [
            /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx("strong", { children: t2`artSetConfig.modal.setCond.title` }) }),
            /* @__PURE__ */ jsx(Typography, { sx: { flexGrow: 1 }, children: /* @__PURE__ */ jsxs(SqBadge, { color: artifactCondCount ? "success" : "warning", children: [
              artifactCondCount,
              " ",
              t2("artSetConfig.selected")
            ] }) }),
            /* @__PURE__ */ jsx(
              Button,
              {
                size: "small",
                onClick: resetArtConds,
                color: "error",
                startIcon: /* @__PURE__ */ jsx(Replay, {}),
                children: t2`artSetConfig.modal.setCond.reset`
              }
            )
          ] }),
          /* @__PURE__ */ jsx(Typography, { children: t2`artSetConfig.modal.setCond.text` })
        ] }) }),
        /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { mb: 1 }, children: /* @__PURE__ */ jsxs(CardContent, { children: [
          /* @__PURE__ */ jsx(Typography, { sx: { flexGrow: 1 }, children: /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsxs(
            Trans,
            {
              t: t2,
              i18nKey: "artSetConfig.modal.ArtSetFilter.title",
              children: [
                "Artifact Sets ",
                /* @__PURE__ */ jsxs(ColorText, { color: "success", children: [
                  "Allowed",
                  /* @__PURE__ */ jsx(default_1$o, { ...iconInlineProps })
                ] }),
                " / ",
                /* @__PURE__ */ jsxs(ColorText, { color: "secondary", variant: "light", children: [
                  "Excluded",
                  /* @__PURE__ */ jsx(default_1$p, { ...iconInlineProps })
                ] })
              ]
            }
          ) }) }),
          /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "artSetConfig.modal.ArtSetFilter.intro", children: [
            "You can allow/exclude which sets you want the builder to consider. In the following examples, ",
            /* @__PURE__ */ jsx("strong", { children: "A" }),
            " is on-set, and ",
            /* @__PURE__ */ jsx("strong", { children: "R" }),
            " is rainbow(off-set)"
          ] }) }),
          /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "artSetConfig.modal.ArtSetFilter.2set", children: [
            /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsxs(ColorText, { color: "secondary", variant: "light", children: [
              "Excluding",
              /* @__PURE__ */ jsx(default_1$p, { ...iconInlineProps }),
              " 2-Set"
            ] }) }),
            "would exclude 2-Set builds:",
            /* @__PURE__ */ jsxs("strong", { children: [
              /* @__PURE__ */ jsx(ColorText, { color: "secondary", variant: "light", children: "AA" }),
              "RRR"
            ] }),
            "and",
            /* @__PURE__ */ jsxs("strong", { children: [
              /* @__PURE__ */ jsx(ColorText, { color: "secondary", variant: "light", children: "AAA" }),
              "RR"
            ] }),
            "."
          ] }) }),
          /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "artSetConfig.modal.ArtSetFilter.4set", children: [
            /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsxs(ColorText, { color: "secondary", variant: "light", children: [
              "Excluding",
              /* @__PURE__ */ jsx(default_1$p, { ...iconInlineProps }),
              " 4-Set"
            ] }) }),
            "would exclude 4-Set builds:",
            /* @__PURE__ */ jsxs("strong", { children: [
              /* @__PURE__ */ jsx(ColorText, { color: "secondary", variant: "light", children: "AAAA" }),
              "R"
            ] }),
            "and",
            /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsx(ColorText, { color: "secondary", variant: "light", children: "AAAAA" }) }),
            "."
          ] }) }),
          /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "artSetConfig.modal.ArtSetFilter.2rain", children: [
            /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsxs(ColorText, { color: "secondary", variant: "light", children: [
              "Excluding",
              /* @__PURE__ */ jsx(default_1$p, { ...iconInlineProps }),
              " 3-Rainbow"
            ] }) }),
            "would exclude 2-Set + 3-Rainbow builds:",
            /* @__PURE__ */ jsxs("strong", { children: [
              "AA",
              /* @__PURE__ */ jsx(ColorText, { color: "secondary", variant: "light", children: "RRR" })
            ] }),
            "and",
            /* @__PURE__ */ jsxs("strong", { children: [
              "AAA",
              /* @__PURE__ */ jsx(ColorText, { color: "secondary", variant: "light", children: "RR" })
            ] }),
            "."
          ] }) }),
          /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "artSetConfig.modal.ArtSetFilter.4rain", children: [
            /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsxs(ColorText, { color: "secondary", variant: "light", children: [
              "Excluding",
              /* @__PURE__ */ jsx(default_1$p, { ...iconInlineProps }),
              " 5-Rainbow"
            ] }) }),
            "would exclude full 5-Rainbow builds:",
            /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsx(ColorText, { color: "secondary", variant: "light", children: "RRRRR" }) }),
            "."
          ] }) })
        ] }) }),
        /* @__PURE__ */ jsxs(
          Grid,
          {
            container: true,
            columns: { xs: 2, lg: 3 },
            sx: { mb: 1 },
            spacing: 1,
            children: [
              /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                AllSetAllowExcludeCard,
                {
                  allowTotal: allowTotals["2"],
                  setNum: 2,
                  setAllExclusion
                }
              ) }),
              /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                AllSetAllowExcludeCard,
                {
                  allowTotal: allowTotals["4"],
                  setNum: 4,
                  setAllExclusion
                }
              ) }),
              /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsxs(CardContent, { children: [
                /* @__PURE__ */ jsx(Typography, { gutterBottom: true, children: /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "artSetConfig.alExRainbow", children: [
                  /* @__PURE__ */ jsxs(ColorText, { color: "success", children: [
                    "Allow ",
                    /* @__PURE__ */ jsx(default_1$o, { ...iconInlineProps })
                  ] }),
                  " / ",
                  /* @__PURE__ */ jsxs(ColorText, { color: "secondary", variant: "light", children: [
                    "Exclude ",
                    /* @__PURE__ */ jsx(default_1$p, { ...iconInlineProps })
                  ] }),
                  " Rainbow Builds"
                ] }) }) }),
                /* @__PURE__ */ jsxs(
                  Box,
                  {
                    sx: { display: "flex", flexDirection: "column", gap: 1 },
                    children: [
                      /* @__PURE__ */ jsx(
                        Button,
                        {
                          fullWidth: true,
                          onClick: () => database.optConfigs.set(optConfigId, {
                            artSetExclusion: handleArtSetExclusion(
                              artSetExclusion,
                              "rainbow",
                              2
                            )
                          }),
                          color: allowRainbow2 ? "success" : "secondary",
                          startIcon: !allowRainbow2 ? /* @__PURE__ */ jsx(CheckBoxOutlineBlank, {}) : /* @__PURE__ */ jsx(CheckBox, {}),
                          endIcon: allowRainbow2 ? /* @__PURE__ */ jsx(default_1$o, {}) : /* @__PURE__ */ jsx(default_1$p, {}),
                          children: t2`artSetConfig.2rainbow`
                        }
                      ),
                      /* @__PURE__ */ jsx(
                        Button,
                        {
                          fullWidth: true,
                          onClick: () => database.optConfigs.set(optConfigId, {
                            artSetExclusion: handleArtSetExclusion(
                              artSetExclusion,
                              "rainbow",
                              4
                            )
                          }),
                          color: allowRainbow4 ? "success" : "secondary",
                          startIcon: !allowRainbow4 ? /* @__PURE__ */ jsx(CheckBoxOutlineBlank, {}) : /* @__PURE__ */ jsx(CheckBox, {}),
                          endIcon: allowRainbow4 ? /* @__PURE__ */ jsx(default_1$o, {}) : /* @__PURE__ */ jsx(default_1$p, {}),
                          children: t2`artSetConfig.4rainbow`
                        }
                      )
                    ]
                  }
                )
              ] }) }) })
            ]
          }
        ),
        /* @__PURE__ */ jsx(Grid, { container: true, spacing: 1, columns: { xs: 2, lg: 3 }, children: artKeys.map((setKey) => /* @__PURE__ */ jsx(
          ArtifactSetCard,
          {
            setKey,
            fakeDataContextObj,
            slotCount: artSlotCount[setKey]
          },
          setKey
        )) })
      ] })
    ] }) })
  ] });
}
function AllSetAllowExcludeCard({
  allowTotal,
  setNum,
  setAllExclusion
}) {
  const { t: t2 } = useTranslation(["page_character_optimize", "sheet"]);
  return /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsxs(CardContent, { children: [
    /* @__PURE__ */ jsxs(Typography, { gutterBottom: true, children: [
      /* @__PURE__ */ jsx("strong", { children: t2(`sheet:${setNum}set`) }),
      " ",
      /* @__PURE__ */ jsxs(SqBadge, { color: "success", children: [
        allowTotal,
        " ",
        /* @__PURE__ */ jsx(default_1$o, { ...iconInlineProps }),
        " ",
        t2("artSetConfig.allowed")
      ] })
    ] }),
    /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", flexDirection: "column", gap: 1 }, children: [
      /* @__PURE__ */ jsx(
        Button,
        {
          fullWidth: true,
          disabled: allowTotal.charAt(0) !== "0" && allowTotal.indexOf("/") === -1,
          onClick: () => setAllExclusion(setNum, false),
          color: "success",
          startIcon: /* @__PURE__ */ jsx(default_1$o, {}),
          children: t2(`artSetConfig.allowAll${setNum}set`)
        }
      ),
      /* @__PURE__ */ jsx(
        Button,
        {
          fullWidth: true,
          disabled: allowTotal.charAt(0) === "0",
          onClick: () => setAllExclusion(setNum, true),
          color: "secondary",
          startIcon: /* @__PURE__ */ jsx(default_1$p, {}),
          children: t2(`artSetConfig.excludeAll${setNum}set`)
        }
      )
    ] })
  ] }) });
}
function ArtifactSetCard({
  setKey,
  fakeDataContextObj,
  slotCount
}) {
  const { t: t2 } = useTranslation("sheet");
  const {
    teamChar: { optConfigId }
  } = reactExports.useContext(TeamCharacterContext);
  const { artSetExclusion } = useOptConfig(optConfigId);
  const setExclusionSet = (artSetExclusion == null ? void 0 : artSetExclusion[setKey]) ?? [];
  const allow4 = !setExclusionSet.includes(4);
  const slots = getNumSlots(slotCount);
  const sheet = getArtSheet(setKey);
  const artStat = getArtSetStat(setKey);
  const set4CondNums = reactExports.useMemo(() => {
    if (!allow4)
      return [];
    return Object.keys(sheet.setEffects).filter(
      (setNumKey) => {
        var _a;
        return (_a = sheet.setEffects[setNumKey]) == null ? void 0 : _a.document.some((doc) => "states" in doc);
      }
    );
  }, [sheet.setEffects, allow4]);
  return /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsxs(
    CardThemed,
    {
      bgt: "light",
      sx: { height: "100%", opacity: slots < 2 ? "50%" : void 0 },
      children: [
        /* @__PURE__ */ jsxs(
          Box,
          {
            className: `grad-${Math.max(...artStat.rarities)}star`,
            width: "100%",
            sx: { display: "flex" },
            children: [
              /* @__PURE__ */ jsx(
                Box,
                {
                  component: NextImage ? NextImage : "img",
                  src: artifactDefIcon(setKey),
                  sx: { height: 100, width: "auto", mx: -1 }
                }
              ),
              /* @__PURE__ */ jsxs(
                Box,
                {
                  sx: {
                    flexGrow: 1,
                    px: 1,
                    display: "flex",
                    flexDirection: "column",
                    justifyContent: "center"
                  },
                  children: [
                    /* @__PURE__ */ jsx(Typography, { variant: "h6", children: /* @__PURE__ */ jsx(ArtifactSetName, { setKey }) }),
                    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(
                      Typography,
                      {
                        variant: "subtitle1",
                        display: "flex",
                        gap: 1,
                        alignItems: "center",
                        children: [
                          artStat.rarities.filter((r2) => r2 >= 3).map((ns) => /* @__PURE__ */ jsxs(
                            Box,
                            {
                              component: "span",
                              sx: { display: "inline-flex", alignItems: "center" },
                              children: [
                                ns,
                                " ",
                                /* @__PURE__ */ jsx(default_1$r, { fontSize: "inherit" })
                              ]
                            },
                            ns
                          )),
                          /* @__PURE__ */ jsx(
                            InfoTooltipInline,
                            {
                              title: /* @__PURE__ */ jsx(
                                reactExports.Suspense,
                                {
                                  fallback: /* @__PURE__ */ jsx(
                                    Skeleton,
                                    {
                                      variant: "rectangular",
                                      width: 300,
                                      height: 200
                                    }
                                  ),
                                  children: /* @__PURE__ */ jsxs(Box, { children: [
                                    /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx(SqBadge, { color: "success", children: t2`2set` }) }),
                                    /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx(
                                      Translate,
                                      {
                                        ns: `artifact_${setKey}_gen`,
                                        key18: "setEffects.2"
                                      }
                                    ) }),
                                    /* @__PURE__ */ jsxs(
                                      Box,
                                      {
                                        paddingTop: 2,
                                        sx: {
                                          opacity: setExclusionSet.includes(4) ? 0.6 : 1
                                        },
                                        children: [
                                          /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx(SqBadge, { color: "success", children: t2`4set` }) }),
                                          /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx(
                                            Translate,
                                            {
                                              ns: `artifact_${setKey}_gen`,
                                              key18: "setEffects.4"
                                            }
                                          ) })
                                        ]
                                      }
                                    )
                                  ] })
                                }
                              )
                            }
                          )
                        ]
                      }
                    ) }),
                    /* @__PURE__ */ jsx(Box, { sx: { display: "flex", gap: 1 }, children: Object.entries(slotCount).map(([slotKey, count]) => /* @__PURE__ */ jsx(
                      Typography,
                      {
                        sx: { flexGrow: 1 },
                        variant: "subtitle2",
                        children: /* @__PURE__ */ jsxs(
                          SqBadge,
                          {
                            sx: { width: "100%" },
                            color: count ? "primary" : "secondary",
                            children: [
                              /* @__PURE__ */ jsx(SlotIcon, { slotKey, iconProps: iconInlineProps }),
                              " ",
                              count
                            ]
                          }
                        )
                      },
                      slotKey
                    )) })
                  ]
                }
              )
            ]
          }
        ),
        allArtifactSetExclusionKeys.includes(setKey) && /* @__PURE__ */ jsx(
          SetInclusionButton,
          {
            setKey,
            buttonGroupSx: { ".MuiButton-root": { borderRadius: 0 } }
          }
        ),
        !!set4CondNums.length && /* @__PURE__ */ jsx(DataContext.Provider, { value: fakeDataContextObj, children: /* @__PURE__ */ jsx(
          CardContent,
          {
            sx: { display: "flex", flexDirection: "column", gap: 2 },
            children: set4CondNums.map((setNumKey) => /* @__PURE__ */ jsx(
              SetEffectDisplay,
              {
                setKey,
                setNumKey: parseInt(setNumKey),
                hideHeader: true,
                conditionalsOnly: true
              },
              setNumKey
            ))
          }
        ) })
      ]
    }
  ) }, setKey);
}
function getNumSlots(slotCount) {
  return Object.values(slotCount).reduce((tot, v2) => tot + (v2 ? 1 : 0), 0);
}
const levels = [0, 4, 8, 12, 16, 20];
function AssumeFullLevelToggle({
  mainStatAssumptionLevel = 0,
  setmainStatAssumptionLevel,
  disabled
}) {
  const { t: t2 } = useTranslation("page_character_optimize");
  return /* @__PURE__ */ jsx(
    DropdownButton,
    {
      fullWidth: true,
      color: mainStatAssumptionLevel ? "success" : "primary",
      disabled,
      title: mainStatAssumptionLevel ? t2("mainStat.assumptionLvl.lvl", { lvl: mainStatAssumptionLevel }) : t2("mainStat.assumptionLvl.no"),
      children: levels.map((lvl) => /* @__PURE__ */ jsx(MenuItem, { onClick: () => setmainStatAssumptionLevel(lvl), children: lvl ? t2("mainStat.assumptionLvl.lvl", { lvl }) : t2("mainStat.assumptionLvl.no") }, lvl))
    }
  );
}
function BonusStatsCard() {
  const { t: t2 } = useTranslation("page_character_optimize");
  const {
    teamChar: { bonusStats }
  } = reactExports.useContext(TeamCharacterContext);
  const { data } = reactExports.useContext(DataContext);
  const bonusStatsKeys = Object.keys(bonusStats);
  if (!bonusStatsKeys.length)
    return null;
  const nodes = bonusStatsKeys.map(
    (k2) => data.get(uiInput.customBonus[k2])
  );
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsx(
      Typography,
      {
        sx: { fontWeight: "bold" },
        children: t2`bonusStats.title`
      }
    ) }),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(FieldDisplayList, { bgt: "light", children: nodes.map((n2) => /* @__PURE__ */ jsx(NodeFieldDisplay, { calcRes: n2 }, JSON.stringify(n2.info))) })
  ] });
}
const Monospace = styled("strong")({
  fontFamily: "monospace"
});
const BorderLinearProgress = styled(LinearProgress)(() => ({
  height: 10,
  borderRadius: 5
}));
function BuildAlert({
  status: { type, tested, failed: _, skipped, total, startTime, finishTime },
  characterName
}) {
  const hasTotal = isFinite(total);
  const generatingBuilds = type !== "inactive";
  const unskipped = total - skipped;
  const testedString = /* @__PURE__ */ jsx(Monospace, { children: tested.toLocaleString() });
  const unskippedString = /* @__PURE__ */ jsx(Monospace, { children: unskipped.toLocaleString() });
  const skippedText = !!skipped && /* @__PURE__ */ jsxs("span", { children: [
    "(",
    /* @__PURE__ */ jsx("b", { children: /* @__PURE__ */ jsx(Monospace, { children: skipped.toLocaleString() }) }),
    " skipped)"
  ] });
  const durationString = /* @__PURE__ */ jsx(Monospace, { children: timeStringMs(
    Math.round((finishTime ?? performance.now()) - (startTime ?? NaN))
  ) });
  const color2 = "success";
  let title = "";
  let subtitle = "";
  let progress = void 0;
  if (generatingBuilds) {
    progress = tested * 100 / unskipped;
    title = /* @__PURE__ */ jsxs(Typography, { children: [
      "Generating and testing ",
      testedString,
      hasTotal ? /* @__PURE__ */ jsxs(Fragment, { children: [
        "/",
        unskippedString
      ] }) : void 0,
      " build configurations against the criteria for ",
      /* @__PURE__ */ jsx("b", { children: characterName }),
      ". ",
      skippedText
    ] });
    subtitle = /* @__PURE__ */ jsxs(Typography, { children: [
      "Time elapsed: ",
      durationString
    ] });
  } else if (tested + skipped) {
    progress = 100;
    title = /* @__PURE__ */ jsxs(Typography, { children: [
      "Generated and tested ",
      testedString,
      " Build configurations against the criteria for ",
      /* @__PURE__ */ jsx("b", { children: characterName }),
      ". ",
      skippedText
    ] });
    subtitle = /* @__PURE__ */ jsxs(Typography, { children: [
      "Total duration: ",
      durationString
    ] });
  } else {
    return null;
  }
  return /* @__PURE__ */ jsxs(
    Alert,
    {
      severity: color2,
      variant: "filled",
      sx: {
        "& .MuiAlert-message": {
          flexGrow: 1
        }
      },
      children: [
        title,
        subtitle,
        progress !== void 0 && /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, alignItems: "center", children: [
          hasTotal && /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(Typography, { children: `${progress.toFixed(1)}%` }) }),
          /* @__PURE__ */ jsx(Grid, { item: true, flexGrow: 1, children: /* @__PURE__ */ jsx(
            BorderLinearProgress,
            {
              variant: hasTotal ? "determinate" : "indeterminate",
              value: progress,
              color: "primary"
            }
          ) })
        ] })
      ]
    }
  );
}
var classnames = { exports: {} };
/*!
	Copyright (c) 2018 Jed Watson.
	Licensed under the MIT License (MIT), see
	http://jedwatson.github.io/classnames
*/
(function(module) {
  (function() {
    var hasOwn = {}.hasOwnProperty;
    function classNames2() {
      var classes = [];
      for (var i = 0; i < arguments.length; i++) {
        var arg = arguments[i];
        if (!arg)
          continue;
        var argType = typeof arg;
        if (argType === "string" || argType === "number") {
          classes.push(arg);
        } else if (Array.isArray(arg)) {
          if (arg.length) {
            var inner = classNames2.apply(null, arg);
            if (inner) {
              classes.push(inner);
            }
          }
        } else if (argType === "object") {
          if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
            classes.push(arg.toString());
            continue;
          }
          for (var key in arg) {
            if (hasOwn.call(arg, key) && arg[key]) {
              classes.push(key);
            }
          }
        }
      }
      return classes.join(" ");
    }
    if (module.exports) {
      classNames2.default = classNames2;
      module.exports = classNames2;
    } else {
      window.classNames = classNames2;
    }
  })();
})(classnames);
var classnamesExports = classnames.exports;
const classNames = /* @__PURE__ */ getDefaultExportFromCjs(classnamesExports);
function isObject$9(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1$1 = isObject$9;
const _isObject = /* @__PURE__ */ getDefaultExportFromCjs(isObject_1$1);
var freeGlobal$3 = typeof commonjsGlobal$1 == "object" && commonjsGlobal$1 && commonjsGlobal$1.Object === Object && commonjsGlobal$1;
var _freeGlobal$1 = freeGlobal$3;
var freeGlobal$2 = _freeGlobal$1;
var freeSelf$1 = typeof self == "object" && self && self.Object === Object && self;
var root$c = freeGlobal$2 || freeSelf$1 || Function("return this")();
var _root$1 = root$c;
var root$b = _root$1;
var Symbol$a = root$b.Symbol;
var _Symbol$1 = Symbol$a;
var Symbol$9 = _Symbol$1;
var objectProto$d = Object.prototype;
var hasOwnProperty$a = objectProto$d.hasOwnProperty;
var nativeObjectToString$3 = objectProto$d.toString;
var symToStringTag$3 = Symbol$9 ? Symbol$9.toStringTag : void 0;
function getRawTag$3(value) {
  var isOwn = hasOwnProperty$a.call(value, symToStringTag$3), tag = value[symToStringTag$3];
  try {
    value[symToStringTag$3] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$3.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$3] = tag;
    } else {
      delete value[symToStringTag$3];
    }
  }
  return result;
}
var _getRawTag$1 = getRawTag$3;
var objectProto$c = Object.prototype;
var nativeObjectToString$2 = objectProto$c.toString;
function objectToString$3(value) {
  return nativeObjectToString$2.call(value);
}
var _objectToString$1 = objectToString$3;
var Symbol$8 = _Symbol$1, getRawTag$2 = _getRawTag$1, objectToString$2 = _objectToString$1;
var nullTag$1 = "[object Null]", undefinedTag$1 = "[object Undefined]";
var symToStringTag$2 = Symbol$8 ? Symbol$8.toStringTag : void 0;
function baseGetTag$a(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag$1 : nullTag$1;
  }
  return symToStringTag$2 && symToStringTag$2 in Object(value) ? getRawTag$2(value) : objectToString$2(value);
}
var _baseGetTag$1 = baseGetTag$a;
var baseGetTag$9 = _baseGetTag$1, isObject$8 = isObject_1$1;
var asyncTag = "[object AsyncFunction]", funcTag$1 = "[object Function]", genTag = "[object GeneratorFunction]", proxyTag = "[object Proxy]";
function isFunction$3(value) {
  if (!isObject$8(value)) {
    return false;
  }
  var tag = baseGetTag$9(value);
  return tag == funcTag$1 || tag == genTag || tag == asyncTag || tag == proxyTag;
}
var isFunction_1 = isFunction$3;
const _isFunction = /* @__PURE__ */ getDefaultExportFromCjs(isFunction_1);
var isArray$e = Array.isArray;
var isArray_1 = isArray$e;
const _isArray = /* @__PURE__ */ getDefaultExportFromCjs(isArray_1);
function isObjectLike$a(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1$1 = isObjectLike$a;
var baseGetTag$8 = _baseGetTag$1, isArray$d = isArray_1, isObjectLike$9 = isObjectLike_1$1;
var stringTag$2 = "[object String]";
function isString(value) {
  return typeof value == "string" || !isArray$d(value) && isObjectLike$9(value) && baseGetTag$8(value) == stringTag$2;
}
var isString_1 = isString;
const _isString = /* @__PURE__ */ getDefaultExportFromCjs(isString_1);
var baseGetTag$7 = _baseGetTag$1, isObjectLike$8 = isObjectLike_1$1;
var symbolTag$2 = "[object Symbol]";
function isSymbol$7(value) {
  return typeof value == "symbol" || isObjectLike$8(value) && baseGetTag$7(value) == symbolTag$2;
}
var isSymbol_1$1 = isSymbol$7;
var isArray$c = isArray_1, isSymbol$6 = isSymbol_1$1;
var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/;
function isKey$3(value, object2) {
  if (isArray$c(value)) {
    return false;
  }
  var type = typeof value;
  if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol$6(value)) {
    return true;
  }
  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object2 != null && value in Object(object2);
}
var _isKey = isKey$3;
var root$a = _root$1;
var coreJsData$1 = root$a["__core-js_shared__"];
var _coreJsData = coreJsData$1;
var coreJsData = _coreJsData;
var maskSrcKey = function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
  return uid ? "Symbol(src)_1." + uid : "";
}();
function isMasked$1(func) {
  return !!maskSrcKey && maskSrcKey in func;
}
var _isMasked = isMasked$1;
var funcProto$1 = Function.prototype;
var funcToString$1 = funcProto$1.toString;
function toSource$2(func) {
  if (func != null) {
    try {
      return funcToString$1.call(func);
    } catch (e3) {
    }
    try {
      return func + "";
    } catch (e3) {
    }
  }
  return "";
}
var _toSource = toSource$2;
var isFunction$2 = isFunction_1, isMasked = _isMasked, isObject$7 = isObject_1$1, toSource$1 = _toSource;
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
var reIsHostCtor = /^\[object .+?Constructor\]$/;
var funcProto = Function.prototype, objectProto$b = Object.prototype;
var funcToString = funcProto.toString;
var hasOwnProperty$9 = objectProto$b.hasOwnProperty;
var reIsNative = RegExp(
  "^" + funcToString.call(hasOwnProperty$9).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
);
function baseIsNative$1(value) {
  if (!isObject$7(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction$2(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource$1(value));
}
var _baseIsNative = baseIsNative$1;
function getValue$1(object2, key) {
  return object2 == null ? void 0 : object2[key];
}
var _getValue = getValue$1;
var baseIsNative = _baseIsNative, getValue = _getValue;
function getNative$7(object2, key) {
  var value = getValue(object2, key);
  return baseIsNative(value) ? value : void 0;
}
var _getNative = getNative$7;
var getNative$6 = _getNative;
var nativeCreate$4 = getNative$6(Object, "create");
var _nativeCreate = nativeCreate$4;
var nativeCreate$3 = _nativeCreate;
function hashClear$1() {
  this.__data__ = nativeCreate$3 ? nativeCreate$3(null) : {};
  this.size = 0;
}
var _hashClear = hashClear$1;
function hashDelete$1(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}
var _hashDelete = hashDelete$1;
var nativeCreate$2 = _nativeCreate;
var HASH_UNDEFINED$2 = "__lodash_hash_undefined__";
var objectProto$a = Object.prototype;
var hasOwnProperty$8 = objectProto$a.hasOwnProperty;
function hashGet$1(key) {
  var data = this.__data__;
  if (nativeCreate$2) {
    var result = data[key];
    return result === HASH_UNDEFINED$2 ? void 0 : result;
  }
  return hasOwnProperty$8.call(data, key) ? data[key] : void 0;
}
var _hashGet = hashGet$1;
var nativeCreate$1 = _nativeCreate;
var objectProto$9 = Object.prototype;
var hasOwnProperty$7 = objectProto$9.hasOwnProperty;
function hashHas$1(key) {
  var data = this.__data__;
  return nativeCreate$1 ? data[key] !== void 0 : hasOwnProperty$7.call(data, key);
}
var _hashHas = hashHas$1;
var nativeCreate = _nativeCreate;
var HASH_UNDEFINED$1 = "__lodash_hash_undefined__";
function hashSet$1(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED$1 : value;
  return this;
}
var _hashSet = hashSet$1;
var hashClear = _hashClear, hashDelete = _hashDelete, hashGet = _hashGet, hashHas = _hashHas, hashSet = _hashSet;
function Hash$1(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
Hash$1.prototype.clear = hashClear;
Hash$1.prototype["delete"] = hashDelete;
Hash$1.prototype.get = hashGet;
Hash$1.prototype.has = hashHas;
Hash$1.prototype.set = hashSet;
var _Hash = Hash$1;
function listCacheClear$1() {
  this.__data__ = [];
  this.size = 0;
}
var _listCacheClear = listCacheClear$1;
function eq$3(value, other) {
  return value === other || value !== value && other !== other;
}
var eq_1 = eq$3;
var eq$2 = eq_1;
function assocIndexOf$4(array2, key) {
  var length = array2.length;
  while (length--) {
    if (eq$2(array2[length][0], key)) {
      return length;
    }
  }
  return -1;
}
var _assocIndexOf = assocIndexOf$4;
var assocIndexOf$3 = _assocIndexOf;
var arrayProto = Array.prototype;
var splice = arrayProto.splice;
function listCacheDelete$1(key) {
  var data = this.__data__, index = assocIndexOf$3(data, key);
  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}
var _listCacheDelete = listCacheDelete$1;
var assocIndexOf$2 = _assocIndexOf;
function listCacheGet$1(key) {
  var data = this.__data__, index = assocIndexOf$2(data, key);
  return index < 0 ? void 0 : data[index][1];
}
var _listCacheGet = listCacheGet$1;
var assocIndexOf$1 = _assocIndexOf;
function listCacheHas$1(key) {
  return assocIndexOf$1(this.__data__, key) > -1;
}
var _listCacheHas = listCacheHas$1;
var assocIndexOf = _assocIndexOf;
function listCacheSet$1(key, value) {
  var data = this.__data__, index = assocIndexOf(data, key);
  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}
var _listCacheSet = listCacheSet$1;
var listCacheClear = _listCacheClear, listCacheDelete = _listCacheDelete, listCacheGet = _listCacheGet, listCacheHas = _listCacheHas, listCacheSet = _listCacheSet;
function ListCache$4(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
ListCache$4.prototype.clear = listCacheClear;
ListCache$4.prototype["delete"] = listCacheDelete;
ListCache$4.prototype.get = listCacheGet;
ListCache$4.prototype.has = listCacheHas;
ListCache$4.prototype.set = listCacheSet;
var _ListCache = ListCache$4;
var getNative$5 = _getNative, root$9 = _root$1;
var Map$4 = getNative$5(root$9, "Map");
var _Map = Map$4;
var Hash = _Hash, ListCache$3 = _ListCache, Map$3 = _Map;
function mapCacheClear$1() {
  this.size = 0;
  this.__data__ = {
    "hash": new Hash(),
    "map": new (Map$3 || ListCache$3)(),
    "string": new Hash()
  };
}
var _mapCacheClear = mapCacheClear$1;
function isKeyable$1(value) {
  var type = typeof value;
  return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
}
var _isKeyable = isKeyable$1;
var isKeyable = _isKeyable;
function getMapData$4(map2, key) {
  var data = map2.__data__;
  return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
}
var _getMapData = getMapData$4;
var getMapData$3 = _getMapData;
function mapCacheDelete$1(key) {
  var result = getMapData$3(this, key)["delete"](key);
  this.size -= result ? 1 : 0;
  return result;
}
var _mapCacheDelete = mapCacheDelete$1;
var getMapData$2 = _getMapData;
function mapCacheGet$1(key) {
  return getMapData$2(this, key).get(key);
}
var _mapCacheGet = mapCacheGet$1;
var getMapData$1 = _getMapData;
function mapCacheHas$1(key) {
  return getMapData$1(this, key).has(key);
}
var _mapCacheHas = mapCacheHas$1;
var getMapData = _getMapData;
function mapCacheSet$1(key, value) {
  var data = getMapData(this, key), size = data.size;
  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}
var _mapCacheSet = mapCacheSet$1;
var mapCacheClear = _mapCacheClear, mapCacheDelete = _mapCacheDelete, mapCacheGet = _mapCacheGet, mapCacheHas = _mapCacheHas, mapCacheSet = _mapCacheSet;
function MapCache$3(entries) {
  var index = -1, length = entries == null ? 0 : entries.length;
  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}
MapCache$3.prototype.clear = mapCacheClear;
MapCache$3.prototype["delete"] = mapCacheDelete;
MapCache$3.prototype.get = mapCacheGet;
MapCache$3.prototype.has = mapCacheHas;
MapCache$3.prototype.set = mapCacheSet;
var _MapCache = MapCache$3;
var MapCache$2 = _MapCache;
var FUNC_ERROR_TEXT$3 = "Expected a function";
function memoize$2(func, resolver) {
  if (typeof func != "function" || resolver != null && typeof resolver != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$3);
  }
  var memoized = function() {
    var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
    if (cache.has(key)) {
      return cache.get(key);
    }
    var result = func.apply(this, args);
    memoized.cache = cache.set(key, result) || cache;
    return result;
  };
  memoized.cache = new (memoize$2.Cache || MapCache$2)();
  return memoized;
}
memoize$2.Cache = MapCache$2;
var memoize_1 = memoize$2;
var memoize$1 = memoize_1;
var MAX_MEMOIZE_SIZE = 500;
function memoizeCapped$1(func) {
  var result = memoize$1(func, function(key) {
    if (cache.size === MAX_MEMOIZE_SIZE) {
      cache.clear();
    }
    return key;
  });
  var cache = result.cache;
  return result;
}
var _memoizeCapped = memoizeCapped$1;
var memoizeCapped = _memoizeCapped;
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reEscapeChar = /\\(\\)?/g;
var stringToPath$1 = memoizeCapped(function(string2) {
  var result = [];
  if (string2.charCodeAt(0) === 46) {
    result.push("");
  }
  string2.replace(rePropName, function(match, number2, quote, subString) {
    result.push(quote ? subString.replace(reEscapeChar, "$1") : number2 || match);
  });
  return result;
});
var _stringToPath = stringToPath$1;
function arrayMap$3(array2, iteratee) {
  var index = -1, length = array2 == null ? 0 : array2.length, result = Array(length);
  while (++index < length) {
    result[index] = iteratee(array2[index], index, array2);
  }
  return result;
}
var _arrayMap = arrayMap$3;
var Symbol$7 = _Symbol$1, arrayMap$2 = _arrayMap, isArray$b = isArray_1, isSymbol$5 = isSymbol_1$1;
var INFINITY$3 = 1 / 0;
var symbolProto$1 = Symbol$7 ? Symbol$7.prototype : void 0, symbolToString = symbolProto$1 ? symbolProto$1.toString : void 0;
function baseToString$1(value) {
  if (typeof value == "string") {
    return value;
  }
  if (isArray$b(value)) {
    return arrayMap$2(value, baseToString$1) + "";
  }
  if (isSymbol$5(value)) {
    return symbolToString ? symbolToString.call(value) : "";
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$3 ? "-0" : result;
}
var _baseToString = baseToString$1;
var baseToString = _baseToString;
function toString$3(value) {
  return value == null ? "" : baseToString(value);
}
var toString_1 = toString$3;
var isArray$a = isArray_1, isKey$2 = _isKey, stringToPath = _stringToPath, toString$2 = toString_1;
function castPath$2(value, object2) {
  if (isArray$a(value)) {
    return value;
  }
  return isKey$2(value, object2) ? [value] : stringToPath(toString$2(value));
}
var _castPath = castPath$2;
var isSymbol$4 = isSymbol_1$1;
var INFINITY$2 = 1 / 0;
function toKey$4(value) {
  if (typeof value == "string" || isSymbol$4(value)) {
    return value;
  }
  var result = value + "";
  return result == "0" && 1 / value == -INFINITY$2 ? "-0" : result;
}
var _toKey = toKey$4;
var castPath$1 = _castPath, toKey$3 = _toKey;
function baseGet$3(object2, path) {
  path = castPath$1(path, object2);
  var index = 0, length = path.length;
  while (object2 != null && index < length) {
    object2 = object2[toKey$3(path[index++])];
  }
  return index && index == length ? object2 : void 0;
}
var _baseGet = baseGet$3;
var baseGet$2 = _baseGet;
function get$1(object2, path, defaultValue) {
  var result = object2 == null ? void 0 : baseGet$2(object2, path);
  return result === void 0 ? defaultValue : result;
}
var get_1 = get$1;
const _get = /* @__PURE__ */ getDefaultExportFromCjs(get_1);
function isNil(value) {
  return value == null;
}
var isNil_1 = isNil;
const _isNil = /* @__PURE__ */ getDefaultExportFromCjs(isNil_1);
var reactIs = { exports: {} };
var reactIs_production_min = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var b = "function" === typeof Symbol && Symbol.for, c$1 = b ? Symbol.for("react.element") : 60103, d = b ? Symbol.for("react.portal") : 60106, e = b ? Symbol.for("react.fragment") : 60107, f = b ? Symbol.for("react.strict_mode") : 60108, g = b ? Symbol.for("react.profiler") : 60114, h = b ? Symbol.for("react.provider") : 60109, k$1 = b ? Symbol.for("react.context") : 60110, l = b ? Symbol.for("react.async_mode") : 60111, m = b ? Symbol.for("react.concurrent_mode") : 60111, n = b ? Symbol.for("react.forward_ref") : 60112, p = b ? Symbol.for("react.suspense") : 60113, q = b ? Symbol.for("react.suspense_list") : 60120, r = b ? Symbol.for("react.memo") : 60115, t = b ? Symbol.for("react.lazy") : 60116, v = b ? Symbol.for("react.block") : 60121, w = b ? Symbol.for("react.fundamental") : 60117, x$1 = b ? Symbol.for("react.responder") : 60118, y$1 = b ? Symbol.for("react.scope") : 60119;
function z(a2) {
  if ("object" === typeof a2 && null !== a2) {
    var u = a2.$$typeof;
    switch (u) {
      case c$1:
        switch (a2 = a2.type, a2) {
          case l:
          case m:
          case e:
          case g:
          case f:
          case p:
            return a2;
          default:
            switch (a2 = a2 && a2.$$typeof, a2) {
              case k$1:
              case n:
              case t:
              case r:
              case h:
                return a2;
              default:
                return u;
            }
        }
      case d:
        return u;
    }
  }
}
function A(a2) {
  return z(a2) === m;
}
reactIs_production_min.AsyncMode = l;
reactIs_production_min.ConcurrentMode = m;
reactIs_production_min.ContextConsumer = k$1;
reactIs_production_min.ContextProvider = h;
reactIs_production_min.Element = c$1;
reactIs_production_min.ForwardRef = n;
reactIs_production_min.Fragment = e;
reactIs_production_min.Lazy = t;
reactIs_production_min.Memo = r;
reactIs_production_min.Portal = d;
reactIs_production_min.Profiler = g;
reactIs_production_min.StrictMode = f;
reactIs_production_min.Suspense = p;
reactIs_production_min.isAsyncMode = function(a2) {
  return A(a2) || z(a2) === l;
};
reactIs_production_min.isConcurrentMode = A;
reactIs_production_min.isContextConsumer = function(a2) {
  return z(a2) === k$1;
};
reactIs_production_min.isContextProvider = function(a2) {
  return z(a2) === h;
};
reactIs_production_min.isElement = function(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === c$1;
};
reactIs_production_min.isForwardRef = function(a2) {
  return z(a2) === n;
};
reactIs_production_min.isFragment = function(a2) {
  return z(a2) === e;
};
reactIs_production_min.isLazy = function(a2) {
  return z(a2) === t;
};
reactIs_production_min.isMemo = function(a2) {
  return z(a2) === r;
};
reactIs_production_min.isPortal = function(a2) {
  return z(a2) === d;
};
reactIs_production_min.isProfiler = function(a2) {
  return z(a2) === g;
};
reactIs_production_min.isStrictMode = function(a2) {
  return z(a2) === f;
};
reactIs_production_min.isSuspense = function(a2) {
  return z(a2) === p;
};
reactIs_production_min.isValidElementType = function(a2) {
  return "string" === typeof a2 || "function" === typeof a2 || a2 === e || a2 === m || a2 === g || a2 === f || a2 === p || a2 === q || "object" === typeof a2 && null !== a2 && (a2.$$typeof === t || a2.$$typeof === r || a2.$$typeof === h || a2.$$typeof === k$1 || a2.$$typeof === n || a2.$$typeof === w || a2.$$typeof === x$1 || a2.$$typeof === y$1 || a2.$$typeof === v);
};
reactIs_production_min.typeOf = z;
{
  reactIs.exports = reactIs_production_min;
}
var reactIsExports = reactIs.exports;
var baseGetTag$6 = _baseGetTag$1, isObjectLike$7 = isObjectLike_1$1;
var numberTag$2 = "[object Number]";
function isNumber$2(value) {
  return typeof value == "number" || isObjectLike$7(value) && baseGetTag$6(value) == numberTag$2;
}
var isNumber_1 = isNumber$2;
const _isNumber = /* @__PURE__ */ getDefaultExportFromCjs(isNumber_1);
var isNumber$1 = isNumber_1;
function isNaN$1(value) {
  return isNumber$1(value) && value != +value;
}
var _isNaN = isNaN$1;
const _isNaN$1 = /* @__PURE__ */ getDefaultExportFromCjs(_isNaN);
var mathSign = function mathSign2(value) {
  if (value === 0) {
    return 0;
  }
  if (value > 0) {
    return 1;
  }
  return -1;
};
var isPercent = function isPercent2(value) {
  return _isString(value) && value.indexOf("%") === value.length - 1;
};
var isNumber = function isNumber2(value) {
  return _isNumber(value) && !_isNaN$1(value);
};
var isNumOrStr = function isNumOrStr2(value) {
  return isNumber(value) || _isString(value);
};
var idCounter = 0;
var uniqueId = function uniqueId2(prefix) {
  var id = ++idCounter;
  return "".concat(prefix || "").concat(id);
};
var getPercentValue = function getPercentValue2(percent, totalValue) {
  var defaultValue = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0;
  var validate = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : false;
  if (!isNumber(percent) && !_isString(percent)) {
    return defaultValue;
  }
  var value;
  if (isPercent(percent)) {
    var index = percent.indexOf("%");
    value = totalValue * parseFloat(percent.slice(0, index)) / 100;
  } else {
    value = +percent;
  }
  if (_isNaN$1(value)) {
    value = defaultValue;
  }
  if (validate && value > totalValue) {
    value = totalValue;
  }
  return value;
};
var getAnyElementOfObject = function getAnyElementOfObject2(obj) {
  if (!obj) {
    return null;
  }
  var keys2 = Object.keys(obj);
  if (keys2 && keys2.length) {
    return obj[keys2[0]];
  }
  return null;
};
var hasDuplicate = function hasDuplicate2(ary) {
  if (!_isArray(ary)) {
    return false;
  }
  var len = ary.length;
  var cache = {};
  for (var i = 0; i < len; i++) {
    if (!cache[ary[i]]) {
      cache[ary[i]] = true;
    } else {
      return true;
    }
  }
  return false;
};
var interpolateNumber$2 = function interpolateNumber(numberA, numberB) {
  if (isNumber(numberA) && isNumber(numberB)) {
    return function(t2) {
      return numberA + t2 * (numberB - numberA);
    };
  }
  return function() {
    return numberB;
  };
};
function findEntryInArray(ary, specifiedKey, specifiedValue) {
  if (!ary || !ary.length) {
    return null;
  }
  return ary.find(function(entry) {
    return entry && (typeof specifiedKey === "function" ? specifiedKey(entry) : _get(entry, specifiedKey)) === specifiedValue;
  });
}
var getLinearRegression = function getLinearRegression2(data) {
  if (!data || !data.length) {
    return null;
  }
  var len = data.length;
  var xsum = 0;
  var ysum = 0;
  var xysum = 0;
  var xxsum = 0;
  var xmin = Infinity;
  var xmax = -Infinity;
  var xcurrent = 0;
  var ycurrent = 0;
  for (var i = 0; i < len; i++) {
    xcurrent = data[i].cx || 0;
    ycurrent = data[i].cy || 0;
    xsum += xcurrent;
    ysum += ycurrent;
    xysum += xcurrent * ycurrent;
    xxsum += xcurrent * xcurrent;
    xmin = Math.min(xmin, xcurrent);
    xmax = Math.max(xmax, xcurrent);
  }
  var a2 = len * xxsum !== xsum * xsum ? (len * xysum - xsum * ysum) / (len * xxsum - xsum * xsum) : 0;
  return {
    xmin,
    xmax,
    a: a2,
    b: (ysum - a2 * xsum) / len
  };
};
function shallowEqual(a2, b2) {
  for (var key in a2) {
    if ({}.hasOwnProperty.call(a2, key) && (!{}.hasOwnProperty.call(b2, key) || a2[key] !== b2[key])) {
      return false;
    }
  }
  for (var _key in b2) {
    if ({}.hasOwnProperty.call(b2, _key) && !{}.hasOwnProperty.call(a2, _key)) {
      return false;
    }
  }
  return true;
}
function _typeof$v(obj) {
  "@babel/helpers - typeof";
  return _typeof$v = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$v(obj);
}
var SVGContainerPropKeys = ["viewBox", "children"];
var SVGElementPropKeys = [
  "aria-activedescendant",
  "aria-atomic",
  "aria-autocomplete",
  "aria-busy",
  "aria-checked",
  "aria-colcount",
  "aria-colindex",
  "aria-colspan",
  "aria-controls",
  "aria-current",
  "aria-describedby",
  "aria-details",
  "aria-disabled",
  "aria-errormessage",
  "aria-expanded",
  "aria-flowto",
  "aria-haspopup",
  "aria-hidden",
  "aria-invalid",
  "aria-keyshortcuts",
  "aria-label",
  "aria-labelledby",
  "aria-level",
  "aria-live",
  "aria-modal",
  "aria-multiline",
  "aria-multiselectable",
  "aria-orientation",
  "aria-owns",
  "aria-placeholder",
  "aria-posinset",
  "aria-pressed",
  "aria-readonly",
  "aria-relevant",
  "aria-required",
  "aria-roledescription",
  "aria-rowcount",
  "aria-rowindex",
  "aria-rowspan",
  "aria-selected",
  "aria-setsize",
  "aria-sort",
  "aria-valuemax",
  "aria-valuemin",
  "aria-valuenow",
  "aria-valuetext",
  "className",
  "color",
  "height",
  "id",
  "lang",
  "max",
  "media",
  "method",
  "min",
  "name",
  "style",
  /*
   * removed 'type' SVGElementPropKey because we do not currently use any SVG elements
   * that can use it and it conflicts with the recharts prop 'type'
   * https://github.com/recharts/recharts/pull/3327
   * https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/type
   */
  // 'type',
  "target",
  "width",
  "role",
  "tabIndex",
  "accentHeight",
  "accumulate",
  "additive",
  "alignmentBaseline",
  "allowReorder",
  "alphabetic",
  "amplitude",
  "arabicForm",
  "ascent",
  "attributeName",
  "attributeType",
  "autoReverse",
  "azimuth",
  "baseFrequency",
  "baselineShift",
  "baseProfile",
  "bbox",
  "begin",
  "bias",
  "by",
  "calcMode",
  "capHeight",
  "clip",
  "clipPath",
  "clipPathUnits",
  "clipRule",
  "colorInterpolation",
  "colorInterpolationFilters",
  "colorProfile",
  "colorRendering",
  "contentScriptType",
  "contentStyleType",
  "cursor",
  "cx",
  "cy",
  "d",
  "decelerate",
  "descent",
  "diffuseConstant",
  "direction",
  "display",
  "divisor",
  "dominantBaseline",
  "dur",
  "dx",
  "dy",
  "edgeMode",
  "elevation",
  "enableBackground",
  "end",
  "exponent",
  "externalResourcesRequired",
  "fill",
  "fillOpacity",
  "fillRule",
  "filter",
  "filterRes",
  "filterUnits",
  "floodColor",
  "floodOpacity",
  "focusable",
  "fontFamily",
  "fontSize",
  "fontSizeAdjust",
  "fontStretch",
  "fontStyle",
  "fontVariant",
  "fontWeight",
  "format",
  "from",
  "fx",
  "fy",
  "g1",
  "g2",
  "glyphName",
  "glyphOrientationHorizontal",
  "glyphOrientationVertical",
  "glyphRef",
  "gradientTransform",
  "gradientUnits",
  "hanging",
  "horizAdvX",
  "horizOriginX",
  "href",
  "ideographic",
  "imageRendering",
  "in2",
  "in",
  "intercept",
  "k1",
  "k2",
  "k3",
  "k4",
  "k",
  "kernelMatrix",
  "kernelUnitLength",
  "kerning",
  "keyPoints",
  "keySplines",
  "keyTimes",
  "lengthAdjust",
  "letterSpacing",
  "lightingColor",
  "limitingConeAngle",
  "local",
  "markerEnd",
  "markerHeight",
  "markerMid",
  "markerStart",
  "markerUnits",
  "markerWidth",
  "mask",
  "maskContentUnits",
  "maskUnits",
  "mathematical",
  "mode",
  "numOctaves",
  "offset",
  "opacity",
  "operator",
  "order",
  "orient",
  "orientation",
  "origin",
  "overflow",
  "overlinePosition",
  "overlineThickness",
  "paintOrder",
  "panose1",
  "pathLength",
  "patternContentUnits",
  "patternTransform",
  "patternUnits",
  "pointerEvents",
  "pointsAtX",
  "pointsAtY",
  "pointsAtZ",
  "preserveAlpha",
  "preserveAspectRatio",
  "primitiveUnits",
  "r",
  "radius",
  "refX",
  "refY",
  "renderingIntent",
  "repeatCount",
  "repeatDur",
  "requiredExtensions",
  "requiredFeatures",
  "restart",
  "result",
  "rotate",
  "rx",
  "ry",
  "seed",
  "shapeRendering",
  "slope",
  "spacing",
  "specularConstant",
  "specularExponent",
  "speed",
  "spreadMethod",
  "startOffset",
  "stdDeviation",
  "stemh",
  "stemv",
  "stitchTiles",
  "stopColor",
  "stopOpacity",
  "strikethroughPosition",
  "strikethroughThickness",
  "string",
  "stroke",
  "strokeDasharray",
  "strokeDashoffset",
  "strokeLinecap",
  "strokeLinejoin",
  "strokeMiterlimit",
  "strokeOpacity",
  "strokeWidth",
  "surfaceScale",
  "systemLanguage",
  "tableValues",
  "targetX",
  "targetY",
  "textAnchor",
  "textDecoration",
  "textLength",
  "textRendering",
  "to",
  "transform",
  "u1",
  "u2",
  "underlinePosition",
  "underlineThickness",
  "unicode",
  "unicodeBidi",
  "unicodeRange",
  "unitsPerEm",
  "vAlphabetic",
  "values",
  "vectorEffect",
  "version",
  "vertAdvY",
  "vertOriginX",
  "vertOriginY",
  "vHanging",
  "vIdeographic",
  "viewTarget",
  "visibility",
  "vMathematical",
  "widths",
  "wordSpacing",
  "writingMode",
  "x1",
  "x2",
  "x",
  "xChannelSelector",
  "xHeight",
  "xlinkActuate",
  "xlinkArcrole",
  "xlinkHref",
  "xlinkRole",
  "xlinkShow",
  "xlinkTitle",
  "xlinkType",
  "xmlBase",
  "xmlLang",
  "xmlns",
  "xmlnsXlink",
  "xmlSpace",
  "y1",
  "y2",
  "y",
  "yChannelSelector",
  "z",
  "zoomAndPan",
  "ref",
  "key",
  "angle"
];
var PolyElementKeys = ["points", "pathLength"];
var FilteredElementKeyMap = {
  svg: SVGContainerPropKeys,
  polygon: PolyElementKeys,
  polyline: PolyElementKeys
};
var EventKeys = ["dangerouslySetInnerHTML", "onCopy", "onCopyCapture", "onCut", "onCutCapture", "onPaste", "onPasteCapture", "onCompositionEnd", "onCompositionEndCapture", "onCompositionStart", "onCompositionStartCapture", "onCompositionUpdate", "onCompositionUpdateCapture", "onFocus", "onFocusCapture", "onBlur", "onBlurCapture", "onChange", "onChangeCapture", "onBeforeInput", "onBeforeInputCapture", "onInput", "onInputCapture", "onReset", "onResetCapture", "onSubmit", "onSubmitCapture", "onInvalid", "onInvalidCapture", "onLoad", "onLoadCapture", "onError", "onErrorCapture", "onKeyDown", "onKeyDownCapture", "onKeyPress", "onKeyPressCapture", "onKeyUp", "onKeyUpCapture", "onAbort", "onAbortCapture", "onCanPlay", "onCanPlayCapture", "onCanPlayThrough", "onCanPlayThroughCapture", "onDurationChange", "onDurationChangeCapture", "onEmptied", "onEmptiedCapture", "onEncrypted", "onEncryptedCapture", "onEnded", "onEndedCapture", "onLoadedData", "onLoadedDataCapture", "onLoadedMetadata", "onLoadedMetadataCapture", "onLoadStart", "onLoadStartCapture", "onPause", "onPauseCapture", "onPlay", "onPlayCapture", "onPlaying", "onPlayingCapture", "onProgress", "onProgressCapture", "onRateChange", "onRateChangeCapture", "onSeeked", "onSeekedCapture", "onSeeking", "onSeekingCapture", "onStalled", "onStalledCapture", "onSuspend", "onSuspendCapture", "onTimeUpdate", "onTimeUpdateCapture", "onVolumeChange", "onVolumeChangeCapture", "onWaiting", "onWaitingCapture", "onAuxClick", "onAuxClickCapture", "onClick", "onClickCapture", "onContextMenu", "onContextMenuCapture", "onDoubleClick", "onDoubleClickCapture", "onDrag", "onDragCapture", "onDragEnd", "onDragEndCapture", "onDragEnter", "onDragEnterCapture", "onDragExit", "onDragExitCapture", "onDragLeave", "onDragLeaveCapture", "onDragOver", "onDragOverCapture", "onDragStart", "onDragStartCapture", "onDrop", "onDropCapture", "onMouseDown", "onMouseDownCapture", "onMouseEnter", "onMouseLeave", "onMouseMove", "onMouseMoveCapture", "onMouseOut", "onMouseOutCapture", "onMouseOver", "onMouseOverCapture", "onMouseUp", "onMouseUpCapture", "onSelect", "onSelectCapture", "onTouchCancel", "onTouchCancelCapture", "onTouchEnd", "onTouchEndCapture", "onTouchMove", "onTouchMoveCapture", "onTouchStart", "onTouchStartCapture", "onPointerDown", "onPointerDownCapture", "onPointerMove", "onPointerMoveCapture", "onPointerUp", "onPointerUpCapture", "onPointerCancel", "onPointerCancelCapture", "onPointerEnter", "onPointerEnterCapture", "onPointerLeave", "onPointerLeaveCapture", "onPointerOver", "onPointerOverCapture", "onPointerOut", "onPointerOutCapture", "onGotPointerCapture", "onGotPointerCaptureCapture", "onLostPointerCapture", "onLostPointerCaptureCapture", "onScroll", "onScrollCapture", "onWheel", "onWheelCapture", "onAnimationStart", "onAnimationStartCapture", "onAnimationEnd", "onAnimationEndCapture", "onAnimationIteration", "onAnimationIterationCapture", "onTransitionEnd", "onTransitionEndCapture"];
var adaptEventHandlers = function adaptEventHandlers2(props, newHandler) {
  if (!props || typeof props === "function" || typeof props === "boolean") {
    return null;
  }
  var inputProps = props;
  if (/* @__PURE__ */ reactExports.isValidElement(props)) {
    inputProps = props.props;
  }
  if (!_isObject(inputProps)) {
    return null;
  }
  var out = {};
  Object.keys(inputProps).forEach(function(key) {
    if (EventKeys.includes(key)) {
      out[key] = newHandler || function(e3) {
        return inputProps[key](inputProps, e3);
      };
    }
  });
  return out;
};
var getEventHandlerOfChild = function getEventHandlerOfChild2(originalHandler, data, index) {
  return function(e3) {
    originalHandler(data, index, e3);
    return null;
  };
};
var adaptEventsOfChild = function adaptEventsOfChild2(props, data, index) {
  if (!_isObject(props) || _typeof$v(props) !== "object") {
    return null;
  }
  var out = null;
  Object.keys(props).forEach(function(key) {
    var item = props[key];
    if (EventKeys.includes(key) && typeof item === "function") {
      if (!out)
        out = {};
      out[key] = getEventHandlerOfChild(item, data, index);
    }
  });
  return out;
};
var _excluded$e = ["children"], _excluded2$2 = ["children"];
function _objectWithoutProperties$f(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$f(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$f(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var REACT_BROWSER_EVENT_MAP = {
  click: "onClick",
  mousedown: "onMouseDown",
  mouseup: "onMouseUp",
  mouseover: "onMouseOver",
  mousemove: "onMouseMove",
  mouseout: "onMouseOut",
  mouseenter: "onMouseEnter",
  mouseleave: "onMouseLeave",
  touchcancel: "onTouchCancel",
  touchend: "onTouchEnd",
  touchmove: "onTouchMove",
  touchstart: "onTouchStart"
};
var getDisplayName = function getDisplayName2(Comp) {
  if (typeof Comp === "string") {
    return Comp;
  }
  if (!Comp) {
    return "";
  }
  return Comp.displayName || Comp.name || "Component";
};
var lastChildren = null;
var lastResult = null;
var toArray = function toArray2(children) {
  if (children === lastChildren && _isArray(lastResult)) {
    return lastResult;
  }
  var result = [];
  reactExports.Children.forEach(children, function(child) {
    if (_isNil(child))
      return;
    if (reactIsExports.isFragment(child)) {
      result = result.concat(toArray2(child.props.children));
    } else {
      result.push(child);
    }
  });
  lastResult = result;
  lastChildren = children;
  return result;
};
function findAllByType(children, type) {
  var result = [];
  var types = [];
  if (_isArray(type)) {
    types = type.map(function(t2) {
      return getDisplayName(t2);
    });
  } else {
    types = [getDisplayName(type)];
  }
  toArray(children).forEach(function(child) {
    var childType = _get(child, "type.displayName") || _get(child, "type.name");
    if (types.indexOf(childType) !== -1) {
      result.push(child);
    }
  });
  return result;
}
function findChildByType(children, type) {
  var result = findAllByType(children, type);
  return result && result[0];
}
var validateWidthHeight = function validateWidthHeight2(el) {
  if (!el || !el.props) {
    return false;
  }
  var _el$props = el.props, width = _el$props.width, height = _el$props.height;
  if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0) {
    return false;
  }
  return true;
};
var SVG_TAGS = ["a", "altGlyph", "altGlyphDef", "altGlyphItem", "animate", "animateColor", "animateMotion", "animateTransform", "circle", "clipPath", "color-profile", "cursor", "defs", "desc", "ellipse", "feBlend", "feColormatrix", "feComponentTransfer", "feComposite", "feConvolveMatrix", "feDiffuseLighting", "feDisplacementMap", "feDistantLight", "feFlood", "feFuncA", "feFuncB", "feFuncG", "feFuncR", "feGaussianBlur", "feImage", "feMerge", "feMergeNode", "feMorphology", "feOffset", "fePointLight", "feSpecularLighting", "feSpotLight", "feTile", "feTurbulence", "filter", "font", "font-face", "font-face-format", "font-face-name", "font-face-url", "foreignObject", "g", "glyph", "glyphRef", "hkern", "image", "line", "lineGradient", "marker", "mask", "metadata", "missing-glyph", "mpath", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "script", "set", "stop", "style", "svg", "switch", "symbol", "text", "textPath", "title", "tref", "tspan", "use", "view", "vkern"];
var isSvgElement = function isSvgElement2(child) {
  return child && child.type && _isString(child.type) && SVG_TAGS.indexOf(child.type) >= 0;
};
var isValidSpreadableProp = function isValidSpreadableProp2(property2, key, includeEvents, svgElementType) {
  var _FilteredElementKeyMa;
  var matchingElementTypeKeys = (_FilteredElementKeyMa = FilteredElementKeyMap === null || FilteredElementKeyMap === void 0 ? void 0 : FilteredElementKeyMap[svgElementType]) !== null && _FilteredElementKeyMa !== void 0 ? _FilteredElementKeyMa : [];
  return !_isFunction(property2) && (svgElementType && matchingElementTypeKeys.includes(key) || SVGElementPropKeys.includes(key)) || includeEvents && EventKeys.includes(key);
};
var filterProps = function filterProps2(props, includeEvents, svgElementType) {
  if (!props || typeof props === "function" || typeof props === "boolean") {
    return null;
  }
  var inputProps = props;
  if (/* @__PURE__ */ reactExports.isValidElement(props)) {
    inputProps = props.props;
  }
  if (!_isObject(inputProps)) {
    return null;
  }
  var out = {};
  Object.keys(inputProps).forEach(function(key) {
    var _inputProps;
    if (isValidSpreadableProp((_inputProps = inputProps) === null || _inputProps === void 0 ? void 0 : _inputProps[key], key, includeEvents, svgElementType)) {
      out[key] = inputProps[key];
    }
  });
  return out;
};
var isChildrenEqual = function isChildrenEqual2(nextChildren, prevChildren) {
  if (nextChildren === prevChildren) {
    return true;
  }
  var count = reactExports.Children.count(nextChildren);
  if (count !== reactExports.Children.count(prevChildren)) {
    return false;
  }
  if (count === 0) {
    return true;
  }
  if (count === 1) {
    return isSingleChildEqual(_isArray(nextChildren) ? nextChildren[0] : nextChildren, _isArray(prevChildren) ? prevChildren[0] : prevChildren);
  }
  for (var i = 0; i < count; i++) {
    var nextChild = nextChildren[i];
    var prevChild = prevChildren[i];
    if (_isArray(nextChild) || _isArray(prevChild)) {
      if (!isChildrenEqual2(nextChild, prevChild)) {
        return false;
      }
    } else if (!isSingleChildEqual(nextChild, prevChild)) {
      return false;
    }
  }
  return true;
};
var isSingleChildEqual = function isSingleChildEqual2(nextChild, prevChild) {
  if (_isNil(nextChild) && _isNil(prevChild)) {
    return true;
  }
  if (!_isNil(nextChild) && !_isNil(prevChild)) {
    var _ref = nextChild.props || {}, nextChildren = _ref.children, nextProps = _objectWithoutProperties$f(_ref, _excluded$e);
    var _ref2 = prevChild.props || {}, prevChildren = _ref2.children, prevProps = _objectWithoutProperties$f(_ref2, _excluded2$2);
    if (nextChildren && prevChildren) {
      return shallowEqual(nextProps, prevProps) && isChildrenEqual(nextChildren, prevChildren);
    }
    if (!nextChildren && !prevChildren) {
      return shallowEqual(nextProps, prevProps);
    }
    return false;
  }
  return false;
};
var renderByOrder = function renderByOrder2(children, renderMap) {
  var elements = [];
  var record = {};
  toArray(children).forEach(function(child, index) {
    if (isSvgElement(child)) {
      elements.push(child);
    } else if (child) {
      var displayName = getDisplayName(child.type);
      var _ref3 = renderMap[displayName] || {}, handler = _ref3.handler, once = _ref3.once;
      if (handler && (!once || !record[displayName])) {
        var results = handler(child, displayName, index);
        elements.push(results);
        record[displayName] = true;
      }
    }
  });
  return elements;
};
var getReactEventByType = function getReactEventByType2(e3) {
  var type = e3 && e3.type;
  if (type && REACT_BROWSER_EVENT_MAP[type]) {
    return REACT_BROWSER_EVENT_MAP[type];
  }
  return null;
};
var parseChildIndex = function parseChildIndex2(child, children) {
  return toArray(children).indexOf(child);
};
var _excluded$d = ["children", "width", "height", "viewBox", "className", "style"];
function _extends$o() {
  _extends$o = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$o.apply(this, arguments);
}
function _objectWithoutProperties$e(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$e(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$e(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function Surface(props) {
  var children = props.children, width = props.width, height = props.height, viewBox = props.viewBox, className = props.className, style = props.style, others = _objectWithoutProperties$e(props, _excluded$d);
  var svgView = viewBox || {
    width,
    height,
    x: 0,
    y: 0
  };
  var layerClass = classNames("recharts-surface", className);
  return /* @__PURE__ */ React.createElement("svg", _extends$o({}, filterProps(others, true, "svg"), {
    className: layerClass,
    width,
    height,
    style,
    viewBox: "".concat(svgView.x, " ").concat(svgView.y, " ").concat(svgView.width, " ").concat(svgView.height)
  }), /* @__PURE__ */ React.createElement("title", null, props.title), /* @__PURE__ */ React.createElement("desc", null, props.desc), children);
}
var _excluded$c = ["children", "className"];
function _extends$n() {
  _extends$n = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$n.apply(this, arguments);
}
function _objectWithoutProperties$d(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$d(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$d(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var Layer = /* @__PURE__ */ React.forwardRef(function(props, ref) {
  var children = props.children, className = props.className, others = _objectWithoutProperties$d(props, _excluded$c);
  var layerClass = classNames("recharts-layer", className);
  return /* @__PURE__ */ React.createElement("g", _extends$n({
    className: layerClass
  }, filterProps(others, true), {
    ref
  }), children);
});
var ListCache$2 = _ListCache;
function stackClear$1() {
  this.__data__ = new ListCache$2();
  this.size = 0;
}
var _stackClear = stackClear$1;
function stackDelete$1(key) {
  var data = this.__data__, result = data["delete"](key);
  this.size = data.size;
  return result;
}
var _stackDelete = stackDelete$1;
function stackGet$1(key) {
  return this.__data__.get(key);
}
var _stackGet = stackGet$1;
function stackHas$1(key) {
  return this.__data__.has(key);
}
var _stackHas = stackHas$1;
var ListCache$1 = _ListCache, Map$2 = _Map, MapCache$1 = _MapCache;
var LARGE_ARRAY_SIZE$1 = 200;
function stackSet$1(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache$1) {
    var pairs = data.__data__;
    if (!Map$2 || pairs.length < LARGE_ARRAY_SIZE$1 - 1) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache$1(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}
var _stackSet = stackSet$1;
var ListCache = _ListCache, stackClear = _stackClear, stackDelete = _stackDelete, stackGet = _stackGet, stackHas = _stackHas, stackSet = _stackSet;
function Stack$2(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}
Stack$2.prototype.clear = stackClear;
Stack$2.prototype["delete"] = stackDelete;
Stack$2.prototype.get = stackGet;
Stack$2.prototype.has = stackHas;
Stack$2.prototype.set = stackSet;
var _Stack = Stack$2;
var HASH_UNDEFINED = "__lodash_hash_undefined__";
function setCacheAdd$1(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}
var _setCacheAdd = setCacheAdd$1;
function setCacheHas$1(value) {
  return this.__data__.has(value);
}
var _setCacheHas = setCacheHas$1;
var MapCache = _MapCache, setCacheAdd = _setCacheAdd, setCacheHas = _setCacheHas;
function SetCache$2(values) {
  var index = -1, length = values == null ? 0 : values.length;
  this.__data__ = new MapCache();
  while (++index < length) {
    this.add(values[index]);
  }
}
SetCache$2.prototype.add = SetCache$2.prototype.push = setCacheAdd;
SetCache$2.prototype.has = setCacheHas;
var _SetCache = SetCache$2;
function arraySome$2(array2, predicate) {
  var index = -1, length = array2 == null ? 0 : array2.length;
  while (++index < length) {
    if (predicate(array2[index], index, array2)) {
      return true;
    }
  }
  return false;
}
var _arraySome = arraySome$2;
function cacheHas$2(cache, key) {
  return cache.has(key);
}
var _cacheHas = cacheHas$2;
var SetCache$1 = _SetCache, arraySome$1 = _arraySome, cacheHas$1 = _cacheHas;
var COMPARE_PARTIAL_FLAG$5 = 1, COMPARE_UNORDERED_FLAG$3 = 2;
function equalArrays$2(array2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$5, arrLength = array2.length, othLength = other.length;
  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  var arrStacked = stack.get(array2);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array2;
  }
  var index = -1, result = true, seen = bitmask & COMPARE_UNORDERED_FLAG$3 ? new SetCache$1() : void 0;
  stack.set(array2, other);
  stack.set(other, array2);
  while (++index < arrLength) {
    var arrValue = array2[index], othValue = other[index];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, arrValue, index, other, array2, stack) : customizer(arrValue, othValue, index, array2, other, stack);
    }
    if (compared !== void 0) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    if (seen) {
      if (!arraySome$1(other, function(othValue2, othIndex) {
        if (!cacheHas$1(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
          return seen.push(othIndex);
        }
      })) {
        result = false;
        break;
      }
    } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
      result = false;
      break;
    }
  }
  stack["delete"](array2);
  stack["delete"](other);
  return result;
}
var _equalArrays = equalArrays$2;
var root$8 = _root$1;
var Uint8Array$1 = root$8.Uint8Array;
var _Uint8Array = Uint8Array$1;
function mapToArray$1(map2) {
  var index = -1, result = Array(map2.size);
  map2.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}
var _mapToArray = mapToArray$1;
function setToArray$3(set2) {
  var index = -1, result = Array(set2.size);
  set2.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}
var _setToArray = setToArray$3;
var Symbol$6 = _Symbol$1, Uint8Array = _Uint8Array, eq$1 = eq_1, equalArrays$1 = _equalArrays, mapToArray = _mapToArray, setToArray$2 = _setToArray;
var COMPARE_PARTIAL_FLAG$4 = 1, COMPARE_UNORDERED_FLAG$2 = 2;
var boolTag$2 = "[object Boolean]", dateTag$1 = "[object Date]", errorTag$1 = "[object Error]", mapTag$2 = "[object Map]", numberTag$1 = "[object Number]", regexpTag$1 = "[object RegExp]", setTag$2 = "[object Set]", stringTag$1 = "[object String]", symbolTag$1 = "[object Symbol]";
var arrayBufferTag$1 = "[object ArrayBuffer]", dataViewTag$2 = "[object DataView]";
var symbolProto = Symbol$6 ? Symbol$6.prototype : void 0, symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
function equalByTag$1(object2, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag$2:
      if (object2.byteLength != other.byteLength || object2.byteOffset != other.byteOffset) {
        return false;
      }
      object2 = object2.buffer;
      other = other.buffer;
    case arrayBufferTag$1:
      if (object2.byteLength != other.byteLength || !equalFunc(new Uint8Array(object2), new Uint8Array(other))) {
        return false;
      }
      return true;
    case boolTag$2:
    case dateTag$1:
    case numberTag$1:
      return eq$1(+object2, +other);
    case errorTag$1:
      return object2.name == other.name && object2.message == other.message;
    case regexpTag$1:
    case stringTag$1:
      return object2 == other + "";
    case mapTag$2:
      var convert2 = mapToArray;
    case setTag$2:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG$4;
      convert2 || (convert2 = setToArray$2);
      if (object2.size != other.size && !isPartial) {
        return false;
      }
      var stacked = stack.get(object2);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG$2;
      stack.set(object2, other);
      var result = equalArrays$1(convert2(object2), convert2(other), bitmask, customizer, equalFunc, stack);
      stack["delete"](object2);
      return result;
    case symbolTag$1:
      if (symbolValueOf) {
        return symbolValueOf.call(object2) == symbolValueOf.call(other);
      }
  }
  return false;
}
var _equalByTag = equalByTag$1;
function arrayPush$2(array2, values) {
  var index = -1, length = values.length, offset = array2.length;
  while (++index < length) {
    array2[offset + index] = values[index];
  }
  return array2;
}
var _arrayPush = arrayPush$2;
var arrayPush$1 = _arrayPush, isArray$9 = isArray_1;
function baseGetAllKeys$1(object2, keysFunc, symbolsFunc) {
  var result = keysFunc(object2);
  return isArray$9(object2) ? result : arrayPush$1(result, symbolsFunc(object2));
}
var _baseGetAllKeys = baseGetAllKeys$1;
function arrayFilter$1(array2, predicate) {
  var index = -1, length = array2 == null ? 0 : array2.length, resIndex = 0, result = [];
  while (++index < length) {
    var value = array2[index];
    if (predicate(value, index, array2)) {
      result[resIndex++] = value;
    }
  }
  return result;
}
var _arrayFilter = arrayFilter$1;
function stubArray$1() {
  return [];
}
var stubArray_1 = stubArray$1;
var arrayFilter = _arrayFilter, stubArray = stubArray_1;
var objectProto$8 = Object.prototype;
var propertyIsEnumerable$1 = objectProto$8.propertyIsEnumerable;
var nativeGetSymbols = Object.getOwnPropertySymbols;
var getSymbols$1 = !nativeGetSymbols ? stubArray : function(object2) {
  if (object2 == null) {
    return [];
  }
  object2 = Object(object2);
  return arrayFilter(nativeGetSymbols(object2), function(symbol) {
    return propertyIsEnumerable$1.call(object2, symbol);
  });
};
var _getSymbols = getSymbols$1;
function baseTimes$1(n2, iteratee) {
  var index = -1, result = Array(n2);
  while (++index < n2) {
    result[index] = iteratee(index);
  }
  return result;
}
var _baseTimes = baseTimes$1;
var baseGetTag$5 = _baseGetTag$1, isObjectLike$6 = isObjectLike_1$1;
var argsTag$2 = "[object Arguments]";
function baseIsArguments$1(value) {
  return isObjectLike$6(value) && baseGetTag$5(value) == argsTag$2;
}
var _baseIsArguments = baseIsArguments$1;
var baseIsArguments = _baseIsArguments, isObjectLike$5 = isObjectLike_1$1;
var objectProto$7 = Object.prototype;
var hasOwnProperty$6 = objectProto$7.hasOwnProperty;
var propertyIsEnumerable = objectProto$7.propertyIsEnumerable;
var isArguments$3 = baseIsArguments(/* @__PURE__ */ function() {
  return arguments;
}()) ? baseIsArguments : function(value) {
  return isObjectLike$5(value) && hasOwnProperty$6.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
};
var isArguments_1 = isArguments$3;
var isBuffer$2 = { exports: {} };
function stubFalse() {
  return false;
}
var stubFalse_1 = stubFalse;
isBuffer$2.exports;
(function(module, exports) {
  var root2 = _root$1, stubFalse2 = stubFalse_1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var Buffer = moduleExports ? root2.Buffer : void 0;
  var nativeIsBuffer = Buffer ? Buffer.isBuffer : void 0;
  var isBuffer2 = nativeIsBuffer || stubFalse2;
  module.exports = isBuffer2;
})(isBuffer$2, isBuffer$2.exports);
var isBufferExports = isBuffer$2.exports;
var MAX_SAFE_INTEGER$2 = 9007199254740991;
var reIsUint = /^(?:0|[1-9]\d*)$/;
function isIndex$3(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER$2 : length;
  return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
}
var _isIndex = isIndex$3;
var MAX_SAFE_INTEGER$1 = 9007199254740991;
function isLength$3(value) {
  return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER$1;
}
var isLength_1 = isLength$3;
var baseGetTag$4 = _baseGetTag$1, isLength$2 = isLength_1, isObjectLike$4 = isObjectLike_1$1;
var argsTag$1 = "[object Arguments]", arrayTag$1 = "[object Array]", boolTag$1 = "[object Boolean]", dateTag = "[object Date]", errorTag = "[object Error]", funcTag = "[object Function]", mapTag$1 = "[object Map]", numberTag = "[object Number]", objectTag$2 = "[object Object]", regexpTag = "[object RegExp]", setTag$1 = "[object Set]", stringTag = "[object String]", weakMapTag$1 = "[object WeakMap]";
var arrayBufferTag = "[object ArrayBuffer]", dataViewTag$1 = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag$1] = typedArrayTags[arrayTag$1] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag$1] = typedArrayTags[dataViewTag$1] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag$1] = typedArrayTags[numberTag] = typedArrayTags[objectTag$2] = typedArrayTags[regexpTag] = typedArrayTags[setTag$1] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag$1] = false;
function baseIsTypedArray$1(value) {
  return isObjectLike$4(value) && isLength$2(value.length) && !!typedArrayTags[baseGetTag$4(value)];
}
var _baseIsTypedArray = baseIsTypedArray$1;
function baseUnary$2(func) {
  return function(value) {
    return func(value);
  };
}
var _baseUnary = baseUnary$2;
var _nodeUtil = { exports: {} };
_nodeUtil.exports;
(function(module, exports) {
  var freeGlobal2 = _freeGlobal$1;
  var freeExports = exports && !exports.nodeType && exports;
  var freeModule = freeExports && true && module && !module.nodeType && module;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal2.process;
  var nodeUtil2 = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e3) {
    }
  }();
  module.exports = nodeUtil2;
})(_nodeUtil, _nodeUtil.exports);
var _nodeUtilExports = _nodeUtil.exports;
var baseIsTypedArray = _baseIsTypedArray, baseUnary$1 = _baseUnary, nodeUtil = _nodeUtilExports;
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
var isTypedArray$2 = nodeIsTypedArray ? baseUnary$1(nodeIsTypedArray) : baseIsTypedArray;
var isTypedArray_1 = isTypedArray$2;
var baseTimes = _baseTimes, isArguments$2 = isArguments_1, isArray$8 = isArray_1, isBuffer$1 = isBufferExports, isIndex$2 = _isIndex, isTypedArray$1 = isTypedArray_1;
var objectProto$6 = Object.prototype;
var hasOwnProperty$5 = objectProto$6.hasOwnProperty;
function arrayLikeKeys$1(value, inherited) {
  var isArr = isArray$8(value), isArg = !isArr && isArguments$2(value), isBuff = !isArr && !isArg && isBuffer$1(value), isType = !isArr && !isArg && !isBuff && isTypedArray$1(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
  for (var key in value) {
    if ((inherited || hasOwnProperty$5.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
    (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
    isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
    isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
    isIndex$2(key, length)))) {
      result.push(key);
    }
  }
  return result;
}
var _arrayLikeKeys = arrayLikeKeys$1;
var objectProto$5 = Object.prototype;
function isPrototype$1(value) {
  var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto$5;
  return value === proto;
}
var _isPrototype = isPrototype$1;
function overArg$1(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}
var _overArg = overArg$1;
var overArg = _overArg;
var nativeKeys$1 = overArg(Object.keys, Object);
var _nativeKeys = nativeKeys$1;
var isPrototype = _isPrototype, nativeKeys = _nativeKeys;
var objectProto$4 = Object.prototype;
var hasOwnProperty$4 = objectProto$4.hasOwnProperty;
function baseKeys$1(object2) {
  if (!isPrototype(object2)) {
    return nativeKeys(object2);
  }
  var result = [];
  for (var key in Object(object2)) {
    if (hasOwnProperty$4.call(object2, key) && key != "constructor") {
      result.push(key);
    }
  }
  return result;
}
var _baseKeys = baseKeys$1;
var isFunction$1 = isFunction_1, isLength$1 = isLength_1;
function isArrayLike$5(value) {
  return value != null && isLength$1(value.length) && !isFunction$1(value);
}
var isArrayLike_1 = isArrayLike$5;
var arrayLikeKeys = _arrayLikeKeys, baseKeys = _baseKeys, isArrayLike$4 = isArrayLike_1;
function keys$5(object2) {
  return isArrayLike$4(object2) ? arrayLikeKeys(object2) : baseKeys(object2);
}
var keys_1 = keys$5;
var baseGetAllKeys = _baseGetAllKeys, getSymbols = _getSymbols, keys$4 = keys_1;
function getAllKeys$1(object2) {
  return baseGetAllKeys(object2, keys$4, getSymbols);
}
var _getAllKeys = getAllKeys$1;
var getAllKeys = _getAllKeys;
var COMPARE_PARTIAL_FLAG$3 = 1;
var objectProto$3 = Object.prototype;
var hasOwnProperty$3 = objectProto$3.hasOwnProperty;
function equalObjects$1(object2, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG$3, objProps = getAllKeys(object2), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty$3.call(other, key))) {
      return false;
    }
  }
  var objStacked = stack.get(object2);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object2;
  }
  var result = true;
  stack.set(object2, other);
  stack.set(other, object2);
  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object2[key], othValue = other[key];
    if (customizer) {
      var compared = isPartial ? customizer(othValue, objValue, key, other, object2, stack) : customizer(objValue, othValue, key, object2, other, stack);
    }
    if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == "constructor");
  }
  if (result && !skipCtor) {
    var objCtor = object2.constructor, othCtor = other.constructor;
    if (objCtor != othCtor && ("constructor" in object2 && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack["delete"](object2);
  stack["delete"](other);
  return result;
}
var _equalObjects = equalObjects$1;
var getNative$4 = _getNative, root$7 = _root$1;
var DataView$2 = getNative$4(root$7, "DataView");
var _DataView = DataView$2;
var getNative$3 = _getNative, root$6 = _root$1;
var Promise$2 = getNative$3(root$6, "Promise");
var _Promise = Promise$2;
var getNative$2 = _getNative, root$5 = _root$1;
var Set$3 = getNative$2(root$5, "Set");
var _Set = Set$3;
var getNative$1 = _getNative, root$4 = _root$1;
var WeakMap$1 = getNative$1(root$4, "WeakMap");
var _WeakMap = WeakMap$1;
var DataView$1 = _DataView, Map$1 = _Map, Promise$1 = _Promise, Set$2 = _Set, WeakMap = _WeakMap, baseGetTag$3 = _baseGetTag$1, toSource = _toSource;
var mapTag = "[object Map]", objectTag$1 = "[object Object]", promiseTag = "[object Promise]", setTag = "[object Set]", weakMapTag = "[object WeakMap]";
var dataViewTag = "[object DataView]";
var dataViewCtorString = toSource(DataView$1), mapCtorString = toSource(Map$1), promiseCtorString = toSource(Promise$1), setCtorString = toSource(Set$2), weakMapCtorString = toSource(WeakMap);
var getTag$1 = baseGetTag$3;
if (DataView$1 && getTag$1(new DataView$1(new ArrayBuffer(1))) != dataViewTag || Map$1 && getTag$1(new Map$1()) != mapTag || Promise$1 && getTag$1(Promise$1.resolve()) != promiseTag || Set$2 && getTag$1(new Set$2()) != setTag || WeakMap && getTag$1(new WeakMap()) != weakMapTag) {
  getTag$1 = function(value) {
    var result = baseGetTag$3(value), Ctor = result == objectTag$1 ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : "";
    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString:
          return dataViewTag;
        case mapCtorString:
          return mapTag;
        case promiseCtorString:
          return promiseTag;
        case setCtorString:
          return setTag;
        case weakMapCtorString:
          return weakMapTag;
      }
    }
    return result;
  };
}
var _getTag = getTag$1;
var Stack$1 = _Stack, equalArrays = _equalArrays, equalByTag = _equalByTag, equalObjects = _equalObjects, getTag = _getTag, isArray$7 = isArray_1, isBuffer = isBufferExports, isTypedArray = isTypedArray_1;
var COMPARE_PARTIAL_FLAG$2 = 1;
var argsTag = "[object Arguments]", arrayTag = "[object Array]", objectTag = "[object Object]";
var objectProto$2 = Object.prototype;
var hasOwnProperty$2 = objectProto$2.hasOwnProperty;
function baseIsEqualDeep$1(object2, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray$7(object2), othIsArr = isArray$7(other), objTag = objIsArr ? arrayTag : getTag(object2), othTag = othIsArr ? arrayTag : getTag(other);
  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;
  var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
  if (isSameTag && isBuffer(object2)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack$1());
    return objIsArr || isTypedArray(object2) ? equalArrays(object2, other, bitmask, customizer, equalFunc, stack) : equalByTag(object2, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG$2)) {
    var objIsWrapped = objIsObj && hasOwnProperty$2.call(object2, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty$2.call(other, "__wrapped__");
    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object2.value() : object2, othUnwrapped = othIsWrapped ? other.value() : other;
      stack || (stack = new Stack$1());
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack$1());
  return equalObjects(object2, other, bitmask, customizer, equalFunc, stack);
}
var _baseIsEqualDeep = baseIsEqualDeep$1;
var baseIsEqualDeep = _baseIsEqualDeep, isObjectLike$3 = isObjectLike_1$1;
function baseIsEqual$3(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike$3(value) && !isObjectLike$3(other)) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual$3, stack);
}
var _baseIsEqual = baseIsEqual$3;
var Stack = _Stack, baseIsEqual$2 = _baseIsEqual;
var COMPARE_PARTIAL_FLAG$1 = 1, COMPARE_UNORDERED_FLAG$1 = 2;
function baseIsMatch$1(object2, source, matchData, customizer) {
  var index = matchData.length, length = index, noCustomizer = !customizer;
  if (object2 == null) {
    return !length;
  }
  object2 = Object(object2);
  while (index--) {
    var data = matchData[index];
    if (noCustomizer && data[2] ? data[1] !== object2[data[0]] : !(data[0] in object2)) {
      return false;
    }
  }
  while (++index < length) {
    data = matchData[index];
    var key = data[0], objValue = object2[key], srcValue = data[1];
    if (noCustomizer && data[2]) {
      if (objValue === void 0 && !(key in object2)) {
        return false;
      }
    } else {
      var stack = new Stack();
      if (customizer) {
        var result = customizer(objValue, srcValue, key, object2, source, stack);
      }
      if (!(result === void 0 ? baseIsEqual$2(srcValue, objValue, COMPARE_PARTIAL_FLAG$1 | COMPARE_UNORDERED_FLAG$1, customizer, stack) : result)) {
        return false;
      }
    }
  }
  return true;
}
var _baseIsMatch = baseIsMatch$1;
var isObject$6 = isObject_1$1;
function isStrictComparable$2(value) {
  return value === value && !isObject$6(value);
}
var _isStrictComparable = isStrictComparable$2;
var isStrictComparable$1 = _isStrictComparable, keys$3 = keys_1;
function getMatchData$1(object2) {
  var result = keys$3(object2), length = result.length;
  while (length--) {
    var key = result[length], value = object2[key];
    result[length] = [key, value, isStrictComparable$1(value)];
  }
  return result;
}
var _getMatchData = getMatchData$1;
function matchesStrictComparable$2(key, srcValue) {
  return function(object2) {
    if (object2 == null) {
      return false;
    }
    return object2[key] === srcValue && (srcValue !== void 0 || key in Object(object2));
  };
}
var _matchesStrictComparable = matchesStrictComparable$2;
var baseIsMatch = _baseIsMatch, getMatchData = _getMatchData, matchesStrictComparable$1 = _matchesStrictComparable;
function baseMatches$1(source) {
  var matchData = getMatchData(source);
  if (matchData.length == 1 && matchData[0][2]) {
    return matchesStrictComparable$1(matchData[0][0], matchData[0][1]);
  }
  return function(object2) {
    return object2 === source || baseIsMatch(object2, source, matchData);
  };
}
var _baseMatches = baseMatches$1;
function baseHasIn$1(object2, key) {
  return object2 != null && key in Object(object2);
}
var _baseHasIn = baseHasIn$1;
var castPath = _castPath, isArguments$1 = isArguments_1, isArray$6 = isArray_1, isIndex$1 = _isIndex, isLength = isLength_1, toKey$2 = _toKey;
function hasPath$1(object2, path, hasFunc) {
  path = castPath(path, object2);
  var index = -1, length = path.length, result = false;
  while (++index < length) {
    var key = toKey$2(path[index]);
    if (!(result = object2 != null && hasFunc(object2, key))) {
      break;
    }
    object2 = object2[key];
  }
  if (result || ++index != length) {
    return result;
  }
  length = object2 == null ? 0 : object2.length;
  return !!length && isLength(length) && isIndex$1(key, length) && (isArray$6(object2) || isArguments$1(object2));
}
var _hasPath = hasPath$1;
var baseHasIn = _baseHasIn, hasPath = _hasPath;
function hasIn$1(object2, path) {
  return object2 != null && hasPath(object2, path, baseHasIn);
}
var hasIn_1 = hasIn$1;
var baseIsEqual$1 = _baseIsEqual, get = get_1, hasIn = hasIn_1, isKey$1 = _isKey, isStrictComparable = _isStrictComparable, matchesStrictComparable = _matchesStrictComparable, toKey$1 = _toKey;
var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
function baseMatchesProperty$1(path, srcValue) {
  if (isKey$1(path) && isStrictComparable(srcValue)) {
    return matchesStrictComparable(toKey$1(path), srcValue);
  }
  return function(object2) {
    var objValue = get(object2, path);
    return objValue === void 0 && objValue === srcValue ? hasIn(object2, path) : baseIsEqual$1(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  };
}
var _baseMatchesProperty = baseMatchesProperty$1;
function identity$b(value) {
  return value;
}
var identity_1 = identity$b;
function baseProperty$1(key) {
  return function(object2) {
    return object2 == null ? void 0 : object2[key];
  };
}
var _baseProperty = baseProperty$1;
var baseGet$1 = _baseGet;
function basePropertyDeep$1(path) {
  return function(object2) {
    return baseGet$1(object2, path);
  };
}
var _basePropertyDeep = basePropertyDeep$1;
var baseProperty = _baseProperty, basePropertyDeep = _basePropertyDeep, isKey = _isKey, toKey = _toKey;
function property$1(path) {
  return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
}
var property_1 = property$1;
var baseMatches = _baseMatches, baseMatchesProperty = _baseMatchesProperty, identity$a = identity_1, isArray$5 = isArray_1, property = property_1;
function baseIteratee$8(value) {
  if (typeof value == "function") {
    return value;
  }
  if (value == null) {
    return identity$a;
  }
  if (typeof value == "object") {
    return isArray$5(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
  }
  return property(value);
}
var _baseIteratee = baseIteratee$8;
function baseFindIndex$2(array2, predicate, fromIndex, fromRight) {
  var length = array2.length, index = fromIndex + (fromRight ? 1 : -1);
  while (fromRight ? index-- : ++index < length) {
    if (predicate(array2[index], index, array2)) {
      return index;
    }
  }
  return -1;
}
var _baseFindIndex = baseFindIndex$2;
function baseIsNaN$1(value) {
  return value !== value;
}
var _baseIsNaN = baseIsNaN$1;
function strictIndexOf$1(array2, value, fromIndex) {
  var index = fromIndex - 1, length = array2.length;
  while (++index < length) {
    if (array2[index] === value) {
      return index;
    }
  }
  return -1;
}
var _strictIndexOf = strictIndexOf$1;
var baseFindIndex$1 = _baseFindIndex, baseIsNaN = _baseIsNaN, strictIndexOf = _strictIndexOf;
function baseIndexOf$1(array2, value, fromIndex) {
  return value === value ? strictIndexOf(array2, value, fromIndex) : baseFindIndex$1(array2, baseIsNaN, fromIndex);
}
var _baseIndexOf = baseIndexOf$1;
var baseIndexOf = _baseIndexOf;
function arrayIncludes$1(array2, value) {
  var length = array2 == null ? 0 : array2.length;
  return !!length && baseIndexOf(array2, value, 0) > -1;
}
var _arrayIncludes = arrayIncludes$1;
function arrayIncludesWith$1(array2, value, comparator) {
  var index = -1, length = array2 == null ? 0 : array2.length;
  while (++index < length) {
    if (comparator(value, array2[index])) {
      return true;
    }
  }
  return false;
}
var _arrayIncludesWith = arrayIncludesWith$1;
function noop$2() {
}
var noop_1 = noop$2;
var Set$1 = _Set, noop$1 = noop_1, setToArray$1 = _setToArray;
var INFINITY$1 = 1 / 0;
var createSet$1 = !(Set$1 && 1 / setToArray$1(new Set$1([, -0]))[1] == INFINITY$1) ? noop$1 : function(values) {
  return new Set$1(values);
};
var _createSet = createSet$1;
var SetCache = _SetCache, arrayIncludes = _arrayIncludes, arrayIncludesWith = _arrayIncludesWith, cacheHas = _cacheHas, createSet = _createSet, setToArray = _setToArray;
var LARGE_ARRAY_SIZE = 200;
function baseUniq$1(array2, iteratee, comparator) {
  var index = -1, includes = arrayIncludes, length = array2.length, isCommon = true, result = [], seen = result;
  if (comparator) {
    isCommon = false;
    includes = arrayIncludesWith;
  } else if (length >= LARGE_ARRAY_SIZE) {
    var set2 = iteratee ? null : createSet(array2);
    if (set2) {
      return setToArray(set2);
    }
    isCommon = false;
    includes = cacheHas;
    seen = new SetCache();
  } else {
    seen = iteratee ? [] : result;
  }
  outer:
    while (++index < length) {
      var value = array2[index], computed = iteratee ? iteratee(value) : value;
      value = comparator || value !== 0 ? value : 0;
      if (isCommon && computed === computed) {
        var seenIndex = seen.length;
        while (seenIndex--) {
          if (seen[seenIndex] === computed) {
            continue outer;
          }
        }
        if (iteratee) {
          seen.push(computed);
        }
        result.push(value);
      } else if (!includes(seen, computed, comparator)) {
        if (seen !== result) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
  return result;
}
var _baseUniq = baseUniq$1;
var baseIteratee$7 = _baseIteratee, baseUniq = _baseUniq;
function uniqBy(array2, iteratee) {
  return array2 && array2.length ? baseUniq(array2, baseIteratee$7(iteratee)) : [];
}
var uniqBy_1 = uniqBy;
const _uniqBy = /* @__PURE__ */ getDefaultExportFromCjs(uniqBy_1);
function baseSlice$1(array2, start, end) {
  var index = -1, length = array2.length;
  if (start < 0) {
    start = -start > length ? 0 : length + start;
  }
  end = end > length ? length : end;
  if (end < 0) {
    end += length;
  }
  length = start > end ? 0 : end - start >>> 0;
  start >>>= 0;
  var result = Array(length);
  while (++index < length) {
    result[index] = array2[index + start];
  }
  return result;
}
var _baseSlice = baseSlice$1;
var baseSlice = _baseSlice;
function castSlice$1(array2, start, end) {
  var length = array2.length;
  end = end === void 0 ? length : end;
  return !start && end >= length ? array2 : baseSlice(array2, start, end);
}
var _castSlice = castSlice$1;
var rsAstralRange$1 = "\\ud800-\\udfff", rsComboMarksRange$1 = "\\u0300-\\u036f", reComboHalfMarksRange$1 = "\\ufe20-\\ufe2f", rsComboSymbolsRange$1 = "\\u20d0-\\u20ff", rsComboRange$1 = rsComboMarksRange$1 + reComboHalfMarksRange$1 + rsComboSymbolsRange$1, rsVarRange$1 = "\\ufe0e\\ufe0f";
var rsZWJ$1 = "\\u200d";
var reHasUnicode = RegExp("[" + rsZWJ$1 + rsAstralRange$1 + rsComboRange$1 + rsVarRange$1 + "]");
function hasUnicode$2(string2) {
  return reHasUnicode.test(string2);
}
var _hasUnicode = hasUnicode$2;
function asciiToArray$1(string2) {
  return string2.split("");
}
var _asciiToArray = asciiToArray$1;
var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsVarRange = "\\ufe0e\\ufe0f";
var rsAstral = "[" + rsAstralRange + "]", rsCombo = "[" + rsComboRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsZWJ = "\\u200d";
var reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
function unicodeToArray$1(string2) {
  return string2.match(reUnicode) || [];
}
var _unicodeToArray = unicodeToArray$1;
var asciiToArray = _asciiToArray, hasUnicode$1 = _hasUnicode, unicodeToArray = _unicodeToArray;
function stringToArray$1(string2) {
  return hasUnicode$1(string2) ? unicodeToArray(string2) : asciiToArray(string2);
}
var _stringToArray = stringToArray$1;
var castSlice = _castSlice, hasUnicode = _hasUnicode, stringToArray = _stringToArray, toString$1 = toString_1;
function createCaseFirst$1(methodName) {
  return function(string2) {
    string2 = toString$1(string2);
    var strSymbols = hasUnicode(string2) ? stringToArray(string2) : void 0;
    var chr = strSymbols ? strSymbols[0] : string2.charAt(0);
    var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string2.slice(1);
    return chr[methodName]() + trailing;
  };
}
var _createCaseFirst = createCaseFirst$1;
var createCaseFirst = _createCaseFirst;
var upperFirst = createCaseFirst("toUpperCase");
var upperFirst_1 = upperFirst;
const _upperFirst = /* @__PURE__ */ getDefaultExportFromCjs(upperFirst_1);
function constant$3(x2) {
  return function constant2() {
    return x2;
  };
}
const cos = Math.cos;
const sin = Math.sin;
const sqrt$1 = Math.sqrt;
const pi$1 = Math.PI;
const tau$1 = 2 * pi$1;
const pi = Math.PI, tau = 2 * pi, epsilon = 1e-6, tauEpsilon = tau - epsilon;
function append(strings) {
  this._ += strings[0];
  for (let i = 1, n2 = strings.length; i < n2; ++i) {
    this._ += arguments[i] + strings[i];
  }
}
function appendRound(digits) {
  let d2 = Math.floor(digits);
  if (!(d2 >= 0))
    throw new Error(`invalid digits: ${digits}`);
  if (d2 > 15)
    return append;
  const k2 = 10 ** d2;
  return function(strings) {
    this._ += strings[0];
    for (let i = 1, n2 = strings.length; i < n2; ++i) {
      this._ += Math.round(arguments[i] * k2) / k2 + strings[i];
    }
  };
}
class Path {
  constructor(digits) {
    this._x0 = this._y0 = // start of current subpath
    this._x1 = this._y1 = null;
    this._ = "";
    this._append = digits == null ? append : appendRound(digits);
  }
  moveTo(x2, y2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}`;
  }
  closePath() {
    if (this._x1 !== null) {
      this._x1 = this._x0, this._y1 = this._y0;
      this._append`Z`;
    }
  }
  lineTo(x2, y2) {
    this._append`L${this._x1 = +x2},${this._y1 = +y2}`;
  }
  quadraticCurveTo(x1, y1, x2, y2) {
    this._append`Q${+x1},${+y1},${this._x1 = +x2},${this._y1 = +y2}`;
  }
  bezierCurveTo(x1, y1, x2, y2, x3, y3) {
    this._append`C${+x1},${+y1},${+x2},${+y2},${this._x1 = +x3},${this._y1 = +y3}`;
  }
  arcTo(x1, y1, x2, y2, r2) {
    x1 = +x1, y1 = +y1, x2 = +x2, y2 = +y2, r2 = +r2;
    if (r2 < 0)
      throw new Error(`negative radius: ${r2}`);
    let x0 = this._x1, y0 = this._y1, x21 = x2 - x1, y21 = y2 - y1, x01 = x0 - x1, y01 = y0 - y1, l01_2 = x01 * x01 + y01 * y01;
    if (this._x1 === null) {
      this._append`M${this._x1 = x1},${this._y1 = y1}`;
    } else if (!(l01_2 > epsilon))
      ;
    else if (!(Math.abs(y01 * x21 - y21 * x01) > epsilon) || !r2) {
      this._append`L${this._x1 = x1},${this._y1 = y1}`;
    } else {
      let x20 = x2 - x0, y20 = y2 - y0, l21_2 = x21 * x21 + y21 * y21, l20_2 = x20 * x20 + y20 * y20, l21 = Math.sqrt(l21_2), l01 = Math.sqrt(l01_2), l2 = r2 * Math.tan((pi - Math.acos((l21_2 + l01_2 - l20_2) / (2 * l21 * l01))) / 2), t01 = l2 / l01, t21 = l2 / l21;
      if (Math.abs(t01 - 1) > epsilon) {
        this._append`L${x1 + t01 * x01},${y1 + t01 * y01}`;
      }
      this._append`A${r2},${r2},0,0,${+(y01 * x20 > x01 * y20)},${this._x1 = x1 + t21 * x21},${this._y1 = y1 + t21 * y21}`;
    }
  }
  arc(x2, y2, r2, a0, a1, ccw) {
    x2 = +x2, y2 = +y2, r2 = +r2, ccw = !!ccw;
    if (r2 < 0)
      throw new Error(`negative radius: ${r2}`);
    let dx = r2 * Math.cos(a0), dy = r2 * Math.sin(a0), x0 = x2 + dx, y0 = y2 + dy, cw = 1 ^ ccw, da = ccw ? a0 - a1 : a1 - a0;
    if (this._x1 === null) {
      this._append`M${x0},${y0}`;
    } else if (Math.abs(this._x1 - x0) > epsilon || Math.abs(this._y1 - y0) > epsilon) {
      this._append`L${x0},${y0}`;
    }
    if (!r2)
      return;
    if (da < 0)
      da = da % tau + tau;
    if (da > tauEpsilon) {
      this._append`A${r2},${r2},0,1,${cw},${x2 - dx},${y2 - dy}A${r2},${r2},0,1,${cw},${this._x1 = x0},${this._y1 = y0}`;
    } else if (da > epsilon) {
      this._append`A${r2},${r2},0,${+(da >= pi)},${cw},${this._x1 = x2 + r2 * Math.cos(a1)},${this._y1 = y2 + r2 * Math.sin(a1)}`;
    }
  }
  rect(x2, y2, w2, h2) {
    this._append`M${this._x0 = this._x1 = +x2},${this._y0 = this._y1 = +y2}h${w2 = +w2}v${+h2}h${-w2}Z`;
  }
  toString() {
    return this._;
  }
}
function withPath(shape) {
  let digits = 3;
  shape.digits = function(_) {
    if (!arguments.length)
      return digits;
    if (_ == null) {
      digits = null;
    } else {
      const d2 = Math.floor(_);
      if (!(d2 >= 0))
        throw new RangeError(`invalid digits: ${_}`);
      digits = d2;
    }
    return shape;
  };
  return () => new Path(digits);
}
function array(x2) {
  return typeof x2 === "object" && "length" in x2 ? x2 : Array.from(x2);
}
function Linear(context) {
  this._context = context;
}
Linear.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default:
        this._context.lineTo(x2, y2);
        break;
    }
  }
};
function curveLinear(context) {
  return new Linear(context);
}
function x(p2) {
  return p2[0];
}
function y(p2) {
  return p2[1];
}
function shapeLine(x$12, y$12) {
  var defined3 = constant$3(true), context = null, curve = curveLinear, output = null, path = withPath(line);
  x$12 = typeof x$12 === "function" ? x$12 : x$12 === void 0 ? x : constant$3(x$12);
  y$12 = typeof y$12 === "function" ? y$12 : y$12 === void 0 ? y : constant$3(y$12);
  function line(data) {
    var i, n2 = (data = array(data)).length, d2, defined0 = false, buffer;
    if (context == null)
      output = curve(buffer = path());
    for (i = 0; i <= n2; ++i) {
      if (!(i < n2 && defined3(d2 = data[i], i, data)) === defined0) {
        if (defined0 = !defined0)
          output.lineStart();
        else
          output.lineEnd();
      }
      if (defined0)
        output.point(+x$12(d2, i, data), +y$12(d2, i, data));
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  line.x = function(_) {
    return arguments.length ? (x$12 = typeof _ === "function" ? _ : constant$3(+_), line) : x$12;
  };
  line.y = function(_) {
    return arguments.length ? (y$12 = typeof _ === "function" ? _ : constant$3(+_), line) : y$12;
  };
  line.defined = function(_) {
    return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant$3(!!_), line) : defined3;
  };
  line.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), line) : curve;
  };
  line.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), line) : context;
  };
  return line;
}
function shapeArea(x0, y0, y1) {
  var x1 = null, defined3 = constant$3(true), context = null, curve = curveLinear, output = null, path = withPath(area);
  x0 = typeof x0 === "function" ? x0 : x0 === void 0 ? x : constant$3(+x0);
  y0 = typeof y0 === "function" ? y0 : y0 === void 0 ? constant$3(0) : constant$3(+y0);
  y1 = typeof y1 === "function" ? y1 : y1 === void 0 ? y : constant$3(+y1);
  function area(data) {
    var i, j, k2, n2 = (data = array(data)).length, d2, defined0 = false, buffer, x0z = new Array(n2), y0z = new Array(n2);
    if (context == null)
      output = curve(buffer = path());
    for (i = 0; i <= n2; ++i) {
      if (!(i < n2 && defined3(d2 = data[i], i, data)) === defined0) {
        if (defined0 = !defined0) {
          j = i;
          output.areaStart();
          output.lineStart();
        } else {
          output.lineEnd();
          output.lineStart();
          for (k2 = i - 1; k2 >= j; --k2) {
            output.point(x0z[k2], y0z[k2]);
          }
          output.lineEnd();
          output.areaEnd();
        }
      }
      if (defined0) {
        x0z[i] = +x0(d2, i, data), y0z[i] = +y0(d2, i, data);
        output.point(x1 ? +x1(d2, i, data) : x0z[i], y1 ? +y1(d2, i, data) : y0z[i]);
      }
    }
    if (buffer)
      return output = null, buffer + "" || null;
  }
  function arealine() {
    return shapeLine().defined(defined3).curve(curve).context(context);
  }
  area.x = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$3(+_), x1 = null, area) : x0;
  };
  area.x0 = function(_) {
    return arguments.length ? (x0 = typeof _ === "function" ? _ : constant$3(+_), area) : x0;
  };
  area.x1 = function(_) {
    return arguments.length ? (x1 = _ == null ? null : typeof _ === "function" ? _ : constant$3(+_), area) : x1;
  };
  area.y = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$3(+_), y1 = null, area) : y0;
  };
  area.y0 = function(_) {
    return arguments.length ? (y0 = typeof _ === "function" ? _ : constant$3(+_), area) : y0;
  };
  area.y1 = function(_) {
    return arguments.length ? (y1 = _ == null ? null : typeof _ === "function" ? _ : constant$3(+_), area) : y1;
  };
  area.lineX0 = area.lineY0 = function() {
    return arealine().x(x0).y(y0);
  };
  area.lineY1 = function() {
    return arealine().x(x0).y(y1);
  };
  area.lineX1 = function() {
    return arealine().x(x1).y(y0);
  };
  area.defined = function(_) {
    return arguments.length ? (defined3 = typeof _ === "function" ? _ : constant$3(!!_), area) : defined3;
  };
  area.curve = function(_) {
    return arguments.length ? (curve = _, context != null && (output = curve(context)), area) : curve;
  };
  area.context = function(_) {
    return arguments.length ? (_ == null ? context = output = null : output = curve(context = _), area) : context;
  };
  return area;
}
const symbolCircle = {
  draw(context, size) {
    const r2 = sqrt$1(size / pi$1);
    context.moveTo(r2, 0);
    context.arc(0, 0, r2, 0, tau$1);
  }
};
const symbolCross = {
  draw(context, size) {
    const r2 = sqrt$1(size / 5) / 2;
    context.moveTo(-3 * r2, -r2);
    context.lineTo(-r2, -r2);
    context.lineTo(-r2, -3 * r2);
    context.lineTo(r2, -3 * r2);
    context.lineTo(r2, -r2);
    context.lineTo(3 * r2, -r2);
    context.lineTo(3 * r2, r2);
    context.lineTo(r2, r2);
    context.lineTo(r2, 3 * r2);
    context.lineTo(-r2, 3 * r2);
    context.lineTo(-r2, r2);
    context.lineTo(-3 * r2, r2);
    context.closePath();
  }
};
const tan30 = sqrt$1(1 / 3);
const tan30_2 = tan30 * 2;
const symbolDiamond = {
  draw(context, size) {
    const y2 = sqrt$1(size / tan30_2);
    const x2 = y2 * tan30;
    context.moveTo(0, -y2);
    context.lineTo(x2, 0);
    context.lineTo(0, y2);
    context.lineTo(-x2, 0);
    context.closePath();
  }
};
const symbolSquare = {
  draw(context, size) {
    const w2 = sqrt$1(size);
    const x2 = -w2 / 2;
    context.rect(x2, x2, w2, w2);
  }
};
const ka = 0.8908130915292852;
const kr = sin(pi$1 / 10) / sin(7 * pi$1 / 10);
const kx = sin(tau$1 / 10) * kr;
const ky = -cos(tau$1 / 10) * kr;
const symbolStar = {
  draw(context, size) {
    const r2 = sqrt$1(size * ka);
    const x2 = kx * r2;
    const y2 = ky * r2;
    context.moveTo(0, -r2);
    context.lineTo(x2, y2);
    for (let i = 1; i < 5; ++i) {
      const a2 = tau$1 * i / 5;
      const c2 = cos(a2);
      const s2 = sin(a2);
      context.lineTo(s2 * r2, -c2 * r2);
      context.lineTo(c2 * x2 - s2 * y2, s2 * x2 + c2 * y2);
    }
    context.closePath();
  }
};
const sqrt3 = sqrt$1(3);
const symbolTriangle = {
  draw(context, size) {
    const y2 = -sqrt$1(size / (sqrt3 * 3));
    context.moveTo(0, y2 * 2);
    context.lineTo(-sqrt3 * y2, -y2);
    context.lineTo(sqrt3 * y2, -y2);
    context.closePath();
  }
};
const c = -0.5;
const s = sqrt$1(3) / 2;
const k = 1 / sqrt$1(12);
const a = (k / 2 + 1) * 3;
const symbolWye = {
  draw(context, size) {
    const r2 = sqrt$1(size / a);
    const x0 = r2 / 2, y0 = r2 * k;
    const x1 = x0, y1 = r2 * k + r2;
    const x2 = -x1, y2 = y1;
    context.moveTo(x0, y0);
    context.lineTo(x1, y1);
    context.lineTo(x2, y2);
    context.lineTo(c * x0 - s * y0, s * x0 + c * y0);
    context.lineTo(c * x1 - s * y1, s * x1 + c * y1);
    context.lineTo(c * x2 - s * y2, s * x2 + c * y2);
    context.lineTo(c * x0 + s * y0, c * y0 - s * x0);
    context.lineTo(c * x1 + s * y1, c * y1 - s * x1);
    context.lineTo(c * x2 + s * y2, c * y2 - s * x2);
    context.closePath();
  }
};
function Symbol$5(type, size) {
  let context = null, path = withPath(symbol);
  type = typeof type === "function" ? type : constant$3(type || symbolCircle);
  size = typeof size === "function" ? size : constant$3(size === void 0 ? 64 : +size);
  function symbol() {
    let buffer;
    if (!context)
      context = buffer = path();
    type.apply(this, arguments).draw(context, +size.apply(this, arguments));
    if (buffer)
      return context = null, buffer + "" || null;
  }
  symbol.type = function(_) {
    return arguments.length ? (type = typeof _ === "function" ? _ : constant$3(_), symbol) : type;
  };
  symbol.size = function(_) {
    return arguments.length ? (size = typeof _ === "function" ? _ : constant$3(+_), symbol) : size;
  };
  symbol.context = function(_) {
    return arguments.length ? (context = _ == null ? null : _, symbol) : context;
  };
  return symbol;
}
function noop() {
}
function point$2(that, x2, y2) {
  that._context.bezierCurveTo(
    (2 * that._x0 + that._x1) / 3,
    (2 * that._y0 + that._y1) / 3,
    (that._x0 + 2 * that._x1) / 3,
    (that._y0 + 2 * that._y1) / 3,
    (that._x0 + 4 * that._x1 + x2) / 6,
    (that._y0 + 4 * that._y1 + y2) / 6
  );
}
function Basis(context) {
  this._context = context;
}
Basis.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 3:
        point$2(this, this._x1, this._y1);
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        this._context.lineTo((5 * this._x0 + this._x1) / 6, (5 * this._y0 + this._y1) / 6);
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasis(context) {
  return new Basis(context);
}
function BasisClosed(context) {
  this._context = context;
}
BasisClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._x0 = this._x1 = this._x2 = this._x3 = this._x4 = this._y0 = this._y1 = this._y2 = this._y3 = this._y4 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 1: {
        this._context.moveTo(this._x2, this._y2);
        this._context.closePath();
        break;
      }
      case 2: {
        this._context.moveTo((this._x2 + 2 * this._x3) / 3, (this._y2 + 2 * this._y3) / 3);
        this._context.lineTo((this._x3 + 2 * this._x2) / 3, (this._y3 + 2 * this._y2) / 3);
        this._context.closePath();
        break;
      }
      case 3: {
        this.point(this._x2, this._y2);
        this.point(this._x3, this._y3);
        this.point(this._x4, this._y4);
        break;
      }
    }
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._x2 = x2, this._y2 = y2;
        break;
      case 1:
        this._point = 2;
        this._x3 = x2, this._y3 = y2;
        break;
      case 2:
        this._point = 3;
        this._x4 = x2, this._y4 = y2;
        this._context.moveTo((this._x0 + 4 * this._x1 + x2) / 6, (this._y0 + 4 * this._y1 + y2) / 6);
        break;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisClosed(context) {
  return new BasisClosed(context);
}
function BasisOpen(context) {
  this._context = context;
}
BasisOpen.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (this._line || this._line !== 0 && this._point === 3)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        var x0 = (this._x0 + 4 * this._x1 + x2) / 6, y0 = (this._y0 + 4 * this._y1 + y2) / 6;
        this._line ? this._context.lineTo(x0, y0) : this._context.moveTo(x0, y0);
        break;
      case 3:
        this._point = 4;
      default:
        point$2(this, x2, y2);
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
  }
};
function curveBasisOpen(context) {
  return new BasisOpen(context);
}
function LinearClosed(context) {
  this._context = context;
}
LinearClosed.prototype = {
  areaStart: noop,
  areaEnd: noop,
  lineStart: function() {
    this._point = 0;
  },
  lineEnd: function() {
    if (this._point)
      this._context.closePath();
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    if (this._point)
      this._context.lineTo(x2, y2);
    else
      this._point = 1, this._context.moveTo(x2, y2);
  }
};
function curveLinearClosed(context) {
  return new LinearClosed(context);
}
function sign(x2) {
  return x2 < 0 ? -1 : 1;
}
function slope3(that, x2, y2) {
  var h0 = that._x1 - that._x0, h1 = x2 - that._x1, s0 = (that._y1 - that._y0) / (h0 || h1 < 0 && -0), s1 = (y2 - that._y1) / (h1 || h0 < 0 && -0), p2 = (s0 * h1 + s1 * h0) / (h0 + h1);
  return (sign(s0) + sign(s1)) * Math.min(Math.abs(s0), Math.abs(s1), 0.5 * Math.abs(p2)) || 0;
}
function slope2(that, t2) {
  var h2 = that._x1 - that._x0;
  return h2 ? (3 * (that._y1 - that._y0) / h2 - t2) / 2 : t2;
}
function point$1(that, t02, t12) {
  var x0 = that._x0, y0 = that._y0, x1 = that._x1, y1 = that._y1, dx = (x1 - x0) / 3;
  that._context.bezierCurveTo(x0 + dx, y0 + dx * t02, x1 - dx, y1 - dx * t12, x1, y1);
}
function MonotoneX(context) {
  this._context = context;
}
MonotoneX.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    switch (this._point) {
      case 2:
        this._context.lineTo(this._x1, this._y1);
        break;
      case 3:
        point$1(this, this._t0, slope2(this, this._t0));
        break;
    }
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    var t12 = NaN;
    x2 = +x2, y2 = +y2;
    if (x2 === this._x1 && y2 === this._y1)
      return;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
        break;
      case 2:
        this._point = 3;
        point$1(this, slope2(this, t12 = slope3(this, x2, y2)), t12);
        break;
      default:
        point$1(this, this._t0, t12 = slope3(this, x2, y2));
        break;
    }
    this._x0 = this._x1, this._x1 = x2;
    this._y0 = this._y1, this._y1 = y2;
    this._t0 = t12;
  }
};
function MonotoneY(context) {
  this._context = new ReflectContext(context);
}
(MonotoneY.prototype = Object.create(MonotoneX.prototype)).point = function(x2, y2) {
  MonotoneX.prototype.point.call(this, y2, x2);
};
function ReflectContext(context) {
  this._context = context;
}
ReflectContext.prototype = {
  moveTo: function(x2, y2) {
    this._context.moveTo(y2, x2);
  },
  closePath: function() {
    this._context.closePath();
  },
  lineTo: function(x2, y2) {
    this._context.lineTo(y2, x2);
  },
  bezierCurveTo: function(x1, y1, x2, y2, x3, y3) {
    this._context.bezierCurveTo(y1, x1, y2, x2, y3, x3);
  }
};
function monotoneX(context) {
  return new MonotoneX(context);
}
function monotoneY(context) {
  return new MonotoneY(context);
}
function Natural(context) {
  this._context = context;
}
Natural.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = [];
    this._y = [];
  },
  lineEnd: function() {
    var x2 = this._x, y2 = this._y, n2 = x2.length;
    if (n2) {
      this._line ? this._context.lineTo(x2[0], y2[0]) : this._context.moveTo(x2[0], y2[0]);
      if (n2 === 2) {
        this._context.lineTo(x2[1], y2[1]);
      } else {
        var px = controlPoints(x2), py = controlPoints(y2);
        for (var i0 = 0, i1 = 1; i1 < n2; ++i0, ++i1) {
          this._context.bezierCurveTo(px[0][i0], py[0][i0], px[1][i0], py[1][i0], x2[i1], y2[i1]);
        }
      }
    }
    if (this._line || this._line !== 0 && n2 === 1)
      this._context.closePath();
    this._line = 1 - this._line;
    this._x = this._y = null;
  },
  point: function(x2, y2) {
    this._x.push(+x2);
    this._y.push(+y2);
  }
};
function controlPoints(x2) {
  var i, n2 = x2.length - 1, m2, a2 = new Array(n2), b2 = new Array(n2), r2 = new Array(n2);
  a2[0] = 0, b2[0] = 2, r2[0] = x2[0] + 2 * x2[1];
  for (i = 1; i < n2 - 1; ++i)
    a2[i] = 1, b2[i] = 4, r2[i] = 4 * x2[i] + 2 * x2[i + 1];
  a2[n2 - 1] = 2, b2[n2 - 1] = 7, r2[n2 - 1] = 8 * x2[n2 - 1] + x2[n2];
  for (i = 1; i < n2; ++i)
    m2 = a2[i] / b2[i - 1], b2[i] -= m2, r2[i] -= m2 * r2[i - 1];
  a2[n2 - 1] = r2[n2 - 1] / b2[n2 - 1];
  for (i = n2 - 2; i >= 0; --i)
    a2[i] = (r2[i] - a2[i + 1]) / b2[i];
  b2[n2 - 1] = (x2[n2] + a2[n2 - 1]) / 2;
  for (i = 0; i < n2 - 1; ++i)
    b2[i] = 2 * x2[i + 1] - a2[i + 1];
  return [a2, b2];
}
function curveNatural(context) {
  return new Natural(context);
}
function Step(context, t2) {
  this._context = context;
  this._t = t2;
}
Step.prototype = {
  areaStart: function() {
    this._line = 0;
  },
  areaEnd: function() {
    this._line = NaN;
  },
  lineStart: function() {
    this._x = this._y = NaN;
    this._point = 0;
  },
  lineEnd: function() {
    if (0 < this._t && this._t < 1 && this._point === 2)
      this._context.lineTo(this._x, this._y);
    if (this._line || this._line !== 0 && this._point === 1)
      this._context.closePath();
    if (this._line >= 0)
      this._t = 1 - this._t, this._line = 1 - this._line;
  },
  point: function(x2, y2) {
    x2 = +x2, y2 = +y2;
    switch (this._point) {
      case 0:
        this._point = 1;
        this._line ? this._context.lineTo(x2, y2) : this._context.moveTo(x2, y2);
        break;
      case 1:
        this._point = 2;
      default: {
        if (this._t <= 0) {
          this._context.lineTo(this._x, y2);
          this._context.lineTo(x2, y2);
        } else {
          var x1 = this._x * (1 - this._t) + x2 * this._t;
          this._context.lineTo(x1, this._y);
          this._context.lineTo(x1, y2);
        }
        break;
      }
    }
    this._x = x2, this._y = y2;
  }
};
function curveStep(context) {
  return new Step(context, 0.5);
}
function stepBefore(context) {
  return new Step(context, 0);
}
function stepAfter(context) {
  return new Step(context, 1);
}
function stackOffsetNone(series, order) {
  if (!((n2 = series.length) > 1))
    return;
  for (var i = 1, j, s0, s1 = series[order[0]], n2, m2 = s1.length; i < n2; ++i) {
    s0 = s1, s1 = series[order[i]];
    for (j = 0; j < m2; ++j) {
      s1[j][1] += s1[j][0] = isNaN(s0[j][1]) ? s0[j][0] : s0[j][1];
    }
  }
}
function stackOrderNone(series) {
  var n2 = series.length, o = new Array(n2);
  while (--n2 >= 0)
    o[n2] = n2;
  return o;
}
function stackValue(d2, key) {
  return d2[key];
}
function stackSeries(key) {
  const series = [];
  series.key = key;
  return series;
}
function shapeStack() {
  var keys2 = constant$3([]), order = stackOrderNone, offset = stackOffsetNone, value = stackValue;
  function stack(data) {
    var sz = Array.from(keys2.apply(this, arguments), stackSeries), i, n2 = sz.length, j = -1, oz;
    for (const d2 of data) {
      for (i = 0, ++j; i < n2; ++i) {
        (sz[i][j] = [0, +value(d2, sz[i].key, j, data)]).data = d2;
      }
    }
    for (i = 0, oz = array(order(sz)); i < n2; ++i) {
      sz[oz[i]].index = i;
    }
    offset(sz, oz);
    return sz;
  }
  stack.keys = function(_) {
    return arguments.length ? (keys2 = typeof _ === "function" ? _ : constant$3(Array.from(_)), stack) : keys2;
  };
  stack.value = function(_) {
    return arguments.length ? (value = typeof _ === "function" ? _ : constant$3(+_), stack) : value;
  };
  stack.order = function(_) {
    return arguments.length ? (order = _ == null ? stackOrderNone : typeof _ === "function" ? _ : constant$3(Array.from(_)), stack) : order;
  };
  stack.offset = function(_) {
    return arguments.length ? (offset = _ == null ? stackOffsetNone : _, stack) : offset;
  };
  return stack;
}
function stackOffsetExpand(series, order) {
  if (!((n2 = series.length) > 0))
    return;
  for (var i, n2, j = 0, m2 = series[0].length, y2; j < m2; ++j) {
    for (y2 = i = 0; i < n2; ++i)
      y2 += series[i][j][1] || 0;
    if (y2)
      for (i = 0; i < n2; ++i)
        series[i][j][1] /= y2;
  }
  stackOffsetNone(series, order);
}
function stackOffsetSilhouette(series, order) {
  if (!((n2 = series.length) > 0))
    return;
  for (var j = 0, s0 = series[order[0]], n2, m2 = s0.length; j < m2; ++j) {
    for (var i = 0, y2 = 0; i < n2; ++i)
      y2 += series[i][j][1] || 0;
    s0[j][1] += s0[j][0] = -y2 / 2;
  }
  stackOffsetNone(series, order);
}
function stackOffsetWiggle(series, order) {
  if (!((n2 = series.length) > 0) || !((m2 = (s0 = series[order[0]]).length) > 0))
    return;
  for (var y2 = 0, j = 1, s0, m2, n2; j < m2; ++j) {
    for (var i = 0, s1 = 0, s2 = 0; i < n2; ++i) {
      var si = series[order[i]], sij0 = si[j][1] || 0, sij1 = si[j - 1][1] || 0, s3 = (sij0 - sij1) / 2;
      for (var k2 = 0; k2 < i; ++k2) {
        var sk = series[order[k2]], skj0 = sk[j][1] || 0, skj1 = sk[j - 1][1] || 0;
        s3 += skj0 - skj1;
      }
      s1 += sij0, s2 += s3 * sij0;
    }
    s0[j - 1][1] += s0[j - 1][0] = y2;
    if (s1)
      y2 -= s2 / s1;
  }
  s0[j - 1][1] += s0[j - 1][0] = y2;
  stackOffsetNone(series, order);
}
function _typeof$u(obj) {
  "@babel/helpers - typeof";
  return _typeof$u = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$u(obj);
}
function _extends$m() {
  _extends$m = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$m.apply(this, arguments);
}
function _classCallCheck$k(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$k(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$s(descriptor.key), descriptor);
  }
}
function _createClass$k(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$k(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$k(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$j(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$j(subClass, superClass);
}
function _setPrototypeOf$j(o, p2) {
  _setPrototypeOf$j = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$j(o, p2);
}
function _createSuper$j(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$j();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$j(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$j(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$j(this, result);
  };
}
function _possibleConstructorReturn$j(self2, call) {
  if (call && (_typeof$u(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$j(self2);
}
function _assertThisInitialized$j(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$j() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$j(o) {
  _getPrototypeOf$j = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$j(o);
}
function _defineProperty$v(obj, key, value) {
  key = _toPropertyKey$s(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$s(arg) {
  var key = _toPrimitive$s(arg, "string");
  return _typeof$u(key) === "symbol" ? key : String(key);
}
function _toPrimitive$s(input2, hint) {
  if (_typeof$u(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$u(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var symbolFactories = {
  symbolCircle,
  symbolCross,
  symbolDiamond,
  symbolSquare,
  symbolStar,
  symbolTriangle,
  symbolWye
};
var RADIAN$1 = Math.PI / 180;
var getSymbolFactory = function getSymbolFactory2(type) {
  var name = "symbol".concat(_upperFirst(type));
  return symbolFactories[name] || symbolCircle;
};
var calculateAreaSize = function calculateAreaSize2(size, sizeType, type) {
  if (sizeType === "area") {
    return size;
  }
  switch (type) {
    case "cross":
      return 5 * size * size / 9;
    case "diamond":
      return 0.5 * size * size / Math.sqrt(3);
    case "square":
      return size * size;
    case "star": {
      var angle = 18 * RADIAN$1;
      return 1.25 * size * size * (Math.tan(angle) - Math.tan(angle * 2) * Math.pow(Math.tan(angle), 2));
    }
    case "triangle":
      return Math.sqrt(3) * size * size / 4;
    case "wye":
      return (21 - 10 * Math.sqrt(3)) * size * size / 8;
    default:
      return Math.PI * size * size / 4;
  }
};
var Symbols = /* @__PURE__ */ function(_PureComponent) {
  _inherits$j(Symbols2, _PureComponent);
  var _super = _createSuper$j(Symbols2);
  function Symbols2() {
    _classCallCheck$k(this, Symbols2);
    return _super.apply(this, arguments);
  }
  _createClass$k(Symbols2, [{
    key: "getPath",
    value: (
      /**
       * Calculate the path of curve
       * @return {String} path
       */
      function getPath() {
        var _this$props = this.props, size = _this$props.size, sizeType = _this$props.sizeType, type = _this$props.type;
        var symbolFactory = getSymbolFactory(type);
        var symbol = Symbol$5().type(symbolFactory).size(calculateAreaSize(size, sizeType, type));
        return symbol();
      }
    )
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props, className = _this$props2.className, cx = _this$props2.cx, cy = _this$props2.cy, size = _this$props2.size;
      var filteredProps = filterProps(this.props, true);
      if (cx === +cx && cy === +cy && size === +size) {
        return /* @__PURE__ */ React.createElement("path", _extends$m({}, filteredProps, {
          className: classNames("recharts-symbols", className),
          transform: "translate(".concat(cx, ", ").concat(cy, ")"),
          d: this.getPath()
        }));
      }
      return null;
    }
  }]);
  return Symbols2;
}(reactExports.PureComponent);
_defineProperty$v(Symbols, "defaultProps", {
  type: "circle",
  size: 64,
  sizeType: "area"
});
_defineProperty$v(Symbols, "registerSymbol", function(key, factory) {
  symbolFactories["symbol".concat(_upperFirst(key))] = factory;
});
function _typeof$t(obj) {
  "@babel/helpers - typeof";
  return _typeof$t = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$t(obj);
}
function _extends$l() {
  _extends$l = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$l.apply(this, arguments);
}
function ownKeys$q(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$q(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$q(Object(source), true).forEach(function(key) {
      _defineProperty$u(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$q(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$j(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$j(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$r(descriptor.key), descriptor);
  }
}
function _createClass$j(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$j(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$j(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$i(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$i(subClass, superClass);
}
function _setPrototypeOf$i(o, p2) {
  _setPrototypeOf$i = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$i(o, p2);
}
function _createSuper$i(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$i();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$i(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$i(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$i(this, result);
  };
}
function _possibleConstructorReturn$i(self2, call) {
  if (call && (_typeof$t(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$i(self2);
}
function _assertThisInitialized$i(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$i() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$i(o) {
  _getPrototypeOf$i = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$i(o);
}
function _defineProperty$u(obj, key, value) {
  key = _toPropertyKey$r(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$r(arg) {
  var key = _toPrimitive$r(arg, "string");
  return _typeof$t(key) === "symbol" ? key : String(key);
}
function _toPrimitive$r(input2, hint) {
  if (_typeof$t(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$t(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var SIZE = 32;
var DefaultLegendContent = /* @__PURE__ */ function(_PureComponent) {
  _inherits$i(DefaultLegendContent2, _PureComponent);
  var _super = _createSuper$i(DefaultLegendContent2);
  function DefaultLegendContent2() {
    _classCallCheck$j(this, DefaultLegendContent2);
    return _super.apply(this, arguments);
  }
  _createClass$j(DefaultLegendContent2, [{
    key: "renderIcon",
    value: (
      /**
       * Render the path of icon
       * @param {Object} data Data of each legend item
       * @return {String} Path element
       */
      function renderIcon(data) {
        var inactiveColor = this.props.inactiveColor;
        var halfSize = SIZE / 2;
        var sixthSize = SIZE / 6;
        var thirdSize = SIZE / 3;
        var color2 = data.inactive ? inactiveColor : data.color;
        if (data.type === "plainline") {
          return /* @__PURE__ */ React.createElement("line", {
            strokeWidth: 4,
            fill: "none",
            stroke: color2,
            strokeDasharray: data.payload.strokeDasharray,
            x1: 0,
            y1: halfSize,
            x2: SIZE,
            y2: halfSize,
            className: "recharts-legend-icon"
          });
        }
        if (data.type === "line") {
          return /* @__PURE__ */ React.createElement("path", {
            strokeWidth: 4,
            fill: "none",
            stroke: color2,
            d: "M0,".concat(halfSize, "h").concat(thirdSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(2 * thirdSize, ",").concat(halfSize, "\n            H").concat(SIZE, "M").concat(2 * thirdSize, ",").concat(halfSize, "\n            A").concat(sixthSize, ",").concat(sixthSize, ",0,1,1,").concat(thirdSize, ",").concat(halfSize),
            className: "recharts-legend-icon"
          });
        }
        if (data.type === "rect") {
          return /* @__PURE__ */ React.createElement("path", {
            stroke: "none",
            fill: color2,
            d: "M0,".concat(SIZE / 8, "h").concat(SIZE, "v").concat(SIZE * 3 / 4, "h").concat(-SIZE, "z"),
            className: "recharts-legend-icon"
          });
        }
        if (/* @__PURE__ */ React.isValidElement(data.legendIcon)) {
          var iconProps = _objectSpread$q({}, data);
          delete iconProps.legendIcon;
          return /* @__PURE__ */ React.cloneElement(data.legendIcon, iconProps);
        }
        return /* @__PURE__ */ React.createElement(Symbols, {
          fill: color2,
          cx: halfSize,
          cy: halfSize,
          size: SIZE,
          sizeType: "diameter",
          type: data.type
        });
      }
    )
    /**
     * Draw items of legend
     * @return {ReactElement} Items
     */
  }, {
    key: "renderItems",
    value: function renderItems() {
      var _this = this;
      var _this$props = this.props, payload = _this$props.payload, iconSize = _this$props.iconSize, layout = _this$props.layout, formatter = _this$props.formatter, inactiveColor = _this$props.inactiveColor;
      var viewBox = {
        x: 0,
        y: 0,
        width: SIZE,
        height: SIZE
      };
      var itemStyle = {
        display: layout === "horizontal" ? "inline-block" : "block",
        marginRight: 10
      };
      var svgStyle = {
        display: "inline-block",
        verticalAlign: "middle",
        marginRight: 4
      };
      return payload.map(function(entry, i) {
        var _classNames;
        var finalFormatter = entry.formatter || formatter;
        var className = classNames((_classNames = {
          "recharts-legend-item": true
        }, _defineProperty$u(_classNames, "legend-item-".concat(i), true), _defineProperty$u(_classNames, "inactive", entry.inactive), _classNames));
        if (entry.type === "none") {
          return null;
        }
        var color2 = entry.inactive ? inactiveColor : entry.color;
        return /* @__PURE__ */ React.createElement("li", _extends$l({
          className,
          style: itemStyle,
          key: "legend-item-".concat(i)
          // eslint-disable-line react/no-array-index-key
        }, adaptEventsOfChild(_this.props, entry, i)), /* @__PURE__ */ React.createElement(Surface, {
          width: iconSize,
          height: iconSize,
          viewBox,
          style: svgStyle
        }, _this.renderIcon(entry)), /* @__PURE__ */ React.createElement("span", {
          className: "recharts-legend-item-text",
          style: {
            color: color2
          }
        }, finalFormatter ? finalFormatter(entry.value, entry, i) : entry.value));
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props, payload = _this$props2.payload, layout = _this$props2.layout, align = _this$props2.align;
      if (!payload || !payload.length) {
        return null;
      }
      var finalStyle = {
        padding: 0,
        margin: 0,
        textAlign: layout === "horizontal" ? align : "left"
      };
      return /* @__PURE__ */ React.createElement("ul", {
        className: "recharts-default-legend",
        style: finalStyle
      }, this.renderItems());
    }
  }]);
  return DefaultLegendContent2;
}(reactExports.PureComponent);
_defineProperty$u(DefaultLegendContent, "displayName", "Legend");
_defineProperty$u(DefaultLegendContent, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "middle",
  inactiveColor: "#ccc"
});
function _typeof$s(obj) {
  "@babel/helpers - typeof";
  return _typeof$s = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$s(obj);
}
var _excluded$b = ["ref"];
function ownKeys$p(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$p(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$p(Object(source), true).forEach(function(key) {
      _defineProperty$t(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$p(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$i(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$i(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$q(descriptor.key), descriptor);
  }
}
function _createClass$i(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$i(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$i(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$h(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$h(subClass, superClass);
}
function _setPrototypeOf$h(o, p2) {
  _setPrototypeOf$h = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$h(o, p2);
}
function _createSuper$h(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$h();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$h(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$h(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$h(this, result);
  };
}
function _possibleConstructorReturn$h(self2, call) {
  if (call && (_typeof$s(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$h(self2);
}
function _assertThisInitialized$h(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$h() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$h(o) {
  _getPrototypeOf$h = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$h(o);
}
function _defineProperty$t(obj, key, value) {
  key = _toPropertyKey$q(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$q(arg) {
  var key = _toPrimitive$q(arg, "string");
  return _typeof$s(key) === "symbol" ? key : String(key);
}
function _toPrimitive$q(input2, hint) {
  if (_typeof$s(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$s(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function _objectWithoutProperties$c(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$c(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$c(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function defaultUniqBy$1(entry) {
  return entry.value;
}
function getUniqPayload$1(option, payload) {
  if (option === true) {
    return _uniqBy(payload, defaultUniqBy$1);
  }
  if (_isFunction(option)) {
    return _uniqBy(payload, option);
  }
  return payload;
}
function renderContent$1(content, props) {
  if (/* @__PURE__ */ React.isValidElement(content)) {
    return /* @__PURE__ */ React.cloneElement(content, props);
  }
  if (_isFunction(content)) {
    return /* @__PURE__ */ React.createElement(content, props);
  }
  props.ref;
  var otherProps = _objectWithoutProperties$c(props, _excluded$b);
  return /* @__PURE__ */ React.createElement(DefaultLegendContent, otherProps);
}
var EPS$2 = 1;
var Legend = /* @__PURE__ */ function(_PureComponent) {
  _inherits$h(Legend2, _PureComponent);
  var _super = _createSuper$h(Legend2);
  function Legend2() {
    var _this;
    _classCallCheck$i(this, Legend2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$t(_assertThisInitialized$h(_this), "state", {
      boxWidth: -1,
      boxHeight: -1
    });
    return _this;
  }
  _createClass$i(Legend2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateBBox();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.updateBBox();
    }
  }, {
    key: "getBBox",
    value: function getBBox() {
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        return this.wrapperNode.getBoundingClientRect();
      }
      return null;
    }
  }, {
    key: "getBBoxSnapshot",
    value: function getBBoxSnapshot() {
      var _this$state = this.state, boxWidth = _this$state.boxWidth, boxHeight = _this$state.boxHeight;
      if (boxWidth >= 0 && boxHeight >= 0) {
        return {
          width: boxWidth,
          height: boxHeight
        };
      }
      return null;
    }
  }, {
    key: "getDefaultPosition",
    value: function getDefaultPosition(style) {
      var _this$props = this.props, layout = _this$props.layout, align = _this$props.align, verticalAlign = _this$props.verticalAlign, margin = _this$props.margin, chartWidth = _this$props.chartWidth, chartHeight = _this$props.chartHeight;
      var hPos, vPos;
      if (!style || (style.left === void 0 || style.left === null) && (style.right === void 0 || style.right === null)) {
        if (align === "center" && layout === "vertical") {
          var _box = this.getBBoxSnapshot() || {
            width: 0
          };
          hPos = {
            left: ((chartWidth || 0) - _box.width) / 2
          };
        } else {
          hPos = align === "right" ? {
            right: margin && margin.right || 0
          } : {
            left: margin && margin.left || 0
          };
        }
      }
      if (!style || (style.top === void 0 || style.top === null) && (style.bottom === void 0 || style.bottom === null)) {
        if (verticalAlign === "middle") {
          var _box2 = this.getBBoxSnapshot() || {
            height: 0
          };
          vPos = {
            top: ((chartHeight || 0) - _box2.height) / 2
          };
        } else {
          vPos = verticalAlign === "bottom" ? {
            bottom: margin && margin.bottom || 0
          } : {
            top: margin && margin.top || 0
          };
        }
      }
      return _objectSpread$p(_objectSpread$p({}, hPos), vPos);
    }
  }, {
    key: "updateBBox",
    value: function updateBBox() {
      var _this$state2 = this.state, boxWidth = _this$state2.boxWidth, boxHeight = _this$state2.boxHeight;
      var onBBoxUpdate = this.props.onBBoxUpdate;
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var _box3 = this.wrapperNode.getBoundingClientRect();
        if (Math.abs(_box3.width - boxWidth) > EPS$2 || Math.abs(_box3.height - boxHeight) > EPS$2) {
          this.setState({
            boxWidth: _box3.width,
            boxHeight: _box3.height
          }, function() {
            if (onBBoxUpdate) {
              onBBoxUpdate(_box3);
            }
          });
        }
      } else if (boxWidth !== -1 || boxHeight !== -1) {
        this.setState({
          boxWidth: -1,
          boxHeight: -1
        }, function() {
          if (onBBoxUpdate) {
            onBBoxUpdate(null);
          }
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props2 = this.props, content = _this$props2.content, width = _this$props2.width, height = _this$props2.height, wrapperStyle = _this$props2.wrapperStyle, payloadUniqBy = _this$props2.payloadUniqBy, payload = _this$props2.payload;
      var outerStyle = _objectSpread$p(_objectSpread$p({
        position: "absolute",
        width: width || "auto",
        height: height || "auto"
      }, this.getDefaultPosition(wrapperStyle)), wrapperStyle);
      return /* @__PURE__ */ React.createElement("div", {
        className: "recharts-legend-wrapper",
        style: outerStyle,
        ref: function ref(node) {
          _this2.wrapperNode = node;
        }
      }, renderContent$1(content, _objectSpread$p(_objectSpread$p({}, this.props), {}, {
        payload: getUniqPayload$1(payloadUniqBy, payload)
      })));
    }
  }], [{
    key: "getWithHeight",
    value: function getWithHeight(item, chartWidth) {
      var layout = item.props.layout;
      if (layout === "vertical" && isNumber(item.props.height)) {
        return {
          height: item.props.height
        };
      }
      if (layout === "horizontal") {
        return {
          width: item.props.width || chartWidth
        };
      }
      return null;
    }
  }]);
  return Legend2;
}(reactExports.PureComponent);
_defineProperty$t(Legend, "displayName", "Legend");
_defineProperty$t(Legend, "defaultProps", {
  iconSize: 14,
  layout: "horizontal",
  align: "center",
  verticalAlign: "bottom"
});
var HAS_WEAKSET_SUPPORT = typeof WeakSet === "function";
var keys$2 = Object.keys;
function sameValueZeroEqual(a2, b2) {
  return a2 === b2 || a2 !== a2 && b2 !== b2;
}
function isPlainObject(value) {
  return value.constructor === Object || value.constructor == null;
}
function isPromiseLike(value) {
  return !!value && typeof value.then === "function";
}
function isReactElement(value) {
  return !!(value && value.$$typeof);
}
function getNewCacheFallback() {
  var values = [];
  return {
    add: function(value) {
      values.push(value);
    },
    has: function(value) {
      return values.indexOf(value) !== -1;
    }
  };
}
var getNewCache = function(canUseWeakMap) {
  if (canUseWeakMap) {
    return function _getNewCache() {
      return /* @__PURE__ */ new WeakSet();
    };
  }
  return getNewCacheFallback;
}(HAS_WEAKSET_SUPPORT);
function createCircularEqualCreator(isEqual2) {
  return function createCircularEqual(comparator) {
    var _comparator = isEqual2 || comparator;
    return function circularEqual(a2, b2, cache) {
      if (cache === void 0) {
        cache = getNewCache();
      }
      var isCacheableA = !!a2 && typeof a2 === "object";
      var isCacheableB = !!b2 && typeof b2 === "object";
      if (isCacheableA || isCacheableB) {
        var hasA = isCacheableA && cache.has(a2);
        var hasB = isCacheableB && cache.has(b2);
        if (hasA || hasB) {
          return hasA && hasB;
        }
        if (isCacheableA) {
          cache.add(a2);
        }
        if (isCacheableB) {
          cache.add(b2);
        }
      }
      return _comparator(a2, b2, cache);
    };
  };
}
function areArraysEqual(a2, b2, isEqual2, meta) {
  var index = a2.length;
  if (b2.length !== index) {
    return false;
  }
  while (index-- > 0) {
    if (!isEqual2(a2[index], b2[index], meta)) {
      return false;
    }
  }
  return true;
}
function areMapsEqual(a2, b2, isEqual2, meta) {
  var isValueEqual = a2.size === b2.size;
  if (isValueEqual && a2.size) {
    var matchedIndices_1 = {};
    a2.forEach(function(aValue, aKey) {
      if (isValueEqual) {
        var hasMatch_1 = false;
        var matchIndex_1 = 0;
        b2.forEach(function(bValue, bKey) {
          if (!hasMatch_1 && !matchedIndices_1[matchIndex_1]) {
            hasMatch_1 = isEqual2(aKey, bKey, meta) && isEqual2(aValue, bValue, meta);
            if (hasMatch_1) {
              matchedIndices_1[matchIndex_1] = true;
            }
          }
          matchIndex_1++;
        });
        isValueEqual = hasMatch_1;
      }
    });
  }
  return isValueEqual;
}
var OWNER = "_owner";
var hasOwnProperty$1 = Function.prototype.bind.call(Function.prototype.call, Object.prototype.hasOwnProperty);
function areObjectsEqual(a2, b2, isEqual2, meta) {
  var keysA = keys$2(a2);
  var index = keysA.length;
  if (keys$2(b2).length !== index) {
    return false;
  }
  if (index) {
    var key = void 0;
    while (index-- > 0) {
      key = keysA[index];
      if (key === OWNER) {
        var reactElementA = isReactElement(a2);
        var reactElementB = isReactElement(b2);
        if ((reactElementA || reactElementB) && reactElementA !== reactElementB) {
          return false;
        }
      }
      if (!hasOwnProperty$1(b2, key) || !isEqual2(a2[key], b2[key], meta)) {
        return false;
      }
    }
  }
  return true;
}
function areRegExpsEqual(a2, b2) {
  return a2.source === b2.source && a2.global === b2.global && a2.ignoreCase === b2.ignoreCase && a2.multiline === b2.multiline && a2.unicode === b2.unicode && a2.sticky === b2.sticky && a2.lastIndex === b2.lastIndex;
}
function areSetsEqual(a2, b2, isEqual2, meta) {
  var isValueEqual = a2.size === b2.size;
  if (isValueEqual && a2.size) {
    var matchedIndices_2 = {};
    a2.forEach(function(aValue) {
      if (isValueEqual) {
        var hasMatch_2 = false;
        var matchIndex_2 = 0;
        b2.forEach(function(bValue) {
          if (!hasMatch_2 && !matchedIndices_2[matchIndex_2]) {
            hasMatch_2 = isEqual2(aValue, bValue, meta);
            if (hasMatch_2) {
              matchedIndices_2[matchIndex_2] = true;
            }
          }
          matchIndex_2++;
        });
        isValueEqual = hasMatch_2;
      }
    });
  }
  return isValueEqual;
}
var HAS_MAP_SUPPORT = typeof Map === "function";
var HAS_SET_SUPPORT = typeof Set === "function";
function createComparator(createIsEqual) {
  var isEqual2 = (
    /* eslint-disable no-use-before-define */
    typeof createIsEqual === "function" ? createIsEqual(comparator) : comparator
  );
  function comparator(a2, b2, meta) {
    if (a2 === b2) {
      return true;
    }
    if (a2 && b2 && typeof a2 === "object" && typeof b2 === "object") {
      if (isPlainObject(a2) && isPlainObject(b2)) {
        return areObjectsEqual(a2, b2, isEqual2, meta);
      }
      var aShape = Array.isArray(a2);
      var bShape = Array.isArray(b2);
      if (aShape || bShape) {
        return aShape === bShape && areArraysEqual(a2, b2, isEqual2, meta);
      }
      aShape = a2 instanceof Date;
      bShape = b2 instanceof Date;
      if (aShape || bShape) {
        return aShape === bShape && sameValueZeroEqual(a2.getTime(), b2.getTime());
      }
      aShape = a2 instanceof RegExp;
      bShape = b2 instanceof RegExp;
      if (aShape || bShape) {
        return aShape === bShape && areRegExpsEqual(a2, b2);
      }
      if (isPromiseLike(a2) || isPromiseLike(b2)) {
        return a2 === b2;
      }
      if (HAS_MAP_SUPPORT) {
        aShape = a2 instanceof Map;
        bShape = b2 instanceof Map;
        if (aShape || bShape) {
          return aShape === bShape && areMapsEqual(a2, b2, isEqual2, meta);
        }
      }
      if (HAS_SET_SUPPORT) {
        aShape = a2 instanceof Set;
        bShape = b2 instanceof Set;
        if (aShape || bShape) {
          return aShape === bShape && areSetsEqual(a2, b2, isEqual2, meta);
        }
      }
      return areObjectsEqual(a2, b2, isEqual2, meta);
    }
    return a2 !== a2 && b2 !== b2;
  }
  return comparator;
}
var deepEqual = createComparator();
createComparator(function() {
  return sameValueZeroEqual;
});
createComparator(createCircularEqualCreator());
createComparator(createCircularEqualCreator(sameValueZeroEqual));
function setRafTimeout(callback) {
  var timeout = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  var currTime = -1;
  var shouldUpdate = function shouldUpdate2(now2) {
    if (currTime < 0) {
      currTime = now2;
    }
    if (now2 - currTime > timeout) {
      callback(now2);
      currTime = -1;
    } else {
      requestAnimationFrame(shouldUpdate2);
    }
  };
  requestAnimationFrame(shouldUpdate);
}
function _typeof$r(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$r = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$r = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$r(obj);
}
function _toArray(arr) {
  return _arrayWithHoles$9(arr) || _iterableToArray$c(arr) || _unsupportedIterableToArray$h(arr) || _nonIterableRest$9();
}
function _nonIterableRest$9() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$h(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$h(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$h(o, minLen);
}
function _arrayLikeToArray$h(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArray$c(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _arrayWithHoles$9(arr) {
  if (Array.isArray(arr))
    return arr;
}
function createAnimateManager() {
  var currStyle = {};
  var handleChange = function handleChange2() {
    return null;
  };
  var shouldStop = false;
  var setStyle = function setStyle2(_style) {
    if (shouldStop) {
      return;
    }
    if (Array.isArray(_style)) {
      if (!_style.length) {
        return;
      }
      var styles = _style;
      var _styles = _toArray(styles), curr = _styles[0], restStyles = _styles.slice(1);
      if (typeof curr === "number") {
        setRafTimeout(setStyle2.bind(null, restStyles), curr);
        return;
      }
      setStyle2(curr);
      setRafTimeout(setStyle2.bind(null, restStyles));
      return;
    }
    if (_typeof$r(_style) === "object") {
      currStyle = _style;
      handleChange(currStyle);
    }
    if (typeof _style === "function") {
      _style();
    }
  };
  return {
    stop: function stop() {
      shouldStop = true;
    },
    start: function start(style) {
      shouldStop = false;
      setStyle(style);
    },
    subscribe: function subscribe(_handleChange) {
      handleChange = _handleChange;
      return function() {
        handleChange = function handleChange2() {
          return null;
        };
      };
    }
  };
}
function ownKeys$o(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$o(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$o(Object(source), true).forEach(function(key) {
        _defineProperty$s(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$o(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$s(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
var PREFIX_LIST$1 = ["Webkit", "Moz", "O", "ms"];
var IN_LINE_PREFIX_LIST = ["-webkit-", "-moz-", "-o-", "-ms-"];
var IN_COMPATIBLE_PROPERTY = ["transform", "transformOrigin", "transition"];
var getIntersectionKeys = function getIntersectionKeys2(preObj, nextObj) {
  return [Object.keys(preObj), Object.keys(nextObj)].reduce(function(a2, b2) {
    return a2.filter(function(c2) {
      return b2.includes(c2);
    });
  });
};
var identity$9 = function identity2(param) {
  return param;
};
var getDashCase = function getDashCase2(name) {
  return name.replace(/([A-Z])/g, function(v2) {
    return "-".concat(v2.toLowerCase());
  });
};
var generatePrefixStyle$1 = function generatePrefixStyle2(name, value) {
  if (IN_COMPATIBLE_PROPERTY.indexOf(name) === -1) {
    return _defineProperty$s({}, name, value);
  }
  var isTransition = name === "transition";
  var camelName = name.replace(/(\w)/, function(v2) {
    return v2.toUpperCase();
  });
  var styleVal = value;
  return PREFIX_LIST$1.reduce(function(result, property2, i) {
    if (isTransition) {
      styleVal = value.replace(/(transform|transform-origin)/gim, "".concat(IN_LINE_PREFIX_LIST[i], "$1"));
    }
    return _objectSpread$o(_objectSpread$o({}, result), {}, _defineProperty$s({}, property2 + camelName, styleVal));
  }, {});
};
var mapObject = function mapObject2(fn, obj) {
  return Object.keys(obj).reduce(function(res, key) {
    return _objectSpread$o(_objectSpread$o({}, res), {}, _defineProperty$s({}, key, fn(key, obj[key])));
  }, {});
};
var translateStyle = function translateStyle2(style) {
  return Object.keys(style).reduce(function(res, key) {
    return _objectSpread$o(_objectSpread$o({}, res), generatePrefixStyle$1(key, res[key]));
  }, style);
};
var getTransitionVal = function getTransitionVal2(props, duration, easing) {
  return props.map(function(prop) {
    return "".concat(getDashCase(prop), " ").concat(duration, "ms ").concat(easing);
  }).join(",");
};
function _slicedToArray$8(arr, i) {
  return _arrayWithHoles$8(arr) || _iterableToArrayLimit$8(arr, i) || _unsupportedIterableToArray$g(arr, i) || _nonIterableRest$8();
}
function _nonIterableRest$8() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit$8(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$8(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _toConsumableArray$b(arr) {
  return _arrayWithoutHoles$b(arr) || _iterableToArray$b(arr) || _unsupportedIterableToArray$g(arr) || _nonIterableSpread$b();
}
function _nonIterableSpread$b() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$g(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$g(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$g(o, minLen);
}
function _iterableToArray$b(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _arrayWithoutHoles$b(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$g(arr);
}
function _arrayLikeToArray$g(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var ACCURACY = 1e-4;
var cubicBezierFactor = function cubicBezierFactor2(c1, c2) {
  return [0, 3 * c1, 3 * c2 - 6 * c1, 3 * c1 - 3 * c2 + 1];
};
var multyTime = function multyTime2(params, t2) {
  return params.map(function(param, i) {
    return param * Math.pow(t2, i);
  }).reduce(function(pre, curr) {
    return pre + curr;
  });
};
var cubicBezier = function cubicBezier2(c1, c2) {
  return function(t2) {
    var params = cubicBezierFactor(c1, c2);
    return multyTime(params, t2);
  };
};
var derivativeCubicBezier = function derivativeCubicBezier2(c1, c2) {
  return function(t2) {
    var params = cubicBezierFactor(c1, c2);
    var newParams = [].concat(_toConsumableArray$b(params.map(function(param, i) {
      return param * i;
    }).slice(1)), [0]);
    return multyTime(newParams, t2);
  };
};
var configBezier = function configBezier2() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var x1 = args[0], y1 = args[1], x2 = args[2], y2 = args[3];
  if (args.length === 1) {
    switch (args[0]) {
      case "linear":
        x1 = 0;
        y1 = 0;
        x2 = 1;
        y2 = 1;
        break;
      case "ease":
        x1 = 0.25;
        y1 = 0.1;
        x2 = 0.25;
        y2 = 1;
        break;
      case "ease-in":
        x1 = 0.42;
        y1 = 0;
        x2 = 1;
        y2 = 1;
        break;
      case "ease-out":
        x1 = 0.42;
        y1 = 0;
        x2 = 0.58;
        y2 = 1;
        break;
      case "ease-in-out":
        x1 = 0;
        y1 = 0;
        x2 = 0.58;
        y2 = 1;
        break;
      default: {
        var easing = args[0].split("(");
        if (easing[0] === "cubic-bezier" && easing[1].split(")")[0].split(",").length === 4) {
          var _easing$1$split$0$spl = easing[1].split(")")[0].split(",").map(function(x3) {
            return parseFloat(x3);
          });
          var _easing$1$split$0$spl2 = _slicedToArray$8(_easing$1$split$0$spl, 4);
          x1 = _easing$1$split$0$spl2[0];
          y1 = _easing$1$split$0$spl2[1];
          x2 = _easing$1$split$0$spl2[2];
          y2 = _easing$1$split$0$spl2[3];
        }
      }
    }
  }
  var curveX = cubicBezier(x1, x2);
  var curveY = cubicBezier(y1, y2);
  var derCurveX = derivativeCubicBezier(x1, x2);
  var rangeValue = function rangeValue2(value) {
    if (value > 1) {
      return 1;
    } else if (value < 0) {
      return 0;
    }
    return value;
  };
  var bezier = function bezier2(_t) {
    var t2 = _t > 1 ? 1 : _t;
    var x3 = t2;
    for (var i = 0; i < 8; ++i) {
      var evalT = curveX(x3) - t2;
      var derVal = derCurveX(x3);
      if (Math.abs(evalT - t2) < ACCURACY || derVal < ACCURACY) {
        return curveY(x3);
      }
      x3 = rangeValue(x3 - evalT / derVal);
    }
    return curveY(x3);
  };
  bezier.isStepper = false;
  return bezier;
};
var configSpring = function configSpring2() {
  var config2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  var _config$stiff = config2.stiff, stiff = _config$stiff === void 0 ? 100 : _config$stiff, _config$damping = config2.damping, damping = _config$damping === void 0 ? 8 : _config$damping, _config$dt = config2.dt, dt = _config$dt === void 0 ? 17 : _config$dt;
  var stepper = function stepper2(currX, destX, currV) {
    var FSpring = -(currX - destX) * stiff;
    var FDamping = currV * damping;
    var newV = currV + (FSpring - FDamping) * dt / 1e3;
    var newX = currV * dt / 1e3 + currX;
    if (Math.abs(newX - destX) < ACCURACY && Math.abs(newV) < ACCURACY) {
      return [destX, 0];
    }
    return [newX, newV];
  };
  stepper.isStepper = true;
  stepper.dt = dt;
  return stepper;
};
var configEasing = function configEasing2() {
  for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    args[_key2] = arguments[_key2];
  }
  var easing = args[0];
  if (typeof easing === "string") {
    switch (easing) {
      case "ease":
      case "ease-in-out":
      case "ease-out":
      case "ease-in":
      case "linear":
        return configBezier(easing);
      case "spring":
        return configSpring();
      default:
        if (easing.split("(")[0] === "cubic-bezier") {
          return configBezier(easing);
        }
    }
  }
  if (typeof easing === "function") {
    return easing;
  }
  return null;
};
function _toConsumableArray$a(arr) {
  return _arrayWithoutHoles$a(arr) || _iterableToArray$a(arr) || _unsupportedIterableToArray$f(arr) || _nonIterableSpread$a();
}
function _nonIterableSpread$a() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$a(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _arrayWithoutHoles$a(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$f(arr);
}
function ownKeys$n(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$n(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$n(Object(source), true).forEach(function(key) {
        _defineProperty$r(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$n(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$r(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _slicedToArray$7(arr, i) {
  return _arrayWithHoles$7(arr) || _iterableToArrayLimit$7(arr, i) || _unsupportedIterableToArray$f(arr, i) || _nonIterableRest$7();
}
function _nonIterableRest$7() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$f(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$f(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$f(o, minLen);
}
function _arrayLikeToArray$f(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$7(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$7(arr) {
  if (Array.isArray(arr))
    return arr;
}
var alpha = function alpha2(begin, end, k2) {
  return begin + (end - begin) * k2;
};
var needContinue = function needContinue2(_ref) {
  var from = _ref.from, to = _ref.to;
  return from !== to;
};
var calStepperVals = function calStepperVals2(easing, preVals, steps) {
  var nextStepVals = mapObject(function(key, val) {
    if (needContinue(val)) {
      var _easing = easing(val.from, val.to, val.velocity), _easing2 = _slicedToArray$7(_easing, 2), newX = _easing2[0], newV = _easing2[1];
      return _objectSpread$n(_objectSpread$n({}, val), {}, {
        from: newX,
        velocity: newV
      });
    }
    return val;
  }, preVals);
  if (steps < 1) {
    return mapObject(function(key, val) {
      if (needContinue(val)) {
        return _objectSpread$n(_objectSpread$n({}, val), {}, {
          velocity: alpha(val.velocity, nextStepVals[key].velocity, steps),
          from: alpha(val.from, nextStepVals[key].from, steps)
        });
      }
      return val;
    }, preVals);
  }
  return calStepperVals2(easing, nextStepVals, steps - 1);
};
const configUpdate = function(from, to, easing, duration, render) {
  var interKeys = getIntersectionKeys(from, to);
  var timingStyle = interKeys.reduce(function(res, key) {
    return _objectSpread$n(_objectSpread$n({}, res), {}, _defineProperty$r({}, key, [from[key], to[key]]));
  }, {});
  var stepperStyle = interKeys.reduce(function(res, key) {
    return _objectSpread$n(_objectSpread$n({}, res), {}, _defineProperty$r({}, key, {
      from: from[key],
      velocity: 0,
      to: to[key]
    }));
  }, {});
  var cafId = -1;
  var preTime;
  var beginTime;
  var update = function update2() {
    return null;
  };
  var getCurrStyle = function getCurrStyle2() {
    return mapObject(function(key, val) {
      return val.from;
    }, stepperStyle);
  };
  var shouldStopAnimation = function shouldStopAnimation2() {
    return !Object.values(stepperStyle).filter(needContinue).length;
  };
  var stepperUpdate = function stepperUpdate2(now2) {
    if (!preTime) {
      preTime = now2;
    }
    var deltaTime = now2 - preTime;
    var steps = deltaTime / easing.dt;
    stepperStyle = calStepperVals(easing, stepperStyle, steps);
    render(_objectSpread$n(_objectSpread$n(_objectSpread$n({}, from), to), getCurrStyle()));
    preTime = now2;
    if (!shouldStopAnimation()) {
      cafId = requestAnimationFrame(update);
    }
  };
  var timingUpdate = function timingUpdate2(now2) {
    if (!beginTime) {
      beginTime = now2;
    }
    var t2 = (now2 - beginTime) / duration;
    var currStyle = mapObject(function(key, val) {
      return alpha.apply(void 0, _toConsumableArray$a(val).concat([easing(t2)]));
    }, timingStyle);
    render(_objectSpread$n(_objectSpread$n(_objectSpread$n({}, from), to), currStyle));
    if (t2 < 1) {
      cafId = requestAnimationFrame(update);
    } else {
      var finalStyle = mapObject(function(key, val) {
        return alpha.apply(void 0, _toConsumableArray$a(val).concat([easing(1)]));
      }, timingStyle);
      render(_objectSpread$n(_objectSpread$n(_objectSpread$n({}, from), to), finalStyle));
    }
  };
  update = easing.isStepper ? stepperUpdate : timingUpdate;
  return function() {
    requestAnimationFrame(update);
    return function() {
      cancelAnimationFrame(cafId);
    };
  };
};
function _typeof$q(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof$q = function _typeof2(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof$q = function _typeof2(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof$q(obj);
}
function _objectWithoutProperties$b(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$b(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$b(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _toConsumableArray$9(arr) {
  return _arrayWithoutHoles$9(arr) || _iterableToArray$9(arr) || _unsupportedIterableToArray$e(arr) || _nonIterableSpread$9();
}
function _nonIterableSpread$9() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$e(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$e(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$e(o, minLen);
}
function _iterableToArray$9(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _arrayWithoutHoles$9(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$e(arr);
}
function _arrayLikeToArray$e(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function ownKeys$m(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
      });
    keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$m(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};
    if (i % 2) {
      ownKeys$m(Object(source), true).forEach(function(key) {
        _defineProperty$q(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$m(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _defineProperty$q(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _classCallCheck$h(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$h(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass$h(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$h(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$h(Constructor, staticProps);
  return Constructor;
}
function _inherits$g(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  if (superClass)
    _setPrototypeOf$g(subClass, superClass);
}
function _setPrototypeOf$g(o, p2) {
  _setPrototypeOf$g = Object.setPrototypeOf || function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$g(o, p2);
}
function _createSuper$g(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$g();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$g(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$g(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$g(this, result);
  };
}
function _possibleConstructorReturn$g(self2, call) {
  if (call && (_typeof$q(call) === "object" || typeof call === "function")) {
    return call;
  }
  return _assertThisInitialized$g(self2);
}
function _assertThisInitialized$g(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$g() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$g(o) {
  _getPrototypeOf$g = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$g(o);
}
var Animate = /* @__PURE__ */ function(_PureComponent) {
  _inherits$g(Animate2, _PureComponent);
  var _super = _createSuper$g(Animate2);
  function Animate2(props, context) {
    var _this;
    _classCallCheck$h(this, Animate2);
    _this = _super.call(this, props, context);
    var _this$props = _this.props, isActive = _this$props.isActive, attributeName = _this$props.attributeName, from = _this$props.from, to = _this$props.to, steps = _this$props.steps, children = _this$props.children;
    _this.handleStyleChange = _this.handleStyleChange.bind(_assertThisInitialized$g(_this));
    _this.changeStyle = _this.changeStyle.bind(_assertThisInitialized$g(_this));
    if (!isActive) {
      _this.state = {
        style: {}
      };
      if (typeof children === "function") {
        _this.state = {
          style: to
        };
      }
      return _possibleConstructorReturn$g(_this);
    }
    if (steps && steps.length) {
      _this.state = {
        style: steps[0].style
      };
    } else if (from) {
      if (typeof children === "function") {
        _this.state = {
          style: from
        };
        return _possibleConstructorReturn$g(_this);
      }
      _this.state = {
        style: attributeName ? _defineProperty$q({}, attributeName, from) : from
      };
    } else {
      _this.state = {
        style: {}
      };
    }
    return _this;
  }
  _createClass$h(Animate2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      var _this$props2 = this.props, isActive = _this$props2.isActive, canBegin = _this$props2.canBegin;
      this.mounted = true;
      if (!isActive || !canBegin) {
        return;
      }
      this.runAnimation(this.props);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      var _this$props3 = this.props, isActive = _this$props3.isActive, canBegin = _this$props3.canBegin, attributeName = _this$props3.attributeName, shouldReAnimate = _this$props3.shouldReAnimate;
      if (!canBegin) {
        return;
      }
      if (!isActive) {
        var newState = {
          style: attributeName ? _defineProperty$q({}, attributeName, this.props.to) : this.props.to
        };
        if (this.state && this.state.style) {
          if (attributeName && this.state.style[attributeName] !== this.props.to || !attributeName && this.state.style !== this.props.to) {
            this.setState(newState);
          }
        }
        return;
      }
      if (deepEqual(prevProps.to, this.props.to) && prevProps.canBegin && prevProps.isActive) {
        return;
      }
      var isTriggered = !prevProps.canBegin || !prevProps.isActive;
      if (this.manager) {
        this.manager.stop();
      }
      if (this.stopJSAnimation) {
        this.stopJSAnimation();
      }
      var from = isTriggered || shouldReAnimate ? this.props.from : prevProps.to;
      if (this.state && this.state.style) {
        var _newState = {
          style: attributeName ? _defineProperty$q({}, attributeName, from) : from
        };
        if (attributeName && this.state.style[attributeName] !== from || !attributeName && this.state.style !== from) {
          this.setState(_newState);
        }
      }
      this.runAnimation(_objectSpread$m(_objectSpread$m({}, this.props), {}, {
        from,
        begin: 0
      }));
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.mounted = false;
      if (this.unSubscribe) {
        this.unSubscribe();
      }
      if (this.manager) {
        this.manager.stop();
        this.manager = null;
      }
      if (this.stopJSAnimation) {
        this.stopJSAnimation();
      }
    }
  }, {
    key: "runJSAnimation",
    value: function runJSAnimation(props) {
      var _this2 = this;
      var from = props.from, to = props.to, duration = props.duration, easing = props.easing, begin = props.begin, onAnimationEnd2 = props.onAnimationEnd, onAnimationStart2 = props.onAnimationStart;
      var startAnimation = configUpdate(from, to, configEasing(easing), duration, this.changeStyle);
      var finalStartAnimation = function finalStartAnimation2() {
        _this2.stopJSAnimation = startAnimation();
      };
      this.manager.start([onAnimationStart2, begin, finalStartAnimation, duration, onAnimationEnd2]);
    }
  }, {
    key: "runStepAnimation",
    value: function runStepAnimation(props) {
      var _this3 = this;
      var steps = props.steps, begin = props.begin, onAnimationStart2 = props.onAnimationStart;
      var _steps$ = steps[0], initialStyle = _steps$.style, _steps$$duration = _steps$.duration, initialTime = _steps$$duration === void 0 ? 0 : _steps$$duration;
      var addStyle = function addStyle2(sequence, nextItem, index) {
        if (index === 0) {
          return sequence;
        }
        var duration = nextItem.duration, _nextItem$easing = nextItem.easing, easing = _nextItem$easing === void 0 ? "ease" : _nextItem$easing, style = nextItem.style, nextProperties = nextItem.properties, onAnimationEnd2 = nextItem.onAnimationEnd;
        var preItem = index > 0 ? steps[index - 1] : nextItem;
        var properties = nextProperties || Object.keys(style);
        if (typeof easing === "function" || easing === "spring") {
          return [].concat(_toConsumableArray$9(sequence), [_this3.runJSAnimation.bind(_this3, {
            from: preItem.style,
            to: style,
            duration,
            easing
          }), duration]);
        }
        var transition = getTransitionVal(properties, duration, easing);
        var newStyle = _objectSpread$m(_objectSpread$m(_objectSpread$m({}, preItem.style), style), {}, {
          transition
        });
        return [].concat(_toConsumableArray$9(sequence), [newStyle, duration, onAnimationEnd2]).filter(identity$9);
      };
      return this.manager.start([onAnimationStart2].concat(_toConsumableArray$9(steps.reduce(addStyle, [initialStyle, Math.max(initialTime, begin)])), [props.onAnimationEnd]));
    }
  }, {
    key: "runAnimation",
    value: function runAnimation(props) {
      if (!this.manager) {
        this.manager = createAnimateManager();
      }
      var begin = props.begin, duration = props.duration, attributeName = props.attributeName, propsTo = props.to, easing = props.easing, onAnimationStart2 = props.onAnimationStart, onAnimationEnd2 = props.onAnimationEnd, steps = props.steps, children = props.children;
      var manager = this.manager;
      this.unSubscribe = manager.subscribe(this.handleStyleChange);
      if (typeof easing === "function" || typeof children === "function" || easing === "spring") {
        this.runJSAnimation(props);
        return;
      }
      if (steps.length > 1) {
        this.runStepAnimation(props);
        return;
      }
      var to = attributeName ? _defineProperty$q({}, attributeName, propsTo) : propsTo;
      var transition = getTransitionVal(Object.keys(to), duration, easing);
      manager.start([onAnimationStart2, begin, _objectSpread$m(_objectSpread$m({}, to), {}, {
        transition
      }), duration, onAnimationEnd2]);
    }
  }, {
    key: "handleStyleChange",
    value: function handleStyleChange(style) {
      this.changeStyle(style);
    }
  }, {
    key: "changeStyle",
    value: function changeStyle(style) {
      if (this.mounted) {
        this.setState({
          style
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props4 = this.props, children = _this$props4.children;
      _this$props4.begin;
      _this$props4.duration;
      _this$props4.attributeName;
      _this$props4.easing;
      var isActive = _this$props4.isActive;
      _this$props4.steps;
      _this$props4.from;
      _this$props4.to;
      _this$props4.canBegin;
      _this$props4.onAnimationEnd;
      _this$props4.shouldReAnimate;
      _this$props4.onAnimationReStart;
      var others = _objectWithoutProperties$b(_this$props4, ["children", "begin", "duration", "attributeName", "easing", "isActive", "steps", "from", "to", "canBegin", "onAnimationEnd", "shouldReAnimate", "onAnimationReStart"]);
      var count = reactExports.Children.count(children);
      var stateStyle = translateStyle(this.state.style);
      if (typeof children === "function") {
        return children(stateStyle);
      }
      if (!isActive || count === 0) {
        return children;
      }
      var cloneContainer = function cloneContainer2(container) {
        var _container$props = container.props, _container$props$styl = _container$props.style, style = _container$props$styl === void 0 ? {} : _container$props$styl, className = _container$props.className;
        var res = /* @__PURE__ */ reactExports.cloneElement(container, _objectSpread$m(_objectSpread$m({}, others), {}, {
          style: _objectSpread$m(_objectSpread$m({}, style), stateStyle),
          className
        }));
        return res;
      };
      if (count === 1) {
        return cloneContainer(reactExports.Children.only(children));
      }
      return /* @__PURE__ */ React.createElement("div", null, reactExports.Children.map(children, function(child) {
        return cloneContainer(child);
      }));
    }
  }]);
  return Animate2;
}(reactExports.PureComponent);
Animate.displayName = "Animate";
Animate.propTypes = {
  from: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
  to: PropTypes.oneOfType([PropTypes.object, PropTypes.string]),
  attributeName: PropTypes.string,
  // animation duration
  duration: PropTypes.number,
  begin: PropTypes.number,
  easing: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
  steps: PropTypes.arrayOf(PropTypes.shape({
    duration: PropTypes.number.isRequired,
    style: PropTypes.object.isRequired,
    easing: PropTypes.oneOfType([PropTypes.oneOf(["ease", "ease-in", "ease-out", "ease-in-out", "linear"]), PropTypes.func]),
    // transition css properties(dash case), optional
    properties: PropTypes.arrayOf("string"),
    onAnimationEnd: PropTypes.func
  })),
  children: PropTypes.oneOfType([PropTypes.node, PropTypes.func]),
  isActive: PropTypes.bool,
  canBegin: PropTypes.bool,
  onAnimationEnd: PropTypes.func,
  // decide if it should reanimate with initial from style when props change
  shouldReAnimate: PropTypes.bool,
  onAnimationStart: PropTypes.func,
  onAnimationReStart: PropTypes.func
};
Animate.defaultProps = {
  begin: 0,
  duration: 1e3,
  from: "",
  to: "",
  attributeName: "",
  easing: "ease",
  isActive: true,
  canBegin: true,
  steps: [],
  onAnimationEnd: function onAnimationEnd() {
  },
  onAnimationStart: function onAnimationStart() {
  }
};
if (Number.isFinite === void 0) {
  Number.isFinite = function(value) {
    return typeof value === "number" && isFinite(value);
  };
}
({
  appearOptions: PropTypes.object,
  enterOptions: PropTypes.object,
  leaveOptions: PropTypes.object,
  children: PropTypes.element
});
({
  appear: PropTypes.object,
  enter: PropTypes.object,
  leave: PropTypes.object,
  children: PropTypes.oneOfType([PropTypes.array, PropTypes.element]),
  component: PropTypes.any
});
var Symbol$4 = _Symbol$1, isArguments = isArguments_1, isArray$4 = isArray_1;
var spreadableSymbol = Symbol$4 ? Symbol$4.isConcatSpreadable : void 0;
function isFlattenable$1(value) {
  return isArray$4(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
}
var _isFlattenable = isFlattenable$1;
var arrayPush = _arrayPush, isFlattenable = _isFlattenable;
function baseFlatten$2(array2, depth, predicate, isStrict, result) {
  var index = -1, length = array2.length;
  predicate || (predicate = isFlattenable);
  result || (result = []);
  while (++index < length) {
    var value = array2[index];
    if (depth > 0 && predicate(value)) {
      if (depth > 1) {
        baseFlatten$2(value, depth - 1, predicate, isStrict, result);
      } else {
        arrayPush(result, value);
      }
    } else if (!isStrict) {
      result[result.length] = value;
    }
  }
  return result;
}
var _baseFlatten = baseFlatten$2;
function createBaseFor$1(fromRight) {
  return function(object2, iteratee, keysFunc) {
    var index = -1, iterable = Object(object2), props = keysFunc(object2), length = props.length;
    while (length--) {
      var key = props[fromRight ? length : ++index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object2;
  };
}
var _createBaseFor = createBaseFor$1;
var createBaseFor = _createBaseFor;
var baseFor$1 = createBaseFor();
var _baseFor = baseFor$1;
var baseFor = _baseFor, keys$1 = keys_1;
function baseForOwn$2(object2, iteratee) {
  return object2 && baseFor(object2, iteratee, keys$1);
}
var _baseForOwn = baseForOwn$2;
var isArrayLike$3 = isArrayLike_1;
function createBaseEach$1(eachFunc, fromRight) {
  return function(collection, iteratee) {
    if (collection == null) {
      return collection;
    }
    if (!isArrayLike$3(collection)) {
      return eachFunc(collection, iteratee);
    }
    var length = collection.length, index = fromRight ? length : -1, iterable = Object(collection);
    while (fromRight ? index-- : ++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  };
}
var _createBaseEach = createBaseEach$1;
var baseForOwn$1 = _baseForOwn, createBaseEach = _createBaseEach;
var baseEach$3 = createBaseEach(baseForOwn$1);
var _baseEach = baseEach$3;
var baseEach$2 = _baseEach, isArrayLike$2 = isArrayLike_1;
function baseMap$2(collection, iteratee) {
  var index = -1, result = isArrayLike$2(collection) ? Array(collection.length) : [];
  baseEach$2(collection, function(value, key, collection2) {
    result[++index] = iteratee(value, key, collection2);
  });
  return result;
}
var _baseMap = baseMap$2;
function baseSortBy$1(array2, comparer) {
  var length = array2.length;
  array2.sort(comparer);
  while (length--) {
    array2[length] = array2[length].value;
  }
  return array2;
}
var _baseSortBy = baseSortBy$1;
var isSymbol$3 = isSymbol_1$1;
function compareAscending$1(value, other) {
  if (value !== other) {
    var valIsDefined = value !== void 0, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol$3(value);
    var othIsDefined = other !== void 0, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol$3(other);
    if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
      return 1;
    }
    if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
      return -1;
    }
  }
  return 0;
}
var _compareAscending = compareAscending$1;
var compareAscending = _compareAscending;
function compareMultiple$1(object2, other, orders) {
  var index = -1, objCriteria = object2.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
  while (++index < length) {
    var result = compareAscending(objCriteria[index], othCriteria[index]);
    if (result) {
      if (index >= ordersLength) {
        return result;
      }
      var order = orders[index];
      return result * (order == "desc" ? -1 : 1);
    }
  }
  return object2.index - other.index;
}
var _compareMultiple = compareMultiple$1;
var arrayMap$1 = _arrayMap, baseGet = _baseGet, baseIteratee$6 = _baseIteratee, baseMap$1 = _baseMap, baseSortBy = _baseSortBy, baseUnary = _baseUnary, compareMultiple = _compareMultiple, identity$8 = identity_1, isArray$3 = isArray_1;
function baseOrderBy$1(collection, iteratees, orders) {
  if (iteratees.length) {
    iteratees = arrayMap$1(iteratees, function(iteratee) {
      if (isArray$3(iteratee)) {
        return function(value) {
          return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
        };
      }
      return iteratee;
    });
  } else {
    iteratees = [identity$8];
  }
  var index = -1;
  iteratees = arrayMap$1(iteratees, baseUnary(baseIteratee$6));
  var result = baseMap$1(collection, function(value, key, collection2) {
    var criteria = arrayMap$1(iteratees, function(iteratee) {
      return iteratee(value);
    });
    return { "criteria": criteria, "index": ++index, "value": value };
  });
  return baseSortBy(result, function(object2, other) {
    return compareMultiple(object2, other, orders);
  });
}
var _baseOrderBy = baseOrderBy$1;
function apply$1(func, thisArg, args) {
  switch (args.length) {
    case 0:
      return func.call(thisArg);
    case 1:
      return func.call(thisArg, args[0]);
    case 2:
      return func.call(thisArg, args[0], args[1]);
    case 3:
      return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}
var _apply = apply$1;
var apply = _apply;
var nativeMax$4 = Math.max;
function overRest$1(func, start, transform) {
  start = nativeMax$4(start === void 0 ? func.length - 1 : start, 0);
  return function() {
    var args = arguments, index = -1, length = nativeMax$4(args.length - start, 0), array2 = Array(length);
    while (++index < length) {
      array2[index] = args[start + index];
    }
    index = -1;
    var otherArgs = Array(start + 1);
    while (++index < start) {
      otherArgs[index] = args[index];
    }
    otherArgs[start] = transform(array2);
    return apply(func, this, otherArgs);
  };
}
var _overRest = overRest$1;
function constant$2(value) {
  return function() {
    return value;
  };
}
var constant_1 = constant$2;
var getNative = _getNative;
var defineProperty$2 = function() {
  try {
    var func = getNative(Object, "defineProperty");
    func({}, "", {});
    return func;
  } catch (e3) {
  }
}();
var _defineProperty$p = defineProperty$2;
var constant$1 = constant_1, defineProperty$1 = _defineProperty$p, identity$7 = identity_1;
var baseSetToString$1 = !defineProperty$1 ? identity$7 : function(func, string2) {
  return defineProperty$1(func, "toString", {
    "configurable": true,
    "enumerable": false,
    "value": constant$1(string2),
    "writable": true
  });
};
var _baseSetToString = baseSetToString$1;
var HOT_COUNT = 800, HOT_SPAN = 16;
var nativeNow = Date.now;
function shortOut$1(func) {
  var count = 0, lastCalled = 0;
  return function() {
    var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return arguments[0];
      }
    } else {
      count = 0;
    }
    return func.apply(void 0, arguments);
  };
}
var _shortOut = shortOut$1;
var baseSetToString = _baseSetToString, shortOut = _shortOut;
var setToString$1 = shortOut(baseSetToString);
var _setToString = setToString$1;
var identity$6 = identity_1, overRest = _overRest, setToString = _setToString;
function baseRest$1(func, start) {
  return setToString(overRest(func, start, identity$6), func + "");
}
var _baseRest = baseRest$1;
var eq = eq_1, isArrayLike$1 = isArrayLike_1, isIndex = _isIndex, isObject$5 = isObject_1$1;
function isIterateeCall$4(value, index, object2) {
  if (!isObject$5(object2)) {
    return false;
  }
  var type = typeof index;
  if (type == "number" ? isArrayLike$1(object2) && isIndex(index, object2.length) : type == "string" && index in object2) {
    return eq(object2[index], value);
  }
  return false;
}
var _isIterateeCall = isIterateeCall$4;
var baseFlatten$1 = _baseFlatten, baseOrderBy = _baseOrderBy, baseRest = _baseRest, isIterateeCall$3 = _isIterateeCall;
var sortBy = baseRest(function(collection, iteratees) {
  if (collection == null) {
    return [];
  }
  var length = iteratees.length;
  if (length > 1 && isIterateeCall$3(collection, iteratees[0], iteratees[1])) {
    iteratees = [];
  } else if (length > 2 && isIterateeCall$3(iteratees[0], iteratees[1], iteratees[2])) {
    iteratees = [iteratees[0]];
  }
  return baseOrderBy(collection, baseFlatten$1(iteratees, 1), []);
});
var sortBy_1 = sortBy;
const _sortBy = /* @__PURE__ */ getDefaultExportFromCjs(sortBy_1);
function _typeof$p(obj) {
  "@babel/helpers - typeof";
  return _typeof$p = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$p(obj);
}
function _slicedToArray$6(arr, i) {
  return _arrayWithHoles$6(arr) || _iterableToArrayLimit$6(arr, i) || _unsupportedIterableToArray$d(arr, i) || _nonIterableRest$6();
}
function _nonIterableRest$6() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$d(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$d(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$d(o, minLen);
}
function _arrayLikeToArray$d(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$6(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$6(arr) {
  if (Array.isArray(arr))
    return arr;
}
function ownKeys$l(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$l(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$l(Object(source), true).forEach(function(key) {
      _defineProperty$o(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$l(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$g(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$g(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$p(descriptor.key), descriptor);
  }
}
function _createClass$g(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$g(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$g(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$f(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$f(subClass, superClass);
}
function _setPrototypeOf$f(o, p2) {
  _setPrototypeOf$f = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$f(o, p2);
}
function _createSuper$f(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$f();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$f(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$f(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$f(this, result);
  };
}
function _possibleConstructorReturn$f(self2, call) {
  if (call && (_typeof$p(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$f(self2);
}
function _assertThisInitialized$f(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$f() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$f(o) {
  _getPrototypeOf$f = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$f(o);
}
function _defineProperty$o(obj, key, value) {
  key = _toPropertyKey$p(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$p(arg) {
  var key = _toPrimitive$p(arg, "string");
  return _typeof$p(key) === "symbol" ? key : String(key);
}
function _toPrimitive$p(input2, hint) {
  if (_typeof$p(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$p(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function defaultFormatter(value) {
  return _isArray(value) && isNumOrStr(value[0]) && isNumOrStr(value[1]) ? value.join(" ~ ") : value;
}
var DefaultTooltipContent = /* @__PURE__ */ function(_PureComponent) {
  _inherits$f(DefaultTooltipContent2, _PureComponent);
  var _super = _createSuper$f(DefaultTooltipContent2);
  function DefaultTooltipContent2() {
    _classCallCheck$g(this, DefaultTooltipContent2);
    return _super.apply(this, arguments);
  }
  _createClass$g(DefaultTooltipContent2, [{
    key: "renderContent",
    value: function renderContent2() {
      var _this$props = this.props, payload = _this$props.payload, separator = _this$props.separator, formatter = _this$props.formatter, itemStyle = _this$props.itemStyle, itemSorter = _this$props.itemSorter;
      if (payload && payload.length) {
        var listStyle = {
          padding: 0,
          margin: 0
        };
        var items = (itemSorter ? _sortBy(payload, itemSorter) : payload).map(function(entry, i) {
          if (entry.type === "none") {
            return null;
          }
          var finalItemStyle = _objectSpread$l({
            display: "block",
            paddingTop: 4,
            paddingBottom: 4,
            color: entry.color || "#000"
          }, itemStyle);
          var finalFormatter = entry.formatter || formatter || defaultFormatter;
          var value = entry.value, name = entry.name;
          if (finalFormatter && value != null && name != null) {
            var formatted = finalFormatter(value, name, entry, i, payload);
            if (Array.isArray(formatted)) {
              var _ref = formatted;
              var _ref2 = _slicedToArray$6(_ref, 2);
              value = _ref2[0];
              name = _ref2[1];
            } else {
              value = formatted;
            }
          }
          return (
            // eslint-disable-next-line react/no-array-index-key
            /* @__PURE__ */ React.createElement("li", {
              className: "recharts-tooltip-item",
              key: "tooltip-item-".concat(i),
              style: finalItemStyle
            }, isNumOrStr(name) ? /* @__PURE__ */ React.createElement("span", {
              className: "recharts-tooltip-item-name"
            }, name) : null, isNumOrStr(name) ? /* @__PURE__ */ React.createElement("span", {
              className: "recharts-tooltip-item-separator"
            }, separator) : null, /* @__PURE__ */ React.createElement("span", {
              className: "recharts-tooltip-item-value"
            }, value), /* @__PURE__ */ React.createElement("span", {
              className: "recharts-tooltip-item-unit"
            }, entry.unit || ""))
          );
        });
        return /* @__PURE__ */ React.createElement("ul", {
          className: "recharts-tooltip-item-list",
          style: listStyle
        }, items);
      }
      return null;
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props, wrapperClassName = _this$props2.wrapperClassName, contentStyle = _this$props2.contentStyle, labelClassName = _this$props2.labelClassName, labelStyle = _this$props2.labelStyle, label = _this$props2.label, labelFormatter = _this$props2.labelFormatter, payload = _this$props2.payload;
      var finalStyle = _objectSpread$l({
        margin: 0,
        padding: 10,
        backgroundColor: "#fff",
        border: "1px solid #ccc",
        whiteSpace: "nowrap"
      }, contentStyle);
      var finalLabelStyle = _objectSpread$l({
        margin: 0
      }, labelStyle);
      var hasLabel = !_isNil(label);
      var finalLabel = hasLabel ? label : "";
      var wrapperCN = classNames("recharts-default-tooltip", wrapperClassName);
      var labelCN = classNames("recharts-tooltip-label", labelClassName);
      if (hasLabel && labelFormatter && payload !== void 0 && payload !== null) {
        finalLabel = labelFormatter(label, payload);
      }
      return /* @__PURE__ */ React.createElement("div", {
        className: wrapperCN,
        style: finalStyle
      }, /* @__PURE__ */ React.createElement("p", {
        className: labelCN,
        style: finalLabelStyle
      }, /* @__PURE__ */ React.isValidElement(finalLabel) ? finalLabel : "".concat(finalLabel)), this.renderContent());
    }
  }]);
  return DefaultTooltipContent2;
}(reactExports.PureComponent);
_defineProperty$o(DefaultTooltipContent, "displayName", "DefaultTooltipContent");
_defineProperty$o(DefaultTooltipContent, "defaultProps", {
  separator: " : ",
  contentStyle: {},
  itemStyle: {},
  labelStyle: {}
});
var parseIsSsrByDefault = function parseIsSsrByDefault2() {
  return !(typeof window !== "undefined" && window.document && window.document.createElement && window.setTimeout);
};
var Global = {
  isSsr: parseIsSsrByDefault(),
  get: function get2(key) {
    return Global[key];
  },
  set: function set(key, value) {
    if (typeof key === "string") {
      Global[key] = value;
    } else {
      var keys2 = Object.keys(key);
      if (keys2 && keys2.length) {
        keys2.forEach(function(k2) {
          Global[k2] = key[k2];
        });
      }
    }
  }
};
function _typeof$o(obj) {
  "@babel/helpers - typeof";
  return _typeof$o = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$o(obj);
}
function ownKeys$k(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$k(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$k(Object(source), true).forEach(function(key) {
      _defineProperty$n(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$k(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$f(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$f(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$o(descriptor.key), descriptor);
  }
}
function _createClass$f(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$f(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$f(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$e(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$e(subClass, superClass);
}
function _setPrototypeOf$e(o, p2) {
  _setPrototypeOf$e = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$e(o, p2);
}
function _createSuper$e(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$e();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$e(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$e(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$e(this, result);
  };
}
function _possibleConstructorReturn$e(self2, call) {
  if (call && (_typeof$o(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$e(self2);
}
function _assertThisInitialized$e(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$e() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$e(o) {
  _getPrototypeOf$e = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$e(o);
}
function _defineProperty$n(obj, key, value) {
  key = _toPropertyKey$o(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$o(arg) {
  var key = _toPrimitive$o(arg, "string");
  return _typeof$o(key) === "symbol" ? key : String(key);
}
function _toPrimitive$o(input2, hint) {
  if (_typeof$o(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$o(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var CLS_PREFIX = "recharts-tooltip-wrapper";
var EPS$1 = 1;
function defaultUniqBy(entry) {
  return entry.dataKey;
}
function getUniqPayload(option, payload) {
  if (option === true) {
    return _uniqBy(payload, defaultUniqBy);
  }
  if (_isFunction(option)) {
    return _uniqBy(payload, option);
  }
  return payload;
}
function renderContent(content, props) {
  if (/* @__PURE__ */ React.isValidElement(content)) {
    return /* @__PURE__ */ React.cloneElement(content, props);
  }
  if (_isFunction(content)) {
    return /* @__PURE__ */ React.createElement(content, props);
  }
  return /* @__PURE__ */ React.createElement(DefaultTooltipContent, props);
}
var Tooltip = /* @__PURE__ */ function(_PureComponent) {
  _inherits$e(Tooltip2, _PureComponent);
  var _super = _createSuper$e(Tooltip2);
  function Tooltip2() {
    var _this;
    _classCallCheck$f(this, Tooltip2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$n(_assertThisInitialized$e(_this), "state", {
      boxWidth: -1,
      boxHeight: -1,
      dismissed: false,
      dismissedAtCoordinate: {
        x: 0,
        y: 0
      }
    });
    _defineProperty$n(_assertThisInitialized$e(_this), "getTranslate", function(_ref) {
      var key = _ref.key, tooltipDimension = _ref.tooltipDimension, viewBoxDimension = _ref.viewBoxDimension;
      var _this$props = _this.props, allowEscapeViewBox = _this$props.allowEscapeViewBox, reverseDirection = _this$props.reverseDirection, coordinate = _this$props.coordinate, offset = _this$props.offset, position = _this$props.position, viewBox = _this$props.viewBox;
      if (position && isNumber(position[key])) {
        return position[key];
      }
      var negative = coordinate[key] - tooltipDimension - offset;
      var positive = coordinate[key] + offset;
      if (allowEscapeViewBox[key]) {
        return reverseDirection[key] ? negative : positive;
      }
      if (reverseDirection[key]) {
        var _tooltipBoundary = negative;
        var _viewBoxBoundary = viewBox[key];
        if (_tooltipBoundary < _viewBoxBoundary) {
          return Math.max(positive, viewBox[key]);
        }
        return Math.max(negative, viewBox[key]);
      }
      var tooltipBoundary = positive + tooltipDimension;
      var viewBoxBoundary = viewBox[key] + viewBoxDimension;
      if (tooltipBoundary > viewBoxBoundary) {
        return Math.max(negative, viewBox[key]);
      }
      return Math.max(positive, viewBox[key]);
    });
    return _this;
  }
  _createClass$f(Tooltip2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.updateBBox();
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate() {
      this.updateBBox();
    }
  }, {
    key: "updateBBox",
    value: function updateBBox() {
      var _this$state = this.state, boxWidth = _this$state.boxWidth, boxHeight = _this$state.boxHeight, dismissed = _this$state.dismissed;
      if (dismissed) {
        this.wrapperNode.blur();
        if (this.props.coordinate.x !== this.state.dismissedAtCoordinate.x || this.props.coordinate.y !== this.state.dismissedAtCoordinate.y) {
          this.setState({
            dismissed: false
          });
        }
      } else {
        this.wrapperNode.focus({
          preventScroll: true
        });
      }
      if (this.wrapperNode && this.wrapperNode.getBoundingClientRect) {
        var box = this.wrapperNode.getBoundingClientRect();
        if (Math.abs(box.width - boxWidth) > EPS$1 || Math.abs(box.height - boxHeight) > EPS$1) {
          this.setState({
            boxWidth: box.width,
            boxHeight: box.height
          });
        }
      } else if (boxWidth !== -1 || boxHeight !== -1) {
        this.setState({
          boxWidth: -1,
          boxHeight: -1
        });
      }
    }
  }, {
    key: "render",
    value: function render() {
      var _classNames, _this2 = this;
      var _this$props2 = this.props, payload = _this$props2.payload, isAnimationActive = _this$props2.isAnimationActive, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, filterNull = _this$props2.filterNull, payloadUniqBy = _this$props2.payloadUniqBy;
      var finalPayload = getUniqPayload(payloadUniqBy, filterNull && payload && payload.length ? payload.filter(function(entry) {
        return !_isNil(entry.value);
      }) : payload);
      var hasPayload = finalPayload && finalPayload.length;
      var _this$props3 = this.props, content = _this$props3.content, viewBox = _this$props3.viewBox, coordinate = _this$props3.coordinate, position = _this$props3.position, active = _this$props3.active, wrapperStyle = _this$props3.wrapperStyle;
      var outerStyle = _objectSpread$k({
        pointerEvents: "none",
        visibility: !this.state.dismissed && active && hasPayload ? "visible" : "hidden",
        position: "absolute",
        top: 0,
        left: 0
      }, wrapperStyle);
      var translateX, translateY;
      if (position && isNumber(position.x) && isNumber(position.y)) {
        translateX = position.x;
        translateY = position.y;
      } else {
        var _this$state2 = this.state, boxWidth = _this$state2.boxWidth, boxHeight = _this$state2.boxHeight;
        if (boxWidth > 0 && boxHeight > 0 && coordinate) {
          translateX = this.getTranslate({
            key: "x",
            tooltipDimension: boxWidth,
            viewBoxDimension: viewBox.width
          });
          translateY = this.getTranslate({
            key: "y",
            tooltipDimension: boxHeight,
            viewBoxDimension: viewBox.height
          });
        } else {
          outerStyle.visibility = "hidden";
        }
      }
      outerStyle = _objectSpread$k(_objectSpread$k({}, translateStyle({
        transform: this.props.useTranslate3d ? "translate3d(".concat(translateX, "px, ").concat(translateY, "px, 0)") : "translate(".concat(translateX, "px, ").concat(translateY, "px)")
      })), outerStyle);
      if (isAnimationActive && active) {
        outerStyle = _objectSpread$k(_objectSpread$k({}, translateStyle({
          transition: "transform ".concat(animationDuration, "ms ").concat(animationEasing)
        })), outerStyle);
      }
      var cls = classNames(CLS_PREFIX, (_classNames = {}, _defineProperty$n(_classNames, "".concat(CLS_PREFIX, "-right"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX >= coordinate.x), _defineProperty$n(_classNames, "".concat(CLS_PREFIX, "-left"), isNumber(translateX) && coordinate && isNumber(coordinate.x) && translateX < coordinate.x), _defineProperty$n(_classNames, "".concat(CLS_PREFIX, "-bottom"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY >= coordinate.y), _defineProperty$n(_classNames, "".concat(CLS_PREFIX, "-top"), isNumber(translateY) && coordinate && isNumber(coordinate.y) && translateY < coordinate.y), _classNames));
      return (
        // ESLint is disabled to allow listening to the `Escape` key. Refer to
        // https://github.com/recharts/recharts/pull/2925
        // eslint-disable-next-line jsx-a11y/no-noninteractive-element-interactions
        /* @__PURE__ */ React.createElement("div", {
          tabIndex: -1,
          role: "dialog",
          onKeyDown: function onKeyDown(event) {
            if (event.key === "Escape") {
              _this2.setState({
                dismissed: true,
                dismissedAtCoordinate: _objectSpread$k(_objectSpread$k({}, _this2.state.dismissedAtCoordinate), {}, {
                  x: _this2.props.coordinate.x,
                  y: _this2.props.coordinate.y
                })
              });
            }
          },
          className: cls,
          style: outerStyle,
          ref: function ref(node) {
            _this2.wrapperNode = node;
          }
        }, renderContent(content, _objectSpread$k(_objectSpread$k({}, this.props), {}, {
          payload: finalPayload
        })))
      );
    }
  }]);
  return Tooltip2;
}(reactExports.PureComponent);
_defineProperty$n(Tooltip, "displayName", "Tooltip");
_defineProperty$n(Tooltip, "defaultProps", {
  active: false,
  allowEscapeViewBox: {
    x: false,
    y: false
  },
  reverseDirection: {
    x: false,
    y: false
  },
  offset: 10,
  viewBox: {
    x1: 0,
    x2: 0,
    y1: 0,
    y2: 0
  },
  coordinate: {
    x: 0,
    y: 0
  },
  cursorStyle: {},
  separator: " : ",
  wrapperStyle: {},
  contentStyle: {},
  itemStyle: {},
  labelStyle: {},
  cursor: true,
  trigger: "hover",
  isAnimationActive: !Global.isSsr,
  animationEasing: "ease",
  animationDuration: 400,
  filterNull: true,
  useTranslate3d: false
});
var extendStatics = function(d2, b2) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b3) {
    d3.__proto__ = b3;
  } || function(d3, b3) {
    for (var p2 in b3)
      if (Object.prototype.hasOwnProperty.call(b3, p2))
        d3[p2] = b3[p2];
  };
  return extendStatics(d2, b2);
};
function __extends(d2, b2) {
  if (typeof b2 !== "function" && b2 !== null)
    throw new TypeError("Class extends value " + String(b2) + " is not a constructor or null");
  extendStatics(d2, b2);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b2 === null ? Object.create(b2) : (__.prototype = b2.prototype, new __());
}
function __rest(s2, e3) {
  var t2 = {};
  for (var p2 in s2)
    if (Object.prototype.hasOwnProperty.call(s2, p2) && e3.indexOf(p2) < 0)
      t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s2); i < p2.length; i++) {
      if (e3.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i]))
        t2[p2[i]] = s2[p2[i]];
    }
  return t2;
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function isObject$3(value) {
  var type = typeof value;
  return value != null && (type == "object" || type == "function");
}
var isObject_1 = isObject$3;
var freeGlobal$1 = typeof commonjsGlobal == "object" && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;
var _freeGlobal = freeGlobal$1;
var freeGlobal = _freeGlobal;
var freeSelf = typeof self == "object" && self && self.Object === Object && self;
var root$2 = freeGlobal || freeSelf || Function("return this")();
var _root = root$2;
var root$1 = _root;
var now$1$1 = function() {
  return root$1.Date.now();
};
var now_1$1 = now$1$1;
var reWhitespace$1 = /\s/;
function trimmedEndIndex$1$1(string2) {
  var index = string2.length;
  while (index-- && reWhitespace$1.test(string2.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex$1 = trimmedEndIndex$1$1;
var trimmedEndIndex$2 = _trimmedEndIndex$1;
var reTrimStart$1 = /^\s+/;
function baseTrim$1$1(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex$2(string2) + 1).replace(reTrimStart$1, "") : string2;
}
var _baseTrim$1 = baseTrim$1$1;
var root$3 = _root;
var Symbol$2 = root$3.Symbol;
var _Symbol = Symbol$2;
var Symbol$1 = _Symbol;
var objectProto$1 = Object.prototype;
var hasOwnProperty = objectProto$1.hasOwnProperty;
var nativeObjectToString$1 = objectProto$1.toString;
var symToStringTag$1 = Symbol$1 ? Symbol$1.toStringTag : void 0;
function getRawTag$1(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag$1), tag = value[symToStringTag$1];
  try {
    value[symToStringTag$1] = void 0;
    var unmasked = true;
  } catch (e3) {
  }
  var result = nativeObjectToString$1.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag$1] = tag;
    } else {
      delete value[symToStringTag$1];
    }
  }
  return result;
}
var _getRawTag = getRawTag$1;
var objectProto = Object.prototype;
var nativeObjectToString = objectProto.toString;
function objectToString$1(value) {
  return nativeObjectToString.call(value);
}
var _objectToString = objectToString$1;
var Symbol$3 = _Symbol, getRawTag = _getRawTag, objectToString = _objectToString;
var nullTag = "[object Null]", undefinedTag = "[object Undefined]";
var symToStringTag = Symbol$3 ? Symbol$3.toStringTag : void 0;
function baseGetTag$1(value) {
  if (value == null) {
    return value === void 0 ? undefinedTag : nullTag;
  }
  return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
}
var _baseGetTag = baseGetTag$1;
function isObjectLike$1(value) {
  return value != null && typeof value == "object";
}
var isObjectLike_1 = isObjectLike$1;
var baseGetTag$2 = _baseGetTag, isObjectLike$2 = isObjectLike_1;
var symbolTag = "[object Symbol]";
function isSymbol$1$1(value) {
  return typeof value == "symbol" || isObjectLike$2(value) && baseGetTag$2(value) == symbolTag;
}
var isSymbol_1 = isSymbol$1$1;
var baseTrim$2 = _baseTrim$1, isObject$2$1 = isObject_1, isSymbol$2 = isSymbol_1;
var NAN$1 = 0 / 0;
var reIsBadHex$1 = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary$1 = /^0b[01]+$/i;
var reIsOctal$1 = /^0o[0-7]+$/i;
var freeParseInt$1 = parseInt;
function toNumber$1$1(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol$2(value)) {
    return NAN$1;
  }
  if (isObject$2$1(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2$1(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim$2(value);
  var isBinary = reIsBinary$1.test(value);
  return isBinary || reIsOctal$1.test(value) ? freeParseInt$1(value.slice(2), isBinary ? 2 : 8) : reIsBadHex$1.test(value) ? NAN$1 : +value;
}
var toNumber_1$1 = toNumber$1$1;
var isObject$1$1 = isObject_1, now$2 = now_1$1, toNumber$3 = toNumber_1$1;
var FUNC_ERROR_TEXT$1$1 = "Expected a function";
var nativeMax$3 = Math.max, nativeMin$1 = Math.min;
function debounce$1$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1$1);
  }
  wait = toNumber$3(wait) || 0;
  if (isObject$1$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax$3(toNumber$3(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin$1(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now$2();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now$2());
  }
  function debounced() {
    var time2 = now$2(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1$1 = debounce$1$1;
var debounce$2 = debounce_1$1, isObject$4 = isObject_1;
var FUNC_ERROR_TEXT$2 = "Expected a function";
function throttle$1(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$2);
  }
  if (isObject$4(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce$2(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1$1 = throttle$1;
var patchResizeHandler = function(resizeCallback, refreshMode, refreshRate, refreshOptions) {
  switch (refreshMode) {
    case "debounce":
      return debounce_1$1(resizeCallback, refreshRate, refreshOptions);
    case "throttle":
      return throttle_1$1(resizeCallback, refreshRate, refreshOptions);
    default:
      return resizeCallback;
  }
};
var isFunction = function(fn) {
  return typeof fn === "function";
};
var isSSR = function() {
  return typeof window === "undefined";
};
var isDOMElement = function(element) {
  return element instanceof Element || element instanceof HTMLDocument;
};
var createNotifier = function(onResize, setSize, handleWidth, handleHeight) {
  return function(_a) {
    var width = _a.width, height = _a.height;
    setSize(function(prev) {
      if (prev.width === width && prev.height === height) {
        return prev;
      }
      if (prev.width === width && !handleHeight || prev.height === height && !handleWidth) {
        return prev;
      }
      if (onResize && isFunction(onResize)) {
        onResize(width, height);
      }
      return { width, height };
    });
  };
};
var ResizeDetector = (
  /** @class */
  function(_super) {
    __extends(ResizeDetector2, _super);
    function ResizeDetector2(props) {
      var _this = _super.call(this, props) || this;
      _this.cancelHandler = function() {
        if (_this.resizeHandler && _this.resizeHandler.cancel) {
          _this.resizeHandler.cancel();
          _this.resizeHandler = null;
        }
      };
      _this.attachObserver = function() {
        var _a2 = _this.props, targetRef = _a2.targetRef, observerOptions = _a2.observerOptions;
        if (isSSR()) {
          return;
        }
        if (targetRef && targetRef.current) {
          _this.targetRef.current = targetRef.current;
        }
        var element = _this.getElement();
        if (!element) {
          return;
        }
        if (_this.observableElement && _this.observableElement === element) {
          return;
        }
        _this.observableElement = element;
        _this.resizeObserver.observe(element, observerOptions);
      };
      _this.getElement = function() {
        var _a2 = _this.props, querySelector = _a2.querySelector, targetDomEl = _a2.targetDomEl;
        if (isSSR())
          return null;
        if (querySelector)
          return document.querySelector(querySelector);
        if (targetDomEl && isDOMElement(targetDomEl))
          return targetDomEl;
        if (_this.targetRef && isDOMElement(_this.targetRef.current))
          return _this.targetRef.current;
        var currentElement = reactDomExports.findDOMNode(_this);
        if (!currentElement)
          return null;
        var renderType = _this.getRenderType();
        switch (renderType) {
          case "renderProp":
            return currentElement;
          case "childFunction":
            return currentElement;
          case "child":
            return currentElement;
          case "childArray":
            return currentElement;
          default:
            return currentElement.parentElement;
        }
      };
      _this.createResizeHandler = function(entries) {
        var _a2 = _this.props, _b = _a2.handleWidth, handleWidth = _b === void 0 ? true : _b, _c = _a2.handleHeight, handleHeight = _c === void 0 ? true : _c, onResize = _a2.onResize;
        if (!handleWidth && !handleHeight)
          return;
        var notifyResize = createNotifier(onResize, _this.setState.bind(_this), handleWidth, handleHeight);
        entries.forEach(function(entry) {
          var _a3 = entry && entry.contentRect || {}, width = _a3.width, height = _a3.height;
          var shouldSetSize = !_this.skipOnMount && !isSSR();
          if (shouldSetSize) {
            notifyResize({ width, height });
          }
          _this.skipOnMount = false;
        });
      };
      _this.getRenderType = function() {
        var _a2 = _this.props, render = _a2.render, children = _a2.children;
        if (isFunction(render)) {
          return "renderProp";
        }
        if (isFunction(children)) {
          return "childFunction";
        }
        if (reactExports.isValidElement(children)) {
          return "child";
        }
        if (Array.isArray(children)) {
          return "childArray";
        }
        return "parent";
      };
      var skipOnMount = props.skipOnMount, refreshMode = props.refreshMode, _a = props.refreshRate, refreshRate = _a === void 0 ? 1e3 : _a, refreshOptions = props.refreshOptions;
      _this.state = {
        width: void 0,
        height: void 0
      };
      _this.skipOnMount = skipOnMount;
      _this.targetRef = reactExports.createRef();
      _this.observableElement = null;
      if (isSSR()) {
        return _this;
      }
      _this.resizeHandler = patchResizeHandler(_this.createResizeHandler, refreshMode, refreshRate, refreshOptions);
      _this.resizeObserver = new window.ResizeObserver(_this.resizeHandler);
      return _this;
    }
    ResizeDetector2.prototype.componentDidMount = function() {
      this.attachObserver();
    };
    ResizeDetector2.prototype.componentDidUpdate = function() {
      this.attachObserver();
    };
    ResizeDetector2.prototype.componentWillUnmount = function() {
      if (isSSR()) {
        return;
      }
      this.observableElement = null;
      this.resizeObserver.disconnect();
      this.cancelHandler();
    };
    ResizeDetector2.prototype.render = function() {
      var _a = this.props, render = _a.render, children = _a.children, _b = _a.nodeType, WrapperTag = _b === void 0 ? "div" : _b;
      var _c = this.state, width = _c.width, height = _c.height;
      var childProps = { width, height, targetRef: this.targetRef };
      var renderType = this.getRenderType();
      var typedChildren;
      switch (renderType) {
        case "renderProp":
          return render && render(childProps);
        case "childFunction":
          typedChildren = children;
          return typedChildren(childProps);
        case "child":
          typedChildren = children;
          if (typedChildren.type && typeof typedChildren.type === "string") {
            childProps.targetRef;
            var nativeProps = __rest(childProps, ["targetRef"]);
            return reactExports.cloneElement(typedChildren, nativeProps);
          }
          return reactExports.cloneElement(typedChildren, childProps);
        case "childArray":
          typedChildren = children;
          return typedChildren.map(function(el) {
            return !!el && reactExports.cloneElement(el, childProps);
          });
        default:
          return reactExports.createElement(WrapperTag, null);
      }
    };
    return ResizeDetector2;
  }(reactExports.PureComponent)
);
var warn = function warn2(condition, format2) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }
};
function _extends$k() {
  _extends$k = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$k.apply(this, arguments);
}
function _slicedToArray$5(arr, i) {
  return _arrayWithHoles$5(arr) || _iterableToArrayLimit$5(arr, i) || _unsupportedIterableToArray$c(arr, i) || _nonIterableRest$5();
}
function _nonIterableRest$5() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$c(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$c(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$c(o, minLen);
}
function _arrayLikeToArray$c(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$5(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$5(arr) {
  if (Array.isArray(arr))
    return arr;
}
var ResponsiveContainer = /* @__PURE__ */ reactExports.forwardRef(function(_ref, ref) {
  var aspect = _ref.aspect, _ref$width = _ref.width, width = _ref$width === void 0 ? "100%" : _ref$width, _ref$height = _ref.height, height = _ref$height === void 0 ? "100%" : _ref$height, minWidth = _ref.minWidth, minHeight = _ref.minHeight, maxHeight = _ref.maxHeight, children = _ref.children, _ref$debounce = _ref.debounce, debounce2 = _ref$debounce === void 0 ? 0 : _ref$debounce, id = _ref.id, className = _ref.className;
  var _useState = reactExports.useState({
    containerWidth: -1,
    containerHeight: -1
  }), _useState2 = _slicedToArray$5(_useState, 2), sizes = _useState2[0], setSizes = _useState2[1];
  var containerRef = reactExports.useRef(null);
  reactExports.useImperativeHandle(ref, function() {
    return containerRef;
  }, [containerRef]);
  var getContainerSize = reactExports.useCallback(function() {
    if (!containerRef.current) {
      return null;
    }
    return {
      containerWidth: containerRef.current.clientWidth,
      containerHeight: containerRef.current.clientHeight
    };
  }, []);
  var updateDimensionsImmediate = reactExports.useCallback(function() {
    var newSize = getContainerSize();
    if (newSize) {
      var containerWidth = newSize.containerWidth, containerHeight = newSize.containerHeight;
      setSizes(function(currentSizes) {
        var oldWidth = currentSizes.containerWidth, oldHeight = currentSizes.containerHeight;
        if (containerWidth !== oldWidth || containerHeight !== oldHeight) {
          return {
            containerWidth,
            containerHeight
          };
        }
        return currentSizes;
      });
    }
  }, [getContainerSize]);
  var chartContent = reactExports.useMemo(function() {
    var containerWidth = sizes.containerWidth, containerHeight = sizes.containerHeight;
    if (containerWidth < 0 || containerHeight < 0) {
      return null;
    }
    warn(isPercent(width) || isPercent(height), "The width(%s) and height(%s) are both fixed numbers,\n       maybe you don't need to use a ResponsiveContainer.", width, height);
    warn(!aspect || aspect > 0, "The aspect(%s) must be greater than zero.", aspect);
    var calculatedWidth = isPercent(width) ? containerWidth : width;
    var calculatedHeight = isPercent(height) ? containerHeight : height;
    if (aspect && aspect > 0) {
      if (calculatedWidth) {
        calculatedHeight = calculatedWidth / aspect;
      } else if (calculatedHeight) {
        calculatedWidth = calculatedHeight * aspect;
      }
      if (maxHeight && calculatedHeight > maxHeight) {
        calculatedHeight = maxHeight;
      }
    }
    warn(calculatedWidth > 0 || calculatedHeight > 0, "The width(%s) and height(%s) of chart should be greater than 0,\n       please check the style of container, or the props width(%s) and height(%s),\n       or add a minWidth(%s) or minHeight(%s) or use aspect(%s) to control the\n       height and width.", calculatedWidth, calculatedHeight, width, height, minWidth, minHeight, aspect);
    return /* @__PURE__ */ reactExports.cloneElement(children, {
      width: calculatedWidth,
      height: calculatedHeight
    });
  }, [aspect, children, height, maxHeight, minHeight, minWidth, sizes, width]);
  reactExports.useEffect(function() {
    var size = getContainerSize();
    if (size) {
      setSizes(size);
    }
  }, [getContainerSize]);
  var style = {
    width,
    height,
    minWidth,
    minHeight,
    maxHeight
  };
  return /* @__PURE__ */ React.createElement(ResizeDetector, {
    handleWidth: true,
    handleHeight: true,
    onResize: updateDimensionsImmediate,
    targetRef: containerRef,
    refreshMode: debounce2 > 0 ? "debounce" : void 0,
    refreshRate: debounce2
  }, /* @__PURE__ */ React.createElement("div", _extends$k({}, id != null ? {
    id: "".concat(id)
  } : {}, {
    className: classNames("recharts-responsive-container", className),
    style,
    ref: containerRef
  }), chartContent));
});
var Cell = function Cell2(_props) {
  return null;
};
Cell.displayName = "Cell";
var dist = { exports: {} };
var openParentheses = "(".charCodeAt(0);
var closeParentheses = ")".charCodeAt(0);
var singleQuote = "'".charCodeAt(0);
var doubleQuote = '"'.charCodeAt(0);
var backslash = "\\".charCodeAt(0);
var slash = "/".charCodeAt(0);
var comma = ",".charCodeAt(0);
var colon = ":".charCodeAt(0);
var star = "*".charCodeAt(0);
var parse$1 = function(input2) {
  var tokens = [];
  var value = input2;
  var next, quote, prev, token, escape, escapePos, whitespacePos;
  var pos = 0;
  var code = value.charCodeAt(pos);
  var max2 = value.length;
  var stack = [{ nodes: tokens }];
  var balanced = 0;
  var parent;
  var name = "";
  var before = "";
  var after = "";
  while (pos < max2) {
    if (code <= 32) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = value.slice(pos, next);
      prev = tokens[tokens.length - 1];
      if (code === closeParentheses && balanced) {
        after = token;
      } else if (prev && prev.type === "div") {
        prev.after = token;
      } else if (code === comma || code === colon || code === slash && value.charCodeAt(next + 1) !== star) {
        before = token;
      } else {
        tokens.push({
          type: "space",
          sourceIndex: pos,
          value: token
        });
      }
      pos = next;
    } else if (code === singleQuote || code === doubleQuote) {
      next = pos;
      quote = code === singleQuote ? "'" : '"';
      token = {
        type: "string",
        sourceIndex: pos,
        quote
      };
      do {
        escape = false;
        next = value.indexOf(quote, next + 1);
        if (~next) {
          escapePos = next;
          while (value.charCodeAt(escapePos - 1) === backslash) {
            escapePos -= 1;
            escape = !escape;
          }
        } else {
          value += quote;
          next = value.length - 1;
          token.unclosed = true;
        }
      } while (escape);
      token.value = value.slice(pos + 1, next);
      tokens.push(token);
      pos = next + 1;
      code = value.charCodeAt(pos);
    } else if (code === slash && value.charCodeAt(pos + 1) === star) {
      token = {
        type: "comment",
        sourceIndex: pos
      };
      next = value.indexOf("*/", pos);
      if (next === -1) {
        token.unclosed = true;
        next = value.length;
      }
      token.value = value.slice(pos + 2, next);
      tokens.push(token);
      pos = next + 2;
      code = value.charCodeAt(pos);
    } else if (code === slash || code === comma || code === colon) {
      token = value[pos];
      tokens.push({
        type: "div",
        sourceIndex: pos - before.length,
        value: token,
        before,
        after: ""
      });
      before = "";
      pos += 1;
      code = value.charCodeAt(pos);
    } else if (openParentheses === code) {
      next = pos;
      do {
        next += 1;
        code = value.charCodeAt(next);
      } while (code <= 32);
      token = {
        type: "function",
        sourceIndex: pos - name.length,
        value: name,
        before: value.slice(pos + 1, next)
      };
      pos = next;
      if (name === "url" && code !== singleQuote && code !== doubleQuote) {
        next -= 1;
        do {
          escape = false;
          next = value.indexOf(")", next + 1);
          if (~next) {
            escapePos = next;
            while (value.charCodeAt(escapePos - 1) === backslash) {
              escapePos -= 1;
              escape = !escape;
            }
          } else {
            value += ")";
            next = value.length - 1;
            token.unclosed = true;
          }
        } while (escape);
        whitespacePos = next;
        do {
          whitespacePos -= 1;
          code = value.charCodeAt(whitespacePos);
        } while (code <= 32);
        if (pos !== whitespacePos + 1) {
          token.nodes = [
            {
              type: "word",
              sourceIndex: pos,
              value: value.slice(pos, whitespacePos + 1)
            }
          ];
        } else {
          token.nodes = [];
        }
        if (token.unclosed && whitespacePos + 1 !== next) {
          token.after = "";
          token.nodes.push({
            type: "space",
            sourceIndex: whitespacePos + 1,
            value: value.slice(whitespacePos + 1, next)
          });
        } else {
          token.after = value.slice(whitespacePos + 1, next);
        }
        pos = next + 1;
        code = value.charCodeAt(pos);
        tokens.push(token);
      } else {
        balanced += 1;
        token.after = "";
        tokens.push(token);
        stack.push(token);
        tokens = token.nodes = [];
        parent = token;
      }
      name = "";
    } else if (closeParentheses === code && balanced) {
      pos += 1;
      code = value.charCodeAt(pos);
      parent.after = after;
      after = "";
      balanced -= 1;
      stack.pop();
      parent = stack[balanced];
      tokens = parent.nodes;
    } else {
      next = pos;
      do {
        if (code === backslash) {
          next += 1;
        }
        next += 1;
        code = value.charCodeAt(next);
      } while (next < max2 && !(code <= 32 || code === singleQuote || code === doubleQuote || code === comma || code === colon || code === slash || code === openParentheses || code === closeParentheses && balanced));
      token = value.slice(pos, next);
      if (openParentheses === code) {
        name = token;
      } else {
        tokens.push({
          type: "word",
          sourceIndex: pos,
          value: token
        });
      }
      pos = next;
    }
  }
  for (pos = stack.length - 1; pos; pos -= 1) {
    stack[pos].unclosed = true;
  }
  return stack[0].nodes;
};
var walk$1 = function walk(nodes, cb, bubble) {
  var i, max2, node, result;
  for (i = 0, max2 = nodes.length; i < max2; i += 1) {
    node = nodes[i];
    if (!bubble) {
      result = cb(node, i, nodes);
    }
    if (result !== false && node.type === "function" && Array.isArray(node.nodes)) {
      walk(node.nodes, cb, bubble);
    }
    if (bubble) {
      cb(node, i, nodes);
    }
  }
};
function stringifyNode(node, custom) {
  var type = node.type;
  var value = node.value;
  var buf;
  var customResult;
  if (custom && (customResult = custom(node)) !== void 0) {
    return customResult;
  } else if (type === "word" || type === "space") {
    return value;
  } else if (type === "string") {
    buf = node.quote || "";
    return buf + value + (node.unclosed ? "" : buf);
  } else if (type === "comment") {
    return "/*" + value + (node.unclosed ? "" : "*/");
  } else if (type === "div") {
    return (node.before || "") + value + (node.after || "");
  } else if (Array.isArray(node.nodes)) {
    buf = stringify$1(node.nodes);
    if (type !== "function") {
      return buf;
    }
    return value + "(" + (node.before || "") + buf + (node.after || "") + (node.unclosed ? "" : ")");
  }
  return value;
}
function stringify$1(nodes, custom) {
  var result, i;
  if (Array.isArray(nodes)) {
    result = "";
    for (i = nodes.length - 1; ~i; i -= 1) {
      result = stringifyNode(nodes[i], custom) + result;
    }
    return result;
  }
  return stringifyNode(nodes, custom);
}
var stringify_1 = stringify$1;
var unit$1;
var hasRequiredUnit;
function requireUnit() {
  if (hasRequiredUnit)
    return unit$1;
  hasRequiredUnit = 1;
  var minus = "-".charCodeAt(0);
  var plus = "+".charCodeAt(0);
  var dot = ".".charCodeAt(0);
  var exp2 = "e".charCodeAt(0);
  var EXP = "E".charCodeAt(0);
  unit$1 = function(value) {
    var pos = 0;
    var length = value.length;
    var dotted = false;
    var sciPos = -1;
    var containsNumber = false;
    var code;
    while (pos < length) {
      code = value.charCodeAt(pos);
      if (code >= 48 && code <= 57) {
        containsNumber = true;
      } else if (code === exp2 || code === EXP) {
        if (sciPos > -1) {
          break;
        }
        sciPos = pos;
      } else if (code === dot) {
        if (dotted) {
          break;
        }
        dotted = true;
      } else if (code === plus || code === minus) {
        if (pos !== 0) {
          break;
        }
      } else {
        break;
      }
      pos += 1;
    }
    if (sciPos + 1 === pos)
      pos--;
    return containsNumber ? {
      number: value.slice(0, pos),
      unit: value.slice(pos)
    } : false;
  };
  return unit$1;
}
var parse = parse$1;
var walk2 = walk$1;
var stringify = stringify_1;
function ValueParser(value) {
  if (this instanceof ValueParser) {
    this.nodes = parse(value);
    return this;
  }
  return new ValueParser(value);
}
ValueParser.prototype.toString = function() {
  return Array.isArray(this.nodes) ? stringify(this.nodes) : "";
};
ValueParser.prototype.walk = function(cb, bubble) {
  walk2(this.nodes, cb, bubble);
  return this;
};
ValueParser.unit = requireUnit();
ValueParser.walk = walk2;
ValueParser.stringify = stringify;
var lib = ValueParser;
var parser = {};
(function(exports) {
  var parser2 = function() {
    function JisonParserError(msg, hash) {
      Object.defineProperty(this, "name", {
        enumerable: false,
        writable: false,
        value: "JisonParserError"
      });
      if (msg == null)
        msg = "???";
      Object.defineProperty(this, "message", {
        enumerable: false,
        writable: true,
        value: msg
      });
      this.hash = hash;
      var stacktrace;
      if (hash && hash.exception instanceof Error) {
        var ex2 = hash.exception;
        this.message = ex2.message || msg;
        stacktrace = ex2.stack;
      }
      if (!stacktrace) {
        if (Error.hasOwnProperty("captureStackTrace")) {
          Error.captureStackTrace(this, this.constructor);
        } else {
          stacktrace = new Error(msg).stack;
        }
      }
      if (stacktrace) {
        Object.defineProperty(this, "stack", {
          enumerable: false,
          writable: false,
          value: stacktrace
        });
      }
    }
    if (typeof Object.setPrototypeOf === "function") {
      Object.setPrototypeOf(JisonParserError.prototype, Error.prototype);
    } else {
      JisonParserError.prototype = Object.create(Error.prototype);
    }
    JisonParserError.prototype.constructor = JisonParserError;
    JisonParserError.prototype.name = "JisonParserError";
    function bp(s3) {
      var rv = [];
      var p2 = s3.pop;
      var r2 = s3.rule;
      for (var i = 0, l2 = p2.length; i < l2; i++) {
        rv.push([
          p2[i],
          r2[i]
        ]);
      }
      return rv;
    }
    function bda(s3) {
      var rv = {};
      var d2 = s3.idx;
      var g2 = s3.goto;
      for (var i = 0, l2 = d2.length; i < l2; i++) {
        var j = d2[i];
        rv[j] = g2[i];
      }
      return rv;
    }
    function bt(s3) {
      var rv = [];
      var d2 = s3.len;
      var y2 = s3.symbol;
      var t2 = s3.type;
      var a2 = s3.state;
      var m2 = s3.mode;
      var g2 = s3.goto;
      for (var i = 0, l2 = d2.length; i < l2; i++) {
        var n2 = d2[i];
        var q2 = {};
        for (var j = 0; j < n2; j++) {
          var z2 = y2.shift();
          switch (t2.shift()) {
            case 2:
              q2[z2] = [
                m2.shift(),
                g2.shift()
              ];
              break;
            case 0:
              q2[z2] = a2.shift();
              break;
            default:
              q2[z2] = [
                3
              ];
          }
        }
        rv.push(q2);
      }
      return rv;
    }
    function s2(c3, l2, a2) {
      a2 = a2 || 0;
      for (var i = 0; i < l2; i++) {
        this.push(c3);
        c3 += a2;
      }
    }
    function c2(i, l2) {
      i = this.length - i;
      for (l2 += i; i < l2; i++) {
        this.push(this[i]);
      }
    }
    function u(a2) {
      var rv = [];
      for (var i = 0, l2 = a2.length; i < l2; i++) {
        var e3 = a2[i];
        if (typeof e3 === "function") {
          i++;
          e3.apply(rv, a2[i]);
        } else {
          rv.push(e3);
        }
      }
      return rv;
    }
    var parser3 = {
      // Code Generator Information Report
      // ---------------------------------
      //
      // Options:
      //
      //   default action mode: ............. ["classic","merge"]
      //   test-compile action mode: ........ "parser:*,lexer:*"
      //   try..catch: ...................... true
      //   default resolve on conflict: ..... true
      //   on-demand look-ahead: ............ false
      //   error recovery token skip maximum: 3
      //   yyerror in parse actions is: ..... NOT recoverable,
      //   yyerror in lexer actions and other non-fatal lexer are:
      //   .................................. NOT recoverable,
      //   debug grammar/output: ............ false
      //   has partial LR conflict upgrade:   true
      //   rudimentary token-stack support:   false
      //   parser table compression mode: ... 2
      //   export debug tables: ............. false
      //   export *all* tables: ............. false
      //   module type: ..................... commonjs
      //   parser engine type: .............. lalr
      //   output main() in the module: ..... true
      //   has user-specified main(): ....... false
      //   has user-specified require()/import modules for main():
      //   .................................. false
      //   number of expected conflicts: .... 0
      //
      //
      // Parser Analysis flags:
      //
      //   no significant actions (parser is a language matcher only):
      //   .................................. false
      //   uses yyleng: ..................... false
      //   uses yylineno: ................... false
      //   uses yytext: ..................... false
      //   uses yylloc: ..................... false
      //   uses ParseError API: ............. false
      //   uses YYERROR: .................... false
      //   uses YYRECOVERING: ............... false
      //   uses YYERROK: .................... false
      //   uses YYCLEARIN: .................. false
      //   tracks rule values: .............. true
      //   assigns rule values: ............. true
      //   uses location tracking: .......... false
      //   assigns location: ................ false
      //   uses yystack: .................... false
      //   uses yysstack: ................... false
      //   uses yysp: ....................... true
      //   uses yyrulelength: ............... false
      //   uses yyMergeLocationInfo API: .... false
      //   has error recovery: .............. false
      //   has error reporting: ............. false
      //
      // --------- END OF REPORT -----------
      trace: function no_op_trace() {
      },
      JisonParserError,
      yy: {},
      options: {
        type: "lalr",
        hasPartialLrUpgradeOnConflict: true,
        errorRecoveryTokenDiscardCount: 3
      },
      symbols_: {
        "$accept": 0,
        "$end": 1,
        "ADD": 3,
        "ANGLE": 16,
        "CHS": 22,
        "COMMA": 14,
        "CSS_CPROP": 13,
        "CSS_VAR": 12,
        "DIV": 6,
        "EMS": 20,
        "EOF": 1,
        "EXS": 21,
        "FREQ": 18,
        "LENGTH": 15,
        "LPAREN": 7,
        "MUL": 5,
        "NESTED_CALC": 9,
        "NUMBER": 11,
        "PERCENTAGE": 28,
        "PREFIX": 10,
        "REMS": 23,
        "RES": 19,
        "RPAREN": 8,
        "SUB": 4,
        "TIME": 17,
        "VHS": 24,
        "VMAXS": 27,
        "VMINS": 26,
        "VWS": 25,
        "css_value": 33,
        "css_variable": 32,
        "error": 2,
        "expression": 29,
        "math_expression": 30,
        "value": 31
      },
      terminals_: {
        1: "EOF",
        2: "error",
        3: "ADD",
        4: "SUB",
        5: "MUL",
        6: "DIV",
        7: "LPAREN",
        8: "RPAREN",
        9: "NESTED_CALC",
        10: "PREFIX",
        11: "NUMBER",
        12: "CSS_VAR",
        13: "CSS_CPROP",
        14: "COMMA",
        15: "LENGTH",
        16: "ANGLE",
        17: "TIME",
        18: "FREQ",
        19: "RES",
        20: "EMS",
        21: "EXS",
        22: "CHS",
        23: "REMS",
        24: "VHS",
        25: "VWS",
        26: "VMINS",
        27: "VMAXS",
        28: "PERCENTAGE"
      },
      TERROR: 2,
      EOF: 1,
      // internals: defined here so the object *structure* doesn't get modified by parse() et al,
      // thus helping JIT compilers like Chrome V8.
      originalQuoteName: null,
      originalParseError: null,
      cleanupAfterParse: null,
      constructParseErrorInfo: null,
      yyMergeLocationInfo: null,
      __reentrant_call_depth: 0,
      // INTERNAL USE ONLY
      __error_infos: [],
      // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
      __error_recovery_infos: [],
      // INTERNAL USE ONLY: the set of parseErrorInfo objects created since the last cleanup
      // APIs which will be set up depending on user action code analysis:
      //yyRecovering: 0,
      //yyErrOk: 0,
      //yyClearIn: 0,
      // Helper APIs
      // -----------
      // Helper function which can be overridden by user code later on: put suitable quotes around
      // literal IDs in a description string.
      quoteName: function parser_quoteName(id_str) {
        return '"' + id_str + '"';
      },
      // Return the name of the given symbol (terminal or non-terminal) as a string, when available.
      //
      // Return NULL when the symbol is unknown to the parser.
      getSymbolName: function parser_getSymbolName(symbol) {
        if (this.terminals_[symbol]) {
          return this.terminals_[symbol];
        }
        var s3 = this.symbols_;
        for (var key in s3) {
          if (s3[key] === symbol) {
            return key;
          }
        }
        return null;
      },
      // Return a more-or-less human-readable description of the given symbol, when available,
      // or the symbol itself, serving as its own 'description' for lack of something better to serve up.
      //
      // Return NULL when the symbol is unknown to the parser.
      describeSymbol: function parser_describeSymbol(symbol) {
        if (symbol !== this.EOF && this.terminal_descriptions_ && this.terminal_descriptions_[symbol]) {
          return this.terminal_descriptions_[symbol];
        } else if (symbol === this.EOF) {
          return "end of input";
        }
        var id = this.getSymbolName(symbol);
        if (id) {
          return this.quoteName(id);
        }
        return null;
      },
      // Produce a (more or less) human-readable list of expected tokens at the point of failure.
      //
      // The produced list may contain token or token set descriptions instead of the tokens
      // themselves to help turning this output into something that easier to read by humans
      // unless `do_not_describe` parameter is set, in which case a list of the raw, *numeric*,
      // expected terminals and nonterminals is produced.
      //
      // The returned list (array) will not contain any duplicate entries.
      collect_expected_token_set: function parser_collect_expected_token_set(state, do_not_describe) {
        var TERROR = this.TERROR;
        var tokenset = [];
        var check = {};
        if (!do_not_describe && this.state_descriptions_ && this.state_descriptions_[state]) {
          return [
            this.state_descriptions_[state]
          ];
        }
        for (var p2 in this.table[state]) {
          p2 = +p2;
          if (p2 !== TERROR) {
            var d2 = do_not_describe ? p2 : this.describeSymbol(p2);
            if (d2 && !check[d2]) {
              tokenset.push(d2);
              check[d2] = true;
            }
          }
        }
        return tokenset;
      },
      productions_: bp({
        pop: u([
          29,
          s2,
          [30, 10],
          31,
          31,
          32,
          32,
          s2,
          [33, 15]
        ]),
        rule: u([
          2,
          s2,
          [3, 5],
          4,
          7,
          s2,
          [1, 4],
          2,
          4,
          6,
          s2,
          [1, 14],
          2
        ])
      }),
      performAction: function parser__PerformAction(yystate, yysp, yyvstack) {
        var yy = this.yy;
        yy.parser;
        yy.lexer;
        switch (yystate) {
          case 0:
            this.$ = yyvstack[yysp - 1];
            break;
          case 1:
            this.$ = yyvstack[yysp - 1];
            return yyvstack[yysp - 1];
          case 2:
          case 3:
          case 4:
          case 5:
            this.$ = { type: "MathExpression", operator: yyvstack[yysp - 1], left: yyvstack[yysp - 2], right: yyvstack[yysp] };
            break;
          case 6:
            this.$ = yyvstack[yysp - 1];
            break;
          case 7:
            this.$ = { type: "Calc", value: yyvstack[yysp - 1] };
            break;
          case 8:
            this.$ = { type: "Calc", value: yyvstack[yysp - 1], prefix: yyvstack[yysp - 5] };
            break;
          case 9:
          case 10:
          case 11:
            this.$ = yyvstack[yysp];
            break;
          case 12:
            this.$ = { type: "Value", value: parseFloat(yyvstack[yysp]) };
            break;
          case 13:
            this.$ = { type: "Value", value: parseFloat(yyvstack[yysp]) * -1 };
            break;
          case 14:
            this.$ = { type: "CssVariable", value: yyvstack[yysp - 1] };
            break;
          case 15:
            this.$ = { type: "CssVariable", value: yyvstack[yysp - 3], fallback: yyvstack[yysp - 1] };
            break;
          case 16:
            this.$ = { type: "LengthValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 17:
            this.$ = { type: "AngleValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 18:
            this.$ = { type: "TimeValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 19:
            this.$ = { type: "FrequencyValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 20:
            this.$ = { type: "ResolutionValue", value: parseFloat(yyvstack[yysp]), unit: /[a-z]+/.exec(yyvstack[yysp])[0] };
            break;
          case 21:
            this.$ = { type: "EmValue", value: parseFloat(yyvstack[yysp]), unit: "em" };
            break;
          case 22:
            this.$ = { type: "ExValue", value: parseFloat(yyvstack[yysp]), unit: "ex" };
            break;
          case 23:
            this.$ = { type: "ChValue", value: parseFloat(yyvstack[yysp]), unit: "ch" };
            break;
          case 24:
            this.$ = { type: "RemValue", value: parseFloat(yyvstack[yysp]), unit: "rem" };
            break;
          case 25:
            this.$ = { type: "VhValue", value: parseFloat(yyvstack[yysp]), unit: "vh" };
            break;
          case 26:
            this.$ = { type: "VwValue", value: parseFloat(yyvstack[yysp]), unit: "vw" };
            break;
          case 27:
            this.$ = { type: "VminValue", value: parseFloat(yyvstack[yysp]), unit: "vmin" };
            break;
          case 28:
            this.$ = { type: "VmaxValue", value: parseFloat(yyvstack[yysp]), unit: "vmax" };
            break;
          case 29:
            this.$ = { type: "PercentageValue", value: parseFloat(yyvstack[yysp]), unit: "%" };
            break;
          case 30:
            var prev = yyvstack[yysp];
            prev.value *= -1;
            this.$ = prev;
            break;
        }
      },
      table: bt({
        len: u([
          24,
          1,
          5,
          23,
          1,
          18,
          s2,
          [0, 3],
          1,
          s2,
          [0, 16],
          s2,
          [23, 4],
          c2,
          [28, 3],
          0,
          0,
          16,
          1,
          6,
          6,
          s2,
          [0, 3],
          5,
          1,
          2,
          c2,
          [37, 3],
          c2,
          [20, 3],
          5,
          0,
          0
        ]),
        symbol: u([
          4,
          7,
          9,
          11,
          12,
          s2,
          [15, 19, 1],
          1,
          1,
          s2,
          [3, 4, 1],
          c2,
          [30, 19],
          c2,
          [29, 4],
          7,
          4,
          10,
          11,
          c2,
          [22, 14],
          c2,
          [19, 3],
          c2,
          [43, 22],
          c2,
          [23, 69],
          c2,
          [139, 4],
          8,
          c2,
          [51, 24],
          4,
          c2,
          [138, 15],
          13,
          c2,
          [186, 5],
          8,
          c2,
          [6, 6],
          c2,
          [5, 5],
          9,
          8,
          14,
          c2,
          [159, 47],
          c2,
          [60, 10]
        ]),
        type: u([
          s2,
          [2, 19],
          s2,
          [0, 5],
          1,
          s2,
          [2, 24],
          s2,
          [0, 4],
          c2,
          [22, 19],
          c2,
          [43, 42],
          c2,
          [23, 70],
          c2,
          [28, 25],
          c2,
          [45, 25],
          c2,
          [113, 54]
        ]),
        state: u([
          1,
          2,
          8,
          6,
          7,
          30,
          c2,
          [4, 3],
          33,
          37,
          c2,
          [5, 3],
          38,
          c2,
          [4, 3],
          39,
          c2,
          [4, 3],
          40,
          c2,
          [4, 3],
          42,
          c2,
          [21, 4],
          50,
          c2,
          [5, 3],
          51,
          c2,
          [4, 3]
        ]),
        mode: u([
          s2,
          [1, 179],
          s2,
          [2, 3],
          c2,
          [5, 5],
          c2,
          [6, 4],
          s2,
          [1, 57]
        ]),
        goto: u([
          5,
          3,
          4,
          24,
          s2,
          [9, 15, 1],
          s2,
          [25, 5, 1],
          c2,
          [24, 19],
          31,
          35,
          32,
          34,
          c2,
          [18, 14],
          36,
          c2,
          [38, 19],
          c2,
          [19, 57],
          c2,
          [118, 4],
          41,
          c2,
          [24, 19],
          43,
          35,
          c2,
          [16, 14],
          44,
          s2,
          [2, 3],
          28,
          29,
          2,
          s2,
          [3, 3],
          28,
          29,
          3,
          c2,
          [53, 4],
          s2,
          [45, 5, 1],
          c2,
          [100, 42],
          52,
          c2,
          [5, 4],
          53
        ])
      }),
      defaultActions: bda({
        idx: u([
          6,
          7,
          8,
          s2,
          [10, 16, 1],
          33,
          34,
          39,
          40,
          41,
          45,
          47,
          52,
          53
        ]),
        goto: u([
          9,
          10,
          11,
          s2,
          [16, 14, 1],
          12,
          1,
          30,
          13,
          s2,
          [4, 4, 1],
          14,
          15,
          8
        ])
      }),
      parseError: function parseError(str, hash, ExceptionClass) {
        if (hash.recoverable) {
          if (typeof this.trace === "function") {
            this.trace(str);
          }
          hash.destroy();
        } else {
          if (typeof this.trace === "function") {
            this.trace(str);
          }
          if (!ExceptionClass) {
            ExceptionClass = this.JisonParserError;
          }
          throw new ExceptionClass(str, hash);
        }
      },
      parse: function parse2(input2) {
        var self2 = this;
        var stack = new Array(128);
        var sstack = new Array(128);
        var vstack = new Array(128);
        var table = this.table;
        var sp = 0;
        var symbol = 0;
        this.TERROR;
        var EOF = this.EOF;
        this.options.errorRecoveryTokenDiscardCount | 0 || 3;
        var NO_ACTION = [
          0,
          54
          /* === table.length :: ensures that anyone using this new state will fail dramatically! */
        ];
        var lexer2;
        if (this.__lexer__) {
          lexer2 = this.__lexer__;
        } else {
          lexer2 = this.__lexer__ = Object.create(this.lexer);
        }
        var sharedState_yy = {
          parseError: void 0,
          quoteName: void 0,
          lexer: void 0,
          parser: void 0,
          pre_parse: void 0,
          post_parse: void 0,
          pre_lex: void 0,
          post_lex: void 0
          // WARNING: must be written this way for the code expanders to work correctly in both ES5 and ES6 modes!
        };
        if (typeof assert !== "function")
          ;
        else {
          assert;
        }
        this.yyGetSharedState = function yyGetSharedState() {
          return sharedState_yy;
        };
        function shallow_copy_noclobber(dst, src) {
          for (var k2 in src) {
            if (typeof dst[k2] === "undefined" && Object.prototype.hasOwnProperty.call(src, k2)) {
              dst[k2] = src[k2];
            }
          }
        }
        shallow_copy_noclobber(sharedState_yy, this.yy);
        sharedState_yy.lexer = lexer2;
        sharedState_yy.parser = this;
        if (typeof sharedState_yy.parseError === "function") {
          this.parseError = function parseErrorAlt(str, hash, ExceptionClass) {
            if (!ExceptionClass) {
              ExceptionClass = this.JisonParserError;
            }
            return sharedState_yy.parseError.call(this, str, hash, ExceptionClass);
          };
        } else {
          this.parseError = this.originalParseError;
        }
        if (typeof sharedState_yy.quoteName === "function") {
          this.quoteName = function quoteNameAlt(id_str) {
            return sharedState_yy.quoteName.call(this, id_str);
          };
        } else {
          this.quoteName = this.originalQuoteName;
        }
        this.cleanupAfterParse = function parser_cleanupAfterParse(resultValue, invoke_post_methods, do_not_nuke_errorinfos) {
          var rv;
          if (invoke_post_methods) {
            var hash;
            if (sharedState_yy.post_parse || this.post_parse) {
              hash = this.constructParseErrorInfo(null, null, null, false);
            }
            if (sharedState_yy.post_parse) {
              rv = sharedState_yy.post_parse.call(this, sharedState_yy, resultValue, hash);
              if (typeof rv !== "undefined")
                resultValue = rv;
            }
            if (this.post_parse) {
              rv = this.post_parse.call(this, sharedState_yy, resultValue, hash);
              if (typeof rv !== "undefined")
                resultValue = rv;
            }
            if (hash && hash.destroy) {
              hash.destroy();
            }
          }
          if (this.__reentrant_call_depth > 1)
            return resultValue;
          if (lexer2.cleanupAfterLex) {
            lexer2.cleanupAfterLex(do_not_nuke_errorinfos);
          }
          if (sharedState_yy) {
            sharedState_yy.lexer = void 0;
            sharedState_yy.parser = void 0;
            if (lexer2.yy === sharedState_yy) {
              lexer2.yy = void 0;
            }
          }
          sharedState_yy = void 0;
          this.parseError = this.originalParseError;
          this.quoteName = this.originalQuoteName;
          stack.length = 0;
          sstack.length = 0;
          vstack.length = 0;
          sp = 0;
          if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
              var el = this.__error_infos[i];
              if (el && typeof el.destroy === "function") {
                el.destroy();
              }
            }
            this.__error_infos.length = 0;
          }
          return resultValue;
        };
        this.constructParseErrorInfo = function parser_constructParseErrorInfo(msg, ex, expected2, recoverable) {
          var pei = {
            errStr: msg,
            exception: ex,
            text: lexer2.match,
            value: lexer2.yytext,
            token: this.describeSymbol(symbol) || symbol,
            token_id: symbol,
            line: lexer2.yylineno,
            expected: expected2,
            recoverable,
            state,
            action,
            new_state: newState,
            symbol_stack: stack,
            state_stack: sstack,
            value_stack: vstack,
            stack_pointer: sp,
            yy: sharedState_yy,
            lexer: lexer2,
            parser: this,
            // and make sure the error info doesn't stay due to potential
            // ref cycle via userland code manipulations.
            // These would otherwise all be memory leak opportunities!
            //
            // Note that only array and object references are nuked as those
            // constitute the set of elements which can produce a cyclic ref.
            // The rest of the members is kept intact as they are harmless.
            destroy: function destructParseErrorInfo() {
              var rec = !!this.recoverable;
              for (var key in this) {
                if (this.hasOwnProperty(key) && typeof key === "object") {
                  this[key] = void 0;
                }
              }
              this.recoverable = rec;
            }
          };
          this.__error_infos.push(pei);
          return pei;
        };
        function stdLex() {
          var token = lexer2.lex();
          if (typeof token !== "number") {
            token = self2.symbols_[token] || token;
          }
          return token || EOF;
        }
        function fastLex() {
          var token = lexer2.fastLex();
          if (typeof token !== "number") {
            token = self2.symbols_[token] || token;
          }
          return token || EOF;
        }
        var lex = stdLex;
        var state, action, r2, t2;
        var yyval = {
          $: true,
          _$: void 0,
          yy: sharedState_yy
        };
        var p2;
        var yyrulelen;
        var this_production;
        var newState;
        var retval = false;
        try {
          this.__reentrant_call_depth++;
          lexer2.setInput(input2, sharedState_yy);
          if (typeof lexer2.canIUse === "function") {
            var lexerInfo = lexer2.canIUse();
            if (lexerInfo.fastLex && typeof fastLex === "function") {
              lex = fastLex;
            }
          }
          vstack[sp] = null;
          sstack[sp] = 0;
          stack[sp] = 0;
          ++sp;
          if (this.pre_parse) {
            this.pre_parse.call(this, sharedState_yy);
          }
          if (sharedState_yy.pre_parse) {
            sharedState_yy.pre_parse.call(this, sharedState_yy);
          }
          newState = sstack[sp - 1];
          for (; ; ) {
            state = newState;
            if (this.defaultActions[state]) {
              action = 2;
              newState = this.defaultActions[state];
            } else {
              if (!symbol) {
                symbol = lex();
              }
              t2 = table[state] && table[state][symbol] || NO_ACTION;
              newState = t2[1];
              action = t2[0];
              if (!action) {
                var errStr;
                var errSymbolDescr = this.describeSymbol(symbol) || symbol;
                var expected = this.collect_expected_token_set(state);
                if (typeof lexer2.yylineno === "number") {
                  errStr = "Parse error on line " + (lexer2.yylineno + 1) + ": ";
                } else {
                  errStr = "Parse error: ";
                }
                if (typeof lexer2.showPosition === "function") {
                  errStr += "\n" + lexer2.showPosition(79 - 10, 10) + "\n";
                }
                if (expected.length) {
                  errStr += "Expecting " + expected.join(", ") + ", got unexpected " + errSymbolDescr;
                } else {
                  errStr += "Unexpected " + errSymbolDescr;
                }
                p2 = this.constructParseErrorInfo(errStr, null, expected, false);
                r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
                if (typeof r2 !== "undefined") {
                  retval = r2;
                }
                break;
              }
            }
            switch (action) {
              default:
                if (action instanceof Array) {
                  p2 = this.constructParseErrorInfo("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol, null, null, false);
                  r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
                  if (typeof r2 !== "undefined") {
                    retval = r2;
                  }
                  break;
                }
                p2 = this.constructParseErrorInfo("Parsing halted. No viable error recovery approach available due to internal system failure.", null, null, false);
                r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
                if (typeof r2 !== "undefined") {
                  retval = r2;
                }
                break;
              case 1:
                stack[sp] = symbol;
                vstack[sp] = lexer2.yytext;
                sstack[sp] = newState;
                ++sp;
                symbol = 0;
                continue;
              case 2:
                this_production = this.productions_[newState - 1];
                yyrulelen = this_production[1];
                r2 = this.performAction.call(yyval, newState, sp - 1, vstack);
                if (typeof r2 !== "undefined") {
                  retval = r2;
                  break;
                }
                sp -= yyrulelen;
                var ntsymbol = this_production[0];
                stack[sp] = ntsymbol;
                vstack[sp] = yyval.$;
                newState = table[sstack[sp - 1]][ntsymbol];
                sstack[sp] = newState;
                ++sp;
                continue;
              case 3:
                if (sp !== -2) {
                  retval = true;
                  sp--;
                  if (typeof vstack[sp] !== "undefined") {
                    retval = vstack[sp];
                  }
                }
                break;
            }
            break;
          }
        } catch (ex) {
          if (ex instanceof this.JisonParserError) {
            throw ex;
          } else if (lexer2 && typeof lexer2.JisonLexerError === "function" && ex instanceof lexer2.JisonLexerError) {
            throw ex;
          }
          p2 = this.constructParseErrorInfo("Parsing aborted due to exception.", ex, null, false);
          retval = false;
          r2 = this.parseError(p2.errStr, p2, this.JisonParserError);
          if (typeof r2 !== "undefined") {
            retval = r2;
          }
        } finally {
          retval = this.cleanupAfterParse(retval, true, true);
          this.__reentrant_call_depth--;
        }
        return retval;
      }
    };
    parser3.originalParseError = parser3.parseError;
    parser3.originalQuoteName = parser3.quoteName;
    var lexer = function() {
      function JisonLexerError(msg, hash) {
        Object.defineProperty(this, "name", {
          enumerable: false,
          writable: false,
          value: "JisonLexerError"
        });
        if (msg == null)
          msg = "???";
        Object.defineProperty(this, "message", {
          enumerable: false,
          writable: true,
          value: msg
        });
        this.hash = hash;
        var stacktrace;
        if (hash && hash.exception instanceof Error) {
          var ex2 = hash.exception;
          this.message = ex2.message || msg;
          stacktrace = ex2.stack;
        }
        if (!stacktrace) {
          if (Error.hasOwnProperty("captureStackTrace")) {
            Error.captureStackTrace(this, this.constructor);
          } else {
            stacktrace = new Error(msg).stack;
          }
        }
        if (stacktrace) {
          Object.defineProperty(this, "stack", {
            enumerable: false,
            writable: false,
            value: stacktrace
          });
        }
      }
      if (typeof Object.setPrototypeOf === "function") {
        Object.setPrototypeOf(JisonLexerError.prototype, Error.prototype);
      } else {
        JisonLexerError.prototype = Object.create(Error.prototype);
      }
      JisonLexerError.prototype.constructor = JisonLexerError;
      JisonLexerError.prototype.name = "JisonLexerError";
      var lexer2 = {
        // Code Generator Information Report
        // ---------------------------------
        //
        // Options:
        //
        //   backtracking: .................... false
        //   location.ranges: ................. false
        //   location line+column tracking: ... true
        //
        //
        // Forwarded Parser Analysis flags:
        //
        //   uses yyleng: ..................... false
        //   uses yylineno: ................... false
        //   uses yytext: ..................... false
        //   uses yylloc: ..................... false
        //   uses lexer values: ............... true / true
        //   location tracking: ............... false
        //   location assignment: ............. false
        //
        //
        // Lexer Analysis flags:
        //
        //   uses yyleng: ..................... ???
        //   uses yylineno: ................... ???
        //   uses yytext: ..................... ???
        //   uses yylloc: ..................... ???
        //   uses ParseError API: ............. ???
        //   uses yyerror: .................... ???
        //   uses location tracking & editing:  ???
        //   uses more() API: ................. ???
        //   uses unput() API: ................ ???
        //   uses reject() API: ............... ???
        //   uses less() API: ................. ???
        //   uses display APIs pastInput(), upcomingInput(), showPosition():
        //        ............................. ???
        //   uses describeYYLLOC() API: ....... ???
        //
        // --------- END OF REPORT -----------
        EOF: 1,
        ERROR: 2,
        // JisonLexerError: JisonLexerError,        /// <-- injected by the code generator
        // options: {},                             /// <-- injected by the code generator
        // yy: ...,                                 /// <-- injected by setInput()
        __currentRuleSet__: null,
        /// INTERNAL USE ONLY: internal rule set cache for the current lexer state  
        __error_infos: [],
        /// INTERNAL USE ONLY: the set of lexErrorInfo objects created since the last cleanup  
        __decompressed: false,
        /// INTERNAL USE ONLY: mark whether the lexer instance has been 'unfolded' completely and is now ready for use  
        done: false,
        /// INTERNAL USE ONLY  
        _backtrack: false,
        /// INTERNAL USE ONLY  
        _input: "",
        /// INTERNAL USE ONLY  
        _more: false,
        /// INTERNAL USE ONLY  
        _signaled_error_token: false,
        /// INTERNAL USE ONLY  
        conditionStack: [],
        /// INTERNAL USE ONLY; managed via `pushState()`, `popState()`, `topState()` and `stateStackSize()`  
        match: "",
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction. `match` is identical to `yytext` except that this one still contains the matched input string after `lexer.performAction()` has been invoked, where userland code MAY have changed/replaced the `yytext` value entirely!  
        matched: "",
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks entire input which has been matched so far  
        matches: false,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks RE match result for last (successful) match attempt  
        yytext: "",
        /// ADVANCED USE ONLY: tracks input which has been matched so far for the lexer token under construction; this value is transferred to the parser as the 'token value' when the parser consumes the lexer token produced through a call to the `lex()` API.  
        offset: 0,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks the 'cursor position' in the input string, i.e. the number of characters matched so far  
        yyleng: 0,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: length of matched input for the token under construction (`yytext`)  
        yylineno: 0,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: 'line number' at which the token under construction is located  
        yylloc: null,
        /// READ-ONLY EXTERNAL ACCESS - ADVANCED USE ONLY: tracks location info (lines + columns) for the token under construction  
        /**
         * INTERNAL USE: construct a suitable error info hash object instance for `parseError`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        constructLexErrorInfo: function lexer_constructLexErrorInfo(msg, recoverable, show_input_position) {
          msg = "" + msg;
          if (show_input_position == void 0) {
            show_input_position = !(msg.indexOf("\n") > 0 && msg.indexOf("^") > 0);
          }
          if (this.yylloc && show_input_position) {
            if (typeof this.prettyPrintRange === "function") {
              this.prettyPrintRange(this.yylloc);
              if (!/\n\s*$/.test(msg)) {
                msg += "\n";
              }
              msg += "\n  Erroneous area:\n" + this.prettyPrintRange(this.yylloc);
            } else if (typeof this.showPosition === "function") {
              var pos_str = this.showPosition();
              if (pos_str) {
                if (msg.length && msg[msg.length - 1] !== "\n" && pos_str[0] !== "\n") {
                  msg += "\n" + pos_str;
                } else {
                  msg += pos_str;
                }
              }
            }
          }
          var pei = {
            errStr: msg,
            recoverable: !!recoverable,
            text: this.match,
            // This one MAY be empty; userland code should use the `upcomingInput` API to obtain more text which follows the 'lexer cursor position'...  
            token: null,
            line: this.yylineno,
            loc: this.yylloc,
            yy: this.yy,
            lexer: this,
            /**
             * and make sure the error info doesn't stay due to potential
             * ref cycle via userland code manipulations.
             * These would otherwise all be memory leak opportunities!
             * 
             * Note that only array and object references are nuked as those
             * constitute the set of elements which can produce a cyclic ref.
             * The rest of the members is kept intact as they are harmless.
             * 
             * @public
             * @this {LexErrorInfo}
             */
            destroy: function destructLexErrorInfo() {
              var rec = !!this.recoverable;
              for (var key in this) {
                if (this.hasOwnProperty(key) && typeof key === "object") {
                  this[key] = void 0;
                }
              }
              this.recoverable = rec;
            }
          };
          this.__error_infos.push(pei);
          return pei;
        },
        /**
         * handler which is invoked when a lexer error occurs.
         * 
         * @public
         * @this {RegExpLexer}
         */
        parseError: function lexer_parseError(str, hash, ExceptionClass) {
          if (!ExceptionClass) {
            ExceptionClass = this.JisonLexerError;
          }
          if (this.yy) {
            if (this.yy.parser && typeof this.yy.parser.parseError === "function") {
              return this.yy.parser.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
            } else if (typeof this.yy.parseError === "function") {
              return this.yy.parseError.call(this, str, hash, ExceptionClass) || this.ERROR;
            }
          }
          throw new ExceptionClass(str, hash);
        },
        /**
         * method which implements `yyerror(str, ...args)` functionality for use inside lexer actions.
         * 
         * @public
         * @this {RegExpLexer}
         */
        yyerror: function yyError(str) {
          var lineno_msg = "";
          if (this.yylloc) {
            lineno_msg = " on line " + (this.yylineno + 1);
          }
          var p2 = this.constructLexErrorInfo(
            "Lexical error" + lineno_msg + ": " + str,
            this.options.lexerErrorsAreRecoverable
          );
          var args = Array.prototype.slice.call(arguments, 1);
          if (args.length) {
            p2.extra_error_attributes = args;
          }
          return this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
        },
        /**
         * final cleanup function for when we have completed lexing the input;
         * make it an API so that external code can use this one once userland
         * code has decided it's time to destroy any lingering lexer error
         * hash object instances and the like: this function helps to clean
         * up these constructs, which *may* carry cyclic references which would
         * otherwise prevent the instances from being properly and timely
         * garbage-collected, i.e. this function helps prevent memory leaks!
         * 
         * @public
         * @this {RegExpLexer}
         */
        cleanupAfterLex: function lexer_cleanupAfterLex(do_not_nuke_errorinfos) {
          this.setInput("", {});
          if (!do_not_nuke_errorinfos) {
            for (var i = this.__error_infos.length - 1; i >= 0; i--) {
              var el = this.__error_infos[i];
              if (el && typeof el.destroy === "function") {
                el.destroy();
              }
            }
            this.__error_infos.length = 0;
          }
          return this;
        },
        /**
         * clear the lexer token context; intended for internal use only
         * 
         * @public
         * @this {RegExpLexer}
         */
        clear: function lexer_clear() {
          this.yytext = "";
          this.yyleng = 0;
          this.match = "";
          this.matches = false;
          this._more = false;
          this._backtrack = false;
          var col = this.yylloc ? this.yylloc.last_column : 0;
          this.yylloc = {
            first_line: this.yylineno + 1,
            first_column: col,
            last_line: this.yylineno + 1,
            last_column: col,
            range: [this.offset, this.offset]
          };
        },
        /**
         * resets the lexer, sets new input
         * 
         * @public
         * @this {RegExpLexer}
         */
        setInput: function lexer_setInput(input2, yy) {
          this.yy = yy || this.yy || {};
          if (!this.__decompressed) {
            var rules = this.rules;
            for (var i = 0, len = rules.length; i < len; i++) {
              var rule_re = rules[i];
              if (typeof rule_re === "number") {
                rules[i] = rules[rule_re];
              }
            }
            var conditions = this.conditions;
            for (var k2 in conditions) {
              var spec = conditions[k2];
              var rule_ids = spec.rules;
              var len = rule_ids.length;
              var rule_regexes = new Array(len + 1);
              var rule_new_ids = new Array(len + 1);
              for (var i = 0; i < len; i++) {
                var idx = rule_ids[i];
                var rule_re = rules[idx];
                rule_regexes[i + 1] = rule_re;
                rule_new_ids[i + 1] = idx;
              }
              spec.rules = rule_new_ids;
              spec.__rule_regexes = rule_regexes;
              spec.__rule_count = len;
            }
            this.__decompressed = true;
          }
          this._input = input2 || "";
          this.clear();
          this._signaled_error_token = false;
          this.done = false;
          this.yylineno = 0;
          this.matched = "";
          this.conditionStack = ["INITIAL"];
          this.__currentRuleSet__ = null;
          this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0,
            range: [0, 0]
          };
          this.offset = 0;
          return this;
        },
        /**
         * edit the remaining input via user-specified callback.
         * This can be used to forward-adjust the input-to-parse, 
         * e.g. inserting macro expansions and alike in the
         * input which has yet to be lexed.
         * The behaviour of this API contrasts the `unput()` et al
         * APIs as those act on the *consumed* input, while this
         * one allows one to manipulate the future, without impacting
         * the current `yyloc` cursor location or any history. 
         * 
         * Use this API to help implement C-preprocessor-like
         * `#include` statements, etc.
         * 
         * The provided callback must be synchronous and is
         * expected to return the edited input (string).
         *
         * The `cpsArg` argument value is passed to the callback
         * as-is.
         *
         * `callback` interface: 
         * `function callback(input, cpsArg)`
         * 
         * - `input` will carry the remaining-input-to-lex string
         *   from the lexer.
         * - `cpsArg` is `cpsArg` passed into this API.
         * 
         * The `this` reference for the callback will be set to
         * reference this lexer instance so that userland code
         * in the callback can easily and quickly access any lexer
         * API. 
         *
         * When the callback returns a non-string-type falsey value,
         * we assume the callback did not edit the input and we
         * will using the input as-is.
         *
         * When the callback returns a non-string-type value, it
         * is converted to a string for lexing via the `"" + retval`
         * operation. (See also why: http://2ality.com/2012/03/converting-to-string.html 
         * -- that way any returned object's `toValue()` and `toString()`
         * methods will be invoked in a proper/desirable order.)
         * 
         * @public
         * @this {RegExpLexer}
         */
        editRemainingInput: function lexer_editRemainingInput(callback, cpsArg) {
          var rv = callback.call(this, this._input, cpsArg);
          if (typeof rv !== "string") {
            if (rv) {
              this._input = "" + rv;
            }
          } else {
            this._input = rv;
          }
          return this;
        },
        /**
         * consumes and returns one char from the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        input: function lexer_input() {
          if (!this._input) {
            return null;
          }
          var ch = this._input[0];
          this.yytext += ch;
          this.yyleng++;
          this.offset++;
          this.match += ch;
          this.matched += ch;
          var slice_len = 1;
          var lines = false;
          if (ch === "\n") {
            lines = true;
          } else if (ch === "\r") {
            lines = true;
            var ch2 = this._input[1];
            if (ch2 === "\n") {
              slice_len++;
              ch += ch2;
              this.yytext += ch2;
              this.yyleng++;
              this.offset++;
              this.match += ch2;
              this.matched += ch2;
              this.yylloc.range[1]++;
            }
          }
          if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
            this.yylloc.last_column = 0;
          } else {
            this.yylloc.last_column++;
          }
          this.yylloc.range[1]++;
          this._input = this._input.slice(slice_len);
          return ch;
        },
        /**
         * unshifts one char (or an entire string) into the input
         * 
         * @public
         * @this {RegExpLexer}
         */
        unput: function lexer_unput(ch) {
          var len = ch.length;
          var lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input;
          this.yytext = this.yytext.substr(0, this.yytext.length - len);
          this.yyleng = this.yytext.length;
          this.offset -= len;
          this.match = this.match.substr(0, this.match.length - len);
          this.matched = this.matched.substr(0, this.matched.length - len);
          if (lines.length > 1) {
            this.yylineno -= lines.length - 1;
            this.yylloc.last_line = this.yylineno + 1;
            var pre = this.match;
            var pre_lines = pre.split(/(?:\r\n?|\n)/g);
            if (pre_lines.length === 1) {
              pre = this.matched;
              pre_lines = pre.split(/(?:\r\n?|\n)/g);
            }
            this.yylloc.last_column = pre_lines[pre_lines.length - 1].length;
          } else {
            this.yylloc.last_column -= len;
          }
          this.yylloc.range[1] = this.yylloc.range[0] + this.yyleng;
          this.done = false;
          return this;
        },
        /**
         * cache matched text and append it on next action
         * 
         * @public
         * @this {RegExpLexer}
         */
        more: function lexer_more() {
          this._more = true;
          return this;
        },
        /**
         * signal the lexer that this rule fails to match the input, so the
         * next matching rule (regex) should be tested instead.
         * 
         * @public
         * @this {RegExpLexer}
         */
        reject: function lexer_reject() {
          if (this.options.backtrack_lexer) {
            this._backtrack = true;
          } else {
            var lineno_msg = "";
            if (this.yylloc) {
              lineno_msg = " on line " + (this.yylineno + 1);
            }
            var p2 = this.constructLexErrorInfo(
              "Lexical error" + lineno_msg + ": You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).",
              false
            );
            this._signaled_error_token = this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
          }
          return this;
        },
        /**
         * retain first n characters of the match
         * 
         * @public
         * @this {RegExpLexer}
         */
        less: function lexer_less(n2) {
          return this.unput(this.match.slice(n2));
        },
        /**
         * return (part of the) already matched input, i.e. for error
         * messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of
         * input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         * 
         * @public
         * @this {RegExpLexer}
         */
        pastInput: function lexer_pastInput(maxSize, maxLines) {
          var past = this.matched.substring(0, this.matched.length - this.match.length);
          if (maxSize < 0)
            maxSize = past.length;
          else if (!maxSize)
            maxSize = 20;
          if (maxLines < 0)
            maxLines = past.length;
          else if (!maxLines)
            maxLines = 1;
          past = past.substr(-maxSize * 2 - 2);
          var a2 = past.replace(/\r\n|\r/g, "\n").split("\n");
          a2 = a2.slice(-maxLines);
          past = a2.join("\n");
          if (past.length > maxSize) {
            past = "..." + past.substr(-maxSize);
          }
          return past;
        },
        /**
         * return (part of the) upcoming input, i.e. for error messages.
         * 
         * Limit the returned string length to `maxSize` (default: 20).
         * 
         * Limit the returned string to the `maxLines` number of lines of input (default: 1).
         * 
         * Negative limit values equal *unlimited*.
         *
         * > ### NOTE ###
         * >
         * > *"upcoming input"* is defined as the whole of the both
         * > the *currently lexed* input, together with any remaining input
         * > following that. *"currently lexed"* input is the input 
         * > already recognized by the lexer but not yet returned with
         * > the lexer token. This happens when you are invoking this API
         * > from inside any lexer rule action code block. 
         * >
         * 
         * @public
         * @this {RegExpLexer}
         */
        upcomingInput: function lexer_upcomingInput(maxSize, maxLines) {
          var next = this.match;
          if (maxSize < 0)
            maxSize = next.length + this._input.length;
          else if (!maxSize)
            maxSize = 20;
          if (maxLines < 0)
            maxLines = maxSize;
          else if (!maxLines)
            maxLines = 1;
          if (next.length < maxSize * 2 + 2) {
            next += this._input.substring(0, maxSize * 2 + 2);
          }
          var a2 = next.replace(/\r\n|\r/g, "\n").split("\n");
          a2 = a2.slice(0, maxLines);
          next = a2.join("\n");
          if (next.length > maxSize) {
            next = next.substring(0, maxSize) + "...";
          }
          return next;
        },
        /**
         * return a string which displays the character position where the
         * lexing error occurred, i.e. for error messages
         * 
         * @public
         * @this {RegExpLexer}
         */
        showPosition: function lexer_showPosition(maxPrefix, maxPostfix) {
          var pre = this.pastInput(maxPrefix).replace(/\s/g, " ");
          var c3 = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput(maxPostfix).replace(/\s/g, " ") + "\n" + c3 + "^";
        },
        /**
         * return an YYLLOC info object derived off the given context (actual, preceding, following, current).
         * Use this method when the given `actual` location is not guaranteed to exist (i.e. when
         * it MAY be NULL) and you MUST have a valid location info object anyway:
         * then we take the given context of the `preceding` and `following` locations, IFF those are available,
         * and reconstruct the `actual` location info from those.
         * If this fails, the heuristic is to take the `current` location, IFF available.
         * If this fails as well, we assume the sought location is at/around the current lexer position
         * and then produce that one as a response. DO NOTE that these heuristic/derived location info
         * values MAY be inaccurate!
         *
         * NOTE: `deriveLocationInfo()` ALWAYS produces a location info object *copy* of `actual`, not just
         * a *reference* hence all input location objects can be assumed to be 'constant' (function has no side-effects).
         * 
         * @public
         * @this {RegExpLexer}
         */
        deriveLocationInfo: function lexer_deriveYYLLOC(actual, preceding, following, current) {
          var loc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0,
            range: [0, 0]
          };
          if (actual) {
            loc.first_line = actual.first_line | 0;
            loc.last_line = actual.last_line | 0;
            loc.first_column = actual.first_column | 0;
            loc.last_column = actual.last_column | 0;
            if (actual.range) {
              loc.range[0] = actual.range[0] | 0;
              loc.range[1] = actual.range[1] | 0;
            }
          }
          if (loc.first_line <= 0 || loc.last_line < loc.first_line) {
            if (loc.first_line <= 0 && preceding) {
              loc.first_line = preceding.last_line | 0;
              loc.first_column = preceding.last_column | 0;
              if (preceding.range) {
                loc.range[0] = actual.range[1] | 0;
              }
            }
            if ((loc.last_line <= 0 || loc.last_line < loc.first_line) && following) {
              loc.last_line = following.first_line | 0;
              loc.last_column = following.first_column | 0;
              if (following.range) {
                loc.range[1] = actual.range[0] | 0;
              }
            }
            if (loc.first_line <= 0 && current && (loc.last_line <= 0 || current.last_line <= loc.last_line)) {
              loc.first_line = current.first_line | 0;
              loc.first_column = current.first_column | 0;
              if (current.range) {
                loc.range[0] = current.range[0] | 0;
              }
            }
            if (loc.last_line <= 0 && current && (loc.first_line <= 0 || current.first_line >= loc.first_line)) {
              loc.last_line = current.last_line | 0;
              loc.last_column = current.last_column | 0;
              if (current.range) {
                loc.range[1] = current.range[1] | 0;
              }
            }
          }
          if (loc.last_line <= 0) {
            if (loc.first_line <= 0) {
              loc.first_line = this.yylloc.first_line;
              loc.last_line = this.yylloc.last_line;
              loc.first_column = this.yylloc.first_column;
              loc.last_column = this.yylloc.last_column;
              loc.range[0] = this.yylloc.range[0];
              loc.range[1] = this.yylloc.range[1];
            } else {
              loc.last_line = this.yylloc.last_line;
              loc.last_column = this.yylloc.last_column;
              loc.range[1] = this.yylloc.range[1];
            }
          }
          if (loc.first_line <= 0) {
            loc.first_line = loc.last_line;
            loc.first_column = 0;
            loc.range[1] = loc.range[0];
          }
          if (loc.first_column < 0) {
            loc.first_column = 0;
          }
          if (loc.last_column < 0) {
            loc.last_column = loc.first_column > 0 ? loc.first_column : 80;
          }
          return loc;
        },
        /**
         * return a string which displays the lines & columns of input which are referenced 
         * by the given location info range, plus a few lines of context.
         * 
         * This function pretty-prints the indicated section of the input, with line numbers 
         * and everything!
         * 
         * This function is very useful to provide highly readable error reports, while
         * the location range may be specified in various flexible ways:
         * 
         * - `loc` is the location info object which references the area which should be
         *   displayed and 'marked up': these lines & columns of text are marked up by `^`
         *   characters below each character in the entire input range.
         * 
         * - `context_loc` is the *optional* location info object which instructs this
         *   pretty-printer how much *leading* context should be displayed alongside
         *   the area referenced by `loc`. This can help provide context for the displayed
         *   error, etc.
         * 
         *   When this location info is not provided, a default context of 3 lines is
         *   used.
         * 
         * - `context_loc2` is another *optional* location info object, which serves
         *   a similar purpose to `context_loc`: it specifies the amount of *trailing*
         *   context lines to display in the pretty-print output.
         * 
         *   When this location info is not provided, a default context of 1 line only is
         *   used.
         * 
         * Special Notes:
         * 
         * - when the `loc`-indicated range is very large (about 5 lines or more), then
         *   only the first and last few lines of this block are printed while a
         *   `...continued...` message will be printed between them.
         * 
         *   This serves the purpose of not printing a huge amount of text when the `loc`
         *   range happens to be huge: this way a manageable & readable output results
         *   for arbitrary large ranges.
         * 
         * - this function can display lines of input which whave not yet been lexed.
         *   `prettyPrintRange()` can access the entire input!
         * 
         * @public
         * @this {RegExpLexer}
         */
        prettyPrintRange: function lexer_prettyPrintRange(loc, context_loc, context_loc2) {
          loc = this.deriveLocationInfo(loc, context_loc, context_loc2);
          const CONTEXT = 3;
          const CONTEXT_TAIL = 1;
          const MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT = 2;
          var input2 = this.matched + this._input;
          var lines = input2.split("\n");
          var l0 = Math.max(1, context_loc ? context_loc.first_line : loc.first_line - CONTEXT);
          var l1 = Math.max(1, context_loc2 ? context_loc2.last_line : loc.last_line + CONTEXT_TAIL);
          var lineno_display_width = 1 + Math.log10(l1 | 1) | 0;
          var ws_prefix = new Array(lineno_display_width).join(" ");
          var nonempty_line_indexes = [];
          var rv = lines.slice(l0 - 1, l1 + 1).map(function injectLineNumber(line, index) {
            var lno = index + l0;
            var lno_pfx = (ws_prefix + lno).substr(-lineno_display_width);
            var rv2 = lno_pfx + ": " + line;
            var errpfx = new Array(lineno_display_width + 1).join("^");
            var offset = 2 + 1;
            var len = 0;
            if (lno === loc.first_line) {
              offset += loc.first_column;
              len = Math.max(
                2,
                (lno === loc.last_line ? loc.last_column : line.length) - loc.first_column + 1
              );
            } else if (lno === loc.last_line) {
              len = Math.max(2, loc.last_column + 1);
            } else if (lno > loc.first_line && lno < loc.last_line) {
              len = Math.max(2, line.length + 1);
            }
            if (len) {
              var lead = new Array(offset).join(".");
              var mark = new Array(len).join("^");
              rv2 += "\n" + errpfx + lead + mark;
              if (line.trim().length > 0) {
                nonempty_line_indexes.push(index);
              }
            }
            rv2 = rv2.replace(/\t/g, " ");
            return rv2;
          });
          if (nonempty_line_indexes.length > 2 * MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT) {
            var clip_start = nonempty_line_indexes[MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT - 1] + 1;
            var clip_end = nonempty_line_indexes[nonempty_line_indexes.length - MINIMUM_VISIBLE_NONEMPTY_LINE_COUNT] - 1;
            var intermediate_line = new Array(lineno_display_width + 1).join(" ") + "  (...continued...)";
            intermediate_line += "\n" + new Array(lineno_display_width + 1).join("-") + "  (---------------)";
            rv.splice(clip_start, clip_end - clip_start + 1, intermediate_line);
          }
          return rv.join("\n");
        },
        /**
         * helper function, used to produce a human readable description as a string, given
         * the input `yylloc` location object.
         * 
         * Set `display_range_too` to TRUE to include the string character index position(s)
         * in the description if the `yylloc.range` is available.
         * 
         * @public
         * @this {RegExpLexer}
         */
        describeYYLLOC: function lexer_describe_yylloc(yylloc, display_range_too) {
          var l1 = yylloc.first_line;
          var l2 = yylloc.last_line;
          var c1 = yylloc.first_column;
          var c22 = yylloc.last_column;
          var dl = l2 - l1;
          var dc = c22 - c1;
          var rv;
          if (dl === 0) {
            rv = "line " + l1 + ", ";
            if (dc <= 1) {
              rv += "column " + c1;
            } else {
              rv += "columns " + c1 + " .. " + c22;
            }
          } else {
            rv = "lines " + l1 + "(column " + c1 + ") .. " + l2 + "(column " + c22 + ")";
          }
          if (yylloc.range && display_range_too) {
            var r1 = yylloc.range[0];
            var r2 = yylloc.range[1] - 1;
            if (r2 <= r1) {
              rv += " {String Offset: " + r1 + "}";
            } else {
              rv += " {String Offset range: " + r1 + " .. " + r2 + "}";
            }
          }
          return rv;
        },
        /**
         * test the lexed token: return FALSE when not a match, otherwise return token.
         * 
         * `match` is supposed to be an array coming out of a regex match, i.e. `match[0]`
         * contains the actually matched text string.
         * 
         * Also move the input cursor forward and update the match collectors:
         * 
         * - `yytext`
         * - `yyleng`
         * - `match`
         * - `matches`
         * - `yylloc`
         * - `offset`
         * 
         * @public
         * @this {RegExpLexer}
         */
        test_match: function lexer_test_match(match, indexed_rule) {
          var token, lines, backup, match_str, match_str_len;
          if (this.options.backtrack_lexer) {
            backup = {
              yylineno: this.yylineno,
              yylloc: {
                first_line: this.yylloc.first_line,
                last_line: this.yylloc.last_line,
                first_column: this.yylloc.first_column,
                last_column: this.yylloc.last_column,
                range: this.yylloc.range.slice(0)
              },
              yytext: this.yytext,
              match: this.match,
              matches: this.matches,
              matched: this.matched,
              yyleng: this.yyleng,
              offset: this.offset,
              _more: this._more,
              _input: this._input,
              //_signaled_error_token: this._signaled_error_token,
              yy: this.yy,
              conditionStack: this.conditionStack.slice(0),
              done: this.done
            };
          }
          match_str = match[0];
          match_str_len = match_str.length;
          lines = match_str.split(/(?:\r\n?|\n)/g);
          if (lines.length > 1) {
            this.yylineno += lines.length - 1;
            this.yylloc.last_line = this.yylineno + 1;
            this.yylloc.last_column = lines[lines.length - 1].length;
          } else {
            this.yylloc.last_column += match_str_len;
          }
          this.yytext += match_str;
          this.match += match_str;
          this.matched += match_str;
          this.matches = match;
          this.yyleng = this.yytext.length;
          this.yylloc.range[1] += match_str_len;
          this.offset += match_str_len;
          this._more = false;
          this._backtrack = false;
          this._input = this._input.slice(match_str_len);
          token = this.performAction.call(
            this,
            this.yy,
            indexed_rule,
            this.conditionStack[this.conditionStack.length - 1]
            /* = YY_START */
          );
          if (this.done && this._input) {
            this.done = false;
          }
          if (token) {
            return token;
          } else if (this._backtrack) {
            for (var k2 in backup) {
              this[k2] = backup[k2];
            }
            this.__currentRuleSet__ = null;
            return false;
          } else if (this._signaled_error_token) {
            token = this._signaled_error_token;
            this._signaled_error_token = false;
            return token;
          }
          return false;
        },
        /**
         * return next match in input
         * 
         * @public
         * @this {RegExpLexer}
         */
        next: function lexer_next() {
          if (this.done) {
            this.clear();
            return this.EOF;
          }
          if (!this._input) {
            this.done = true;
          }
          var token, match, tempMatch, index;
          if (!this._more) {
            this.clear();
          }
          var spec = this.__currentRuleSet__;
          if (!spec) {
            spec = this.__currentRuleSet__ = this._currentRules();
            if (!spec || !spec.rules) {
              var lineno_msg = "";
              if (this.options.trackPosition) {
                lineno_msg = " on line " + (this.yylineno + 1);
              }
              var p2 = this.constructLexErrorInfo(
                "Internal lexer engine error" + lineno_msg + ': The lex grammar programmer pushed a non-existing condition name "' + this.topState() + '"; this is a fatal error and should be reported to the application programmer team!',
                false
              );
              return this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
            }
          }
          var rule_ids = spec.rules;
          var regexes = spec.__rule_regexes;
          var len = spec.__rule_count;
          for (var i = 1; i <= len; i++) {
            tempMatch = this._input.match(regexes[i]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
              match = tempMatch;
              index = i;
              if (this.options.backtrack_lexer) {
                token = this.test_match(tempMatch, rule_ids[i]);
                if (token !== false) {
                  return token;
                } else if (this._backtrack) {
                  match = void 0;
                  continue;
                } else {
                  return false;
                }
              } else if (!this.options.flex) {
                break;
              }
            }
          }
          if (match) {
            token = this.test_match(match, rule_ids[index]);
            if (token !== false) {
              return token;
            }
            return false;
          }
          if (!this._input) {
            this.done = true;
            this.clear();
            return this.EOF;
          } else {
            var lineno_msg = "";
            if (this.options.trackPosition) {
              lineno_msg = " on line " + (this.yylineno + 1);
            }
            var p2 = this.constructLexErrorInfo(
              "Lexical error" + lineno_msg + ": Unrecognized text.",
              this.options.lexerErrorsAreRecoverable
            );
            var pendingInput = this._input;
            var activeCondition = this.topState();
            var conditionStackDepth = this.conditionStack.length;
            token = this.parseError(p2.errStr, p2, this.JisonLexerError) || this.ERROR;
            if (token === this.ERROR) {
              if (!this.matches && // and make sure the input has been modified/consumed ...
              pendingInput === this._input && // ...or the lexer state has been modified significantly enough
              // to merit a non-consuming error handling action right now.
              activeCondition === this.topState() && conditionStackDepth === this.conditionStack.length) {
                this.input();
              }
            }
            return token;
          }
        },
        /**
         * return next match that has a token
         * 
         * @public
         * @this {RegExpLexer}
         */
        lex: function lexer_lex() {
          var r2;
          if (typeof this.pre_lex === "function") {
            r2 = this.pre_lex.call(this, 0);
          }
          if (typeof this.options.pre_lex === "function") {
            r2 = this.options.pre_lex.call(this, r2) || r2;
          }
          if (this.yy && typeof this.yy.pre_lex === "function") {
            r2 = this.yy.pre_lex.call(this, r2) || r2;
          }
          while (!r2) {
            r2 = this.next();
          }
          if (this.yy && typeof this.yy.post_lex === "function") {
            r2 = this.yy.post_lex.call(this, r2) || r2;
          }
          if (typeof this.options.post_lex === "function") {
            r2 = this.options.post_lex.call(this, r2) || r2;
          }
          if (typeof this.post_lex === "function") {
            r2 = this.post_lex.call(this, r2) || r2;
          }
          return r2;
        },
        /**
         * return next match that has a token. Identical to the `lex()` API but does not invoke any of the 
         * `pre_lex()` nor any of the `post_lex()` callbacks.
         * 
         * @public
         * @this {RegExpLexer}
         */
        fastLex: function lexer_fastLex() {
          var r2;
          while (!r2) {
            r2 = this.next();
          }
          return r2;
        },
        /**
         * return info about the lexer state that can help a parser or other lexer API user to use the
         * most efficient means available. This API is provided to aid run-time performance for larger
         * systems which employ this lexer.
         * 
         * @public
         * @this {RegExpLexer}
         */
        canIUse: function lexer_canIUse() {
          var rv = {
            fastLex: !(typeof this.pre_lex === "function" || typeof this.options.pre_lex === "function" || this.yy && typeof this.yy.pre_lex === "function" || this.yy && typeof this.yy.post_lex === "function" || typeof this.options.post_lex === "function" || typeof this.post_lex === "function") && typeof this.fastLex === "function"
          };
          return rv;
        },
        /**
         * backwards compatible alias for `pushState()`;
         * the latter is symmetrical with `popState()` and we advise to use
         * those APIs in any modern lexer code, rather than `begin()`.
         * 
         * @public
         * @this {RegExpLexer}
         */
        begin: function lexer_begin(condition) {
          return this.pushState(condition);
        },
        /**
         * activates a new lexer condition state (pushes the new lexer
         * condition state onto the condition stack)
         * 
         * @public
         * @this {RegExpLexer}
         */
        pushState: function lexer_pushState(condition) {
          this.conditionStack.push(condition);
          this.__currentRuleSet__ = null;
          return this;
        },
        /**
         * pop the previously active lexer condition state off the condition
         * stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        popState: function lexer_popState() {
          var n2 = this.conditionStack.length - 1;
          if (n2 > 0) {
            this.__currentRuleSet__ = null;
            return this.conditionStack.pop();
          } else {
            return this.conditionStack[0];
          }
        },
        /**
         * return the currently active lexer condition state; when an index
         * argument is provided it produces the N-th previous condition state,
         * if available
         * 
         * @public
         * @this {RegExpLexer}
         */
        topState: function lexer_topState(n2) {
          n2 = this.conditionStack.length - 1 - Math.abs(n2 || 0);
          if (n2 >= 0) {
            return this.conditionStack[n2];
          } else {
            return "INITIAL";
          }
        },
        /**
         * (internal) determine the lexer rule set which is active for the
         * currently active lexer condition state
         * 
         * @public
         * @this {RegExpLexer}
         */
        _currentRules: function lexer__currentRules() {
          if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]];
          } else {
            return this.conditions["INITIAL"];
          }
        },
        /**
         * return the number of states currently on the stack
         * 
         * @public
         * @this {RegExpLexer}
         */
        stateStackSize: function lexer_stateStackSize() {
          return this.conditionStack.length;
        },
        options: {
          trackPosition: true
        },
        JisonLexerError,
        performAction: function lexer__performAction(yy, yyrulenumber, YY_START) {
          switch (yyrulenumber) {
            case 1:
              break;
            default:
              return this.simpleCaseActionClusters[yyrulenumber];
          }
        },
        simpleCaseActionClusters: {
          /*! Conditions:: INITIAL */
          /*! Rule::       (--[0-9a-z-A-Z-]*) */
          0: 13,
          /*! Conditions:: INITIAL */
          /*! Rule::       \* */
          2: 5,
          /*! Conditions:: INITIAL */
          /*! Rule::       \/ */
          3: 6,
          /*! Conditions:: INITIAL */
          /*! Rule::       \+ */
          4: 3,
          /*! Conditions:: INITIAL */
          /*! Rule::       - */
          5: 4,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)px\b */
          6: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)cm\b */
          7: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)mm\b */
          8: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)in\b */
          9: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)pt\b */
          10: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)pc\b */
          11: 15,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)deg\b */
          12: 16,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)grad\b */
          13: 16,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)rad\b */
          14: 16,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)turn\b */
          15: 16,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)s\b */
          16: 17,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ms\b */
          17: 17,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)Hz\b */
          18: 18,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)kHz\b */
          19: 18,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dpi\b */
          20: 19,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dpcm\b */
          21: 19,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)dppx\b */
          22: 19,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)em\b */
          23: 20,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ex\b */
          24: 21,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)ch\b */
          25: 22,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)rem\b */
          26: 23,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vw\b */
          27: 25,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vh\b */
          28: 24,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vmin\b */
          29: 26,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)vmax\b */
          30: 27,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)% */
          31: 28,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([0-9]+(\.[0-9]*)?|\.[0-9]+)\b */
          32: 11,
          /*! Conditions:: INITIAL */
          /*! Rule::       (calc) */
          33: 9,
          /*! Conditions:: INITIAL */
          /*! Rule::       (var) */
          34: 12,
          /*! Conditions:: INITIAL */
          /*! Rule::       ([a-z]+) */
          35: 10,
          /*! Conditions:: INITIAL */
          /*! Rule::       \( */
          36: 7,
          /*! Conditions:: INITIAL */
          /*! Rule::       \) */
          37: 8,
          /*! Conditions:: INITIAL */
          /*! Rule::       , */
          38: 14,
          /*! Conditions:: INITIAL */
          /*! Rule::       $ */
          39: 1
        },
        rules: [
          /*  0: */
          /^(?:(--[\d\-A-Za-z]*))/,
          /*  1: */
          /^(?:\s+)/,
          /*  2: */
          /^(?:\*)/,
          /*  3: */
          /^(?:\/)/,
          /*  4: */
          /^(?:\+)/,
          /*  5: */
          /^(?:-)/,
          /*  6: */
          /^(?:(\d+(\.\d*)?|\.\d+)px\b)/,
          /*  7: */
          /^(?:(\d+(\.\d*)?|\.\d+)cm\b)/,
          /*  8: */
          /^(?:(\d+(\.\d*)?|\.\d+)mm\b)/,
          /*  9: */
          /^(?:(\d+(\.\d*)?|\.\d+)in\b)/,
          /* 10: */
          /^(?:(\d+(\.\d*)?|\.\d+)pt\b)/,
          /* 11: */
          /^(?:(\d+(\.\d*)?|\.\d+)pc\b)/,
          /* 12: */
          /^(?:(\d+(\.\d*)?|\.\d+)deg\b)/,
          /* 13: */
          /^(?:(\d+(\.\d*)?|\.\d+)grad\b)/,
          /* 14: */
          /^(?:(\d+(\.\d*)?|\.\d+)rad\b)/,
          /* 15: */
          /^(?:(\d+(\.\d*)?|\.\d+)turn\b)/,
          /* 16: */
          /^(?:(\d+(\.\d*)?|\.\d+)s\b)/,
          /* 17: */
          /^(?:(\d+(\.\d*)?|\.\d+)ms\b)/,
          /* 18: */
          /^(?:(\d+(\.\d*)?|\.\d+)Hz\b)/,
          /* 19: */
          /^(?:(\d+(\.\d*)?|\.\d+)kHz\b)/,
          /* 20: */
          /^(?:(\d+(\.\d*)?|\.\d+)dpi\b)/,
          /* 21: */
          /^(?:(\d+(\.\d*)?|\.\d+)dpcm\b)/,
          /* 22: */
          /^(?:(\d+(\.\d*)?|\.\d+)dppx\b)/,
          /* 23: */
          /^(?:(\d+(\.\d*)?|\.\d+)em\b)/,
          /* 24: */
          /^(?:(\d+(\.\d*)?|\.\d+)ex\b)/,
          /* 25: */
          /^(?:(\d+(\.\d*)?|\.\d+)ch\b)/,
          /* 26: */
          /^(?:(\d+(\.\d*)?|\.\d+)rem\b)/,
          /* 27: */
          /^(?:(\d+(\.\d*)?|\.\d+)vw\b)/,
          /* 28: */
          /^(?:(\d+(\.\d*)?|\.\d+)vh\b)/,
          /* 29: */
          /^(?:(\d+(\.\d*)?|\.\d+)vmin\b)/,
          /* 30: */
          /^(?:(\d+(\.\d*)?|\.\d+)vmax\b)/,
          /* 31: */
          /^(?:(\d+(\.\d*)?|\.\d+)%)/,
          /* 32: */
          /^(?:(\d+(\.\d*)?|\.\d+)\b)/,
          /* 33: */
          /^(?:(calc))/,
          /* 34: */
          /^(?:(var))/,
          /* 35: */
          /^(?:([a-z]+))/,
          /* 36: */
          /^(?:\()/,
          /* 37: */
          /^(?:\))/,
          /* 38: */
          /^(?:,)/,
          /* 39: */
          /^(?:$)/
        ],
        conditions: {
          "INITIAL": {
            rules: [
              0,
              1,
              2,
              3,
              4,
              5,
              6,
              7,
              8,
              9,
              10,
              11,
              12,
              13,
              14,
              15,
              16,
              17,
              18,
              19,
              20,
              21,
              22,
              23,
              24,
              25,
              26,
              27,
              28,
              29,
              30,
              31,
              32,
              33,
              34,
              35,
              36,
              37,
              38,
              39
            ],
            inclusive: true
          }
        }
      };
      return lexer2;
    }();
    parser3.lexer = lexer;
    function Parser() {
      this.yy = {};
    }
    Parser.prototype = parser3;
    parser3.Parser = Parser;
    return new Parser();
  }();
  if (typeof commonjsRequire !== "undefined" && true) {
    exports.parser = parser2;
    exports.Parser = parser2.Parser;
    exports.parse = function() {
      return parser2.parse.apply(parser2, arguments);
    };
  }
})(parser);
var reducer = {};
var convert = { exports: {} };
var conversions = {
  // length
  "px": {
    "px": 1,
    "cm": 96 / 2.54,
    "mm": 96 / 25.4,
    "in": 96,
    "pt": 96 / 72,
    "pc": 16
  },
  "cm": {
    "px": 2.54 / 96,
    "cm": 1,
    "mm": 0.1,
    "in": 2.54,
    "pt": 2.54 / 72,
    "pc": 2.54 / 6
  },
  "mm": {
    "px": 25.4 / 96,
    "cm": 10,
    "mm": 1,
    "in": 25.4,
    "pt": 25.4 / 72,
    "pc": 25.4 / 6
  },
  "in": {
    "px": 1 / 96,
    "cm": 1 / 2.54,
    "mm": 1 / 25.4,
    "in": 1,
    "pt": 1 / 72,
    "pc": 1 / 6
  },
  "pt": {
    "px": 0.75,
    "cm": 72 / 2.54,
    "mm": 72 / 25.4,
    "in": 72,
    "pt": 1,
    "pc": 12
  },
  "pc": {
    "px": 6 / 96,
    "cm": 6 / 2.54,
    "mm": 6 / 25.4,
    "in": 6,
    "pt": 6 / 72,
    "pc": 1
  },
  // angle
  "deg": {
    "deg": 1,
    "grad": 0.9,
    "rad": 180 / Math.PI,
    "turn": 360
  },
  "grad": {
    "deg": 400 / 360,
    "grad": 1,
    "rad": 200 / Math.PI,
    "turn": 400
  },
  "rad": {
    "deg": Math.PI / 180,
    "grad": Math.PI / 200,
    "rad": 1,
    "turn": Math.PI * 2
  },
  "turn": {
    "deg": 1 / 360,
    "grad": 1 / 400,
    "rad": 0.5 / Math.PI,
    "turn": 1
  },
  // time
  "s": {
    "s": 1,
    "ms": 1 / 1e3
  },
  "ms": {
    "s": 1e3,
    "ms": 1
  },
  // frequency
  "Hz": {
    "Hz": 1,
    "kHz": 1e3
  },
  "kHz": {
    "Hz": 1 / 1e3,
    "kHz": 1
  },
  // resolution
  "dpi": {
    "dpi": 1,
    "dpcm": 1 / 2.54,
    "dppx": 1 / 96
  },
  "dpcm": {
    "dpi": 2.54,
    "dpcm": 1,
    "dppx": 2.54 / 96
  },
  "dppx": {
    "dpi": 96,
    "dpcm": 96 / 2.54,
    "dppx": 1
  }
};
var cssUnitConverter = function(value, sourceUnit, targetUnit, precision) {
  if (!conversions.hasOwnProperty(targetUnit))
    throw new Error("Cannot convert to " + targetUnit);
  if (!conversions[targetUnit].hasOwnProperty(sourceUnit))
    throw new Error("Cannot convert from " + sourceUnit + " to " + targetUnit);
  var converted = conversions[targetUnit][sourceUnit] * value;
  if (precision !== false) {
    precision = Math.pow(10, parseInt(precision) || 5);
    return Math.round(converted * precision) / precision;
  }
  return converted;
};
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _cssUnitConverter = cssUnitConverter;
  var _cssUnitConverter2 = _interopRequireDefault2(_cssUnitConverter);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  function convertNodes(left, right, precision) {
    switch (left.type) {
      case "LengthValue":
      case "AngleValue":
      case "TimeValue":
      case "FrequencyValue":
      case "ResolutionValue":
        return convertAbsoluteLength(left, right, precision);
      default:
        return { left, right };
    }
  }
  function convertAbsoluteLength(left, right, precision) {
    if (right.type === left.type) {
      right = {
        type: left.type,
        value: (0, _cssUnitConverter2.default)(right.value, right.unit, left.unit, precision),
        unit: left.unit
      };
    }
    return { left, right };
  }
  exports.default = convertNodes;
  module.exports = exports["default"];
})(convert, convert.exports);
var convertExports = convert.exports;
Object.defineProperty(reducer, "__esModule", {
  value: true
});
reducer.flip = flip;
var _convert = convertExports;
var _convert2 = _interopRequireDefault$2(_convert);
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { default: obj };
}
function reduce(node, precision) {
  if (node.type === "MathExpression")
    return reduceMathExpression(node, precision);
  if (node.type === "Calc")
    return reduce(node.value, precision);
  return node;
}
function isEqual$1(left, right) {
  return left.type === right.type && left.value === right.value;
}
function isValueType(type) {
  switch (type) {
    case "LengthValue":
    case "AngleValue":
    case "TimeValue":
    case "FrequencyValue":
    case "ResolutionValue":
    case "EmValue":
    case "ExValue":
    case "ChValue":
    case "RemValue":
    case "VhValue":
    case "VwValue":
    case "VminValue":
    case "VmaxValue":
    case "PercentageValue":
    case "Value":
      return true;
  }
  return false;
}
function convertMathExpression(node, precision) {
  var nodes = (0, _convert2.default)(node.left, node.right, precision);
  var left = reduce(nodes.left, precision);
  var right = reduce(nodes.right, precision);
  if (left.type === "MathExpression" && right.type === "MathExpression") {
    if (left.operator === "/" && right.operator === "*" || left.operator === "-" && right.operator === "+" || left.operator === "*" && right.operator === "/" || left.operator === "+" && right.operator === "-") {
      if (isEqual$1(left.right, right.right))
        nodes = (0, _convert2.default)(left.left, right.left, precision);
      else if (isEqual$1(left.right, right.left))
        nodes = (0, _convert2.default)(left.left, right.right, precision);
      left = reduce(nodes.left, precision);
      right = reduce(nodes.right, precision);
    }
  }
  node.left = left;
  node.right = right;
  return node;
}
function flip(operator) {
  return operator === "+" ? "-" : "+";
}
function flipValue(node) {
  if (isValueType(node.type))
    node.value = -node.value;
  else if (node.type == "MathExpression") {
    node.left = flipValue(node.left);
    node.right = flipValue(node.right);
  }
  return node;
}
function reduceAddSubExpression(node, precision) {
  var _node = node, left = _node.left, right = _node.right, op = _node.operator;
  if (left.type === "CssVariable" || right.type === "CssVariable")
    return node;
  if (right.value === 0)
    return left;
  if (left.value === 0 && op === "+")
    return right;
  if (left.value === 0 && op === "-")
    return flipValue(right);
  if (left.type === right.type && isValueType(left.type)) {
    node = Object.assign({}, left);
    if (op === "+")
      node.value = left.value + right.value;
    else
      node.value = left.value - right.value;
  }
  if (isValueType(left.type) && (right.operator === "+" || right.operator === "-") && right.type === "MathExpression") {
    if (left.type === right.left.type) {
      node = Object.assign({}, node);
      node.left = reduce({
        type: "MathExpression",
        operator: op,
        left,
        right: right.left
      }, precision);
      node.right = right.right;
      node.operator = op === "-" ? flip(right.operator) : right.operator;
      return reduce(node, precision);
    } else if (left.type === right.right.type) {
      node = Object.assign({}, node);
      node.left = reduce({
        type: "MathExpression",
        operator: op === "-" ? flip(right.operator) : right.operator,
        left,
        right: right.right
      }, precision);
      node.right = right.left;
      return reduce(node, precision);
    }
  }
  if (left.type === "MathExpression" && (left.operator === "+" || left.operator === "-") && isValueType(right.type)) {
    if (right.type === left.left.type) {
      node = Object.assign({}, left);
      node.left = reduce({
        type: "MathExpression",
        operator: op,
        left: left.left,
        right
      }, precision);
      return reduce(node, precision);
    } else if (right.type === left.right.type) {
      node = Object.assign({}, left);
      if (left.operator === "-") {
        node.right = reduce({
          type: "MathExpression",
          operator: op === "-" ? "+" : "-",
          left: right,
          right: left.right
        }, precision);
        node.operator = op === "-" ? "-" : "+";
      } else {
        node.right = reduce({
          type: "MathExpression",
          operator: op,
          left: left.right,
          right
        }, precision);
      }
      if (node.right.value < 0) {
        node.right.value *= -1;
        node.operator = node.operator === "-" ? "+" : "-";
      }
      return reduce(node, precision);
    }
  }
  return node;
}
function reduceDivisionExpression(node, precision) {
  if (!isValueType(node.right.type))
    return node;
  if (node.right.type !== "Value")
    throw new Error('Cannot divide by "' + node.right.unit + '", number expected');
  if (node.right.value === 0)
    throw new Error("Cannot divide by zero");
  if (node.left.type === "MathExpression") {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value /= node.right.value;
      node.left.right.value /= node.right.value;
      return reduce(node.left, precision);
    }
    return node;
  } else if (isValueType(node.left.type)) {
    node.left.value /= node.right.value;
    return node.left;
  }
  return node;
}
function reduceMultiplicationExpression(node) {
  if (node.left.type === "MathExpression" && node.right.type === "Value") {
    if (isValueType(node.left.left.type) && isValueType(node.left.right.type)) {
      node.left.left.value *= node.right.value;
      node.left.right.value *= node.right.value;
      return node.left;
    }
  } else if (isValueType(node.left.type) && node.right.type === "Value") {
    node.left.value *= node.right.value;
    return node.left;
  } else if (node.left.type === "Value" && node.right.type === "MathExpression") {
    if (isValueType(node.right.left.type) && isValueType(node.right.right.type)) {
      node.right.left.value *= node.left.value;
      node.right.right.value *= node.left.value;
      return node.right;
    }
  } else if (node.left.type === "Value" && isValueType(node.right.type)) {
    node.right.value *= node.left.value;
    return node.right;
  }
  return node;
}
function reduceMathExpression(node, precision) {
  node = convertMathExpression(node, precision);
  switch (node.operator) {
    case "+":
    case "-":
      return reduceAddSubExpression(node, precision);
    case "/":
      return reduceDivisionExpression(node, precision);
    case "*":
      return reduceMultiplicationExpression(node);
  }
  return node;
}
reducer.default = reduce;
var stringifier = { exports: {} };
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.default = function(calc, node, precision) {
    var str = stringify2(node, precision);
    if (node.type === "MathExpression") {
      str = calc + "(" + str + ")";
    }
    return str;
  };
  var _reducer = reducer;
  var order = {
    "*": 0,
    "/": 0,
    "+": 1,
    "-": 1
  };
  function round2(value, prec) {
    if (prec !== false) {
      var precision = Math.pow(10, prec);
      return Math.round(value * precision) / precision;
    }
    return value;
  }
  function stringify2(node, prec) {
    switch (node.type) {
      case "MathExpression": {
        var left = node.left, right = node.right, op = node.operator;
        var str = "";
        if (left.type === "MathExpression" && order[op] < order[left.operator])
          str += "(" + stringify2(left, prec) + ")";
        else
          str += stringify2(left, prec);
        str += " " + node.operator + " ";
        if (right.type === "MathExpression" && order[op] < order[right.operator]) {
          str += "(" + stringify2(right, prec) + ")";
        } else if (right.type === "MathExpression" && op === "-" && ["+", "-"].includes(right.operator)) {
          right.operator = (0, _reducer.flip)(right.operator);
          str += stringify2(right, prec);
        } else {
          str += stringify2(right, prec);
        }
        return str;
      }
      case "Value":
        return round2(node.value, prec);
      case "CssVariable":
        if (node.fallback) {
          return "var(" + node.value + ", " + stringify2(node.fallback, prec) + ")";
        }
        return "var(" + node.value + ")";
      case "Calc":
        if (node.prefix) {
          return "-" + node.prefix + "-calc(" + stringify2(node.value, prec) + ")";
        }
        return "calc(" + stringify2(node.value, prec) + ")";
      default:
        return round2(node.value, prec) + node.unit;
    }
  }
  module.exports = exports["default"];
})(stringifier, stringifier.exports);
var stringifierExports = stringifier.exports;
(function(module, exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  var _postcssValueParser = lib;
  var _postcssValueParser2 = _interopRequireDefault2(_postcssValueParser);
  var _parser = parser;
  var _reducer = reducer;
  var _reducer2 = _interopRequireDefault2(_reducer);
  var _stringifier = stringifierExports;
  var _stringifier2 = _interopRequireDefault2(_stringifier);
  function _interopRequireDefault2(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }
  var MATCH_CALC = /((?:\-[a-z]+\-)?calc)/;
  exports.default = function(value) {
    var precision = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 5;
    return (0, _postcssValueParser2.default)(value).walk(function(node) {
      if (node.type !== "function" || !MATCH_CALC.test(node.value))
        return;
      var contents = _postcssValueParser2.default.stringify(node.nodes);
      if (contents.indexOf("constant") >= 0 || contents.indexOf("env") >= 0)
        return;
      var ast = _parser.parser.parse(contents);
      var reducedAst = (0, _reducer2.default)(ast, precision);
      node.type = "word";
      node.value = (0, _stringifier2.default)(node.value, reducedAst, precision);
    }, true).toString();
  };
  module.exports = exports["default"];
})(dist, dist.exports);
var distExports = dist.exports;
const reduceCSSCalc = /* @__PURE__ */ getDefaultExportFromCjs(distExports);
function _typeof$n(obj) {
  "@babel/helpers - typeof";
  return _typeof$n = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$n(obj);
}
function ownKeys$j(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$j(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$j(Object(source), true).forEach(function(key) {
      _defineProperty$m(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$j(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$m(obj, key, value) {
  key = _toPropertyKey$n(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$n(arg) {
  var key = _toPrimitive$n(arg, "string");
  return _typeof$n(key) === "symbol" ? key : String(key);
}
function _toPrimitive$n(input2, hint) {
  if (_typeof$n(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$n(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function _toConsumableArray$8(arr) {
  return _arrayWithoutHoles$8(arr) || _iterableToArray$8(arr) || _unsupportedIterableToArray$b(arr) || _nonIterableSpread$8();
}
function _nonIterableSpread$8() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$b(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$b(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$b(o, minLen);
}
function _iterableToArray$8(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$8(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$b(arr);
}
function _arrayLikeToArray$b(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var stringCache = {
  widthCache: {},
  cacheCount: 0
};
var MAX_CACHE_NUM = 2e3;
var SPAN_STYLE = {
  position: "absolute",
  top: "-20000px",
  left: 0,
  padding: 0,
  margin: 0,
  border: "none",
  whiteSpace: "pre"
};
var STYLE_LIST = ["minWidth", "maxWidth", "width", "minHeight", "maxHeight", "height", "top", "left", "fontSize", "lineHeight", "padding", "margin", "paddingLeft", "paddingRight", "paddingTop", "paddingBottom", "marginLeft", "marginRight", "marginTop", "marginBottom"];
var MEASUREMENT_SPAN_ID = "recharts_measurement_span";
function autoCompleteStyle(name, value) {
  if (STYLE_LIST.indexOf(name) >= 0 && value === +value) {
    return "".concat(value, "px");
  }
  return value;
}
function camelToMiddleLine(text) {
  var strs = text.split("");
  var formatStrs = strs.reduce(function(result, entry) {
    if (entry === entry.toUpperCase()) {
      return [].concat(_toConsumableArray$8(result), ["-", entry.toLowerCase()]);
    }
    return [].concat(_toConsumableArray$8(result), [entry]);
  }, []);
  return formatStrs.join("");
}
var getStyleString = function getStyleString2(style) {
  return Object.keys(style).reduce(function(result, s2) {
    return "".concat(result).concat(camelToMiddleLine(s2), ":").concat(autoCompleteStyle(s2, style[s2]), ";");
  }, "");
};
var getStringSize = function getStringSize2(text) {
  var style = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  if (text === void 0 || text === null || Global.isSsr) {
    return {
      width: 0,
      height: 0
    };
  }
  var str = "".concat(text);
  var styleString = getStyleString(style);
  var cacheKey = "".concat(str, "-").concat(styleString);
  if (stringCache.widthCache[cacheKey]) {
    return stringCache.widthCache[cacheKey];
  }
  try {
    var measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);
    if (!measurementSpan) {
      measurementSpan = document.createElement("span");
      measurementSpan.setAttribute("id", MEASUREMENT_SPAN_ID);
      measurementSpan.setAttribute("aria-hidden", "true");
      document.body.appendChild(measurementSpan);
    }
    var measurementSpanStyle = _objectSpread$j(_objectSpread$j({}, SPAN_STYLE), style);
    Object.keys(measurementSpanStyle).map(function(styleKey) {
      measurementSpan.style[styleKey] = measurementSpanStyle[styleKey];
      return styleKey;
    });
    measurementSpan.textContent = str;
    var rect = measurementSpan.getBoundingClientRect();
    var result = {
      width: rect.width,
      height: rect.height
    };
    stringCache.widthCache[cacheKey] = result;
    if (++stringCache.cacheCount > MAX_CACHE_NUM) {
      stringCache.cacheCount = 0;
      stringCache.widthCache = {};
    }
    return result;
  } catch (e3) {
    return {
      width: 0,
      height: 0
    };
  }
};
var getOffset = function getOffset2(el) {
  var html = el.ownerDocument.documentElement;
  var box = {
    top: 0,
    left: 0
  };
  if (typeof el.getBoundingClientRect !== "undefined") {
    box = el.getBoundingClientRect();
  }
  return {
    top: box.top + window.pageYOffset - html.clientTop,
    left: box.left + window.pageXOffset - html.clientLeft
  };
};
var calculateChartCoordinate = function calculateChartCoordinate2(event, offset) {
  return {
    chartX: Math.round(event.pageX - offset.left),
    chartY: Math.round(event.pageY - offset.top)
  };
};
var _excluded$a = ["dx", "dy", "textAnchor", "verticalAnchor", "scaleToFit", "angle", "lineHeight", "capHeight", "className", "breakAll"];
function _typeof$m(obj) {
  "@babel/helpers - typeof";
  return _typeof$m = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$m(obj);
}
function _extends$j() {
  _extends$j = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$j.apply(this, arguments);
}
function _objectWithoutProperties$a(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$a(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$a(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$e(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$e(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$m(descriptor.key), descriptor);
  }
}
function _createClass$e(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$e(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$e(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$d(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$d(subClass, superClass);
}
function _setPrototypeOf$d(o, p2) {
  _setPrototypeOf$d = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$d(o, p2);
}
function _createSuper$d(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$d();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$d(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$d(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$d(this, result);
  };
}
function _possibleConstructorReturn$d(self2, call) {
  if (call && (_typeof$m(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$d(self2);
}
function _assertThisInitialized$d(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$d() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$d(o) {
  _getPrototypeOf$d = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$d(o);
}
function _slicedToArray$4(arr, i) {
  return _arrayWithHoles$4(arr) || _iterableToArrayLimit$4(arr, i) || _unsupportedIterableToArray$a(arr, i) || _nonIterableRest$4();
}
function _nonIterableRest$4() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$a(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$a(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$a(o, minLen);
}
function _arrayLikeToArray$a(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$4(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$4(arr) {
  if (Array.isArray(arr))
    return arr;
}
function ownKeys$i(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$i(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$i(Object(source), true).forEach(function(key) {
      _defineProperty$l(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$i(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$l(obj, key, value) {
  key = _toPropertyKey$m(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$m(arg) {
  var key = _toPrimitive$m(arg, "string");
  return _typeof$m(key) === "symbol" ? key : String(key);
}
function _toPrimitive$m(input2, hint) {
  if (_typeof$m(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$m(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var BREAKING_SPACES = /[ \f\n\r\t\v\u2028\u2029]+/;
var calculateWordWidths = function calculateWordWidths2(props) {
  try {
    var words = [];
    if (!_isNil(props.children)) {
      if (props.breakAll) {
        words = props.children.toString().split("");
      } else {
        words = props.children.toString().split(BREAKING_SPACES);
      }
    }
    var wordsWithComputedWidth = words.map(function(word) {
      return {
        word,
        width: getStringSize(word, props.style).width
      };
    });
    var spaceWidth = props.breakAll ? 0 : getStringSize(" ", props.style).width;
    return {
      wordsWithComputedWidth,
      spaceWidth
    };
  } catch (e3) {
    return null;
  }
};
var calculateWordsByLines = function calculateWordsByLines2(props, initialWordsWithComputedWith, spaceWidth, lineWidth, scaleToFit) {
  var shouldLimitLines = isNumber(props.maxLines);
  var text = props.children;
  var calculate = function calculate2() {
    var words = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
    return words.reduce(function(result2, _ref) {
      var word = _ref.word, width = _ref.width;
      var currentLine = result2[result2.length - 1];
      if (currentLine && (lineWidth == null || scaleToFit || currentLine.width + width + spaceWidth < lineWidth)) {
        currentLine.words.push(word);
        currentLine.width += width + spaceWidth;
      } else {
        var newLine = {
          words: [word],
          width
        };
        result2.push(newLine);
      }
      return result2;
    }, []);
  };
  var originalResult = calculate(initialWordsWithComputedWith);
  var findLongestLine = function findLongestLine2(words) {
    return words.reduce(function(a2, b2) {
      return a2.width > b2.width ? a2 : b2;
    });
  };
  if (!shouldLimitLines) {
    return originalResult;
  }
  var suffix = "…";
  var checkOverflow = function checkOverflow2(index) {
    var tempText = text.slice(0, index);
    var words = calculateWordWidths(_objectSpread$i(_objectSpread$i({}, props), {}, {
      children: tempText + suffix
    })).wordsWithComputedWidth;
    var result2 = calculate(words);
    var doesOverflow = result2.length > props.maxLines || findLongestLine(result2).width > lineWidth;
    return [doesOverflow, result2];
  };
  var start = 0;
  var end = text.length - 1;
  var iterations = 0;
  var trimmedResult;
  while (start <= end && iterations <= text.length - 1) {
    var middle = Math.floor((start + end) / 2);
    var prev = middle - 1;
    var _checkOverflow = checkOverflow(prev), _checkOverflow2 = _slicedToArray$4(_checkOverflow, 2), doesPrevOverflow = _checkOverflow2[0], result = _checkOverflow2[1];
    var _checkOverflow3 = checkOverflow(middle), _checkOverflow4 = _slicedToArray$4(_checkOverflow3, 1), doesMiddleOverflow = _checkOverflow4[0];
    if (!doesPrevOverflow && !doesMiddleOverflow) {
      start = middle + 1;
    }
    if (doesPrevOverflow && doesMiddleOverflow) {
      end = middle - 1;
    }
    if (!doesPrevOverflow && doesMiddleOverflow) {
      trimmedResult = result;
      break;
    }
    iterations++;
  }
  return trimmedResult || originalResult;
};
var getWordsWithoutCalculate = function getWordsWithoutCalculate2(children) {
  var words = !_isNil(children) ? children.toString().split(BREAKING_SPACES) : [];
  return [{
    words
  }];
};
var getWordsByLines = function getWordsByLines2(props, needCalculate) {
  if ((props.width || props.scaleToFit) && !Global.isSsr) {
    var wordsWithComputedWidth, spaceWidth;
    if (needCalculate) {
      var wordWidths = calculateWordWidths(props);
      if (wordWidths) {
        var wcw = wordWidths.wordsWithComputedWidth, sw = wordWidths.spaceWidth;
        wordsWithComputedWidth = wcw;
        spaceWidth = sw;
      } else {
        return getWordsWithoutCalculate(props.children);
      }
      return calculateWordsByLines(props, wordsWithComputedWidth, spaceWidth, props.width, props.scaleToFit);
    }
  }
  return getWordsWithoutCalculate(props.children);
};
var Text = /* @__PURE__ */ function(_Component) {
  _inherits$d(Text2, _Component);
  var _super = _createSuper$d(Text2);
  function Text2() {
    var _this;
    _classCallCheck$e(this, Text2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$l(_assertThisInitialized$d(_this), "state", {});
    return _this;
  }
  _createClass$e(Text2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, dx = _this$props.dx, dy = _this$props.dy, textAnchor = _this$props.textAnchor, verticalAnchor = _this$props.verticalAnchor, scaleToFit = _this$props.scaleToFit, angle = _this$props.angle, lineHeight = _this$props.lineHeight, capHeight = _this$props.capHeight, className = _this$props.className, breakAll = _this$props.breakAll, textProps = _objectWithoutProperties$a(_this$props, _excluded$a);
      var wordsByLines = this.state.wordsByLines;
      if (!isNumOrStr(textProps.x) || !isNumOrStr(textProps.y)) {
        return null;
      }
      var x2 = textProps.x + (isNumber(dx) ? dx : 0);
      var y2 = textProps.y + (isNumber(dy) ? dy : 0);
      var startDy;
      switch (verticalAnchor) {
        case "start":
          startDy = reduceCSSCalc("calc(".concat(capHeight, ")"));
          break;
        case "middle":
          startDy = reduceCSSCalc("calc(".concat((wordsByLines.length - 1) / 2, " * -").concat(lineHeight, " + (").concat(capHeight, " / 2))"));
          break;
        default:
          startDy = reduceCSSCalc("calc(".concat(wordsByLines.length - 1, " * -").concat(lineHeight, ")"));
          break;
      }
      var transforms = [];
      if (scaleToFit) {
        var lineWidth = wordsByLines[0].width;
        var width = this.props.width;
        transforms.push("scale(".concat((isNumber(width) ? width / lineWidth : 1) / lineWidth, ")"));
      }
      if (angle) {
        transforms.push("rotate(".concat(angle, ", ").concat(x2, ", ").concat(y2, ")"));
      }
      if (transforms.length) {
        textProps.transform = transforms.join(" ");
      }
      return /* @__PURE__ */ React.createElement("text", _extends$j({}, filterProps(textProps, true), {
        x: x2,
        y: y2,
        className: classNames("recharts-text", className),
        textAnchor,
        fill: textProps.fill.includes("url") ? Text2.defaultProps.fill : textProps.fill
      }), wordsByLines.map(function(line, index) {
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ React.createElement("tspan", {
            x: x2,
            dy: index === 0 ? startDy : lineHeight,
            key: index
          }, line.words.join(breakAll ? "" : " "))
        );
      }));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.width !== prevState.prevWidth || nextProps.scaleToFit !== prevState.prevScaleToFit || nextProps.children !== prevState.prevChildren || nextProps.style !== prevState.prevStyle || nextProps.breakAll !== prevState.prevBreakAll) {
        var needCalculate = nextProps.children !== prevState.prevChildren || nextProps.style !== prevState.prevStyle || nextProps.breakAll !== prevState.prevBreakAll;
        return {
          prevWidth: nextProps.width,
          prevScaleToFit: nextProps.scaleToFit,
          prevChildren: nextProps.children,
          prevStyle: nextProps.style,
          wordsByLines: getWordsByLines(nextProps, needCalculate)
        };
      }
      return null;
    }
  }]);
  return Text2;
}(reactExports.Component);
_defineProperty$l(Text, "defaultProps", {
  x: 0,
  y: 0,
  lineHeight: "1em",
  capHeight: "0.71em",
  // Magic number from d3
  scaleToFit: false,
  textAnchor: "start",
  verticalAnchor: "end",
  // Maintain compat with existing charts / default SVG behavior
  fill: "#808080"
});
var baseIsEqual = _baseIsEqual;
function isEqual(value, other) {
  return baseIsEqual(value, other);
}
var isEqual_1 = isEqual;
const _isEqual = /* @__PURE__ */ getDefaultExportFromCjs(isEqual_1);
var isSymbol$1 = isSymbol_1$1;
function baseExtremum$2(array2, iteratee, comparator) {
  var index = -1, length = array2.length;
  while (++index < length) {
    var value = array2[index], current = iteratee(value);
    if (current != null && (computed === void 0 ? current === current && !isSymbol$1(current) : comparator(current, computed))) {
      var computed = current, result = value;
    }
  }
  return result;
}
var _baseExtremum = baseExtremum$2;
function baseGt$1(value, other) {
  return value > other;
}
var _baseGt = baseGt$1;
var baseExtremum$1 = _baseExtremum, baseGt = _baseGt, identity$5 = identity_1;
function max$1(array2) {
  return array2 && array2.length ? baseExtremum$1(array2, identity$5, baseGt) : void 0;
}
var max_1 = max$1;
const _max = /* @__PURE__ */ getDefaultExportFromCjs(max_1);
function baseLt$1(value, other) {
  return value < other;
}
var _baseLt = baseLt$1;
var baseExtremum = _baseExtremum, baseLt = _baseLt, identity$4 = identity_1;
function min$1(array2) {
  return array2 && array2.length ? baseExtremum(array2, identity$4, baseLt) : void 0;
}
var min_1 = min$1;
const _min = /* @__PURE__ */ getDefaultExportFromCjs(min_1);
var arrayMap = _arrayMap, baseIteratee$5 = _baseIteratee, baseMap = _baseMap, isArray$2 = isArray_1;
function map$3(collection, iteratee) {
  var func = isArray$2(collection) ? arrayMap : baseMap;
  return func(collection, baseIteratee$5(iteratee));
}
var map_1 = map$3;
var baseFlatten = _baseFlatten, map$2 = map_1;
function flatMap(collection, iteratee) {
  return baseFlatten(map$2(collection, iteratee), 1);
}
var flatMap_1 = flatMap;
const _flatMap = /* @__PURE__ */ getDefaultExportFromCjs(flatMap_1);
function ascending(a2, b2) {
  return a2 == null || b2 == null ? NaN : a2 < b2 ? -1 : a2 > b2 ? 1 : a2 >= b2 ? 0 : NaN;
}
function descending(a2, b2) {
  return a2 == null || b2 == null ? NaN : b2 < a2 ? -1 : b2 > a2 ? 1 : b2 >= a2 ? 0 : NaN;
}
function bisector(f2) {
  let compare1, compare2, delta;
  if (f2.length !== 2) {
    compare1 = ascending;
    compare2 = (d2, x2) => ascending(f2(d2), x2);
    delta = (d2, x2) => f2(d2) - x2;
  } else {
    compare1 = f2 === ascending || f2 === descending ? f2 : zero$1;
    compare2 = f2;
    delta = f2;
  }
  function left(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) < 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function right(a2, x2, lo = 0, hi = a2.length) {
    if (lo < hi) {
      if (compare1(x2, x2) !== 0)
        return hi;
      do {
        const mid = lo + hi >>> 1;
        if (compare2(a2[mid], x2) <= 0)
          lo = mid + 1;
        else
          hi = mid;
      } while (lo < hi);
    }
    return lo;
  }
  function center(a2, x2, lo = 0, hi = a2.length) {
    const i = left(a2, x2, lo, hi - 1);
    return i > lo && delta(a2[i - 1], x2) > -delta(a2[i], x2) ? i - 1 : i;
  }
  return { left, center, right };
}
function zero$1() {
  return 0;
}
function number$2(x2) {
  return x2 === null ? NaN : +x2;
}
function* numbers(values, valueof) {
  if (valueof === void 0) {
    for (let value of values) {
      if (value != null && (value = +value) >= value) {
        yield value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (value = +value) >= value) {
        yield value;
      }
    }
  }
}
const ascendingBisect = bisector(ascending);
const bisectRight = ascendingBisect.right;
bisector(number$2).center;
class InternMap extends Map {
  constructor(entries, key = keyof) {
    super();
    Object.defineProperties(this, { _intern: { value: /* @__PURE__ */ new Map() }, _key: { value: key } });
    if (entries != null)
      for (const [key2, value] of entries)
        this.set(key2, value);
  }
  get(key) {
    return super.get(intern_get(this, key));
  }
  has(key) {
    return super.has(intern_get(this, key));
  }
  set(key, value) {
    return super.set(intern_set(this, key), value);
  }
  delete(key) {
    return super.delete(intern_delete(this, key));
  }
}
function intern_get({ _intern, _key }, value) {
  const key = _key(value);
  return _intern.has(key) ? _intern.get(key) : value;
}
function intern_set({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key))
    return _intern.get(key);
  _intern.set(key, value);
  return value;
}
function intern_delete({ _intern, _key }, value) {
  const key = _key(value);
  if (_intern.has(key)) {
    value = _intern.get(key);
    _intern.delete(key);
  }
  return value;
}
function keyof(value) {
  return value !== null && typeof value === "object" ? value.valueOf() : value;
}
function compareDefined(compare = ascending) {
  if (compare === ascending)
    return ascendingDefined;
  if (typeof compare !== "function")
    throw new TypeError("compare is not a function");
  return (a2, b2) => {
    const x2 = compare(a2, b2);
    if (x2 || x2 === 0)
      return x2;
    return (compare(b2, b2) === 0) - (compare(a2, a2) === 0);
  };
}
function ascendingDefined(a2, b2) {
  return (a2 == null || !(a2 >= a2)) - (b2 == null || !(b2 >= b2)) || (a2 < b2 ? -1 : a2 > b2 ? 1 : 0);
}
const e10 = Math.sqrt(50), e5 = Math.sqrt(10), e2 = Math.sqrt(2);
function tickSpec(start, stop, count) {
  const step = (stop - start) / Math.max(0, count), power = Math.floor(Math.log10(step)), error = step / Math.pow(10, power), factor = error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1;
  let i1, i2, inc;
  if (power < 0) {
    inc = Math.pow(10, -power) / factor;
    i1 = Math.round(start * inc);
    i2 = Math.round(stop * inc);
    if (i1 / inc < start)
      ++i1;
    if (i2 / inc > stop)
      --i2;
    inc = -inc;
  } else {
    inc = Math.pow(10, power) * factor;
    i1 = Math.round(start / inc);
    i2 = Math.round(stop / inc);
    if (i1 * inc < start)
      ++i1;
    if (i2 * inc > stop)
      --i2;
  }
  if (i2 < i1 && 0.5 <= count && count < 2)
    return tickSpec(start, stop, count * 2);
  return [i1, i2, inc];
}
function ticks(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  if (!(count > 0))
    return [];
  if (start === stop)
    return [start];
  const reverse3 = stop < start, [i1, i2, inc] = reverse3 ? tickSpec(stop, start, count) : tickSpec(start, stop, count);
  if (!(i2 >= i1))
    return [];
  const n2 = i2 - i1 + 1, ticks2 = new Array(n2);
  if (reverse3) {
    if (inc < 0)
      for (let i = 0; i < n2; ++i)
        ticks2[i] = (i2 - i) / -inc;
    else
      for (let i = 0; i < n2; ++i)
        ticks2[i] = (i2 - i) * inc;
  } else {
    if (inc < 0)
      for (let i = 0; i < n2; ++i)
        ticks2[i] = (i1 + i) / -inc;
    else
      for (let i = 0; i < n2; ++i)
        ticks2[i] = (i1 + i) * inc;
  }
  return ticks2;
}
function tickIncrement(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  return tickSpec(start, stop, count)[2];
}
function tickStep(start, stop, count) {
  stop = +stop, start = +start, count = +count;
  const reverse3 = stop < start, inc = reverse3 ? tickIncrement(stop, start, count) : tickIncrement(start, stop, count);
  return (reverse3 ? -1 : 1) * (inc < 0 ? 1 / -inc : inc);
}
function max(values, valueof) {
  let max2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (max2 < value || max2 === void 0 && value >= value)) {
        max2 = value;
      }
    }
  }
  return max2;
}
function min(values, valueof) {
  let min2;
  if (valueof === void 0) {
    for (const value of values) {
      if (value != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  } else {
    let index = -1;
    for (let value of values) {
      if ((value = valueof(value, ++index, values)) != null && (min2 > value || min2 === void 0 && value >= value)) {
        min2 = value;
      }
    }
  }
  return min2;
}
function quickselect(array2, k2, left = 0, right = Infinity, compare) {
  k2 = Math.floor(k2);
  left = Math.floor(Math.max(0, left));
  right = Math.floor(Math.min(array2.length - 1, right));
  if (!(left <= k2 && k2 <= right))
    return array2;
  compare = compare === void 0 ? ascendingDefined : compareDefined(compare);
  while (right > left) {
    if (right - left > 600) {
      const n2 = right - left + 1;
      const m2 = k2 - left + 1;
      const z2 = Math.log(n2);
      const s2 = 0.5 * Math.exp(2 * z2 / 3);
      const sd = 0.5 * Math.sqrt(z2 * s2 * (n2 - s2) / n2) * (m2 - n2 / 2 < 0 ? -1 : 1);
      const newLeft = Math.max(left, Math.floor(k2 - m2 * s2 / n2 + sd));
      const newRight = Math.min(right, Math.floor(k2 + (n2 - m2) * s2 / n2 + sd));
      quickselect(array2, k2, newLeft, newRight, compare);
    }
    const t2 = array2[k2];
    let i = left;
    let j = right;
    swap(array2, left, k2);
    if (compare(array2[right], t2) > 0)
      swap(array2, left, right);
    while (i < j) {
      swap(array2, i, j), ++i, --j;
      while (compare(array2[i], t2) < 0)
        ++i;
      while (compare(array2[j], t2) > 0)
        --j;
    }
    if (compare(array2[left], t2) === 0)
      swap(array2, left, j);
    else
      ++j, swap(array2, j, right);
    if (j <= k2)
      left = j + 1;
    if (k2 <= j)
      right = j - 1;
  }
  return array2;
}
function swap(array2, i, j) {
  const t2 = array2[i];
  array2[i] = array2[j];
  array2[j] = t2;
}
function quantile$1(values, p2, valueof) {
  values = Float64Array.from(numbers(values, valueof));
  if (!(n2 = values.length) || isNaN(p2 = +p2))
    return;
  if (p2 <= 0 || n2 < 2)
    return min(values);
  if (p2 >= 1)
    return max(values);
  var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = max(quickselect(values, i0).subarray(0, i0 + 1)), value1 = min(values.subarray(i0 + 1));
  return value0 + (value1 - value0) * (i - i0);
}
function quantileSorted(values, p2, valueof = number$2) {
  if (!(n2 = values.length) || isNaN(p2 = +p2))
    return;
  if (p2 <= 0 || n2 < 2)
    return +valueof(values[0], 0, values);
  if (p2 >= 1)
    return +valueof(values[n2 - 1], n2 - 1, values);
  var n2, i = (n2 - 1) * p2, i0 = Math.floor(i), value0 = +valueof(values[i0], i0, values), value1 = +valueof(values[i0 + 1], i0 + 1, values);
  return value0 + (value1 - value0) * (i - i0);
}
function range$2(start, stop, step) {
  start = +start, stop = +stop, step = (n2 = arguments.length) < 2 ? (stop = start, start = 0, 1) : n2 < 3 ? 1 : +step;
  var i = -1, n2 = Math.max(0, Math.ceil((stop - start) / step)) | 0, range3 = new Array(n2);
  while (++i < n2) {
    range3[i] = start + i * step;
  }
  return range3;
}
function initRange(domain, range3) {
  switch (arguments.length) {
    case 0:
      break;
    case 1:
      this.range(domain);
      break;
    default:
      this.range(range3).domain(domain);
      break;
  }
  return this;
}
function initInterpolator(domain, interpolator) {
  switch (arguments.length) {
    case 0:
      break;
    case 1: {
      if (typeof domain === "function")
        this.interpolator(domain);
      else
        this.range(domain);
      break;
    }
    default: {
      this.domain(domain);
      if (typeof interpolator === "function")
        this.interpolator(interpolator);
      else
        this.range(interpolator);
      break;
    }
  }
  return this;
}
const implicit = Symbol("implicit");
function ordinal() {
  var index = new InternMap(), domain = [], range3 = [], unknown = implicit;
  function scale2(d2) {
    let i = index.get(d2);
    if (i === void 0) {
      if (unknown !== implicit)
        return unknown;
      index.set(d2, i = domain.push(d2) - 1);
    }
    return range3[i % range3.length];
  }
  scale2.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [], index = new InternMap();
    for (const value of _) {
      if (index.has(value))
        continue;
      index.set(value, domain.push(value) - 1);
    }
    return scale2;
  };
  scale2.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), scale2) : range3.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return ordinal(domain, range3).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function band() {
  var scale2 = ordinal().unknown(void 0), domain = scale2.domain, ordinalRange = scale2.range, r0 = 0, r1 = 1, step, bandwidth, round2 = false, paddingInner = 0, paddingOuter = 0, align = 0.5;
  delete scale2.unknown;
  function rescale() {
    var n2 = domain().length, reverse3 = r1 < r0, start = reverse3 ? r1 : r0, stop = reverse3 ? r0 : r1;
    step = (stop - start) / Math.max(1, n2 - paddingInner + paddingOuter * 2);
    if (round2)
      step = Math.floor(step);
    start += (stop - start - step * (n2 - paddingInner)) * align;
    bandwidth = step * (1 - paddingInner);
    if (round2)
      start = Math.round(start), bandwidth = Math.round(bandwidth);
    var values = range$2(n2).map(function(i) {
      return start + step * i;
    });
    return ordinalRange(reverse3 ? values.reverse() : values);
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale2.range = function(_) {
    return arguments.length ? ([r0, r1] = _, r0 = +r0, r1 = +r1, rescale()) : [r0, r1];
  };
  scale2.rangeRound = function(_) {
    return [r0, r1] = _, r0 = +r0, r1 = +r1, round2 = true, rescale();
  };
  scale2.bandwidth = function() {
    return bandwidth;
  };
  scale2.step = function() {
    return step;
  };
  scale2.round = function(_) {
    return arguments.length ? (round2 = !!_, rescale()) : round2;
  };
  scale2.padding = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, paddingOuter = +_), rescale()) : paddingInner;
  };
  scale2.paddingInner = function(_) {
    return arguments.length ? (paddingInner = Math.min(1, _), rescale()) : paddingInner;
  };
  scale2.paddingOuter = function(_) {
    return arguments.length ? (paddingOuter = +_, rescale()) : paddingOuter;
  };
  scale2.align = function(_) {
    return arguments.length ? (align = Math.max(0, Math.min(1, _)), rescale()) : align;
  };
  scale2.copy = function() {
    return band(domain(), [r0, r1]).round(round2).paddingInner(paddingInner).paddingOuter(paddingOuter).align(align);
  };
  return initRange.apply(rescale(), arguments);
}
function pointish(scale2) {
  var copy2 = scale2.copy;
  scale2.padding = scale2.paddingOuter;
  delete scale2.paddingInner;
  delete scale2.paddingOuter;
  scale2.copy = function() {
    return pointish(copy2());
  };
  return scale2;
}
function point() {
  return pointish(band.apply(null, arguments).paddingInner(1));
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp(`^rgb\\(${reI},${reI},${reI}\\)$`), reRgbPercent = new RegExp(`^rgb\\(${reP},${reP},${reP}\\)$`), reRgbaInteger = new RegExp(`^rgba\\(${reI},${reI},${reI},${reN}\\)$`), reRgbaPercent = new RegExp(`^rgba\\(${reP},${reP},${reP},${reN}\\)$`), reHslPercent = new RegExp(`^hsl\\(${reN},${reP},${reP}\\)$`), reHslaPercent = new RegExp(`^hsla\\(${reN},${reP},${reP},${reN}\\)$`);
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color, color, {
  copy(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHex8: color_formatHex8,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHex8() {
  return this.rgb().formatHex8();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color(format2) {
  var m2, l2;
  format2 = (format2 + "").trim().toLowerCase();
  return (m2 = reHex.exec(format2)) ? (l2 = m2[1].length, m2 = parseInt(m2[1], 16), l2 === 6 ? rgbn(m2) : l2 === 3 ? new Rgb(m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, (m2 & 15) << 4 | m2 & 15, 1) : l2 === 8 ? rgba(m2 >> 24 & 255, m2 >> 16 & 255, m2 >> 8 & 255, (m2 & 255) / 255) : l2 === 4 ? rgba(m2 >> 12 & 15 | m2 >> 8 & 240, m2 >> 8 & 15 | m2 >> 4 & 240, m2 >> 4 & 15 | m2 & 240, ((m2 & 15) << 4 | m2 & 15) / 255) : null) : (m2 = reRgbInteger.exec(format2)) ? new Rgb(m2[1], m2[2], m2[3], 1) : (m2 = reRgbPercent.exec(format2)) ? new Rgb(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, 1) : (m2 = reRgbaInteger.exec(format2)) ? rgba(m2[1], m2[2], m2[3], m2[4]) : (m2 = reRgbaPercent.exec(format2)) ? rgba(m2[1] * 255 / 100, m2[2] * 255 / 100, m2[3] * 255 / 100, m2[4]) : (m2 = reHslPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, 1) : (m2 = reHslaPercent.exec(format2)) ? hsla(m2[1], m2[2] / 100, m2[3] / 100, m2[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n2) {
  return new Rgb(n2 >> 16 & 255, n2 >> 8 & 255, n2 & 255, 1);
}
function rgba(r2, g2, b2, a2) {
  if (a2 <= 0)
    r2 = g2 = b2 = NaN;
  return new Rgb(r2, g2, b2, a2);
}
function rgbConvert(o) {
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb$1(r2, g2, b2, opacity) {
  return arguments.length === 1 ? rgbConvert(r2) : new Rgb(r2, g2, b2, opacity == null ? 1 : opacity);
}
function Rgb(r2, g2, b2, opacity) {
  this.r = +r2;
  this.g = +g2;
  this.b = +b2;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Rgb(this.r * k2, this.g * k2, this.b * k2, this.opacity);
  },
  rgb() {
    return this;
  },
  clamp() {
    return new Rgb(clampi(this.r), clampi(this.g), clampi(this.b), clampa(this.opacity));
  },
  displayable() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatHex8: rgb_formatHex8,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}`;
}
function rgb_formatHex8() {
  return `#${hex(this.r)}${hex(this.g)}${hex(this.b)}${hex((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
}
function rgb_formatRgb() {
  const a2 = clampa(this.opacity);
  return `${a2 === 1 ? "rgb(" : "rgba("}${clampi(this.r)}, ${clampi(this.g)}, ${clampi(this.b)}${a2 === 1 ? ")" : `, ${a2})`}`;
}
function clampa(opacity) {
  return isNaN(opacity) ? 1 : Math.max(0, Math.min(1, opacity));
}
function clampi(value) {
  return Math.max(0, Math.min(255, Math.round(value) || 0));
}
function hex(value) {
  value = clampi(value);
  return (value < 16 ? "0" : "") + value.toString(16);
}
function hsla(h2, s2, l2, a2) {
  if (a2 <= 0)
    h2 = s2 = l2 = NaN;
  else if (l2 <= 0 || l2 >= 1)
    h2 = s2 = NaN;
  else if (s2 <= 0)
    h2 = NaN;
  return new Hsl(h2, s2, l2, a2);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color))
    o = color(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r2 = o.r / 255, g2 = o.g / 255, b2 = o.b / 255, min2 = Math.min(r2, g2, b2), max2 = Math.max(r2, g2, b2), h2 = NaN, s2 = max2 - min2, l2 = (max2 + min2) / 2;
  if (s2) {
    if (r2 === max2)
      h2 = (g2 - b2) / s2 + (g2 < b2) * 6;
    else if (g2 === max2)
      h2 = (b2 - r2) / s2 + 2;
    else
      h2 = (r2 - g2) / s2 + 4;
    s2 /= l2 < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h2 *= 60;
  } else {
    s2 = l2 > 0 && l2 < 1 ? 0 : h2;
  }
  return new Hsl(h2, s2, l2, o.opacity);
}
function hsl(h2, s2, l2, opacity) {
  return arguments.length === 1 ? hslConvert(h2) : new Hsl(h2, s2, l2, opacity == null ? 1 : opacity);
}
function Hsl(h2, s2, l2, opacity) {
  this.h = +h2;
  this.s = +s2;
  this.l = +l2;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color, {
  brighter(k2) {
    k2 = k2 == null ? brighter : Math.pow(brighter, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  darker(k2) {
    k2 = k2 == null ? darker : Math.pow(darker, k2);
    return new Hsl(this.h, this.s, this.l * k2, this.opacity);
  },
  rgb() {
    var h2 = this.h % 360 + (this.h < 0) * 360, s2 = isNaN(h2) || isNaN(this.s) ? 0 : this.s, l2 = this.l, m2 = l2 + (l2 < 0.5 ? l2 : 1 - l2) * s2, m1 = 2 * l2 - m2;
    return new Rgb(
      hsl2rgb(h2 >= 240 ? h2 - 240 : h2 + 120, m1, m2),
      hsl2rgb(h2, m1, m2),
      hsl2rgb(h2 < 120 ? h2 + 240 : h2 - 120, m1, m2),
      this.opacity
    );
  },
  clamp() {
    return new Hsl(clamph(this.h), clampt(this.s), clampt(this.l), clampa(this.opacity));
  },
  displayable() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl() {
    const a2 = clampa(this.opacity);
    return `${a2 === 1 ? "hsl(" : "hsla("}${clamph(this.h)}, ${clampt(this.s) * 100}%, ${clampt(this.l) * 100}%${a2 === 1 ? ")" : `, ${a2})`}`;
  }
}));
function clamph(value) {
  value = (value || 0) % 360;
  return value < 0 ? value + 360 : value;
}
function clampt(value) {
  return Math.max(0, Math.min(1, value || 0));
}
function hsl2rgb(h2, m1, m2) {
  return (h2 < 60 ? m1 + (m2 - m1) * h2 / 60 : h2 < 180 ? m2 : h2 < 240 ? m1 + (m2 - m1) * (240 - h2) / 60 : m1) * 255;
}
const constant = (x2) => () => x2;
function linear$1(a2, d2) {
  return function(t2) {
    return a2 + t2 * d2;
  };
}
function exponential(a2, b2, y2) {
  return a2 = Math.pow(a2, y2), b2 = Math.pow(b2, y2) - a2, y2 = 1 / y2, function(t2) {
    return Math.pow(a2 + t2 * b2, y2);
  };
}
function gamma(y2) {
  return (y2 = +y2) === 1 ? nogamma : function(a2, b2) {
    return b2 - a2 ? exponential(a2, b2, y2) : constant(isNaN(a2) ? b2 : a2);
  };
}
function nogamma(a2, b2) {
  var d2 = b2 - a2;
  return d2 ? linear$1(a2, d2) : constant(isNaN(a2) ? b2 : a2);
}
const rgb = function rgbGamma(y2) {
  var color2 = gamma(y2);
  function rgb2(start, end) {
    var r2 = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g2 = color2(start.g, end.g), b2 = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t2) {
      start.r = r2(t2);
      start.g = g2(t2);
      start.b = b2(t2);
      start.opacity = opacity(t2);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function numberArray(a2, b2) {
  if (!b2)
    b2 = [];
  var n2 = a2 ? Math.min(b2.length, a2.length) : 0, c2 = b2.slice(), i;
  return function(t2) {
    for (i = 0; i < n2; ++i)
      c2[i] = a2[i] * (1 - t2) + b2[i] * t2;
    return c2;
  };
}
function isNumberArray(x2) {
  return ArrayBuffer.isView(x2) && !(x2 instanceof DataView);
}
function genericArray(a2, b2) {
  var nb = b2 ? b2.length : 0, na = a2 ? Math.min(nb, a2.length) : 0, x2 = new Array(na), c2 = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x2[i] = interpolate(a2[i], b2[i]);
  for (; i < nb; ++i)
    c2[i] = b2[i];
  return function(t2) {
    for (i = 0; i < na; ++i)
      c2[i] = x2[i](t2);
    return c2;
  };
}
function date$1(a2, b2) {
  var d2 = /* @__PURE__ */ new Date();
  return a2 = +a2, b2 = +b2, function(t2) {
    return d2.setTime(a2 * (1 - t2) + b2 * t2), d2;
  };
}
function interpolateNumber$1(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return a2 * (1 - t2) + b2 * t2;
  };
}
function object(a2, b2) {
  var i = {}, c2 = {}, k2;
  if (a2 === null || typeof a2 !== "object")
    a2 = {};
  if (b2 === null || typeof b2 !== "object")
    b2 = {};
  for (k2 in b2) {
    if (k2 in a2) {
      i[k2] = interpolate(a2[k2], b2[k2]);
    } else {
      c2[k2] = b2[k2];
    }
  }
  return function(t2) {
    for (k2 in i)
      c2[k2] = i[k2](t2);
    return c2;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b2) {
  return function() {
    return b2;
  };
}
function one(b2) {
  return function(t2) {
    return b2(t2) + "";
  };
}
function string(a2, b2) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s2 = [], q2 = [];
  a2 = a2 + "", b2 = b2 + "";
  while ((am = reA.exec(a2)) && (bm = reB.exec(b2))) {
    if ((bs = bm.index) > bi) {
      bs = b2.slice(bi, bs);
      if (s2[i])
        s2[i] += bs;
      else
        s2[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s2[i])
        s2[i] += bm;
      else
        s2[++i] = bm;
    } else {
      s2[++i] = null;
      q2.push({ i, x: interpolateNumber$1(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b2.length) {
    bs = b2.slice(bi);
    if (s2[i])
      s2[i] += bs;
    else
      s2[++i] = bs;
  }
  return s2.length < 2 ? q2[0] ? one(q2[0].x) : zero(b2) : (b2 = q2.length, function(t2) {
    for (var i2 = 0, o; i2 < b2; ++i2)
      s2[(o = q2[i2]).i] = o.x(t2);
    return s2.join("");
  });
}
function interpolate(a2, b2) {
  var t2 = typeof b2, c2;
  return b2 == null || t2 === "boolean" ? constant(b2) : (t2 === "number" ? interpolateNumber$1 : t2 === "string" ? (c2 = color(b2)) ? (b2 = c2, rgb) : string : b2 instanceof color ? rgb : b2 instanceof Date ? date$1 : isNumberArray(b2) ? numberArray : Array.isArray(b2) ? genericArray : typeof b2.valueOf !== "function" && typeof b2.toString !== "function" || isNaN(b2) ? object : interpolateNumber$1)(a2, b2);
}
function interpolateRound(a2, b2) {
  return a2 = +a2, b2 = +b2, function(t2) {
    return Math.round(a2 * (1 - t2) + b2 * t2);
  };
}
function piecewise(interpolate$1, values) {
  if (values === void 0)
    values = interpolate$1, interpolate$1 = interpolate;
  var i = 0, n2 = values.length - 1, v2 = values[0], I = new Array(n2 < 0 ? 0 : n2);
  while (i < n2)
    I[i] = interpolate$1(v2, v2 = values[++i]);
  return function(t2) {
    var i2 = Math.max(0, Math.min(n2 - 1, Math.floor(t2 *= n2)));
    return I[i2](t2 - i2);
  };
}
function constants(x2) {
  return function() {
    return x2;
  };
}
function number$1(x2) {
  return +x2;
}
var unit = [0, 1];
function identity$3(x2) {
  return x2;
}
function normalize(a2, b2) {
  return (b2 -= a2 = +a2) ? function(x2) {
    return (x2 - a2) / b2;
  } : constants(isNaN(b2) ? NaN : 0.5);
}
function clamper(a2, b2) {
  var t2;
  if (a2 > b2)
    t2 = a2, a2 = b2, b2 = t2;
  return function(x2) {
    return Math.max(a2, Math.min(b2, x2));
  };
}
function bimap(domain, range3, interpolate2) {
  var d0 = domain[0], d1 = domain[1], r0 = range3[0], r1 = range3[1];
  if (d1 < d0)
    d0 = normalize(d1, d0), r0 = interpolate2(r1, r0);
  else
    d0 = normalize(d0, d1), r0 = interpolate2(r0, r1);
  return function(x2) {
    return r0(d0(x2));
  };
}
function polymap(domain, range3, interpolate2) {
  var j = Math.min(domain.length, range3.length) - 1, d2 = new Array(j), r2 = new Array(j), i = -1;
  if (domain[j] < domain[0]) {
    domain = domain.slice().reverse();
    range3 = range3.slice().reverse();
  }
  while (++i < j) {
    d2[i] = normalize(domain[i], domain[i + 1]);
    r2[i] = interpolate2(range3[i], range3[i + 1]);
  }
  return function(x2) {
    var i2 = bisectRight(domain, x2, 1, j) - 1;
    return r2[i2](d2[i2](x2));
  };
}
function copy$1(source, target) {
  return target.domain(source.domain()).range(source.range()).interpolate(source.interpolate()).clamp(source.clamp()).unknown(source.unknown());
}
function transformer$2() {
  var domain = unit, range3 = unit, interpolate$1 = interpolate, transform, untransform, unknown, clamp2 = identity$3, piecewise2, output, input2;
  function rescale() {
    var n2 = Math.min(domain.length, range3.length);
    if (clamp2 !== identity$3)
      clamp2 = clamper(domain[0], domain[n2 - 1]);
    piecewise2 = n2 > 2 ? polymap : bimap;
    output = input2 = null;
    return scale2;
  }
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : (output || (output = piecewise2(domain.map(transform), range3, interpolate$1)))(transform(clamp2(x2)));
  }
  scale2.invert = function(y2) {
    return clamp2(untransform((input2 || (input2 = piecewise2(range3, domain.map(transform), interpolateNumber$1)))(y2)));
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain = Array.from(_, number$1), rescale()) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), rescale()) : range3.slice();
  };
  scale2.rangeRound = function(_) {
    return range3 = Array.from(_), interpolate$1 = interpolateRound, rescale();
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = _ ? true : identity$3, rescale()) : clamp2 !== identity$3;
  };
  scale2.interpolate = function(_) {
    return arguments.length ? (interpolate$1 = _, rescale()) : interpolate$1;
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t2, u) {
    transform = t2, untransform = u;
    return rescale();
  };
}
function continuous() {
  return transformer$2()(identity$3, identity$3);
}
function formatDecimal(x2) {
  return Math.abs(x2 = Math.round(x2)) >= 1e21 ? x2.toLocaleString("en").replace(/,/g, "") : x2.toString(10);
}
function formatDecimalParts(x2, p2) {
  if ((i = (x2 = p2 ? x2.toExponential(p2 - 1) : x2.toExponential()).indexOf("e")) < 0)
    return null;
  var i, coefficient = x2.slice(0, i);
  return [
    coefficient.length > 1 ? coefficient[0] + coefficient.slice(2) : coefficient,
    +x2.slice(i + 1)
  ];
}
function exponent(x2) {
  return x2 = formatDecimalParts(Math.abs(x2)), x2 ? x2[1] : NaN;
}
function formatGroup(grouping, thousands) {
  return function(value, width) {
    var i = value.length, t2 = [], j = 0, g2 = grouping[0], length = 0;
    while (i > 0 && g2 > 0) {
      if (length + g2 + 1 > width)
        g2 = Math.max(1, width - length);
      t2.push(value.substring(i -= g2, i + g2));
      if ((length += g2 + 1) > width)
        break;
      g2 = grouping[j = (j + 1) % grouping.length];
    }
    return t2.reverse().join(thousands);
  };
}
function formatNumerals(numerals) {
  return function(value) {
    return value.replace(/[0-9]/g, function(i) {
      return numerals[+i];
    });
  };
}
var re = /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
function formatSpecifier(specifier) {
  if (!(match = re.exec(specifier)))
    throw new Error("invalid format: " + specifier);
  var match;
  return new FormatSpecifier({
    fill: match[1],
    align: match[2],
    sign: match[3],
    symbol: match[4],
    zero: match[5],
    width: match[6],
    comma: match[7],
    precision: match[8] && match[8].slice(1),
    trim: match[9],
    type: match[10]
  });
}
formatSpecifier.prototype = FormatSpecifier.prototype;
function FormatSpecifier(specifier) {
  this.fill = specifier.fill === void 0 ? " " : specifier.fill + "";
  this.align = specifier.align === void 0 ? ">" : specifier.align + "";
  this.sign = specifier.sign === void 0 ? "-" : specifier.sign + "";
  this.symbol = specifier.symbol === void 0 ? "" : specifier.symbol + "";
  this.zero = !!specifier.zero;
  this.width = specifier.width === void 0 ? void 0 : +specifier.width;
  this.comma = !!specifier.comma;
  this.precision = specifier.precision === void 0 ? void 0 : +specifier.precision;
  this.trim = !!specifier.trim;
  this.type = specifier.type === void 0 ? "" : specifier.type + "";
}
FormatSpecifier.prototype.toString = function() {
  return this.fill + this.align + this.sign + this.symbol + (this.zero ? "0" : "") + (this.width === void 0 ? "" : Math.max(1, this.width | 0)) + (this.comma ? "," : "") + (this.precision === void 0 ? "" : "." + Math.max(0, this.precision | 0)) + (this.trim ? "~" : "") + this.type;
};
function formatTrim(s2) {
  out:
    for (var n2 = s2.length, i = 1, i0 = -1, i1; i < n2; ++i) {
      switch (s2[i]) {
        case ".":
          i0 = i1 = i;
          break;
        case "0":
          if (i0 === 0)
            i0 = i;
          i1 = i;
          break;
        default:
          if (!+s2[i])
            break out;
          if (i0 > 0)
            i0 = 0;
          break;
      }
    }
  return i0 > 0 ? s2.slice(0, i0) + s2.slice(i1 + 1) : s2;
}
var prefixExponent;
function formatPrefixAuto(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2)
    return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1], i = exponent2 - (prefixExponent = Math.max(-8, Math.min(8, Math.floor(exponent2 / 3))) * 3) + 1, n2 = coefficient.length;
  return i === n2 ? coefficient : i > n2 ? coefficient + new Array(i - n2 + 1).join("0") : i > 0 ? coefficient.slice(0, i) + "." + coefficient.slice(i) : "0." + new Array(1 - i).join("0") + formatDecimalParts(x2, Math.max(0, p2 + i - 1))[0];
}
function formatRounded(x2, p2) {
  var d2 = formatDecimalParts(x2, p2);
  if (!d2)
    return x2 + "";
  var coefficient = d2[0], exponent2 = d2[1];
  return exponent2 < 0 ? "0." + new Array(-exponent2).join("0") + coefficient : coefficient.length > exponent2 + 1 ? coefficient.slice(0, exponent2 + 1) + "." + coefficient.slice(exponent2 + 1) : coefficient + new Array(exponent2 - coefficient.length + 2).join("0");
}
const formatTypes = {
  "%": (x2, p2) => (x2 * 100).toFixed(p2),
  "b": (x2) => Math.round(x2).toString(2),
  "c": (x2) => x2 + "",
  "d": formatDecimal,
  "e": (x2, p2) => x2.toExponential(p2),
  "f": (x2, p2) => x2.toFixed(p2),
  "g": (x2, p2) => x2.toPrecision(p2),
  "o": (x2) => Math.round(x2).toString(8),
  "p": (x2, p2) => formatRounded(x2 * 100, p2),
  "r": formatRounded,
  "s": formatPrefixAuto,
  "X": (x2) => Math.round(x2).toString(16).toUpperCase(),
  "x": (x2) => Math.round(x2).toString(16)
};
function identity$2(x2) {
  return x2;
}
var map$1 = Array.prototype.map, prefixes = ["y", "z", "a", "f", "p", "n", "µ", "m", "", "k", "M", "G", "T", "P", "E", "Z", "Y"];
function formatLocale$1(locale2) {
  var group = locale2.grouping === void 0 || locale2.thousands === void 0 ? identity$2 : formatGroup(map$1.call(locale2.grouping, Number), locale2.thousands + ""), currencyPrefix = locale2.currency === void 0 ? "" : locale2.currency[0] + "", currencySuffix = locale2.currency === void 0 ? "" : locale2.currency[1] + "", decimal = locale2.decimal === void 0 ? "." : locale2.decimal + "", numerals = locale2.numerals === void 0 ? identity$2 : formatNumerals(map$1.call(locale2.numerals, String)), percent = locale2.percent === void 0 ? "%" : locale2.percent + "", minus = locale2.minus === void 0 ? "−" : locale2.minus + "", nan = locale2.nan === void 0 ? "NaN" : locale2.nan + "";
  function newFormat(specifier) {
    specifier = formatSpecifier(specifier);
    var fill = specifier.fill, align = specifier.align, sign2 = specifier.sign, symbol = specifier.symbol, zero2 = specifier.zero, width = specifier.width, comma2 = specifier.comma, precision = specifier.precision, trim = specifier.trim, type = specifier.type;
    if (type === "n")
      comma2 = true, type = "g";
    else if (!formatTypes[type])
      precision === void 0 && (precision = 12), trim = true, type = "g";
    if (zero2 || fill === "0" && align === "=")
      zero2 = true, fill = "0", align = "=";
    var prefix = symbol === "$" ? currencyPrefix : symbol === "#" && /[boxX]/.test(type) ? "0" + type.toLowerCase() : "", suffix = symbol === "$" ? currencySuffix : /[%p]/.test(type) ? percent : "";
    var formatType = formatTypes[type], maybeSuffix = /[defgprs%]/.test(type);
    precision = precision === void 0 ? 6 : /[gprs]/.test(type) ? Math.max(1, Math.min(21, precision)) : Math.max(0, Math.min(20, precision));
    function format2(value) {
      var valuePrefix = prefix, valueSuffix = suffix, i, n2, c2;
      if (type === "c") {
        valueSuffix = formatType(value) + valueSuffix;
        value = "";
      } else {
        value = +value;
        var valueNegative = value < 0 || 1 / value < 0;
        value = isNaN(value) ? nan : formatType(Math.abs(value), precision);
        if (trim)
          value = formatTrim(value);
        if (valueNegative && +value === 0 && sign2 !== "+")
          valueNegative = false;
        valuePrefix = (valueNegative ? sign2 === "(" ? sign2 : minus : sign2 === "-" || sign2 === "(" ? "" : sign2) + valuePrefix;
        valueSuffix = (type === "s" ? prefixes[8 + prefixExponent / 3] : "") + valueSuffix + (valueNegative && sign2 === "(" ? ")" : "");
        if (maybeSuffix) {
          i = -1, n2 = value.length;
          while (++i < n2) {
            if (c2 = value.charCodeAt(i), 48 > c2 || c2 > 57) {
              valueSuffix = (c2 === 46 ? decimal + value.slice(i + 1) : value.slice(i)) + valueSuffix;
              value = value.slice(0, i);
              break;
            }
          }
        }
      }
      if (comma2 && !zero2)
        value = group(value, Infinity);
      var length = valuePrefix.length + value.length + valueSuffix.length, padding = length < width ? new Array(width - length + 1).join(fill) : "";
      if (comma2 && zero2)
        value = group(padding + value, padding.length ? width - valueSuffix.length : Infinity), padding = "";
      switch (align) {
        case "<":
          value = valuePrefix + value + valueSuffix + padding;
          break;
        case "=":
          value = valuePrefix + padding + value + valueSuffix;
          break;
        case "^":
          value = padding.slice(0, length = padding.length >> 1) + valuePrefix + value + valueSuffix + padding.slice(length);
          break;
        default:
          value = padding + valuePrefix + value + valueSuffix;
          break;
      }
      return numerals(value);
    }
    format2.toString = function() {
      return specifier + "";
    };
    return format2;
  }
  function formatPrefix2(specifier, value) {
    var f2 = newFormat((specifier = formatSpecifier(specifier), specifier.type = "f", specifier)), e3 = Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3, k2 = Math.pow(10, -e3), prefix = prefixes[8 + e3 / 3];
    return function(value2) {
      return f2(k2 * value2) + prefix;
    };
  }
  return {
    format: newFormat,
    formatPrefix: formatPrefix2
  };
}
var locale$1;
var format;
var formatPrefix;
defaultLocale$1({
  thousands: ",",
  grouping: [3],
  currency: ["$", ""]
});
function defaultLocale$1(definition) {
  locale$1 = formatLocale$1(definition);
  format = locale$1.format;
  formatPrefix = locale$1.formatPrefix;
  return locale$1;
}
function precisionFixed(step) {
  return Math.max(0, -exponent(Math.abs(step)));
}
function precisionPrefix(step, value) {
  return Math.max(0, Math.max(-8, Math.min(8, Math.floor(exponent(value) / 3))) * 3 - exponent(Math.abs(step)));
}
function precisionRound(step, max2) {
  step = Math.abs(step), max2 = Math.abs(max2) - step;
  return Math.max(0, exponent(max2) - exponent(step)) + 1;
}
function tickFormat(start, stop, count, specifier) {
  var step = tickStep(start, stop, count), precision;
  specifier = formatSpecifier(specifier == null ? ",f" : specifier);
  switch (specifier.type) {
    case "s": {
      var value = Math.max(Math.abs(start), Math.abs(stop));
      if (specifier.precision == null && !isNaN(precision = precisionPrefix(step, value)))
        specifier.precision = precision;
      return formatPrefix(specifier, value);
    }
    case "":
    case "e":
    case "g":
    case "p":
    case "r": {
      if (specifier.precision == null && !isNaN(precision = precisionRound(step, Math.max(Math.abs(start), Math.abs(stop)))))
        specifier.precision = precision - (specifier.type === "e");
      break;
    }
    case "f":
    case "%": {
      if (specifier.precision == null && !isNaN(precision = precisionFixed(step)))
        specifier.precision = precision - (specifier.type === "%") * 2;
      break;
    }
  }
  return format(specifier);
}
function linearish(scale2) {
  var domain = scale2.domain;
  scale2.ticks = function(count) {
    var d2 = domain();
    return ticks(d2[0], d2[d2.length - 1], count == null ? 10 : count);
  };
  scale2.tickFormat = function(count, specifier) {
    var d2 = domain();
    return tickFormat(d2[0], d2[d2.length - 1], count == null ? 10 : count, specifier);
  };
  scale2.nice = function(count) {
    if (count == null)
      count = 10;
    var d2 = domain();
    var i0 = 0;
    var i1 = d2.length - 1;
    var start = d2[i0];
    var stop = d2[i1];
    var prestep;
    var step;
    var maxIter = 10;
    if (stop < start) {
      step = start, start = stop, stop = step;
      step = i0, i0 = i1, i1 = step;
    }
    while (maxIter-- > 0) {
      step = tickIncrement(start, stop, count);
      if (step === prestep) {
        d2[i0] = start;
        d2[i1] = stop;
        return domain(d2);
      } else if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
      } else {
        break;
      }
      prestep = step;
    }
    return scale2;
  };
  return scale2;
}
function linear() {
  var scale2 = continuous();
  scale2.copy = function() {
    return copy$1(scale2, linear());
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}
function identity$1(domain) {
  var unknown;
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : x2;
  }
  scale2.invert = scale2;
  scale2.domain = scale2.range = function(_) {
    return arguments.length ? (domain = Array.from(_, number$1), scale2) : domain.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return identity$1(domain).unknown(unknown);
  };
  domain = arguments.length ? Array.from(domain, number$1) : [0, 1];
  return linearish(scale2);
}
function nice(domain, interval) {
  domain = domain.slice();
  var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], t2;
  if (x1 < x0) {
    t2 = i0, i0 = i1, i1 = t2;
    t2 = x0, x0 = x1, x1 = t2;
  }
  domain[i0] = interval.floor(x0);
  domain[i1] = interval.ceil(x1);
  return domain;
}
function transformLog(x2) {
  return Math.log(x2);
}
function transformExp(x2) {
  return Math.exp(x2);
}
function transformLogn(x2) {
  return -Math.log(-x2);
}
function transformExpn(x2) {
  return -Math.exp(-x2);
}
function pow10(x2) {
  return isFinite(x2) ? +("1e" + x2) : x2 < 0 ? 0 : x2;
}
function powp(base) {
  return base === 10 ? pow10 : base === Math.E ? Math.exp : (x2) => Math.pow(base, x2);
}
function logp(base) {
  return base === Math.E ? Math.log : base === 10 && Math.log10 || base === 2 && Math.log2 || (base = Math.log(base), (x2) => Math.log(x2) / base);
}
function reflect(f2) {
  return (x2, k2) => -f2(-x2, k2);
}
function loggish(transform) {
  const scale2 = transform(transformLog, transformExp);
  const domain = scale2.domain;
  let base = 10;
  let logs;
  let pows;
  function rescale() {
    logs = logp(base), pows = powp(base);
    if (domain()[0] < 0) {
      logs = reflect(logs), pows = reflect(pows);
      transform(transformLogn, transformExpn);
    } else {
      transform(transformLog, transformExp);
    }
    return scale2;
  }
  scale2.base = function(_) {
    return arguments.length ? (base = +_, rescale()) : base;
  };
  scale2.domain = function(_) {
    return arguments.length ? (domain(_), rescale()) : domain();
  };
  scale2.ticks = (count) => {
    const d2 = domain();
    let u = d2[0];
    let v2 = d2[d2.length - 1];
    const r2 = v2 < u;
    if (r2)
      [u, v2] = [v2, u];
    let i = logs(u);
    let j = logs(v2);
    let k2;
    let t2;
    const n2 = count == null ? 10 : +count;
    let z2 = [];
    if (!(base % 1) && j - i < n2) {
      i = Math.floor(i), j = Math.ceil(j);
      if (u > 0)
        for (; i <= j; ++i) {
          for (k2 = 1; k2 < base; ++k2) {
            t2 = i < 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t2 < u)
              continue;
            if (t2 > v2)
              break;
            z2.push(t2);
          }
        }
      else
        for (; i <= j; ++i) {
          for (k2 = base - 1; k2 >= 1; --k2) {
            t2 = i > 0 ? k2 / pows(-i) : k2 * pows(i);
            if (t2 < u)
              continue;
            if (t2 > v2)
              break;
            z2.push(t2);
          }
        }
      if (z2.length * 2 < n2)
        z2 = ticks(u, v2, n2);
    } else {
      z2 = ticks(i, j, Math.min(j - i, n2)).map(pows);
    }
    return r2 ? z2.reverse() : z2;
  };
  scale2.tickFormat = (count, specifier) => {
    if (count == null)
      count = 10;
    if (specifier == null)
      specifier = base === 10 ? "s" : ",";
    if (typeof specifier !== "function") {
      if (!(base % 1) && (specifier = formatSpecifier(specifier)).precision == null)
        specifier.trim = true;
      specifier = format(specifier);
    }
    if (count === Infinity)
      return specifier;
    const k2 = Math.max(1, base * count / scale2.ticks().length);
    return (d2) => {
      let i = d2 / pows(Math.round(logs(d2)));
      if (i * base < base - 0.5)
        i *= base;
      return i <= k2 ? specifier(d2) : "";
    };
  };
  scale2.nice = () => {
    return domain(nice(domain(), {
      floor: (x2) => pows(Math.floor(logs(x2))),
      ceil: (x2) => pows(Math.ceil(logs(x2)))
    }));
  };
  return scale2;
}
function log() {
  const scale2 = loggish(transformer$2()).domain([1, 10]);
  scale2.copy = () => copy$1(scale2, log()).base(scale2.base());
  initRange.apply(scale2, arguments);
  return scale2;
}
function transformSymlog(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.log1p(Math.abs(x2 / c2));
  };
}
function transformSymexp(c2) {
  return function(x2) {
    return Math.sign(x2) * Math.expm1(Math.abs(x2)) * c2;
  };
}
function symlogish(transform) {
  var c2 = 1, scale2 = transform(transformSymlog(c2), transformSymexp(c2));
  scale2.constant = function(_) {
    return arguments.length ? transform(transformSymlog(c2 = +_), transformSymexp(c2)) : c2;
  };
  return linearish(scale2);
}
function symlog() {
  var scale2 = symlogish(transformer$2());
  scale2.copy = function() {
    return copy$1(scale2, symlog()).constant(scale2.constant());
  };
  return initRange.apply(scale2, arguments);
}
function transformPow(exponent2) {
  return function(x2) {
    return x2 < 0 ? -Math.pow(-x2, exponent2) : Math.pow(x2, exponent2);
  };
}
function transformSqrt(x2) {
  return x2 < 0 ? -Math.sqrt(-x2) : Math.sqrt(x2);
}
function transformSquare(x2) {
  return x2 < 0 ? -x2 * x2 : x2 * x2;
}
function powish(transform) {
  var scale2 = transform(identity$3, identity$3), exponent2 = 1;
  function rescale() {
    return exponent2 === 1 ? transform(identity$3, identity$3) : exponent2 === 0.5 ? transform(transformSqrt, transformSquare) : transform(transformPow(exponent2), transformPow(1 / exponent2));
  }
  scale2.exponent = function(_) {
    return arguments.length ? (exponent2 = +_, rescale()) : exponent2;
  };
  return linearish(scale2);
}
function pow() {
  var scale2 = powish(transformer$2());
  scale2.copy = function() {
    return copy$1(scale2, pow()).exponent(scale2.exponent());
  };
  initRange.apply(scale2, arguments);
  return scale2;
}
function sqrt() {
  return pow.apply(null, arguments).exponent(0.5);
}
function square(x2) {
  return Math.sign(x2) * x2 * x2;
}
function unsquare(x2) {
  return Math.sign(x2) * Math.sqrt(Math.abs(x2));
}
function radial() {
  var squared = continuous(), range3 = [0, 1], round2 = false, unknown;
  function scale2(x2) {
    var y2 = unsquare(squared(x2));
    return isNaN(y2) ? unknown : round2 ? Math.round(y2) : y2;
  }
  scale2.invert = function(y2) {
    return squared.invert(square(y2));
  };
  scale2.domain = function(_) {
    return arguments.length ? (squared.domain(_), scale2) : squared.domain();
  };
  scale2.range = function(_) {
    return arguments.length ? (squared.range((range3 = Array.from(_, number$1)).map(square)), scale2) : range3.slice();
  };
  scale2.rangeRound = function(_) {
    return scale2.range(_).round(true);
  };
  scale2.round = function(_) {
    return arguments.length ? (round2 = !!_, scale2) : round2;
  };
  scale2.clamp = function(_) {
    return arguments.length ? (squared.clamp(_), scale2) : squared.clamp();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return radial(squared.domain(), range3).round(round2).clamp(squared.clamp()).unknown(unknown);
  };
  initRange.apply(scale2, arguments);
  return linearish(scale2);
}
function quantile() {
  var domain = [], range3 = [], thresholds = [], unknown;
  function rescale() {
    var i = 0, n2 = Math.max(1, range3.length);
    thresholds = new Array(n2 - 1);
    while (++i < n2)
      thresholds[i - 1] = quantileSorted(domain, i / n2);
    return scale2;
  }
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : range3[bisectRight(thresholds, x2)];
  }
  scale2.invertExtent = function(y2) {
    var i = range3.indexOf(y2);
    return i < 0 ? [NaN, NaN] : [
      i > 0 ? thresholds[i - 1] : domain[0],
      i < thresholds.length ? thresholds[i] : domain[domain.length - 1]
    ];
  };
  scale2.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d2 of _)
      if (d2 != null && !isNaN(d2 = +d2))
        domain.push(d2);
    domain.sort(ascending);
    return rescale();
  };
  scale2.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), rescale()) : range3.slice();
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.quantiles = function() {
    return thresholds.slice();
  };
  scale2.copy = function() {
    return quantile().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}
function quantize() {
  var x0 = 0, x1 = 1, n2 = 1, domain = [0.5], range3 = [0, 1], unknown;
  function scale2(x2) {
    return x2 != null && x2 <= x2 ? range3[bisectRight(domain, x2, 0, n2)] : unknown;
  }
  function rescale() {
    var i = -1;
    domain = new Array(n2);
    while (++i < n2)
      domain[i] = ((i + 1) * x1 - (i - n2) * x0) / (n2 + 1);
    return scale2;
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, x0 = +x0, x1 = +x1, rescale()) : [x0, x1];
  };
  scale2.range = function(_) {
    return arguments.length ? (n2 = (range3 = Array.from(_)).length - 1, rescale()) : range3.slice();
  };
  scale2.invertExtent = function(y2) {
    var i = range3.indexOf(y2);
    return i < 0 ? [NaN, NaN] : i < 1 ? [x0, domain[0]] : i >= n2 ? [domain[n2 - 1], x1] : [domain[i - 1], domain[i]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : scale2;
  };
  scale2.thresholds = function() {
    return domain.slice();
  };
  scale2.copy = function() {
    return quantize().domain([x0, x1]).range(range3).unknown(unknown);
  };
  return initRange.apply(linearish(scale2), arguments);
}
function threshold() {
  var domain = [0.5], range3 = [0, 1], unknown, n2 = 1;
  function scale2(x2) {
    return x2 != null && x2 <= x2 ? range3[bisectRight(domain, x2, 0, n2)] : unknown;
  }
  scale2.domain = function(_) {
    return arguments.length ? (domain = Array.from(_), n2 = Math.min(domain.length, range3.length - 1), scale2) : domain.slice();
  };
  scale2.range = function(_) {
    return arguments.length ? (range3 = Array.from(_), n2 = Math.min(domain.length, range3.length - 1), scale2) : range3.slice();
  };
  scale2.invertExtent = function(y2) {
    var i = range3.indexOf(y2);
    return [domain[i - 1], domain[i]];
  };
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  scale2.copy = function() {
    return threshold().domain(domain).range(range3).unknown(unknown);
  };
  return initRange.apply(scale2, arguments);
}
const t0 = /* @__PURE__ */ new Date(), t1 = /* @__PURE__ */ new Date();
function timeInterval(floori, offseti, count, field) {
  function interval(date2) {
    return floori(date2 = arguments.length === 0 ? /* @__PURE__ */ new Date() : /* @__PURE__ */ new Date(+date2)), date2;
  }
  interval.floor = (date2) => {
    return floori(date2 = /* @__PURE__ */ new Date(+date2)), date2;
  };
  interval.ceil = (date2) => {
    return floori(date2 = new Date(date2 - 1)), offseti(date2, 1), floori(date2), date2;
  };
  interval.round = (date2) => {
    const d0 = interval(date2), d1 = interval.ceil(date2);
    return date2 - d0 < d1 - date2 ? d0 : d1;
  };
  interval.offset = (date2, step) => {
    return offseti(date2 = /* @__PURE__ */ new Date(+date2), step == null ? 1 : Math.floor(step)), date2;
  };
  interval.range = (start, stop, step) => {
    const range3 = [];
    start = interval.ceil(start);
    step = step == null ? 1 : Math.floor(step);
    if (!(start < stop) || !(step > 0))
      return range3;
    let previous;
    do
      range3.push(previous = /* @__PURE__ */ new Date(+start)), offseti(start, step), floori(start);
    while (previous < start && start < stop);
    return range3;
  };
  interval.filter = (test) => {
    return timeInterval((date2) => {
      if (date2 >= date2)
        while (floori(date2), !test(date2))
          date2.setTime(date2 - 1);
    }, (date2, step) => {
      if (date2 >= date2) {
        if (step < 0)
          while (++step <= 0) {
            while (offseti(date2, -1), !test(date2)) {
            }
          }
        else
          while (--step >= 0) {
            while (offseti(date2, 1), !test(date2)) {
            }
          }
      }
    });
  };
  if (count) {
    interval.count = (start, end) => {
      t0.setTime(+start), t1.setTime(+end);
      floori(t0), floori(t1);
      return Math.floor(count(t0, t1));
    };
    interval.every = (step) => {
      step = Math.floor(step);
      return !isFinite(step) || !(step > 0) ? null : !(step > 1) ? interval : interval.filter(field ? (d2) => field(d2) % step === 0 : (d2) => interval.count(0, d2) % step === 0);
    };
  }
  return interval;
}
const millisecond = timeInterval(() => {
}, (date2, step) => {
  date2.setTime(+date2 + step);
}, (start, end) => {
  return end - start;
});
millisecond.every = (k2) => {
  k2 = Math.floor(k2);
  if (!isFinite(k2) || !(k2 > 0))
    return null;
  if (!(k2 > 1))
    return millisecond;
  return timeInterval((date2) => {
    date2.setTime(Math.floor(date2 / k2) * k2);
  }, (date2, step) => {
    date2.setTime(+date2 + step * k2);
  }, (start, end) => {
    return (end - start) / k2;
  });
};
millisecond.range;
const durationSecond = 1e3;
const durationMinute = durationSecond * 60;
const durationHour = durationMinute * 60;
const durationDay = durationHour * 24;
const durationWeek = durationDay * 7;
const durationMonth = durationDay * 30;
const durationYear = durationDay * 365;
const second = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds());
}, (date2, step) => {
  date2.setTime(+date2 + step * durationSecond);
}, (start, end) => {
  return (end - start) / durationSecond;
}, (date2) => {
  return date2.getUTCSeconds();
});
second.range;
const timeMinute = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getMinutes();
});
timeMinute.range;
const utcMinute = timeInterval((date2) => {
  date2.setUTCSeconds(0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationMinute);
}, (start, end) => {
  return (end - start) / durationMinute;
}, (date2) => {
  return date2.getUTCMinutes();
});
utcMinute.range;
const timeHour = timeInterval((date2) => {
  date2.setTime(date2 - date2.getMilliseconds() - date2.getSeconds() * durationSecond - date2.getMinutes() * durationMinute);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getHours();
});
timeHour.range;
const utcHour = timeInterval((date2) => {
  date2.setUTCMinutes(0, 0, 0);
}, (date2, step) => {
  date2.setTime(+date2 + step * durationHour);
}, (start, end) => {
  return (end - start) / durationHour;
}, (date2) => {
  return date2.getUTCHours();
});
utcHour.range;
const timeDay = timeInterval(
  (date2) => date2.setHours(0, 0, 0, 0),
  (date2, step) => date2.setDate(date2.getDate() + step),
  (start, end) => (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationDay,
  (date2) => date2.getDate() - 1
);
timeDay.range;
const utcDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return date2.getUTCDate() - 1;
});
utcDay.range;
const unixDay = timeInterval((date2) => {
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCDate(date2.getUTCDate() + step);
}, (start, end) => {
  return (end - start) / durationDay;
}, (date2) => {
  return Math.floor(date2 / durationDay);
});
unixDay.range;
function timeWeekday(i) {
  return timeInterval((date2) => {
    date2.setDate(date2.getDate() - (date2.getDay() + 7 - i) % 7);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setDate(date2.getDate() + step * 7);
  }, (start, end) => {
    return (end - start - (end.getTimezoneOffset() - start.getTimezoneOffset()) * durationMinute) / durationWeek;
  });
}
const timeSunday = timeWeekday(0);
const timeMonday = timeWeekday(1);
const timeTuesday = timeWeekday(2);
const timeWednesday = timeWeekday(3);
const timeThursday = timeWeekday(4);
const timeFriday = timeWeekday(5);
const timeSaturday = timeWeekday(6);
timeSunday.range;
timeMonday.range;
timeTuesday.range;
timeWednesday.range;
timeThursday.range;
timeFriday.range;
timeSaturday.range;
function utcWeekday(i) {
  return timeInterval((date2) => {
    date2.setUTCDate(date2.getUTCDate() - (date2.getUTCDay() + 7 - i) % 7);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCDate(date2.getUTCDate() + step * 7);
  }, (start, end) => {
    return (end - start) / durationWeek;
  });
}
const utcSunday = utcWeekday(0);
const utcMonday = utcWeekday(1);
const utcTuesday = utcWeekday(2);
const utcWednesday = utcWeekday(3);
const utcThursday = utcWeekday(4);
const utcFriday = utcWeekday(5);
const utcSaturday = utcWeekday(6);
utcSunday.range;
utcMonday.range;
utcTuesday.range;
utcWednesday.range;
utcThursday.range;
utcFriday.range;
utcSaturday.range;
const timeMonth = timeInterval((date2) => {
  date2.setDate(1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setMonth(date2.getMonth() + step);
}, (start, end) => {
  return end.getMonth() - start.getMonth() + (end.getFullYear() - start.getFullYear()) * 12;
}, (date2) => {
  return date2.getMonth();
});
timeMonth.range;
const utcMonth = timeInterval((date2) => {
  date2.setUTCDate(1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCMonth(date2.getUTCMonth() + step);
}, (start, end) => {
  return end.getUTCMonth() - start.getUTCMonth() + (end.getUTCFullYear() - start.getUTCFullYear()) * 12;
}, (date2) => {
  return date2.getUTCMonth();
});
utcMonth.range;
const timeYear = timeInterval((date2) => {
  date2.setMonth(0, 1);
  date2.setHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setFullYear(date2.getFullYear() + step);
}, (start, end) => {
  return end.getFullYear() - start.getFullYear();
}, (date2) => {
  return date2.getFullYear();
});
timeYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setFullYear(Math.floor(date2.getFullYear() / k2) * k2);
    date2.setMonth(0, 1);
    date2.setHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setFullYear(date2.getFullYear() + step * k2);
  });
};
timeYear.range;
const utcYear = timeInterval((date2) => {
  date2.setUTCMonth(0, 1);
  date2.setUTCHours(0, 0, 0, 0);
}, (date2, step) => {
  date2.setUTCFullYear(date2.getUTCFullYear() + step);
}, (start, end) => {
  return end.getUTCFullYear() - start.getUTCFullYear();
}, (date2) => {
  return date2.getUTCFullYear();
});
utcYear.every = (k2) => {
  return !isFinite(k2 = Math.floor(k2)) || !(k2 > 0) ? null : timeInterval((date2) => {
    date2.setUTCFullYear(Math.floor(date2.getUTCFullYear() / k2) * k2);
    date2.setUTCMonth(0, 1);
    date2.setUTCHours(0, 0, 0, 0);
  }, (date2, step) => {
    date2.setUTCFullYear(date2.getUTCFullYear() + step * k2);
  });
};
utcYear.range;
function ticker(year, month, week, day, hour, minute) {
  const tickIntervals = [
    [second, 1, durationSecond],
    [second, 5, 5 * durationSecond],
    [second, 15, 15 * durationSecond],
    [second, 30, 30 * durationSecond],
    [minute, 1, durationMinute],
    [minute, 5, 5 * durationMinute],
    [minute, 15, 15 * durationMinute],
    [minute, 30, 30 * durationMinute],
    [hour, 1, durationHour],
    [hour, 3, 3 * durationHour],
    [hour, 6, 6 * durationHour],
    [hour, 12, 12 * durationHour],
    [day, 1, durationDay],
    [day, 2, 2 * durationDay],
    [week, 1, durationWeek],
    [month, 1, durationMonth],
    [month, 3, 3 * durationMonth],
    [year, 1, durationYear]
  ];
  function ticks2(start, stop, count) {
    const reverse3 = stop < start;
    if (reverse3)
      [start, stop] = [stop, start];
    const interval = count && typeof count.range === "function" ? count : tickInterval(start, stop, count);
    const ticks3 = interval ? interval.range(start, +stop + 1) : [];
    return reverse3 ? ticks3.reverse() : ticks3;
  }
  function tickInterval(start, stop, count) {
    const target = Math.abs(stop - start) / count;
    const i = bisector(([, , step2]) => step2).right(tickIntervals, target);
    if (i === tickIntervals.length)
      return year.every(tickStep(start / durationYear, stop / durationYear, count));
    if (i === 0)
      return millisecond.every(Math.max(tickStep(start, stop, count), 1));
    const [t2, step] = tickIntervals[target / tickIntervals[i - 1][2] < tickIntervals[i][2] / target ? i - 1 : i];
    return t2.every(step);
  }
  return [ticks2, tickInterval];
}
const [utcTicks, utcTickInterval] = ticker(utcYear, utcMonth, utcSunday, unixDay, utcHour, utcMinute);
const [timeTicks, timeTickInterval] = ticker(timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute);
function localDate(d2) {
  if (0 <= d2.y && d2.y < 100) {
    var date2 = new Date(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
    date2.setFullYear(d2.y);
    return date2;
  }
  return new Date(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L);
}
function utcDate(d2) {
  if (0 <= d2.y && d2.y < 100) {
    var date2 = new Date(Date.UTC(-1, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
    date2.setUTCFullYear(d2.y);
    return date2;
  }
  return new Date(Date.UTC(d2.y, d2.m, d2.d, d2.H, d2.M, d2.S, d2.L));
}
function newDate(y2, m2, d2) {
  return { y: y2, m: m2, d: d2, H: 0, M: 0, S: 0, L: 0 };
}
function formatLocale(locale2) {
  var locale_dateTime = locale2.dateTime, locale_date = locale2.date, locale_time = locale2.time, locale_periods = locale2.periods, locale_weekdays = locale2.days, locale_shortWeekdays = locale2.shortDays, locale_months = locale2.months, locale_shortMonths = locale2.shortMonths;
  var periodRe = formatRe(locale_periods), periodLookup = formatLookup(locale_periods), weekdayRe = formatRe(locale_weekdays), weekdayLookup = formatLookup(locale_weekdays), shortWeekdayRe = formatRe(locale_shortWeekdays), shortWeekdayLookup = formatLookup(locale_shortWeekdays), monthRe = formatRe(locale_months), monthLookup = formatLookup(locale_months), shortMonthRe = formatRe(locale_shortMonths), shortMonthLookup = formatLookup(locale_shortMonths);
  var formats = {
    "a": formatShortWeekday,
    "A": formatWeekday,
    "b": formatShortMonth,
    "B": formatMonth,
    "c": null,
    "d": formatDayOfMonth,
    "e": formatDayOfMonth,
    "f": formatMicroseconds,
    "g": formatYearISO,
    "G": formatFullYearISO,
    "H": formatHour24,
    "I": formatHour12,
    "j": formatDayOfYear,
    "L": formatMilliseconds,
    "m": formatMonthNumber,
    "M": formatMinutes,
    "p": formatPeriod,
    "q": formatQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatSeconds,
    "u": formatWeekdayNumberMonday,
    "U": formatWeekNumberSunday,
    "V": formatWeekNumberISO,
    "w": formatWeekdayNumberSunday,
    "W": formatWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatYear,
    "Y": formatFullYear,
    "Z": formatZone,
    "%": formatLiteralPercent
  };
  var utcFormats = {
    "a": formatUTCShortWeekday,
    "A": formatUTCWeekday,
    "b": formatUTCShortMonth,
    "B": formatUTCMonth,
    "c": null,
    "d": formatUTCDayOfMonth,
    "e": formatUTCDayOfMonth,
    "f": formatUTCMicroseconds,
    "g": formatUTCYearISO,
    "G": formatUTCFullYearISO,
    "H": formatUTCHour24,
    "I": formatUTCHour12,
    "j": formatUTCDayOfYear,
    "L": formatUTCMilliseconds,
    "m": formatUTCMonthNumber,
    "M": formatUTCMinutes,
    "p": formatUTCPeriod,
    "q": formatUTCQuarter,
    "Q": formatUnixTimestamp,
    "s": formatUnixTimestampSeconds,
    "S": formatUTCSeconds,
    "u": formatUTCWeekdayNumberMonday,
    "U": formatUTCWeekNumberSunday,
    "V": formatUTCWeekNumberISO,
    "w": formatUTCWeekdayNumberSunday,
    "W": formatUTCWeekNumberMonday,
    "x": null,
    "X": null,
    "y": formatUTCYear,
    "Y": formatUTCFullYear,
    "Z": formatUTCZone,
    "%": formatLiteralPercent
  };
  var parses = {
    "a": parseShortWeekday,
    "A": parseWeekday,
    "b": parseShortMonth,
    "B": parseMonth,
    "c": parseLocaleDateTime,
    "d": parseDayOfMonth,
    "e": parseDayOfMonth,
    "f": parseMicroseconds,
    "g": parseYear,
    "G": parseFullYear,
    "H": parseHour24,
    "I": parseHour24,
    "j": parseDayOfYear,
    "L": parseMilliseconds,
    "m": parseMonthNumber,
    "M": parseMinutes,
    "p": parsePeriod,
    "q": parseQuarter,
    "Q": parseUnixTimestamp,
    "s": parseUnixTimestampSeconds,
    "S": parseSeconds,
    "u": parseWeekdayNumberMonday,
    "U": parseWeekNumberSunday,
    "V": parseWeekNumberISO,
    "w": parseWeekdayNumberSunday,
    "W": parseWeekNumberMonday,
    "x": parseLocaleDate,
    "X": parseLocaleTime,
    "y": parseYear,
    "Y": parseFullYear,
    "Z": parseZone,
    "%": parseLiteralPercent
  };
  formats.x = newFormat(locale_date, formats);
  formats.X = newFormat(locale_time, formats);
  formats.c = newFormat(locale_dateTime, formats);
  utcFormats.x = newFormat(locale_date, utcFormats);
  utcFormats.X = newFormat(locale_time, utcFormats);
  utcFormats.c = newFormat(locale_dateTime, utcFormats);
  function newFormat(specifier, formats2) {
    return function(date2) {
      var string2 = [], i = -1, j = 0, n2 = specifier.length, c2, pad2, format2;
      if (!(date2 instanceof Date))
        date2 = /* @__PURE__ */ new Date(+date2);
      while (++i < n2) {
        if (specifier.charCodeAt(i) === 37) {
          string2.push(specifier.slice(j, i));
          if ((pad2 = pads[c2 = specifier.charAt(++i)]) != null)
            c2 = specifier.charAt(++i);
          else
            pad2 = c2 === "e" ? " " : "0";
          if (format2 = formats2[c2])
            c2 = format2(date2, pad2);
          string2.push(c2);
          j = i + 1;
        }
      }
      string2.push(specifier.slice(j, i));
      return string2.join("");
    };
  }
  function newParse(specifier, Z) {
    return function(string2) {
      var d2 = newDate(1900, void 0, 1), i = parseSpecifier(d2, specifier, string2 += "", 0), week, day;
      if (i != string2.length)
        return null;
      if ("Q" in d2)
        return new Date(d2.Q);
      if ("s" in d2)
        return new Date(d2.s * 1e3 + ("L" in d2 ? d2.L : 0));
      if (Z && !("Z" in d2))
        d2.Z = 0;
      if ("p" in d2)
        d2.H = d2.H % 12 + d2.p * 12;
      if (d2.m === void 0)
        d2.m = "q" in d2 ? d2.q : 0;
      if ("V" in d2) {
        if (d2.V < 1 || d2.V > 53)
          return null;
        if (!("w" in d2))
          d2.w = 1;
        if ("Z" in d2) {
          week = utcDate(newDate(d2.y, 0, 1)), day = week.getUTCDay();
          week = day > 4 || day === 0 ? utcMonday.ceil(week) : utcMonday(week);
          week = utcDay.offset(week, (d2.V - 1) * 7);
          d2.y = week.getUTCFullYear();
          d2.m = week.getUTCMonth();
          d2.d = week.getUTCDate() + (d2.w + 6) % 7;
        } else {
          week = localDate(newDate(d2.y, 0, 1)), day = week.getDay();
          week = day > 4 || day === 0 ? timeMonday.ceil(week) : timeMonday(week);
          week = timeDay.offset(week, (d2.V - 1) * 7);
          d2.y = week.getFullYear();
          d2.m = week.getMonth();
          d2.d = week.getDate() + (d2.w + 6) % 7;
        }
      } else if ("W" in d2 || "U" in d2) {
        if (!("w" in d2))
          d2.w = "u" in d2 ? d2.u % 7 : "W" in d2 ? 1 : 0;
        day = "Z" in d2 ? utcDate(newDate(d2.y, 0, 1)).getUTCDay() : localDate(newDate(d2.y, 0, 1)).getDay();
        d2.m = 0;
        d2.d = "W" in d2 ? (d2.w + 6) % 7 + d2.W * 7 - (day + 5) % 7 : d2.w + d2.U * 7 - (day + 6) % 7;
      }
      if ("Z" in d2) {
        d2.H += d2.Z / 100 | 0;
        d2.M += d2.Z % 100;
        return utcDate(d2);
      }
      return localDate(d2);
    };
  }
  function parseSpecifier(d2, specifier, string2, j) {
    var i = 0, n2 = specifier.length, m2 = string2.length, c2, parse2;
    while (i < n2) {
      if (j >= m2)
        return -1;
      c2 = specifier.charCodeAt(i++);
      if (c2 === 37) {
        c2 = specifier.charAt(i++);
        parse2 = parses[c2 in pads ? specifier.charAt(i++) : c2];
        if (!parse2 || (j = parse2(d2, string2, j)) < 0)
          return -1;
      } else if (c2 != string2.charCodeAt(j++)) {
        return -1;
      }
    }
    return j;
  }
  function parsePeriod(d2, string2, i) {
    var n2 = periodRe.exec(string2.slice(i));
    return n2 ? (d2.p = periodLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseShortWeekday(d2, string2, i) {
    var n2 = shortWeekdayRe.exec(string2.slice(i));
    return n2 ? (d2.w = shortWeekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseWeekday(d2, string2, i) {
    var n2 = weekdayRe.exec(string2.slice(i));
    return n2 ? (d2.w = weekdayLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseShortMonth(d2, string2, i) {
    var n2 = shortMonthRe.exec(string2.slice(i));
    return n2 ? (d2.m = shortMonthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseMonth(d2, string2, i) {
    var n2 = monthRe.exec(string2.slice(i));
    return n2 ? (d2.m = monthLookup.get(n2[0].toLowerCase()), i + n2[0].length) : -1;
  }
  function parseLocaleDateTime(d2, string2, i) {
    return parseSpecifier(d2, locale_dateTime, string2, i);
  }
  function parseLocaleDate(d2, string2, i) {
    return parseSpecifier(d2, locale_date, string2, i);
  }
  function parseLocaleTime(d2, string2, i) {
    return parseSpecifier(d2, locale_time, string2, i);
  }
  function formatShortWeekday(d2) {
    return locale_shortWeekdays[d2.getDay()];
  }
  function formatWeekday(d2) {
    return locale_weekdays[d2.getDay()];
  }
  function formatShortMonth(d2) {
    return locale_shortMonths[d2.getMonth()];
  }
  function formatMonth(d2) {
    return locale_months[d2.getMonth()];
  }
  function formatPeriod(d2) {
    return locale_periods[+(d2.getHours() >= 12)];
  }
  function formatQuarter(d2) {
    return 1 + ~~(d2.getMonth() / 3);
  }
  function formatUTCShortWeekday(d2) {
    return locale_shortWeekdays[d2.getUTCDay()];
  }
  function formatUTCWeekday(d2) {
    return locale_weekdays[d2.getUTCDay()];
  }
  function formatUTCShortMonth(d2) {
    return locale_shortMonths[d2.getUTCMonth()];
  }
  function formatUTCMonth(d2) {
    return locale_months[d2.getUTCMonth()];
  }
  function formatUTCPeriod(d2) {
    return locale_periods[+(d2.getUTCHours() >= 12)];
  }
  function formatUTCQuarter(d2) {
    return 1 + ~~(d2.getUTCMonth() / 3);
  }
  return {
    format: function(specifier) {
      var f2 = newFormat(specifier += "", formats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    parse: function(specifier) {
      var p2 = newParse(specifier += "", false);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    },
    utcFormat: function(specifier) {
      var f2 = newFormat(specifier += "", utcFormats);
      f2.toString = function() {
        return specifier;
      };
      return f2;
    },
    utcParse: function(specifier) {
      var p2 = newParse(specifier += "", true);
      p2.toString = function() {
        return specifier;
      };
      return p2;
    }
  };
}
var pads = { "-": "", "_": " ", "0": "0" }, numberRe = /^\s*\d+/, percentRe = /^%/, requoteRe = /[\\^$*+?|[\]().{}]/g;
function pad(value, fill, width) {
  var sign2 = value < 0 ? "-" : "", string2 = (sign2 ? -value : value) + "", length = string2.length;
  return sign2 + (length < width ? new Array(width - length + 1).join(fill) + string2 : string2);
}
function requote(s2) {
  return s2.replace(requoteRe, "\\$&");
}
function formatRe(names) {
  return new RegExp("^(?:" + names.map(requote).join("|") + ")", "i");
}
function formatLookup(names) {
  return new Map(names.map((name, i) => [name.toLowerCase(), i]));
}
function parseWeekdayNumberSunday(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 1));
  return n2 ? (d2.w = +n2[0], i + n2[0].length) : -1;
}
function parseWeekdayNumberMonday(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 1));
  return n2 ? (d2.u = +n2[0], i + n2[0].length) : -1;
}
function parseWeekNumberSunday(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 2));
  return n2 ? (d2.U = +n2[0], i + n2[0].length) : -1;
}
function parseWeekNumberISO(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 2));
  return n2 ? (d2.V = +n2[0], i + n2[0].length) : -1;
}
function parseWeekNumberMonday(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 2));
  return n2 ? (d2.W = +n2[0], i + n2[0].length) : -1;
}
function parseFullYear(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 4));
  return n2 ? (d2.y = +n2[0], i + n2[0].length) : -1;
}
function parseYear(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 2));
  return n2 ? (d2.y = +n2[0] + (+n2[0] > 68 ? 1900 : 2e3), i + n2[0].length) : -1;
}
function parseZone(d2, string2, i) {
  var n2 = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(string2.slice(i, i + 6));
  return n2 ? (d2.Z = n2[1] ? 0 : -(n2[2] + (n2[3] || "00")), i + n2[0].length) : -1;
}
function parseQuarter(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 1));
  return n2 ? (d2.q = n2[0] * 3 - 3, i + n2[0].length) : -1;
}
function parseMonthNumber(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 2));
  return n2 ? (d2.m = n2[0] - 1, i + n2[0].length) : -1;
}
function parseDayOfMonth(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 2));
  return n2 ? (d2.d = +n2[0], i + n2[0].length) : -1;
}
function parseDayOfYear(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 3));
  return n2 ? (d2.m = 0, d2.d = +n2[0], i + n2[0].length) : -1;
}
function parseHour24(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 2));
  return n2 ? (d2.H = +n2[0], i + n2[0].length) : -1;
}
function parseMinutes(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 2));
  return n2 ? (d2.M = +n2[0], i + n2[0].length) : -1;
}
function parseSeconds(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 2));
  return n2 ? (d2.S = +n2[0], i + n2[0].length) : -1;
}
function parseMilliseconds(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 3));
  return n2 ? (d2.L = +n2[0], i + n2[0].length) : -1;
}
function parseMicroseconds(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i, i + 6));
  return n2 ? (d2.L = Math.floor(n2[0] / 1e3), i + n2[0].length) : -1;
}
function parseLiteralPercent(d2, string2, i) {
  var n2 = percentRe.exec(string2.slice(i, i + 1));
  return n2 ? i + n2[0].length : -1;
}
function parseUnixTimestamp(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i));
  return n2 ? (d2.Q = +n2[0], i + n2[0].length) : -1;
}
function parseUnixTimestampSeconds(d2, string2, i) {
  var n2 = numberRe.exec(string2.slice(i));
  return n2 ? (d2.s = +n2[0], i + n2[0].length) : -1;
}
function formatDayOfMonth(d2, p2) {
  return pad(d2.getDate(), p2, 2);
}
function formatHour24(d2, p2) {
  return pad(d2.getHours(), p2, 2);
}
function formatHour12(d2, p2) {
  return pad(d2.getHours() % 12 || 12, p2, 2);
}
function formatDayOfYear(d2, p2) {
  return pad(1 + timeDay.count(timeYear(d2), d2), p2, 3);
}
function formatMilliseconds(d2, p2) {
  return pad(d2.getMilliseconds(), p2, 3);
}
function formatMicroseconds(d2, p2) {
  return formatMilliseconds(d2, p2) + "000";
}
function formatMonthNumber(d2, p2) {
  return pad(d2.getMonth() + 1, p2, 2);
}
function formatMinutes(d2, p2) {
  return pad(d2.getMinutes(), p2, 2);
}
function formatSeconds(d2, p2) {
  return pad(d2.getSeconds(), p2, 2);
}
function formatWeekdayNumberMonday(d2) {
  var day = d2.getDay();
  return day === 0 ? 7 : day;
}
function formatWeekNumberSunday(d2, p2) {
  return pad(timeSunday.count(timeYear(d2) - 1, d2), p2, 2);
}
function dISO(d2) {
  var day = d2.getDay();
  return day >= 4 || day === 0 ? timeThursday(d2) : timeThursday.ceil(d2);
}
function formatWeekNumberISO(d2, p2) {
  d2 = dISO(d2);
  return pad(timeThursday.count(timeYear(d2), d2) + (timeYear(d2).getDay() === 4), p2, 2);
}
function formatWeekdayNumberSunday(d2) {
  return d2.getDay();
}
function formatWeekNumberMonday(d2, p2) {
  return pad(timeMonday.count(timeYear(d2) - 1, d2), p2, 2);
}
function formatYear(d2, p2) {
  return pad(d2.getFullYear() % 100, p2, 2);
}
function formatYearISO(d2, p2) {
  d2 = dISO(d2);
  return pad(d2.getFullYear() % 100, p2, 2);
}
function formatFullYear(d2, p2) {
  return pad(d2.getFullYear() % 1e4, p2, 4);
}
function formatFullYearISO(d2, p2) {
  var day = d2.getDay();
  d2 = day >= 4 || day === 0 ? timeThursday(d2) : timeThursday.ceil(d2);
  return pad(d2.getFullYear() % 1e4, p2, 4);
}
function formatZone(d2) {
  var z2 = d2.getTimezoneOffset();
  return (z2 > 0 ? "-" : (z2 *= -1, "+")) + pad(z2 / 60 | 0, "0", 2) + pad(z2 % 60, "0", 2);
}
function formatUTCDayOfMonth(d2, p2) {
  return pad(d2.getUTCDate(), p2, 2);
}
function formatUTCHour24(d2, p2) {
  return pad(d2.getUTCHours(), p2, 2);
}
function formatUTCHour12(d2, p2) {
  return pad(d2.getUTCHours() % 12 || 12, p2, 2);
}
function formatUTCDayOfYear(d2, p2) {
  return pad(1 + utcDay.count(utcYear(d2), d2), p2, 3);
}
function formatUTCMilliseconds(d2, p2) {
  return pad(d2.getUTCMilliseconds(), p2, 3);
}
function formatUTCMicroseconds(d2, p2) {
  return formatUTCMilliseconds(d2, p2) + "000";
}
function formatUTCMonthNumber(d2, p2) {
  return pad(d2.getUTCMonth() + 1, p2, 2);
}
function formatUTCMinutes(d2, p2) {
  return pad(d2.getUTCMinutes(), p2, 2);
}
function formatUTCSeconds(d2, p2) {
  return pad(d2.getUTCSeconds(), p2, 2);
}
function formatUTCWeekdayNumberMonday(d2) {
  var dow = d2.getUTCDay();
  return dow === 0 ? 7 : dow;
}
function formatUTCWeekNumberSunday(d2, p2) {
  return pad(utcSunday.count(utcYear(d2) - 1, d2), p2, 2);
}
function UTCdISO(d2) {
  var day = d2.getUTCDay();
  return day >= 4 || day === 0 ? utcThursday(d2) : utcThursday.ceil(d2);
}
function formatUTCWeekNumberISO(d2, p2) {
  d2 = UTCdISO(d2);
  return pad(utcThursday.count(utcYear(d2), d2) + (utcYear(d2).getUTCDay() === 4), p2, 2);
}
function formatUTCWeekdayNumberSunday(d2) {
  return d2.getUTCDay();
}
function formatUTCWeekNumberMonday(d2, p2) {
  return pad(utcMonday.count(utcYear(d2) - 1, d2), p2, 2);
}
function formatUTCYear(d2, p2) {
  return pad(d2.getUTCFullYear() % 100, p2, 2);
}
function formatUTCYearISO(d2, p2) {
  d2 = UTCdISO(d2);
  return pad(d2.getUTCFullYear() % 100, p2, 2);
}
function formatUTCFullYear(d2, p2) {
  return pad(d2.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCFullYearISO(d2, p2) {
  var day = d2.getUTCDay();
  d2 = day >= 4 || day === 0 ? utcThursday(d2) : utcThursday.ceil(d2);
  return pad(d2.getUTCFullYear() % 1e4, p2, 4);
}
function formatUTCZone() {
  return "+0000";
}
function formatLiteralPercent() {
  return "%";
}
function formatUnixTimestamp(d2) {
  return +d2;
}
function formatUnixTimestampSeconds(d2) {
  return Math.floor(+d2 / 1e3);
}
var locale;
var timeFormat;
var utcFormat;
defaultLocale({
  dateTime: "%x, %X",
  date: "%-m/%-d/%Y",
  time: "%-I:%M:%S %p",
  periods: ["AM", "PM"],
  days: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
  shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
  months: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
  shortMonths: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"]
});
function defaultLocale(definition) {
  locale = formatLocale(definition);
  timeFormat = locale.format;
  locale.parse;
  utcFormat = locale.utcFormat;
  locale.utcParse;
  return locale;
}
function date(t2) {
  return new Date(t2);
}
function number(t2) {
  return t2 instanceof Date ? +t2 : +/* @__PURE__ */ new Date(+t2);
}
function calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2) {
  var scale2 = continuous(), invert = scale2.invert, domain = scale2.domain;
  var formatMillisecond = format2(".%L"), formatSecond = format2(":%S"), formatMinute = format2("%I:%M"), formatHour = format2("%I %p"), formatDay = format2("%a %d"), formatWeek = format2("%b %d"), formatMonth = format2("%B"), formatYear2 = format2("%Y");
  function tickFormat2(date2) {
    return (second2(date2) < date2 ? formatMillisecond : minute(date2) < date2 ? formatSecond : hour(date2) < date2 ? formatMinute : day(date2) < date2 ? formatHour : month(date2) < date2 ? week(date2) < date2 ? formatDay : formatWeek : year(date2) < date2 ? formatMonth : formatYear2)(date2);
  }
  scale2.invert = function(y2) {
    return new Date(invert(y2));
  };
  scale2.domain = function(_) {
    return arguments.length ? domain(Array.from(_, number)) : domain().map(date);
  };
  scale2.ticks = function(interval) {
    var d2 = domain();
    return ticks2(d2[0], d2[d2.length - 1], interval == null ? 10 : interval);
  };
  scale2.tickFormat = function(count, specifier) {
    return specifier == null ? tickFormat2 : format2(specifier);
  };
  scale2.nice = function(interval) {
    var d2 = domain();
    if (!interval || typeof interval.range !== "function")
      interval = tickInterval(d2[0], d2[d2.length - 1], interval == null ? 10 : interval);
    return interval ? domain(nice(d2, interval)) : scale2;
  };
  scale2.copy = function() {
    return copy$1(scale2, calendar(ticks2, tickInterval, year, month, week, day, hour, minute, second2, format2));
  };
  return scale2;
}
function time() {
  return initRange.apply(calendar(timeTicks, timeTickInterval, timeYear, timeMonth, timeSunday, timeDay, timeHour, timeMinute, second, timeFormat).domain([new Date(2e3, 0, 1), new Date(2e3, 0, 2)]), arguments);
}
function utcTime() {
  return initRange.apply(calendar(utcTicks, utcTickInterval, utcYear, utcMonth, utcSunday, utcDay, utcHour, utcMinute, second, utcFormat).domain([Date.UTC(2e3, 0, 1), Date.UTC(2e3, 0, 2)]), arguments);
}
function transformer$1() {
  var x0 = 0, x1 = 1, t02, t12, k10, transform, interpolator = identity$3, clamp2 = false, unknown;
  function scale2(x2) {
    return x2 == null || isNaN(x2 = +x2) ? unknown : interpolator(k10 === 0 ? 0.5 : (x2 = (transform(x2) - t02) * k10, clamp2 ? Math.max(0, Math.min(1, x2)) : x2));
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x0, x1] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02), scale2) : [x0, x1];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  function range3(interpolate2) {
    return function(_) {
      var r0, r1;
      return arguments.length ? ([r0, r1] = _, interpolator = interpolate2(r0, r1), scale2) : [interpolator(0), interpolator(1)];
    };
  }
  scale2.range = range3(interpolate);
  scale2.rangeRound = range3(interpolateRound);
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t2) {
    transform = t2, t02 = t2(x0), t12 = t2(x1), k10 = t02 === t12 ? 0 : 1 / (t12 - t02);
    return scale2;
  };
}
function copy(source, target) {
  return target.domain(source.domain()).interpolator(source.interpolator()).clamp(source.clamp()).unknown(source.unknown());
}
function sequential() {
  var scale2 = linearish(transformer$1()(identity$3));
  scale2.copy = function() {
    return copy(scale2, sequential());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialLog() {
  var scale2 = loggish(transformer$1()).domain([1, 10]);
  scale2.copy = function() {
    return copy(scale2, sequentialLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSymlog() {
  var scale2 = symlogish(transformer$1());
  scale2.copy = function() {
    return copy(scale2, sequentialSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialPow() {
  var scale2 = powish(transformer$1());
  scale2.copy = function() {
    return copy(scale2, sequentialPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function sequentialSqrt() {
  return sequentialPow.apply(null, arguments).exponent(0.5);
}
function sequentialQuantile() {
  var domain = [], interpolator = identity$3;
  function scale2(x2) {
    if (x2 != null && !isNaN(x2 = +x2))
      return interpolator((bisectRight(domain, x2, 1) - 1) / (domain.length - 1));
  }
  scale2.domain = function(_) {
    if (!arguments.length)
      return domain.slice();
    domain = [];
    for (let d2 of _)
      if (d2 != null && !isNaN(d2 = +d2))
        domain.push(d2);
    domain.sort(ascending);
    return scale2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  scale2.range = function() {
    return domain.map((d2, i) => interpolator(i / (domain.length - 1)));
  };
  scale2.quantiles = function(n2) {
    return Array.from({ length: n2 + 1 }, (_, i) => quantile$1(domain, i / n2));
  };
  scale2.copy = function() {
    return sequentialQuantile(interpolator).domain(domain);
  };
  return initInterpolator.apply(scale2, arguments);
}
function transformer() {
  var x0 = 0, x1 = 0.5, x2 = 1, s2 = 1, t02, t12, t2, k10, k21, interpolator = identity$3, transform, clamp2 = false, unknown;
  function scale2(x3) {
    return isNaN(x3 = +x3) ? unknown : (x3 = 0.5 + ((x3 = +transform(x3)) - t12) * (s2 * x3 < s2 * t12 ? k10 : k21), interpolator(clamp2 ? Math.max(0, Math.min(1, x3)) : x3));
  }
  scale2.domain = function(_) {
    return arguments.length ? ([x0, x1, x2] = _, t02 = transform(x0 = +x0), t12 = transform(x1 = +x1), t2 = transform(x2 = +x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1, scale2) : [x0, x1, x2];
  };
  scale2.clamp = function(_) {
    return arguments.length ? (clamp2 = !!_, scale2) : clamp2;
  };
  scale2.interpolator = function(_) {
    return arguments.length ? (interpolator = _, scale2) : interpolator;
  };
  function range3(interpolate2) {
    return function(_) {
      var r0, r1, r2;
      return arguments.length ? ([r0, r1, r2] = _, interpolator = piecewise(interpolate2, [r0, r1, r2]), scale2) : [interpolator(0), interpolator(0.5), interpolator(1)];
    };
  }
  scale2.range = range3(interpolate);
  scale2.rangeRound = range3(interpolateRound);
  scale2.unknown = function(_) {
    return arguments.length ? (unknown = _, scale2) : unknown;
  };
  return function(t3) {
    transform = t3, t02 = t3(x0), t12 = t3(x1), t2 = t3(x2), k10 = t02 === t12 ? 0 : 0.5 / (t12 - t02), k21 = t12 === t2 ? 0 : 0.5 / (t2 - t12), s2 = t12 < t02 ? -1 : 1;
    return scale2;
  };
}
function diverging() {
  var scale2 = linearish(transformer()(identity$3));
  scale2.copy = function() {
    return copy(scale2, diverging());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingLog() {
  var scale2 = loggish(transformer()).domain([0.1, 1, 10]);
  scale2.copy = function() {
    return copy(scale2, divergingLog()).base(scale2.base());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSymlog() {
  var scale2 = symlogish(transformer());
  scale2.copy = function() {
    return copy(scale2, divergingSymlog()).constant(scale2.constant());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingPow() {
  var scale2 = powish(transformer());
  scale2.copy = function() {
    return copy(scale2, divergingPow()).exponent(scale2.exponent());
  };
  return initInterpolator.apply(scale2, arguments);
}
function divergingSqrt() {
  return divergingPow.apply(null, arguments).exponent(0.5);
}
const d3Scales = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  scaleBand: band,
  scaleDiverging: diverging,
  scaleDivergingLog: divergingLog,
  scaleDivergingPow: divergingPow,
  scaleDivergingSqrt: divergingSqrt,
  scaleDivergingSymlog: divergingSymlog,
  scaleIdentity: identity$1,
  scaleImplicit: implicit,
  scaleLinear: linear,
  scaleLog: log,
  scaleOrdinal: ordinal,
  scalePoint: point,
  scalePow: pow,
  scaleQuantile: quantile,
  scaleQuantize: quantize,
  scaleRadial: radial,
  scaleSequential: sequential,
  scaleSequentialLog: sequentialLog,
  scaleSequentialPow: sequentialPow,
  scaleSequentialQuantile: sequentialQuantile,
  scaleSequentialSqrt: sequentialSqrt,
  scaleSequentialSymlog: sequentialSymlog,
  scaleSqrt: sqrt,
  scaleSymlog: symlog,
  scaleThreshold: threshold,
  scaleTime: time,
  scaleUtc: utcTime,
  tickFormat
}, Symbol.toStringTag, { value: "Module" }));
var MAX_DIGITS = 1e9, defaults = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed during run-time using `Decimal.config`.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used by default by `toInteger`, `toDecimalPlaces`, `toExponential`,
  // `toFixed`, `toPrecision` and `toSignificantDigits`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -MAX_E
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to MAX_E
  // The natural logarithm of 10.
  // 115 digits
  LN10: "2.302585092994045684017991454684364207601101488628772976033327900967572609677352480235997205089598298341967784042286"
}, Decimal, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", exponentOutOfRange = decimalError + "Exponent out of range: ", mathfloor = Math.floor, mathpow = Math.pow, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, ONE, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, MAX_E = mathfloor(MAX_SAFE_INTEGER / LOG_BASE), P = {};
P.absoluteValue = P.abs = function() {
  var x2 = new this.constructor(this);
  if (x2.s)
    x2.s = 1;
  return x2;
};
P.comparedTo = P.cmp = function(y2) {
  var i, j, xdL, ydL, x2 = this;
  y2 = new x2.constructor(y2);
  if (x2.s !== y2.s)
    return x2.s || -y2.s;
  if (x2.e !== y2.e)
    return x2.e > y2.e ^ x2.s < 0 ? 1 : -1;
  xdL = x2.d.length;
  ydL = y2.d.length;
  for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
    if (x2.d[i] !== y2.d[i])
      return x2.d[i] > y2.d[i] ^ x2.s < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ x2.s < 0 ? 1 : -1;
};
P.decimalPlaces = P.dp = function() {
  var x2 = this, w2 = x2.d.length - 1, dp = (w2 - x2.e) * LOG_BASE;
  w2 = x2.d[w2];
  if (w2)
    for (; w2 % 10 == 0; w2 /= 10)
      dp--;
  return dp < 0 ? 0 : dp;
};
P.dividedBy = P.div = function(y2) {
  return divide(this, new this.constructor(y2));
};
P.dividedToIntegerBy = P.idiv = function(y2) {
  var x2 = this, Ctor = x2.constructor;
  return round(divide(x2, new Ctor(y2), 0, 1), Ctor.precision);
};
P.equals = P.eq = function(y2) {
  return !this.cmp(y2);
};
P.exponent = function() {
  return getBase10Exponent(this);
};
P.greaterThan = P.gt = function(y2) {
  return this.cmp(y2) > 0;
};
P.greaterThanOrEqualTo = P.gte = function(y2) {
  return this.cmp(y2) >= 0;
};
P.isInteger = P.isint = function() {
  return this.e > this.d.length - 2;
};
P.isNegative = P.isneg = function() {
  return this.s < 0;
};
P.isPositive = P.ispos = function() {
  return this.s > 0;
};
P.isZero = function() {
  return this.s === 0;
};
P.lessThan = P.lt = function(y2) {
  return this.cmp(y2) < 0;
};
P.lessThanOrEqualTo = P.lte = function(y2) {
  return this.cmp(y2) < 1;
};
P.logarithm = P.log = function(base) {
  var r2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision, wpr = pr + 5;
  if (base === void 0) {
    base = new Ctor(10);
  } else {
    base = new Ctor(base);
    if (base.s < 1 || base.eq(ONE))
      throw Error(decimalError + "NaN");
  }
  if (x2.s < 1)
    throw Error(decimalError + (x2.s ? "NaN" : "-Infinity"));
  if (x2.eq(ONE))
    return new Ctor(0);
  external = false;
  r2 = divide(ln(x2, wpr), ln(base, wpr), wpr);
  external = true;
  return round(r2, pr);
};
P.minus = P.sub = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? subtract(x2, y2) : add(x2, (y2.s = -y2.s, y2));
};
P.modulo = P.mod = function(y2) {
  var q2, x2 = this, Ctor = x2.constructor, pr = Ctor.precision;
  y2 = new Ctor(y2);
  if (!y2.s)
    throw Error(decimalError + "NaN");
  if (!x2.s)
    return round(new Ctor(x2), pr);
  external = false;
  q2 = divide(x2, y2, 0, 1).times(y2);
  external = true;
  return x2.minus(q2);
};
P.naturalExponential = P.exp = function() {
  return exp(this);
};
P.naturalLogarithm = P.ln = function() {
  return ln(this);
};
P.negated = P.neg = function() {
  var x2 = new this.constructor(this);
  x2.s = -x2.s || 0;
  return x2;
};
P.plus = P.add = function(y2) {
  var x2 = this;
  y2 = new x2.constructor(y2);
  return x2.s == y2.s ? add(x2, y2) : subtract(x2, (y2.s = -y2.s, y2));
};
P.precision = P.sd = function(z2) {
  var e3, sd, w2, x2 = this;
  if (z2 !== void 0 && z2 !== !!z2 && z2 !== 1 && z2 !== 0)
    throw Error(invalidArgument + z2);
  e3 = getBase10Exponent(x2) + 1;
  w2 = x2.d.length - 1;
  sd = w2 * LOG_BASE + 1;
  w2 = x2.d[w2];
  if (w2) {
    for (; w2 % 10 == 0; w2 /= 10)
      sd--;
    for (w2 = x2.d[0]; w2 >= 10; w2 /= 10)
      sd++;
  }
  return z2 && e3 > sd ? e3 : sd;
};
P.squareRoot = P.sqrt = function() {
  var e3, n2, pr, r2, s2, t2, wpr, x2 = this, Ctor = x2.constructor;
  if (x2.s < 1) {
    if (!x2.s)
      return new Ctor(0);
    throw Error(decimalError + "NaN");
  }
  e3 = getBase10Exponent(x2);
  external = false;
  s2 = Math.sqrt(+x2);
  if (s2 == 0 || s2 == 1 / 0) {
    n2 = digitsToString(x2.d);
    if ((n2.length + e3) % 2 == 0)
      n2 += "0";
    s2 = Math.sqrt(n2);
    e3 = mathfloor((e3 + 1) / 2) - (e3 < 0 || e3 % 2);
    if (s2 == 1 / 0) {
      n2 = "5e" + e3;
    } else {
      n2 = s2.toExponential();
      n2 = n2.slice(0, n2.indexOf("e") + 1) + e3;
    }
    r2 = new Ctor(n2);
  } else {
    r2 = new Ctor(s2.toString());
  }
  pr = Ctor.precision;
  s2 = wpr = pr + 3;
  for (; ; ) {
    t2 = r2;
    r2 = t2.plus(divide(x2, t2, wpr + 2)).times(0.5);
    if (digitsToString(t2.d).slice(0, wpr) === (n2 = digitsToString(r2.d)).slice(0, wpr)) {
      n2 = n2.slice(wpr - 3, wpr + 1);
      if (s2 == wpr && n2 == "4999") {
        round(t2, pr + 1, 0);
        if (t2.times(t2).eq(x2)) {
          r2 = t2;
          break;
        }
      } else if (n2 != "9999") {
        break;
      }
      wpr += 4;
    }
  }
  external = true;
  return round(r2, pr);
};
P.times = P.mul = function(y2) {
  var carry, e3, i, k2, r2, rL, t2, xdL, ydL, x2 = this, Ctor = x2.constructor, xd = x2.d, yd = (y2 = new Ctor(y2)).d;
  if (!x2.s || !y2.s)
    return new Ctor(0);
  y2.s *= x2.s;
  e3 = x2.e + y2.e;
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r2 = xd;
    xd = yd;
    yd = r2;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r2 = [];
  rL = xdL + ydL;
  for (i = rL; i--; )
    r2.push(0);
  for (i = ydL; --i >= 0; ) {
    carry = 0;
    for (k2 = xdL + i; k2 > i; ) {
      t2 = r2[k2] + yd[i] * xd[k2 - i - 1] + carry;
      r2[k2--] = t2 % BASE | 0;
      carry = t2 / BASE | 0;
    }
    r2[k2] = (r2[k2] + carry) % BASE | 0;
  }
  for (; !r2[--rL]; )
    r2.pop();
  if (carry)
    ++e3;
  else
    r2.shift();
  y2.d = r2;
  y2.e = e3;
  return external ? round(y2, Ctor.precision) : y2;
};
P.toDecimalPlaces = P.todp = function(dp, rm) {
  var x2 = this, Ctor = x2.constructor;
  x2 = new Ctor(x2);
  if (dp === void 0)
    return x2;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return round(x2, dp + getBase10Exponent(x2) + 1, rm);
};
P.toExponential = function(dp, rm) {
  var str, x2 = this, Ctor = x2.constructor;
  if (dp === void 0) {
    str = toString(x2, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = round(new Ctor(x2), dp + 1, rm);
    str = toString(x2, true, dp + 1);
  }
  return str;
};
P.toFixed = function(dp, rm) {
  var str, y2, x2 = this, Ctor = x2.constructor;
  if (dp === void 0)
    return toString(x2);
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  y2 = round(new Ctor(x2), dp + getBase10Exponent(x2) + 1, rm);
  str = toString(y2.abs(), false, dp + getBase10Exponent(y2) + 1);
  return x2.isneg() && !x2.isZero() ? "-" + str : str;
};
P.toInteger = P.toint = function() {
  var x2 = this, Ctor = x2.constructor;
  return round(new Ctor(x2), getBase10Exponent(x2) + 1, Ctor.rounding);
};
P.toNumber = function() {
  return +this;
};
P.toPower = P.pow = function(y2) {
  var e3, k2, pr, r2, sign2, yIsInt, x2 = this, Ctor = x2.constructor, guard = 12, yn = +(y2 = new Ctor(y2));
  if (!y2.s)
    return new Ctor(ONE);
  x2 = new Ctor(x2);
  if (!x2.s) {
    if (y2.s < 1)
      throw Error(decimalError + "Infinity");
    return x2;
  }
  if (x2.eq(ONE))
    return x2;
  pr = Ctor.precision;
  if (y2.eq(ONE))
    return round(x2, pr);
  e3 = y2.e;
  k2 = y2.d.length - 1;
  yIsInt = e3 >= k2;
  sign2 = x2.s;
  if (!yIsInt) {
    if (sign2 < 0)
      throw Error(decimalError + "NaN");
  } else if ((k2 = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r2 = new Ctor(ONE);
    e3 = Math.ceil(pr / LOG_BASE + 4);
    external = false;
    for (; ; ) {
      if (k2 % 2) {
        r2 = r2.times(x2);
        truncate(r2.d, e3);
      }
      k2 = mathfloor(k2 / 2);
      if (k2 === 0)
        break;
      x2 = x2.times(x2);
      truncate(x2.d, e3);
    }
    external = true;
    return y2.s < 0 ? new Ctor(ONE).div(r2) : round(r2, pr);
  }
  sign2 = sign2 < 0 && y2.d[Math.max(e3, k2)] & 1 ? -1 : 1;
  x2.s = 1;
  external = false;
  r2 = y2.times(ln(x2, pr + guard));
  external = true;
  r2 = exp(r2);
  r2.s = sign2;
  return r2;
};
P.toPrecision = function(sd, rm) {
  var e3, str, x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    e3 = getBase10Exponent(x2);
    str = toString(x2, e3 <= Ctor.toExpNeg || e3 >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x2 = round(new Ctor(x2), sd, rm);
    e3 = getBase10Exponent(x2);
    str = toString(x2, sd <= e3 || e3 <= Ctor.toExpNeg, sd);
  }
  return str;
};
P.toSignificantDigits = P.tosd = function(sd, rm) {
  var x2 = this, Ctor = x2.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return round(new Ctor(x2), sd, rm);
};
P.toString = P.valueOf = P.val = P.toJSON = P[Symbol.for("nodejs.util.inspect.custom")] = function() {
  var x2 = this, e3 = getBase10Exponent(x2), Ctor = x2.constructor;
  return toString(x2, e3 <= Ctor.toExpNeg || e3 >= Ctor.toExpPos);
};
function add(x2, y2) {
  var carry, d2, e3, i, k2, len, xd, yd, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (!y2.s)
      y2 = new Ctor(x2);
    return external ? round(y2, pr) : y2;
  }
  xd = x2.d;
  yd = y2.d;
  k2 = x2.e;
  e3 = y2.e;
  xd = xd.slice();
  i = k2 - e3;
  if (i) {
    if (i < 0) {
      d2 = xd;
      i = -i;
      len = yd.length;
    } else {
      d2 = yd;
      e3 = k2;
      len = xd.length;
    }
    k2 = Math.ceil(pr / LOG_BASE);
    len = k2 > len ? k2 + 1 : len + 1;
    if (i > len) {
      i = len;
      d2.length = 1;
    }
    d2.reverse();
    for (; i--; )
      d2.push(0);
    d2.reverse();
  }
  len = xd.length;
  i = yd.length;
  if (len - i < 0) {
    i = len;
    d2 = yd;
    yd = xd;
    xd = d2;
  }
  for (carry = 0; i; ) {
    carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
    xd[i] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e3;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y2.d = xd;
  y2.e = e3;
  return external ? round(y2, pr) : y2;
}
function checkInt32(i, min2, max2) {
  if (i !== ~~i || i < min2 || i > max2) {
    throw Error(invalidArgument + i);
  }
}
function digitsToString(d2) {
  var i, k2, ws, indexOfLastWord = d2.length - 1, str = "", w2 = d2[0];
  if (indexOfLastWord > 0) {
    str += w2;
    for (i = 1; i < indexOfLastWord; i++) {
      ws = d2[i] + "";
      k2 = LOG_BASE - ws.length;
      if (k2)
        str += getZeroString(k2);
      str += ws;
    }
    w2 = d2[i];
    ws = w2 + "";
    k2 = LOG_BASE - ws.length;
    if (k2)
      str += getZeroString(k2);
  } else if (w2 === 0) {
    return "0";
  }
  for (; w2 % 10 === 0; )
    w2 /= 10;
  return str + w2;
}
var divide = /* @__PURE__ */ function() {
  function multiplyInteger(x2, k2) {
    var temp, carry = 0, i = x2.length;
    for (x2 = x2.slice(); i--; ) {
      temp = x2[i] * k2 + carry;
      x2[i] = temp % BASE | 0;
      carry = temp / BASE | 0;
    }
    if (carry)
      x2.unshift(carry);
    return x2;
  }
  function compare(a2, b2, aL, bL) {
    var i, r2;
    if (aL != bL) {
      r2 = aL > bL ? 1 : -1;
    } else {
      for (i = r2 = 0; i < aL; i++) {
        if (a2[i] != b2[i]) {
          r2 = a2[i] > b2[i] ? 1 : -1;
          break;
        }
      }
    }
    return r2;
  }
  function subtract2(a2, b2, aL) {
    var i = 0;
    for (; aL--; ) {
      a2[aL] -= i;
      i = a2[aL] < b2[aL] ? 1 : 0;
      a2[aL] = i * BASE + a2[aL] - b2[aL];
    }
    for (; !a2[0] && a2.length > 1; )
      a2.shift();
  }
  return function(x2, y2, pr, dp) {
    var cmp, e3, i, k2, prod2, prodL, q2, qd, rem, remL, rem0, sd, t2, xi, xL, yd0, yL, yz, Ctor = x2.constructor, sign2 = x2.s == y2.s ? 1 : -1, xd = x2.d, yd = y2.d;
    if (!x2.s)
      return new Ctor(x2);
    if (!y2.s)
      throw Error(decimalError + "Division by zero");
    e3 = x2.e - y2.e;
    yL = yd.length;
    xL = xd.length;
    q2 = new Ctor(sign2);
    qd = q2.d = [];
    for (i = 0; yd[i] == (xd[i] || 0); )
      ++i;
    if (yd[i] > (xd[i] || 0))
      --e3;
    if (pr == null) {
      sd = pr = Ctor.precision;
    } else if (dp) {
      sd = pr + (getBase10Exponent(x2) - getBase10Exponent(y2)) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0)
      return new Ctor(0);
    sd = sd / LOG_BASE + 2 | 0;
    i = 0;
    if (yL == 1) {
      k2 = 0;
      yd = yd[0];
      sd++;
      for (; (i < xL || k2) && sd--; i++) {
        t2 = k2 * BASE + (xd[i] || 0);
        qd[i] = t2 / yd | 0;
        k2 = t2 % yd | 0;
      }
    } else {
      k2 = BASE / (yd[0] + 1) | 0;
      if (k2 > 1) {
        yd = multiplyInteger(yd, k2);
        xd = multiplyInteger(xd, k2);
        yL = yd.length;
        xL = xd.length;
      }
      xi = yL;
      rem = xd.slice(0, yL);
      remL = rem.length;
      for (; remL < yL; )
        rem[remL++] = 0;
      yz = yd.slice();
      yz.unshift(0);
      yd0 = yd[0];
      if (yd[1] >= BASE / 2)
        ++yd0;
      do {
        k2 = 0;
        cmp = compare(yd, rem, yL, remL);
        if (cmp < 0) {
          rem0 = rem[0];
          if (yL != remL)
            rem0 = rem0 * BASE + (rem[1] || 0);
          k2 = rem0 / yd0 | 0;
          if (k2 > 1) {
            if (k2 >= BASE)
              k2 = BASE - 1;
            prod2 = multiplyInteger(yd, k2);
            prodL = prod2.length;
            remL = rem.length;
            cmp = compare(prod2, rem, prodL, remL);
            if (cmp == 1) {
              k2--;
              subtract2(prod2, yL < prodL ? yz : yd, prodL);
            }
          } else {
            if (k2 == 0)
              cmp = k2 = 1;
            prod2 = yd.slice();
          }
          prodL = prod2.length;
          if (prodL < remL)
            prod2.unshift(0);
          subtract2(rem, prod2, remL);
          if (cmp == -1) {
            remL = rem.length;
            cmp = compare(yd, rem, yL, remL);
            if (cmp < 1) {
              k2++;
              subtract2(rem, yL < remL ? yz : yd, remL);
            }
          }
          remL = rem.length;
        } else if (cmp === 0) {
          k2++;
          rem = [0];
        }
        qd[i++] = k2;
        if (cmp && rem[0]) {
          rem[remL++] = xd[xi] || 0;
        } else {
          rem = [xd[xi]];
          remL = 1;
        }
      } while ((xi++ < xL || rem[0] !== void 0) && sd--);
    }
    if (!qd[0])
      qd.shift();
    q2.e = e3;
    return round(q2, dp ? pr + getBase10Exponent(q2) + 1 : pr);
  };
}();
function exp(x2, sd) {
  var denominator, guard, pow2, sum2, t2, wpr, i = 0, k2 = 0, Ctor = x2.constructor, pr = Ctor.precision;
  if (getBase10Exponent(x2) > 16)
    throw Error(exponentOutOfRange + getBase10Exponent(x2));
  if (!x2.s)
    return new Ctor(ONE);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t2 = new Ctor(0.03125);
  while (x2.abs().gte(0.1)) {
    x2 = x2.times(t2);
    k2 += 5;
  }
  guard = Math.log(mathpow(2, k2)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(ONE);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = round(pow2.times(x2), wpr);
    denominator = denominator.times(++i);
    t2 = sum2.plus(divide(pow2, denominator, wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      while (k2--)
        sum2 = round(sum2.times(sum2), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round(sum2, pr)) : sum2;
    }
    sum2 = t2;
  }
}
function getBase10Exponent(x2) {
  var e3 = x2.e * LOG_BASE, w2 = x2.d[0];
  for (; w2 >= 10; w2 /= 10)
    e3++;
  return e3;
}
function getLn10(Ctor, sd, pr) {
  if (sd > Ctor.LN10.sd()) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(decimalError + "LN10 precision limit exceeded");
  }
  return round(new Ctor(Ctor.LN10), sd);
}
function getZeroString(k2) {
  var zs = "";
  for (; k2--; )
    zs += "0";
  return zs;
}
function ln(y2, sd) {
  var c2, c0, denominator, e3, numerator, sum2, t2, wpr, x2, n2 = 1, guard = 10, x3 = y2, xd = x3.d, Ctor = x3.constructor, pr = Ctor.precision;
  if (x3.s < 1)
    throw Error(decimalError + (x3.s ? "NaN" : "-Infinity"));
  if (x3.eq(ONE))
    return new Ctor(0);
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  if (x3.eq(10)) {
    if (sd == null)
      external = true;
    return getLn10(Ctor, wpr);
  }
  wpr += guard;
  Ctor.precision = wpr;
  c2 = digitsToString(xd);
  c0 = c2.charAt(0);
  e3 = getBase10Exponent(x3);
  if (Math.abs(e3) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c2.charAt(1) > 3) {
      x3 = x3.times(y2);
      c2 = digitsToString(x3.d);
      c0 = c2.charAt(0);
      n2++;
    }
    e3 = getBase10Exponent(x3);
    if (c0 > 1) {
      x3 = new Ctor("0." + c2);
      e3++;
    } else {
      x3 = new Ctor(c0 + "." + c2.slice(1));
    }
  } else {
    t2 = getLn10(Ctor, wpr + 2, pr).times(e3 + "");
    x3 = ln(new Ctor(c0 + "." + c2.slice(1)), wpr - guard).plus(t2);
    Ctor.precision = pr;
    return sd == null ? (external = true, round(x3, pr)) : x3;
  }
  sum2 = numerator = x3 = divide(x3.minus(ONE), x3.plus(ONE), wpr);
  x2 = round(x3.times(x3), wpr);
  denominator = 3;
  for (; ; ) {
    numerator = round(numerator.times(x2), wpr);
    t2 = sum2.plus(divide(numerator, new Ctor(denominator), wpr));
    if (digitsToString(t2.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e3 !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e3 + ""));
      sum2 = divide(sum2, new Ctor(n2), wpr);
      Ctor.precision = pr;
      return sd == null ? (external = true, round(sum2, pr)) : sum2;
    }
    sum2 = t2;
    denominator += 2;
  }
}
function parseDecimal(x2, str) {
  var e3, i, len;
  if ((e3 = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i = str.search(/e/i)) > 0) {
    if (e3 < 0)
      e3 = i;
    e3 += +str.slice(i + 1);
    str = str.substring(0, i);
  } else if (e3 < 0) {
    e3 = str.length;
  }
  for (i = 0; str.charCodeAt(i) === 48; )
    ++i;
  for (len = str.length; str.charCodeAt(len - 1) === 48; )
    --len;
  str = str.slice(i, len);
  if (str) {
    len -= i;
    e3 = e3 - i - 1;
    x2.e = mathfloor(e3 / LOG_BASE);
    x2.d = [];
    i = (e3 + 1) % LOG_BASE;
    if (e3 < 0)
      i += LOG_BASE;
    if (i < len) {
      if (i)
        x2.d.push(+str.slice(0, i));
      for (len -= LOG_BASE; i < len; )
        x2.d.push(+str.slice(i, i += LOG_BASE));
      str = str.slice(i);
      i = LOG_BASE - str.length;
    } else {
      i -= len;
    }
    for (; i--; )
      str += "0";
    x2.d.push(+str);
    if (external && (x2.e > MAX_E || x2.e < -MAX_E))
      throw Error(exponentOutOfRange + e3);
  } else {
    x2.s = 0;
    x2.e = 0;
    x2.d = [0];
  }
  return x2;
}
function round(x2, sd, rm) {
  var i, j, k2, n2, rd, doRound, w2, xdi, xd = x2.d;
  for (n2 = 1, k2 = xd[0]; k2 >= 10; k2 /= 10)
    n2++;
  i = sd - n2;
  if (i < 0) {
    i += LOG_BASE;
    j = sd;
    w2 = xd[xdi = 0];
  } else {
    xdi = Math.ceil((i + 1) / LOG_BASE);
    k2 = xd.length;
    if (xdi >= k2)
      return x2;
    w2 = k2 = xd[xdi];
    for (n2 = 1; k2 >= 10; k2 /= 10)
      n2++;
    i %= LOG_BASE;
    j = i - LOG_BASE + n2;
  }
  if (rm !== void 0) {
    k2 = mathpow(10, n2 - j - 1);
    rd = w2 / k2 % 10 | 0;
    doRound = sd < 0 || xd[xdi + 1] !== void 0 || w2 % k2;
    doRound = rm < 4 ? (rd || doRound) && (rm == 0 || rm == (x2.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || doRound || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
    (i > 0 ? j > 0 ? w2 / mathpow(10, n2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x2.s < 0 ? 8 : 7));
  }
  if (sd < 1 || !xd[0]) {
    if (doRound) {
      k2 = getBase10Exponent(x2);
      xd.length = 1;
      sd = sd - k2 - 1;
      xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
      x2.e = mathfloor(-sd / LOG_BASE) || 0;
    } else {
      xd.length = 1;
      xd[0] = x2.e = x2.s = 0;
    }
    return x2;
  }
  if (i == 0) {
    xd.length = xdi;
    k2 = 1;
    xdi--;
  } else {
    xd.length = xdi + 1;
    k2 = mathpow(10, LOG_BASE - i);
    xd[xdi] = j > 0 ? (w2 / mathpow(10, n2 - j) % mathpow(10, j) | 0) * k2 : 0;
  }
  if (doRound) {
    for (; ; ) {
      if (xdi == 0) {
        if ((xd[0] += k2) == BASE) {
          xd[0] = 1;
          ++x2.e;
        }
        break;
      } else {
        xd[xdi] += k2;
        if (xd[xdi] != BASE)
          break;
        xd[xdi--] = 0;
        k2 = 1;
      }
    }
  }
  for (i = xd.length; xd[--i] === 0; )
    xd.pop();
  if (external && (x2.e > MAX_E || x2.e < -MAX_E)) {
    throw Error(exponentOutOfRange + getBase10Exponent(x2));
  }
  return x2;
}
function subtract(x2, y2) {
  var d2, e3, i, j, k2, len, xd, xe, xLTy, yd, Ctor = x2.constructor, pr = Ctor.precision;
  if (!x2.s || !y2.s) {
    if (y2.s)
      y2.s = -y2.s;
    else
      y2 = new Ctor(x2);
    return external ? round(y2, pr) : y2;
  }
  xd = x2.d;
  yd = y2.d;
  e3 = y2.e;
  xe = x2.e;
  xd = xd.slice();
  k2 = xe - e3;
  if (k2) {
    xLTy = k2 < 0;
    if (xLTy) {
      d2 = xd;
      k2 = -k2;
      len = yd.length;
    } else {
      d2 = yd;
      e3 = xe;
      len = xd.length;
    }
    i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k2 > i) {
      k2 = i;
      d2.length = 1;
    }
    d2.reverse();
    for (i = k2; i--; )
      d2.push(0);
    d2.reverse();
  } else {
    i = xd.length;
    len = yd.length;
    xLTy = i < len;
    if (xLTy)
      len = i;
    for (i = 0; i < len; i++) {
      if (xd[i] != yd[i]) {
        xLTy = xd[i] < yd[i];
        break;
      }
    }
    k2 = 0;
  }
  if (xLTy) {
    d2 = xd;
    xd = yd;
    yd = d2;
    y2.s = -y2.s;
  }
  len = xd.length;
  for (i = yd.length - len; i > 0; --i)
    xd[len++] = 0;
  for (i = yd.length; i > k2; ) {
    if (xd[--i] < yd[i]) {
      for (j = i; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i] += BASE;
    }
    xd[i] -= yd[i];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e3;
  if (!xd[0])
    return new Ctor(0);
  y2.d = xd;
  y2.e = e3;
  return external ? round(y2, pr) : y2;
}
function toString(x2, isExp, sd) {
  var k2, e3 = getBase10Exponent(x2), str = digitsToString(x2.d), len = str.length;
  if (isExp) {
    if (sd && (k2 = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k2);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (e3 < 0 ? "e" : "e+") + e3;
  } else if (e3 < 0) {
    str = "0." + getZeroString(-e3 - 1) + str;
    if (sd && (k2 = sd - len) > 0)
      str += getZeroString(k2);
  } else if (e3 >= len) {
    str += getZeroString(e3 + 1 - len);
    if (sd && (k2 = sd - e3 - 1) > 0)
      str = str + "." + getZeroString(k2);
  } else {
    if ((k2 = e3 + 1) < len)
      str = str.slice(0, k2) + "." + str.slice(k2);
    if (sd && (k2 = sd - len) > 0) {
      if (e3 + 1 === len)
        str += ".";
      str += getZeroString(k2);
    }
  }
  return x2.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function clone(obj) {
  var i, p2, ps;
  function Decimal2(value) {
    var x2 = this;
    if (!(x2 instanceof Decimal2))
      return new Decimal2(value);
    x2.constructor = Decimal2;
    if (value instanceof Decimal2) {
      x2.s = value.s;
      x2.e = value.e;
      x2.d = (value = value.d) ? value.slice() : value;
      return;
    }
    if (typeof value === "number") {
      if (value * 0 !== 0) {
        throw Error(invalidArgument + value);
      }
      if (value > 0) {
        x2.s = 1;
      } else if (value < 0) {
        value = -value;
        x2.s = -1;
      } else {
        x2.s = 0;
        x2.e = 0;
        x2.d = [0];
        return;
      }
      if (value === ~~value && value < 1e7) {
        x2.e = 0;
        x2.d = [value];
        return;
      }
      return parseDecimal(x2, value.toString());
    } else if (typeof value !== "string") {
      throw Error(invalidArgument + value);
    }
    if (value.charCodeAt(0) === 45) {
      value = value.slice(1);
      x2.s = -1;
    } else {
      x2.s = 1;
    }
    if (isDecimal.test(value))
      parseDecimal(x2, value);
    else
      throw Error(invalidArgument + value);
  }
  Decimal2.prototype = P;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.clone = clone;
  Decimal2.config = Decimal2.set = config;
  if (obj === void 0)
    obj = {};
  if (obj) {
    ps = ["precision", "rounding", "toExpNeg", "toExpPos", "LN10"];
    for (i = 0; i < ps.length; )
      if (!obj.hasOwnProperty(p2 = ps[i++]))
        obj[p2] = this[p2];
  }
  Decimal2.config(obj);
  return Decimal2;
}
function config(obj) {
  if (!obj || typeof obj !== "object") {
    throw Error(decimalError + "Object expected");
  }
  var i, p2, v2, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -1 / 0,
    0,
    "toExpPos",
    0,
    1 / 0
  ];
  for (i = 0; i < ps.length; i += 3) {
    if ((v2 = obj[p2 = ps[i]]) !== void 0) {
      if (mathfloor(v2) === v2 && v2 >= ps[i + 1] && v2 <= ps[i + 2])
        this[p2] = v2;
      else
        throw Error(invalidArgument + p2 + ": " + v2);
    }
  }
  if ((v2 = obj[p2 = "LN10"]) !== void 0) {
    if (v2 == Math.LN10)
      this[p2] = new this(v2);
    else
      throw Error(invalidArgument + p2 + ": " + v2);
  }
  return this;
}
var Decimal = clone(defaults);
ONE = new Decimal(1);
const Decimal$1 = Decimal;
function _toConsumableArray$7(arr) {
  return _arrayWithoutHoles$7(arr) || _iterableToArray$7(arr) || _unsupportedIterableToArray$9(arr) || _nonIterableSpread$7();
}
function _nonIterableSpread$7() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$9(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$9(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$9(o, minLen);
}
function _iterableToArray$7(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _arrayWithoutHoles$7(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$9(arr);
}
function _arrayLikeToArray$9(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
var identity = function identity3(i) {
  return i;
};
var PLACE_HOLDER = {
  "@@functional/placeholder": true
};
var isPlaceHolder = function isPlaceHolder2(val) {
  return val === PLACE_HOLDER;
};
var curry0 = function curry02(fn) {
  return function _curried() {
    if (arguments.length === 0 || arguments.length === 1 && isPlaceHolder(arguments.length <= 0 ? void 0 : arguments[0])) {
      return _curried;
    }
    return fn.apply(void 0, arguments);
  };
};
var curryN = function curryN2(n2, fn) {
  if (n2 === 1) {
    return fn;
  }
  return curry0(function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    var argsLength = args.filter(function(arg) {
      return arg !== PLACE_HOLDER;
    }).length;
    if (argsLength >= n2) {
      return fn.apply(void 0, args);
    }
    return curryN2(n2 - argsLength, curry0(function() {
      for (var _len2 = arguments.length, restArgs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        restArgs[_key2] = arguments[_key2];
      }
      var newArgs = args.map(function(arg) {
        return isPlaceHolder(arg) ? restArgs.shift() : arg;
      });
      return fn.apply(void 0, _toConsumableArray$7(newArgs).concat(restArgs));
    }));
  });
};
var curry = function curry2(fn) {
  return curryN(fn.length, fn);
};
var range$1 = function range(begin, end) {
  var arr = [];
  for (var i = begin; i < end; ++i) {
    arr[i - begin] = i;
  }
  return arr;
};
var map = curry(function(fn, arr) {
  if (Array.isArray(arr)) {
    return arr.map(fn);
  }
  return Object.keys(arr).map(function(key) {
    return arr[key];
  }).map(fn);
});
var compose = function compose2() {
  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
    args[_key3] = arguments[_key3];
  }
  if (!args.length) {
    return identity;
  }
  var fns = args.reverse();
  var firstFn = fns[0];
  var tailsFn = fns.slice(1);
  return function() {
    return tailsFn.reduce(function(res, fn) {
      return fn(res);
    }, firstFn.apply(void 0, arguments));
  };
};
var reverse = function reverse2(arr) {
  if (Array.isArray(arr)) {
    return arr.reverse();
  }
  return arr.split("").reverse.join("");
};
var memoize = function memoize2(fn) {
  var lastArgs = null;
  var lastResult2 = null;
  return function() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    if (lastArgs && args.every(function(val, i) {
      return val === lastArgs[i];
    })) {
      return lastResult2;
    }
    lastArgs = args;
    lastResult2 = fn.apply(void 0, args);
    return lastResult2;
  };
};
function getDigitCount(value) {
  var result;
  if (value === 0) {
    result = 1;
  } else {
    result = Math.floor(new Decimal$1(value).abs().log(10).toNumber()) + 1;
  }
  return result;
}
function rangeStep(start, end, step) {
  var num = new Decimal$1(start);
  var i = 0;
  var result = [];
  while (num.lt(end) && i < 1e5) {
    result.push(num.toNumber());
    num = num.add(step);
    i++;
  }
  return result;
}
var interpolateNumber2 = curry(function(a2, b2, t2) {
  var newA = +a2;
  var newB = +b2;
  return newA + t2 * (newB - newA);
});
var uninterpolateNumber = curry(function(a2, b2, x2) {
  var diff = b2 - +a2;
  diff = diff || Infinity;
  return (x2 - a2) / diff;
});
var uninterpolateTruncation = curry(function(a2, b2, x2) {
  var diff = b2 - +a2;
  diff = diff || Infinity;
  return Math.max(0, Math.min(1, (x2 - a2) / diff));
});
const Arithmetic = {
  rangeStep,
  getDigitCount,
  interpolateNumber: interpolateNumber2,
  uninterpolateNumber,
  uninterpolateTruncation
};
function _toConsumableArray$6(arr) {
  return _arrayWithoutHoles$6(arr) || _iterableToArray$6(arr) || _unsupportedIterableToArray$8(arr) || _nonIterableSpread$6();
}
function _nonIterableSpread$6() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArray$6(iter) {
  if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter))
    return Array.from(iter);
}
function _arrayWithoutHoles$6(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$8(arr);
}
function _slicedToArray$3(arr, i) {
  return _arrayWithHoles$3(arr) || _iterableToArrayLimit$3(arr, i) || _unsupportedIterableToArray$8(arr, i) || _nonIterableRest$3();
}
function _nonIterableRest$3() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$8(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$8(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$8(o, minLen);
}
function _arrayLikeToArray$8(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }
  return arr2;
}
function _iterableToArrayLimit$3(arr, i) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _arrayWithHoles$3(arr) {
  if (Array.isArray(arr))
    return arr;
}
function getValidInterval(_ref) {
  var _ref2 = _slicedToArray$3(_ref, 2), min2 = _ref2[0], max2 = _ref2[1];
  var validMin = min2, validMax = max2;
  if (min2 > max2) {
    validMin = max2;
    validMax = min2;
  }
  return [validMin, validMax];
}
function getFormatStep(roughStep, allowDecimals, correctionFactor) {
  if (roughStep.lte(0)) {
    return new Decimal$1(0);
  }
  var digitCount = Arithmetic.getDigitCount(roughStep.toNumber());
  var digitCountValue = new Decimal$1(10).pow(digitCount);
  var stepRatio = roughStep.div(digitCountValue);
  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;
  var amendStepRatio = new Decimal$1(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);
  var formatStep = amendStepRatio.mul(digitCountValue);
  return allowDecimals ? formatStep : new Decimal$1(Math.ceil(formatStep));
}
function getTickOfSingleValue(value, tickCount, allowDecimals) {
  var step = 1;
  var middle = new Decimal$1(value);
  if (!middle.isint() && allowDecimals) {
    var absVal = Math.abs(value);
    if (absVal < 1) {
      step = new Decimal$1(10).pow(Arithmetic.getDigitCount(value) - 1);
      middle = new Decimal$1(Math.floor(middle.div(step).toNumber())).mul(step);
    } else if (absVal > 1) {
      middle = new Decimal$1(Math.floor(value));
    }
  } else if (value === 0) {
    middle = new Decimal$1(Math.floor((tickCount - 1) / 2));
  } else if (!allowDecimals) {
    middle = new Decimal$1(Math.floor(value));
  }
  var middleIndex = Math.floor((tickCount - 1) / 2);
  var fn = compose(map(function(n2) {
    return middle.add(new Decimal$1(n2 - middleIndex).mul(step)).toNumber();
  }), range$1);
  return fn(0, tickCount);
}
function calculateStep(min2, max2, tickCount, allowDecimals) {
  var correctionFactor = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  if (!Number.isFinite((max2 - min2) / (tickCount - 1))) {
    return {
      step: new Decimal$1(0),
      tickMin: new Decimal$1(0),
      tickMax: new Decimal$1(0)
    };
  }
  var step = getFormatStep(new Decimal$1(max2).sub(min2).div(tickCount - 1), allowDecimals, correctionFactor);
  var middle;
  if (min2 <= 0 && max2 >= 0) {
    middle = new Decimal$1(0);
  } else {
    middle = new Decimal$1(min2).add(max2).div(2);
    middle = middle.sub(new Decimal$1(middle).mod(step));
  }
  var belowCount = Math.ceil(middle.sub(min2).div(step).toNumber());
  var upCount = Math.ceil(new Decimal$1(max2).sub(middle).div(step).toNumber());
  var scaleCount = belowCount + upCount + 1;
  if (scaleCount > tickCount) {
    return calculateStep(min2, max2, tickCount, allowDecimals, correctionFactor + 1);
  }
  if (scaleCount < tickCount) {
    upCount = max2 > 0 ? upCount + (tickCount - scaleCount) : upCount;
    belowCount = max2 > 0 ? belowCount : belowCount + (tickCount - scaleCount);
  }
  return {
    step,
    tickMin: middle.sub(new Decimal$1(belowCount).mul(step)),
    tickMax: middle.add(new Decimal$1(upCount).mul(step))
  };
}
function getNiceTickValuesFn(_ref3) {
  var _ref4 = _slicedToArray$3(_ref3, 2), min2 = _ref4[0], max2 = _ref4[1];
  var tickCount = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 6;
  var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var count = Math.max(tickCount, 2);
  var _getValidInterval = getValidInterval([min2, max2]), _getValidInterval2 = _slicedToArray$3(_getValidInterval, 2), cormin = _getValidInterval2[0], cormax = _getValidInterval2[1];
  if (cormin === -Infinity || cormax === Infinity) {
    var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray$6(range$1(0, tickCount - 1).map(function() {
      return Infinity;
    }))) : [].concat(_toConsumableArray$6(range$1(0, tickCount - 1).map(function() {
      return -Infinity;
    })), [cormax]);
    return min2 > max2 ? reverse(_values) : _values;
  }
  if (cormin === cormax) {
    return getTickOfSingleValue(cormin, tickCount, allowDecimals);
  }
  var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals), step = _calculateStep.step, tickMin = _calculateStep.tickMin, tickMax = _calculateStep.tickMax;
  var values = Arithmetic.rangeStep(tickMin, tickMax.add(new Decimal$1(0.1).mul(step)), step);
  return min2 > max2 ? reverse(values) : values;
}
function getTickValuesFixedDomainFn(_ref7, tickCount) {
  var _ref8 = _slicedToArray$3(_ref7, 2), min2 = _ref8[0], max2 = _ref8[1];
  var allowDecimals = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  var _getValidInterval5 = getValidInterval([min2, max2]), _getValidInterval6 = _slicedToArray$3(_getValidInterval5, 2), cormin = _getValidInterval6[0], cormax = _getValidInterval6[1];
  if (cormin === -Infinity || cormax === Infinity) {
    return [min2, max2];
  }
  if (cormin === cormax) {
    return [cormin];
  }
  var count = Math.max(tickCount, 2);
  var step = getFormatStep(new Decimal$1(cormax).sub(cormin).div(count - 1), allowDecimals, 0);
  var values = [].concat(_toConsumableArray$6(Arithmetic.rangeStep(new Decimal$1(cormin), new Decimal$1(cormax).sub(new Decimal$1(0.99).mul(step)), step)), [cormax]);
  return min2 > max2 ? reverse(values) : values;
}
var getNiceTickValues = memoize(getNiceTickValuesFn);
var getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn);
var _excluded$9 = ["offset", "layout", "width", "dataKey", "data", "dataPointFormatter", "xAxis", "yAxis"];
function _extends$i() {
  _extends$i = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$i.apply(this, arguments);
}
function _slicedToArray$2(arr, i) {
  return _arrayWithHoles$2(arr) || _iterableToArrayLimit$2(arr, i) || _unsupportedIterableToArray$7(arr, i) || _nonIterableRest$2();
}
function _nonIterableRest$2() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$7(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$7(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$7(o, minLen);
}
function _arrayLikeToArray$7(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$2(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$2(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _objectWithoutProperties$9(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$9(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$9(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function ErrorBar(props) {
  var offset = props.offset, layout = props.layout, width = props.width, dataKey = props.dataKey, data = props.data, dataPointFormatter = props.dataPointFormatter, xAxis = props.xAxis, yAxis = props.yAxis, others = _objectWithoutProperties$9(props, _excluded$9);
  var svgProps = filterProps(others);
  var errorBars = data.map(function(entry, i) {
    var _dataPointFormatter = dataPointFormatter(entry, dataKey), x2 = _dataPointFormatter.x, y2 = _dataPointFormatter.y, value = _dataPointFormatter.value, errorVal = _dataPointFormatter.errorVal;
    if (!errorVal) {
      return null;
    }
    var lineCoordinates = [];
    var lowBound, highBound;
    if (Array.isArray(errorVal)) {
      var _errorVal = _slicedToArray$2(errorVal, 2);
      lowBound = _errorVal[0];
      highBound = _errorVal[1];
    } else {
      lowBound = highBound = errorVal;
    }
    if (layout === "vertical") {
      var scale2 = xAxis.scale;
      var yMid = y2 + offset;
      var yMin = yMid + width;
      var yMax = yMid - width;
      var xMin = scale2(value - lowBound);
      var xMax = scale2(value + highBound);
      lineCoordinates.push({
        x1: xMax,
        y1: yMin,
        x2: xMax,
        y2: yMax
      });
      lineCoordinates.push({
        x1: xMin,
        y1: yMid,
        x2: xMax,
        y2: yMid
      });
      lineCoordinates.push({
        x1: xMin,
        y1: yMin,
        x2: xMin,
        y2: yMax
      });
    } else if (layout === "horizontal") {
      var _scale = yAxis.scale;
      var xMid = x2 + offset;
      var _xMin = xMid - width;
      var _xMax = xMid + width;
      var _yMin = _scale(value - lowBound);
      var _yMax = _scale(value + highBound);
      lineCoordinates.push({
        x1: _xMin,
        y1: _yMax,
        x2: _xMax,
        y2: _yMax
      });
      lineCoordinates.push({
        x1: xMid,
        y1: _yMin,
        x2: xMid,
        y2: _yMax
      });
      lineCoordinates.push({
        x1: _xMin,
        y1: _yMin,
        x2: _xMax,
        y2: _yMin
      });
    }
    return (
      // eslint-disable-next-line react/no-array-index-key
      /* @__PURE__ */ React.createElement(Layer, _extends$i({
        className: "recharts-errorBar",
        key: "bar-".concat(i)
      }, svgProps), lineCoordinates.map(function(coordinates, index) {
        return (
          // eslint-disable-next-line react/no-array-index-key
          /* @__PURE__ */ React.createElement("line", _extends$i({}, coordinates, {
            key: "line-".concat(index)
          }))
        );
      }))
    );
  });
  return /* @__PURE__ */ React.createElement(Layer, {
    className: "recharts-errorBars"
  }, errorBars);
}
ErrorBar.defaultProps = {
  stroke: "black",
  strokeWidth: 1.5,
  width: 5,
  offset: 0,
  layout: "horizontal"
};
ErrorBar.displayName = "ErrorBar";
function _typeof$l(obj) {
  "@babel/helpers - typeof";
  return _typeof$l = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$l(obj);
}
function _toConsumableArray$5(arr) {
  return _arrayWithoutHoles$5(arr) || _iterableToArray$5(arr) || _unsupportedIterableToArray$6(arr) || _nonIterableSpread$5();
}
function _nonIterableSpread$5() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$6(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$6(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$6(o, minLen);
}
function _iterableToArray$5(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$5(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$6(arr);
}
function _arrayLikeToArray$6(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function ownKeys$h(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$h(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$h(Object(source), true).forEach(function(key) {
      _defineProperty$k(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$h(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$k(obj, key, value) {
  key = _toPropertyKey$l(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$l(arg) {
  var key = _toPrimitive$l(arg, "string");
  return _typeof$l(key) === "symbol" ? key : String(key);
}
function _toPrimitive$l(input2, hint) {
  if (_typeof$l(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$l(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function getValueByDataKey(obj, dataKey, defaultValue) {
  if (_isNil(obj) || _isNil(dataKey)) {
    return defaultValue;
  }
  if (isNumOrStr(dataKey)) {
    return _get(obj, dataKey, defaultValue);
  }
  if (_isFunction(dataKey)) {
    return dataKey(obj);
  }
  return defaultValue;
}
function getDomainOfDataByKey(data, key, type, filterNil) {
  var flattenData = _flatMap(data, function(entry) {
    return getValueByDataKey(entry, key);
  });
  if (type === "number") {
    var domain = flattenData.filter(function(entry) {
      return isNumber(entry) || parseFloat(entry);
    });
    return domain.length ? [_min(domain), _max(domain)] : [Infinity, -Infinity];
  }
  var validateData = filterNil ? flattenData.filter(function(entry) {
    return !_isNil(entry);
  }) : flattenData;
  return validateData.map(function(entry) {
    return isNumOrStr(entry) || entry instanceof Date ? entry : "";
  });
}
var calculateActiveTickIndex = function calculateActiveTickIndex2(coordinate) {
  var _ticks$length;
  var ticks2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];
  var unsortedTicks = arguments.length > 2 ? arguments[2] : void 0;
  var axis = arguments.length > 3 ? arguments[3] : void 0;
  var index = -1;
  var len = (_ticks$length = ticks2 === null || ticks2 === void 0 ? void 0 : ticks2.length) !== null && _ticks$length !== void 0 ? _ticks$length : 0;
  if (len <= 1) {
    return 0;
  }
  if (axis && axis.axisType === "angleAxis" && Math.abs(Math.abs(axis.range[1] - axis.range[0]) - 360) <= 1e-6) {
    var range3 = axis.range;
    for (var i = 0; i < len; i++) {
      var before = i > 0 ? unsortedTicks[i - 1].coordinate : unsortedTicks[len - 1].coordinate;
      var cur = unsortedTicks[i].coordinate;
      var after = i >= len - 1 ? unsortedTicks[0].coordinate : unsortedTicks[i + 1].coordinate;
      var sameDirectionCoord = void 0;
      if (mathSign(cur - before) !== mathSign(after - cur)) {
        var diffInterval = [];
        if (mathSign(after - cur) === mathSign(range3[1] - range3[0])) {
          sameDirectionCoord = after;
          var curInRange = cur + range3[1] - range3[0];
          diffInterval[0] = Math.min(curInRange, (curInRange + before) / 2);
          diffInterval[1] = Math.max(curInRange, (curInRange + before) / 2);
        } else {
          sameDirectionCoord = before;
          var afterInRange = after + range3[1] - range3[0];
          diffInterval[0] = Math.min(cur, (afterInRange + cur) / 2);
          diffInterval[1] = Math.max(cur, (afterInRange + cur) / 2);
        }
        var sameInterval = [Math.min(cur, (sameDirectionCoord + cur) / 2), Math.max(cur, (sameDirectionCoord + cur) / 2)];
        if (coordinate > sameInterval[0] && coordinate <= sameInterval[1] || coordinate >= diffInterval[0] && coordinate <= diffInterval[1]) {
          index = unsortedTicks[i].index;
          break;
        }
      } else {
        var min2 = Math.min(before, after);
        var max2 = Math.max(before, after);
        if (coordinate > (min2 + cur) / 2 && coordinate <= (max2 + cur) / 2) {
          index = unsortedTicks[i].index;
          break;
        }
      }
    }
  } else {
    for (var _i = 0; _i < len; _i++) {
      if (_i === 0 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i > 0 && _i < len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2 && coordinate <= (ticks2[_i].coordinate + ticks2[_i + 1].coordinate) / 2 || _i === len - 1 && coordinate > (ticks2[_i].coordinate + ticks2[_i - 1].coordinate) / 2) {
        index = ticks2[_i].index;
        break;
      }
    }
  }
  return index;
};
var getMainColorOfGraphicItem = function getMainColorOfGraphicItem2(item) {
  var _ref = item, displayName = _ref.type.displayName;
  var _item$props = item.props, stroke = _item$props.stroke, fill = _item$props.fill;
  var result;
  switch (displayName) {
    case "Line":
      result = stroke;
      break;
    case "Area":
    case "Radar":
      result = stroke && stroke !== "none" ? stroke : fill;
      break;
    default:
      result = fill;
      break;
  }
  return result;
};
var getLegendProps = function getLegendProps2(_ref2) {
  var children = _ref2.children, formattedGraphicalItems = _ref2.formattedGraphicalItems, legendWidth = _ref2.legendWidth, legendContent = _ref2.legendContent;
  var legendItem = findChildByType(children, Legend);
  if (!legendItem) {
    return null;
  }
  var legendData;
  if (legendItem.props && legendItem.props.payload) {
    legendData = legendItem.props && legendItem.props.payload;
  } else if (legendContent === "children") {
    legendData = (formattedGraphicalItems || []).reduce(function(result, _ref3) {
      var item = _ref3.item, props = _ref3.props;
      var data = props.sectors || props.data || [];
      return result.concat(data.map(function(entry) {
        return {
          type: legendItem.props.iconType || item.props.legendType,
          value: entry.name,
          color: entry.fill,
          payload: entry
        };
      }));
    }, []);
  } else {
    legendData = (formattedGraphicalItems || []).map(function(_ref4) {
      var item = _ref4.item;
      var _item$props2 = item.props, dataKey = _item$props2.dataKey, name = _item$props2.name, legendType = _item$props2.legendType, hide = _item$props2.hide;
      return {
        inactive: hide,
        dataKey,
        type: legendItem.props.iconType || legendType || "square",
        color: getMainColorOfGraphicItem(item),
        value: name || dataKey,
        payload: item.props
      };
    });
  }
  return _objectSpread$h(_objectSpread$h(_objectSpread$h({}, legendItem.props), Legend.getWithHeight(legendItem, legendWidth)), {}, {
    payload: legendData,
    item: legendItem
  });
};
var getBarSizeList = function getBarSizeList2(_ref5) {
  var globalSize = _ref5.barSize, _ref5$stackGroups = _ref5.stackGroups, stackGroups = _ref5$stackGroups === void 0 ? {} : _ref5$stackGroups;
  if (!stackGroups) {
    return {};
  }
  var result = {};
  var numericAxisIds = Object.keys(stackGroups);
  for (var i = 0, len = numericAxisIds.length; i < len; i++) {
    var sgs = stackGroups[numericAxisIds[i]].stackGroups;
    var stackIds = Object.keys(sgs);
    for (var j = 0, sLen = stackIds.length; j < sLen; j++) {
      var _sgs$stackIds$j = sgs[stackIds[j]], items = _sgs$stackIds$j.items, cateAxisId = _sgs$stackIds$j.cateAxisId;
      var barItems = items.filter(function(item) {
        return getDisplayName(item.type).indexOf("Bar") >= 0;
      });
      if (barItems && barItems.length) {
        var selfSize = barItems[0].props.barSize;
        var cateId = barItems[0].props[cateAxisId];
        if (!result[cateId]) {
          result[cateId] = [];
        }
        result[cateId].push({
          item: barItems[0],
          stackList: barItems.slice(1),
          barSize: _isNil(selfSize) ? globalSize : selfSize
        });
      }
    }
  }
  return result;
};
var getBarPosition = function getBarPosition2(_ref6) {
  var barGap = _ref6.barGap, barCategoryGap = _ref6.barCategoryGap, bandSize = _ref6.bandSize, _ref6$sizeList = _ref6.sizeList, sizeList = _ref6$sizeList === void 0 ? [] : _ref6$sizeList, maxBarSize = _ref6.maxBarSize;
  var len = sizeList.length;
  if (len < 1)
    return null;
  var realBarGap = getPercentValue(barGap, bandSize, 0, true);
  var result;
  if (sizeList[0].barSize === +sizeList[0].barSize) {
    var useFull = false;
    var fullBarSize = bandSize / len;
    var sum2 = sizeList.reduce(function(res, entry) {
      return res + entry.barSize || 0;
    }, 0);
    sum2 += (len - 1) * realBarGap;
    if (sum2 >= bandSize) {
      sum2 -= (len - 1) * realBarGap;
      realBarGap = 0;
    }
    if (sum2 >= bandSize && fullBarSize > 0) {
      useFull = true;
      fullBarSize *= 0.9;
      sum2 = len * fullBarSize;
    }
    var offset = (bandSize - sum2) / 2 >> 0;
    var prev = {
      offset: offset - realBarGap,
      size: 0
    };
    result = sizeList.reduce(function(res, entry) {
      var newRes = [].concat(_toConsumableArray$5(res), [{
        item: entry.item,
        position: {
          offset: prev.offset + prev.size + realBarGap,
          size: useFull ? fullBarSize : entry.barSize
        }
      }]);
      prev = newRes[newRes.length - 1].position;
      if (entry.stackList && entry.stackList.length) {
        entry.stackList.forEach(function(item) {
          newRes.push({
            item,
            position: prev
          });
        });
      }
      return newRes;
    }, []);
  } else {
    var _offset = getPercentValue(barCategoryGap, bandSize, 0, true);
    if (bandSize - 2 * _offset - (len - 1) * realBarGap <= 0) {
      realBarGap = 0;
    }
    var originalSize = (bandSize - 2 * _offset - (len - 1) * realBarGap) / len;
    if (originalSize > 1) {
      originalSize >>= 0;
    }
    var size = maxBarSize === +maxBarSize ? Math.min(originalSize, maxBarSize) : originalSize;
    result = sizeList.reduce(function(res, entry, i) {
      var newRes = [].concat(_toConsumableArray$5(res), [{
        item: entry.item,
        position: {
          offset: _offset + (originalSize + realBarGap) * i + (originalSize - size) / 2,
          size
        }
      }]);
      if (entry.stackList && entry.stackList.length) {
        entry.stackList.forEach(function(item) {
          newRes.push({
            item,
            position: newRes[newRes.length - 1].position
          });
        });
      }
      return newRes;
    }, []);
  }
  return result;
};
var appendOffsetOfLegend = function appendOffsetOfLegend2(offset, items, props, legendBox) {
  var children = props.children, width = props.width, margin = props.margin;
  var legendWidth = width - (margin.left || 0) - (margin.right || 0);
  var legendProps = getLegendProps({
    children,
    legendWidth
  });
  var newOffset = offset;
  if (legendProps) {
    var box = legendBox || {};
    var align = legendProps.align, verticalAlign = legendProps.verticalAlign, layout = legendProps.layout;
    if ((layout === "vertical" || layout === "horizontal" && verticalAlign === "middle") && isNumber(offset[align])) {
      newOffset = _objectSpread$h(_objectSpread$h({}, offset), {}, _defineProperty$k({}, align, newOffset[align] + (box.width || 0)));
    }
    if ((layout === "horizontal" || layout === "vertical" && align === "center") && isNumber(offset[verticalAlign])) {
      newOffset = _objectSpread$h(_objectSpread$h({}, offset), {}, _defineProperty$k({}, verticalAlign, newOffset[verticalAlign] + (box.height || 0)));
    }
  }
  return newOffset;
};
var isErrorBarRelevantForAxis = function isErrorBarRelevantForAxis2(layout, axisType, direction) {
  if (_isNil(axisType)) {
    return true;
  }
  if (layout === "horizontal") {
    return axisType === "yAxis";
  }
  if (layout === "vertical") {
    return axisType === "xAxis";
  }
  if (direction === "x") {
    return axisType === "xAxis";
  }
  if (direction === "y") {
    return axisType === "yAxis";
  }
  return true;
};
var getDomainOfErrorBars = function getDomainOfErrorBars2(data, item, dataKey, layout, axisType) {
  var children = item.props.children;
  var errorBars = findAllByType(children, ErrorBar).filter(function(errorBarChild) {
    return isErrorBarRelevantForAxis(layout, axisType, errorBarChild.props.direction);
  });
  if (errorBars && errorBars.length) {
    var keys2 = errorBars.map(function(errorBarChild) {
      return errorBarChild.props.dataKey;
    });
    return data.reduce(function(result, entry) {
      var entryValue = getValueByDataKey(entry, dataKey, 0);
      var mainValue = _isArray(entryValue) ? [_min(entryValue), _max(entryValue)] : [entryValue, entryValue];
      var errorDomain = keys2.reduce(function(prevErrorArr, k2) {
        var errorValue = getValueByDataKey(entry, k2, 0);
        var lowerValue = mainValue[0] - Math.abs(_isArray(errorValue) ? errorValue[0] : errorValue);
        var upperValue = mainValue[1] + Math.abs(_isArray(errorValue) ? errorValue[1] : errorValue);
        return [Math.min(lowerValue, prevErrorArr[0]), Math.max(upperValue, prevErrorArr[1])];
      }, [Infinity, -Infinity]);
      return [Math.min(errorDomain[0], result[0]), Math.max(errorDomain[1], result[1])];
    }, [Infinity, -Infinity]);
  }
  return null;
};
var parseErrorBarsOfAxis = function parseErrorBarsOfAxis2(data, items, dataKey, axisType, layout) {
  var domains = items.map(function(item) {
    return getDomainOfErrorBars(data, item, dataKey, layout, axisType);
  }).filter(function(entry) {
    return !_isNil(entry);
  });
  if (domains && domains.length) {
    return domains.reduce(function(result, entry) {
      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
    }, [Infinity, -Infinity]);
  }
  return null;
};
var getDomainOfItemsWithSameAxis = function getDomainOfItemsWithSameAxis2(data, items, type, layout, filterNil) {
  var domains = items.map(function(item) {
    var dataKey = item.props.dataKey;
    if (type === "number" && dataKey) {
      return getDomainOfErrorBars(data, item, dataKey, layout) || getDomainOfDataByKey(data, dataKey, type, filterNil);
    }
    return getDomainOfDataByKey(data, dataKey, type, filterNil);
  });
  if (type === "number") {
    return domains.reduce(function(result, entry) {
      return [Math.min(result[0], entry[0]), Math.max(result[1], entry[1])];
    }, [Infinity, -Infinity]);
  }
  var tag = {};
  return domains.reduce(function(result, entry) {
    for (var i = 0, len = entry.length; i < len; i++) {
      if (!tag[entry[i]]) {
        tag[entry[i]] = true;
        result.push(entry[i]);
      }
    }
    return result;
  }, []);
};
var isCategoricalAxis = function isCategoricalAxis2(layout, axisType) {
  return layout === "horizontal" && axisType === "xAxis" || layout === "vertical" && axisType === "yAxis" || layout === "centric" && axisType === "angleAxis" || layout === "radial" && axisType === "radiusAxis";
};
var getCoordinatesOfGrid = function getCoordinatesOfGrid2(ticks2, min2, max2) {
  var hasMin, hasMax;
  var values = ticks2.map(function(entry) {
    if (entry.coordinate === min2) {
      hasMin = true;
    }
    if (entry.coordinate === max2) {
      hasMax = true;
    }
    return entry.coordinate;
  });
  if (!hasMin) {
    values.push(min2);
  }
  if (!hasMax) {
    values.push(max2);
  }
  return values;
};
var getTicksOfAxis = function getTicksOfAxis2(axis, isGrid, isAll) {
  if (!axis)
    return null;
  var scale2 = axis.scale;
  var duplicateDomain = axis.duplicateDomain, type = axis.type, range3 = axis.range;
  var offsetForBand = axis.realScaleType === "scaleBand" ? scale2.bandwidth() / 2 : 2;
  var offset = (isGrid || isAll) && type === "category" && scale2.bandwidth ? scale2.bandwidth() / offsetForBand : 0;
  offset = axis.axisType === "angleAxis" ? mathSign(range3[0] - range3[1]) * 2 * offset : offset;
  if (isGrid && (axis.ticks || axis.niceTicks)) {
    return (axis.ticks || axis.niceTicks).map(function(entry) {
      var scaleContent = duplicateDomain ? duplicateDomain.indexOf(entry) : entry;
      return {
        coordinate: scale2(scaleContent) + offset,
        value: entry,
        offset
      };
    });
  }
  if (axis.isCategorical && axis.categoricalDomain) {
    return axis.categoricalDomain.map(function(entry, index) {
      return {
        coordinate: scale2(entry) + offset,
        value: entry,
        index,
        offset
      };
    });
  }
  if (scale2.ticks && !isAll) {
    return scale2.ticks(axis.tickCount).map(function(entry) {
      return {
        coordinate: scale2(entry) + offset,
        value: entry,
        offset
      };
    });
  }
  return scale2.domain().map(function(entry, index) {
    return {
      coordinate: scale2(entry) + offset,
      value: duplicateDomain ? duplicateDomain[entry] : entry,
      index,
      offset
    };
  });
};
var combineEventHandlers = function combineEventHandlers2(defaultHandler, parentHandler, childHandler) {
  var customizedHandler;
  if (_isFunction(childHandler)) {
    customizedHandler = childHandler;
  } else if (_isFunction(parentHandler)) {
    customizedHandler = parentHandler;
  }
  if (_isFunction(defaultHandler) || customizedHandler) {
    return function(arg1, arg2, arg3, arg4) {
      if (_isFunction(defaultHandler)) {
        defaultHandler(arg1, arg2, arg3, arg4);
      }
      if (_isFunction(customizedHandler)) {
        customizedHandler(arg1, arg2, arg3, arg4);
      }
    };
  }
  return null;
};
var parseScale = function parseScale2(axis, chartType, hasBar) {
  var scale2 = axis.scale, type = axis.type, layout = axis.layout, axisType = axis.axisType;
  if (scale2 === "auto") {
    if (layout === "radial" && axisType === "radiusAxis") {
      return {
        scale: band(),
        realScaleType: "band"
      };
    }
    if (layout === "radial" && axisType === "angleAxis") {
      return {
        scale: linear(),
        realScaleType: "linear"
      };
    }
    if (type === "category" && chartType && (chartType.indexOf("LineChart") >= 0 || chartType.indexOf("AreaChart") >= 0 || chartType.indexOf("ComposedChart") >= 0 && !hasBar)) {
      return {
        scale: point(),
        realScaleType: "point"
      };
    }
    if (type === "category") {
      return {
        scale: band(),
        realScaleType: "band"
      };
    }
    return {
      scale: linear(),
      realScaleType: "linear"
    };
  }
  if (_isString(scale2)) {
    var name = "scale".concat(_upperFirst(scale2));
    return {
      scale: (d3Scales[name] || point)(),
      realScaleType: d3Scales[name] ? name : "point"
    };
  }
  return _isFunction(scale2) ? {
    scale: scale2
  } : {
    scale: point(),
    realScaleType: "point"
  };
};
var EPS = 1e-4;
var checkDomainOfScale = function checkDomainOfScale2(scale2) {
  var domain = scale2.domain();
  if (!domain || domain.length <= 2) {
    return;
  }
  var len = domain.length;
  var range3 = scale2.range();
  var min2 = Math.min(range3[0], range3[1]) - EPS;
  var max2 = Math.max(range3[0], range3[1]) + EPS;
  var first = scale2(domain[0]);
  var last2 = scale2(domain[len - 1]);
  if (first < min2 || first > max2 || last2 < min2 || last2 > max2) {
    scale2.domain([domain[0], domain[len - 1]]);
  }
};
var findPositionOfBar = function findPositionOfBar2(barPosition, child) {
  if (!barPosition) {
    return null;
  }
  for (var i = 0, len = barPosition.length; i < len; i++) {
    if (barPosition[i].item === child) {
      return barPosition[i].position;
    }
  }
  return null;
};
var truncateByDomain = function truncateByDomain2(value, domain) {
  if (!domain || domain.length !== 2 || !isNumber(domain[0]) || !isNumber(domain[1])) {
    return value;
  }
  var min2 = Math.min(domain[0], domain[1]);
  var max2 = Math.max(domain[0], domain[1]);
  var result = [value[0], value[1]];
  if (!isNumber(value[0]) || value[0] < min2) {
    result[0] = min2;
  }
  if (!isNumber(value[1]) || value[1] > max2) {
    result[1] = max2;
  }
  if (result[0] > max2) {
    result[0] = max2;
  }
  if (result[1] < min2) {
    result[1] = min2;
  }
  return result;
};
var offsetSign = function offsetSign2(series) {
  var n2 = series.length;
  if (n2 <= 0) {
    return;
  }
  for (var j = 0, m2 = series[0].length; j < m2; ++j) {
    var positive = 0;
    var negative = 0;
    for (var i = 0; i < n2; ++i) {
      var value = _isNaN$1(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
      if (value >= 0) {
        series[i][j][0] = positive;
        series[i][j][1] = positive + value;
        positive = series[i][j][1];
      } else {
        series[i][j][0] = negative;
        series[i][j][1] = negative + value;
        negative = series[i][j][1];
      }
    }
  }
};
var offsetPositive = function offsetPositive2(series) {
  var n2 = series.length;
  if (n2 <= 0) {
    return;
  }
  for (var j = 0, m2 = series[0].length; j < m2; ++j) {
    var positive = 0;
    for (var i = 0; i < n2; ++i) {
      var value = _isNaN$1(series[i][j][1]) ? series[i][j][0] : series[i][j][1];
      if (value >= 0) {
        series[i][j][0] = positive;
        series[i][j][1] = positive + value;
        positive = series[i][j][1];
      } else {
        series[i][j][0] = 0;
        series[i][j][1] = 0;
      }
    }
  }
};
var STACK_OFFSET_MAP = {
  sign: offsetSign,
  expand: stackOffsetExpand,
  none: stackOffsetNone,
  silhouette: stackOffsetSilhouette,
  wiggle: stackOffsetWiggle,
  positive: offsetPositive
};
var getStackedData = function getStackedData2(data, stackItems, offsetType) {
  var dataKeys = stackItems.map(function(item) {
    return item.props.dataKey;
  });
  var stack = shapeStack().keys(dataKeys).value(function(d2, key) {
    return +getValueByDataKey(d2, key, 0);
  }).order(stackOrderNone).offset(STACK_OFFSET_MAP[offsetType]);
  return stack(data);
};
var getStackGroupsByAxisId = function getStackGroupsByAxisId2(data, _items, numericAxisId, cateAxisId, offsetType, reverseStackOrder) {
  if (!data) {
    return null;
  }
  var items = reverseStackOrder ? _items.reverse() : _items;
  var stackGroups = items.reduce(function(result, item) {
    var _item$props3 = item.props, stackId = _item$props3.stackId, hide = _item$props3.hide;
    if (hide) {
      return result;
    }
    var axisId = item.props[numericAxisId];
    var parentGroup = result[axisId] || {
      hasStack: false,
      stackGroups: {}
    };
    if (isNumOrStr(stackId)) {
      var childGroup = parentGroup.stackGroups[stackId] || {
        numericAxisId,
        cateAxisId,
        items: []
      };
      childGroup.items.push(item);
      parentGroup.hasStack = true;
      parentGroup.stackGroups[stackId] = childGroup;
    } else {
      parentGroup.stackGroups[uniqueId("_stackId_")] = {
        numericAxisId,
        cateAxisId,
        items: [item]
      };
    }
    return _objectSpread$h(_objectSpread$h({}, result), {}, _defineProperty$k({}, axisId, parentGroup));
  }, {});
  return Object.keys(stackGroups).reduce(function(result, axisId) {
    var group = stackGroups[axisId];
    if (group.hasStack) {
      group.stackGroups = Object.keys(group.stackGroups).reduce(function(res, stackId) {
        var g2 = group.stackGroups[stackId];
        return _objectSpread$h(_objectSpread$h({}, res), {}, _defineProperty$k({}, stackId, {
          numericAxisId,
          cateAxisId,
          items: g2.items,
          stackedData: getStackedData(data, g2.items, offsetType)
        }));
      }, {});
    }
    return _objectSpread$h(_objectSpread$h({}, result), {}, _defineProperty$k({}, axisId, group));
  }, {});
};
var getTicksOfScale = function getTicksOfScale2(scale2, opts) {
  var realScaleType = opts.realScaleType, type = opts.type, tickCount = opts.tickCount, originalDomain = opts.originalDomain, allowDecimals = opts.allowDecimals;
  var scaleType = realScaleType || opts.scale;
  if (scaleType !== "auto" && scaleType !== "linear") {
    return null;
  }
  if (tickCount && type === "number" && originalDomain && (originalDomain[0] === "auto" || originalDomain[1] === "auto")) {
    var domain = scale2.domain();
    if (!domain.length) {
      return null;
    }
    var tickValues = getNiceTickValues(domain, tickCount, allowDecimals);
    scale2.domain([_min(tickValues), _max(tickValues)]);
    return {
      niceTicks: tickValues
    };
  }
  if (tickCount && type === "number") {
    var _domain = scale2.domain();
    var _tickValues = getTickValuesFixedDomain(_domain, tickCount, allowDecimals);
    return {
      niceTicks: _tickValues
    };
  }
  return null;
};
var getCateCoordinateOfLine = function getCateCoordinateOfLine2(_ref7) {
  var axis = _ref7.axis, ticks2 = _ref7.ticks, bandSize = _ref7.bandSize, entry = _ref7.entry, index = _ref7.index, dataKey = _ref7.dataKey;
  if (axis.type === "category") {
    if (!axis.allowDuplicatedCategory && axis.dataKey && !_isNil(entry[axis.dataKey])) {
      var matchedTick = findEntryInArray(ticks2, "value", entry[axis.dataKey]);
      if (matchedTick) {
        return matchedTick.coordinate + bandSize / 2;
      }
    }
    return ticks2[index] ? ticks2[index].coordinate + bandSize / 2 : null;
  }
  var value = getValueByDataKey(entry, !_isNil(dataKey) ? dataKey : axis.dataKey);
  return !_isNil(value) ? axis.scale(value) : null;
};
var getCateCoordinateOfBar = function getCateCoordinateOfBar2(_ref8) {
  var axis = _ref8.axis, ticks2 = _ref8.ticks, offset = _ref8.offset, bandSize = _ref8.bandSize, entry = _ref8.entry, index = _ref8.index;
  if (axis.type === "category") {
    return ticks2[index] ? ticks2[index].coordinate + offset : null;
  }
  var value = getValueByDataKey(entry, axis.dataKey, axis.domain[index]);
  return !_isNil(value) ? axis.scale(value) - bandSize / 2 + offset : null;
};
var getBaseValueOfBar = function getBaseValueOfBar2(_ref9) {
  var numericAxis = _ref9.numericAxis;
  var domain = numericAxis.scale.domain();
  if (numericAxis.type === "number") {
    var min2 = Math.min(domain[0], domain[1]);
    var max2 = Math.max(domain[0], domain[1]);
    if (min2 <= 0 && max2 >= 0) {
      return 0;
    }
    if (max2 < 0) {
      return max2;
    }
    return min2;
  }
  return domain[0];
};
var getStackedDataOfItem = function getStackedDataOfItem2(item, stackGroups) {
  var stackId = item.props.stackId;
  if (isNumOrStr(stackId)) {
    var group = stackGroups[stackId];
    if (group && group.items.length) {
      var itemIndex = -1;
      for (var i = 0, len = group.items.length; i < len; i++) {
        if (group.items[i] === item) {
          itemIndex = i;
          break;
        }
      }
      return itemIndex >= 0 ? group.stackedData[itemIndex] : null;
    }
  }
  return null;
};
var getDomainOfSingle = function getDomainOfSingle2(data) {
  return data.reduce(function(result, entry) {
    return [_min(entry.concat([result[0]]).filter(isNumber)), _max(entry.concat([result[1]]).filter(isNumber))];
  }, [Infinity, -Infinity]);
};
var getDomainOfStackGroups = function getDomainOfStackGroups2(stackGroups, startIndex, endIndex) {
  return Object.keys(stackGroups).reduce(function(result, stackId) {
    var group = stackGroups[stackId];
    var stackedData = group.stackedData;
    var domain = stackedData.reduce(function(res, entry) {
      var s2 = getDomainOfSingle(entry.slice(startIndex, endIndex + 1));
      return [Math.min(res[0], s2[0]), Math.max(res[1], s2[1])];
    }, [Infinity, -Infinity]);
    return [Math.min(domain[0], result[0]), Math.max(domain[1], result[1])];
  }, [Infinity, -Infinity]).map(function(result) {
    return result === Infinity || result === -Infinity ? 0 : result;
  });
};
var MIN_VALUE_REG = /^dataMin[\s]*-[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var MAX_VALUE_REG = /^dataMax[\s]*\+[\s]*([0-9]+([.]{1}[0-9]+){0,1})$/;
var parseSpecifiedDomain = function parseSpecifiedDomain2(specifiedDomain, dataDomain, allowDataOverflow) {
  if (_isFunction(specifiedDomain)) {
    return specifiedDomain(dataDomain, allowDataOverflow);
  }
  if (!_isArray(specifiedDomain)) {
    return dataDomain;
  }
  var domain = [];
  if (isNumber(specifiedDomain[0])) {
    domain[0] = allowDataOverflow ? specifiedDomain[0] : Math.min(specifiedDomain[0], dataDomain[0]);
  } else if (MIN_VALUE_REG.test(specifiedDomain[0])) {
    var value = +MIN_VALUE_REG.exec(specifiedDomain[0])[1];
    domain[0] = dataDomain[0] - value;
  } else if (_isFunction(specifiedDomain[0])) {
    domain[0] = specifiedDomain[0](dataDomain[0]);
  } else {
    domain[0] = dataDomain[0];
  }
  if (isNumber(specifiedDomain[1])) {
    domain[1] = allowDataOverflow ? specifiedDomain[1] : Math.max(specifiedDomain[1], dataDomain[1]);
  } else if (MAX_VALUE_REG.test(specifiedDomain[1])) {
    var _value = +MAX_VALUE_REG.exec(specifiedDomain[1])[1];
    domain[1] = dataDomain[1] + _value;
  } else if (_isFunction(specifiedDomain[1])) {
    domain[1] = specifiedDomain[1](dataDomain[1]);
  } else {
    domain[1] = dataDomain[1];
  }
  return domain;
};
var getBandSizeOfAxis = function getBandSizeOfAxis2(axis, ticks2, isBar) {
  if (axis && axis.scale && axis.scale.bandwidth) {
    var bandWidth = axis.scale.bandwidth();
    if (!isBar || bandWidth > 0) {
      return bandWidth;
    }
  }
  if (axis && ticks2 && ticks2.length >= 2) {
    var orderedTicks = _sortBy(ticks2, function(o) {
      return o.coordinate;
    });
    var bandSize = Infinity;
    for (var i = 1, len = orderedTicks.length; i < len; i++) {
      var cur = orderedTicks[i];
      var prev = orderedTicks[i - 1];
      bandSize = Math.min((cur.coordinate || 0) - (prev.coordinate || 0), bandSize);
    }
    return bandSize === Infinity ? 0 : bandSize;
  }
  return isBar ? void 0 : 0;
};
var parseDomainOfCategoryAxis = function parseDomainOfCategoryAxis2(specifiedDomain, calculatedDomain, axisChild) {
  if (!specifiedDomain || !specifiedDomain.length) {
    return calculatedDomain;
  }
  if (_isEqual(specifiedDomain, _get(axisChild, "type.defaultProps.domain"))) {
    return calculatedDomain;
  }
  return specifiedDomain;
};
var getTooltipItem = function getTooltipItem2(graphicalItem, payload) {
  var _graphicalItem$props = graphicalItem.props, dataKey = _graphicalItem$props.dataKey, name = _graphicalItem$props.name, unit2 = _graphicalItem$props.unit, formatter = _graphicalItem$props.formatter, tooltipType = _graphicalItem$props.tooltipType, chartType = _graphicalItem$props.chartType;
  return _objectSpread$h(_objectSpread$h({}, filterProps(graphicalItem)), {}, {
    dataKey,
    unit: unit2,
    formatter,
    name: name || dataKey,
    color: getMainColorOfGraphicItem(graphicalItem),
    value: getValueByDataKey(payload, dataKey),
    type: tooltipType,
    payload,
    chartType
  });
};
function _typeof$k(obj) {
  "@babel/helpers - typeof";
  return _typeof$k = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$k(obj);
}
function ownKeys$g(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$g(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$g(Object(source), true).forEach(function(key) {
      _defineProperty$j(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$g(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$j(obj, key, value) {
  key = _toPropertyKey$k(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$k(arg) {
  var key = _toPrimitive$k(arg, "string");
  return _typeof$k(key) === "symbol" ? key : String(key);
}
function _toPrimitive$k(input2, hint) {
  if (_typeof$k(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$k(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var RADIAN = Math.PI / 180;
var radianToDegree = function radianToDegree2(angleInRadian) {
  return angleInRadian * 180 / Math.PI;
};
var polarToCartesian = function polarToCartesian2(cx, cy, radius, angle) {
  return {
    x: cx + Math.cos(-RADIAN * angle) * radius,
    y: cy + Math.sin(-RADIAN * angle) * radius
  };
};
var distanceBetweenPoints = function distanceBetweenPoints2(point2, anotherPoint) {
  var x1 = point2.x, y1 = point2.y;
  var x2 = anotherPoint.x, y2 = anotherPoint.y;
  return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
};
var getAngleOfPoint = function getAngleOfPoint2(_ref, _ref2) {
  var x2 = _ref.x, y2 = _ref.y;
  var cx = _ref2.cx, cy = _ref2.cy;
  var radius = distanceBetweenPoints({
    x: x2,
    y: y2
  }, {
    x: cx,
    y: cy
  });
  if (radius <= 0) {
    return {
      radius
    };
  }
  var cos2 = (x2 - cx) / radius;
  var angleInRadian = Math.acos(cos2);
  if (y2 > cy) {
    angleInRadian = 2 * Math.PI - angleInRadian;
  }
  return {
    radius,
    angle: radianToDegree(angleInRadian),
    angleInRadian
  };
};
var formatAngleOfSector = function formatAngleOfSector2(_ref3) {
  var startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
  var startCnt = Math.floor(startAngle / 360);
  var endCnt = Math.floor(endAngle / 360);
  var min2 = Math.min(startCnt, endCnt);
  return {
    startAngle: startAngle - min2 * 360,
    endAngle: endAngle - min2 * 360
  };
};
var reverseFormatAngleOfSetor = function reverseFormatAngleOfSetor2(angle, _ref4) {
  var startAngle = _ref4.startAngle, endAngle = _ref4.endAngle;
  var startCnt = Math.floor(startAngle / 360);
  var endCnt = Math.floor(endAngle / 360);
  var min2 = Math.min(startCnt, endCnt);
  return angle + min2 * 360;
};
var inRangeOfSector = function inRangeOfSector2(_ref5, sector) {
  var x2 = _ref5.x, y2 = _ref5.y;
  var _getAngleOfPoint = getAngleOfPoint({
    x: x2,
    y: y2
  }, sector), radius = _getAngleOfPoint.radius, angle = _getAngleOfPoint.angle;
  var innerRadius = sector.innerRadius, outerRadius = sector.outerRadius;
  if (radius < innerRadius || radius > outerRadius) {
    return false;
  }
  if (radius === 0) {
    return true;
  }
  var _formatAngleOfSector = formatAngleOfSector(sector), startAngle = _formatAngleOfSector.startAngle, endAngle = _formatAngleOfSector.endAngle;
  var formatAngle = angle;
  var inRange;
  if (startAngle <= endAngle) {
    while (formatAngle > endAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < startAngle) {
      formatAngle += 360;
    }
    inRange = formatAngle >= startAngle && formatAngle <= endAngle;
  } else {
    while (formatAngle > startAngle) {
      formatAngle -= 360;
    }
    while (formatAngle < endAngle) {
      formatAngle += 360;
    }
    inRange = formatAngle >= endAngle && formatAngle <= startAngle;
  }
  if (inRange) {
    return _objectSpread$g(_objectSpread$g({}, sector), {}, {
      radius,
      angle: reverseFormatAngleOfSetor(formatAngle, sector)
    });
  }
  return null;
};
function _typeof$j(obj) {
  "@babel/helpers - typeof";
  return _typeof$j = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$j(obj);
}
function _toConsumableArray$4(arr) {
  return _arrayWithoutHoles$4(arr) || _iterableToArray$4(arr) || _unsupportedIterableToArray$5(arr) || _nonIterableSpread$4();
}
function _nonIterableSpread$4() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$5(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$5(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$5(o, minLen);
}
function _iterableToArray$4(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$4(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$5(arr);
}
function _arrayLikeToArray$5(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function ownKeys$f(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$f(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$f(Object(source), true).forEach(function(key) {
      _defineProperty$i(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$f(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$i(obj, key, value) {
  key = _toPropertyKey$j(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$j(arg) {
  var key = _toPrimitive$j(arg, "string");
  return _typeof$j(key) === "symbol" ? key : String(key);
}
function _toPrimitive$j(input2, hint) {
  if (_typeof$j(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$j(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function _extends$h() {
  _extends$h = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$h.apply(this, arguments);
}
var getLabel = function getLabel2(props) {
  var value = props.value, formatter = props.formatter;
  var label = _isNil(props.children) ? value : props.children;
  if (_isFunction(formatter)) {
    return formatter(label);
  }
  return label;
};
var getDeltaAngle$1 = function getDeltaAngle(startAngle, endAngle) {
  var sign2 = mathSign(endAngle - startAngle);
  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 360);
  return sign2 * deltaAngle;
};
var renderRadialLabel = function renderRadialLabel2(labelProps, label, attrs) {
  var position = labelProps.position, viewBox = labelProps.viewBox, offset = labelProps.offset, className = labelProps.className;
  var _ref = viewBox, cx = _ref.cx, cy = _ref.cy, innerRadius = _ref.innerRadius, outerRadius = _ref.outerRadius, startAngle = _ref.startAngle, endAngle = _ref.endAngle, clockWise = _ref.clockWise;
  var radius = (innerRadius + outerRadius) / 2;
  var deltaAngle = getDeltaAngle$1(startAngle, endAngle);
  var sign2 = deltaAngle >= 0 ? 1 : -1;
  var labelAngle, direction;
  if (position === "insideStart") {
    labelAngle = startAngle + sign2 * offset;
    direction = clockWise;
  } else if (position === "insideEnd") {
    labelAngle = endAngle - sign2 * offset;
    direction = !clockWise;
  } else if (position === "end") {
    labelAngle = endAngle + sign2 * offset;
    direction = clockWise;
  }
  direction = deltaAngle <= 0 ? direction : !direction;
  var startPoint = polarToCartesian(cx, cy, radius, labelAngle);
  var endPoint = polarToCartesian(cx, cy, radius, labelAngle + (direction ? 1 : -1) * 359);
  var path = "M".concat(startPoint.x, ",").concat(startPoint.y, "\n    A").concat(radius, ",").concat(radius, ",0,1,").concat(direction ? 0 : 1, ",\n    ").concat(endPoint.x, ",").concat(endPoint.y);
  var id = _isNil(labelProps.id) ? uniqueId("recharts-radial-line-") : labelProps.id;
  return /* @__PURE__ */ React.createElement("text", _extends$h({}, attrs, {
    dominantBaseline: "central",
    className: classNames("recharts-radial-bar-label", className)
  }), /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("path", {
    id,
    d: path
  })), /* @__PURE__ */ React.createElement("textPath", {
    xlinkHref: "#".concat(id)
  }, label));
};
var getAttrsOfPolarLabel = function getAttrsOfPolarLabel2(props) {
  var viewBox = props.viewBox, offset = props.offset, position = props.position;
  var _ref2 = viewBox, cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;
  var midAngle = (startAngle + endAngle) / 2;
  if (position === "outside") {
    var _polarToCartesian = polarToCartesian(cx, cy, outerRadius + offset, midAngle), _x = _polarToCartesian.x, _y = _polarToCartesian.y;
    return {
      x: _x,
      y: _y,
      textAnchor: _x >= cx ? "start" : "end",
      verticalAnchor: "middle"
    };
  }
  if (position === "center") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "middle"
    };
  }
  if (position === "centerTop") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "start"
    };
  }
  if (position === "centerBottom") {
    return {
      x: cx,
      y: cy,
      textAnchor: "middle",
      verticalAnchor: "end"
    };
  }
  var r2 = (innerRadius + outerRadius) / 2;
  var _polarToCartesian2 = polarToCartesian(cx, cy, r2, midAngle), x2 = _polarToCartesian2.x, y2 = _polarToCartesian2.y;
  return {
    x: x2,
    y: y2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  };
};
var getAttrsOfCartesianLabel = function getAttrsOfCartesianLabel2(props) {
  var viewBox = props.viewBox, parentViewBox = props.parentViewBox, offset = props.offset, position = props.position;
  var _ref3 = viewBox, x2 = _ref3.x, y2 = _ref3.y, width = _ref3.width, height = _ref3.height;
  var verticalSign = height >= 0 ? 1 : -1;
  var verticalOffset = verticalSign * offset;
  var verticalEnd = verticalSign > 0 ? "end" : "start";
  var verticalStart = verticalSign > 0 ? "start" : "end";
  var horizontalSign = width >= 0 ? 1 : -1;
  var horizontalOffset = horizontalSign * offset;
  var horizontalEnd = horizontalSign > 0 ? "end" : "start";
  var horizontalStart = horizontalSign > 0 ? "start" : "end";
  if (position === "top") {
    var attrs = {
      x: x2 + width / 2,
      y: y2 - verticalSign * offset,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    };
    return _objectSpread$f(_objectSpread$f({}, attrs), parentViewBox ? {
      height: Math.max(y2 - parentViewBox.y, 0),
      width
    } : {});
  }
  if (position === "bottom") {
    var _attrs = {
      x: x2 + width / 2,
      y: y2 + height + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    };
    return _objectSpread$f(_objectSpread$f({}, _attrs), parentViewBox ? {
      height: Math.max(parentViewBox.y + parentViewBox.height - (y2 + height), 0),
      width
    } : {});
  }
  if (position === "left") {
    var _attrs2 = {
      x: x2 - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    };
    return _objectSpread$f(_objectSpread$f({}, _attrs2), parentViewBox ? {
      width: Math.max(_attrs2.x - parentViewBox.x, 0),
      height
    } : {});
  }
  if (position === "right") {
    var _attrs3 = {
      x: x2 + width + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    };
    return _objectSpread$f(_objectSpread$f({}, _attrs3), parentViewBox ? {
      width: Math.max(parentViewBox.x + parentViewBox.width - _attrs3.x, 0),
      height
    } : {});
  }
  var sizeAttrs = parentViewBox ? {
    width,
    height
  } : {};
  if (position === "insideLeft") {
    return _objectSpread$f({
      x: x2 + horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalStart,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position === "insideRight") {
    return _objectSpread$f({
      x: x2 + width - horizontalOffset,
      y: y2 + height / 2,
      textAnchor: horizontalEnd,
      verticalAnchor: "middle"
    }, sizeAttrs);
  }
  if (position === "insideTop") {
    return _objectSpread$f({
      x: x2 + width / 2,
      y: y2 + verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideBottom") {
    return _objectSpread$f({
      x: x2 + width / 2,
      y: y2 + height - verticalOffset,
      textAnchor: "middle",
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position === "insideTopLeft") {
    return _objectSpread$f({
      x: x2 + horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideTopRight") {
    return _objectSpread$f({
      x: x2 + width - horizontalOffset,
      y: y2 + verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalStart
    }, sizeAttrs);
  }
  if (position === "insideBottomLeft") {
    return _objectSpread$f({
      x: x2 + horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalStart,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (position === "insideBottomRight") {
    return _objectSpread$f({
      x: x2 + width - horizontalOffset,
      y: y2 + height - verticalOffset,
      textAnchor: horizontalEnd,
      verticalAnchor: verticalEnd
    }, sizeAttrs);
  }
  if (_isObject(position) && (isNumber(position.x) || isPercent(position.x)) && (isNumber(position.y) || isPercent(position.y))) {
    return _objectSpread$f({
      x: x2 + getPercentValue(position.x, width),
      y: y2 + getPercentValue(position.y, height),
      textAnchor: "end",
      verticalAnchor: "end"
    }, sizeAttrs);
  }
  return _objectSpread$f({
    x: x2 + width / 2,
    y: y2 + height / 2,
    textAnchor: "middle",
    verticalAnchor: "middle"
  }, sizeAttrs);
};
var isPolar = function isPolar2(viewBox) {
  return "cx" in viewBox && isNumber(viewBox.cx);
};
function Label(props) {
  var viewBox = props.viewBox, position = props.position, value = props.value, children = props.children, content = props.content, _props$className = props.className, className = _props$className === void 0 ? "" : _props$className, textBreakAll = props.textBreakAll;
  if (!viewBox || _isNil(value) && _isNil(children) && !/* @__PURE__ */ reactExports.isValidElement(content) && !_isFunction(content)) {
    return null;
  }
  if (/* @__PURE__ */ reactExports.isValidElement(content)) {
    return /* @__PURE__ */ reactExports.cloneElement(content, props);
  }
  var label;
  if (_isFunction(content)) {
    label = /* @__PURE__ */ reactExports.createElement(content, props);
    if (/* @__PURE__ */ reactExports.isValidElement(label)) {
      return label;
    }
  } else {
    label = getLabel(props);
  }
  var isPolarLabel = isPolar(viewBox);
  var attrs = filterProps(props, true);
  if (isPolarLabel && (position === "insideStart" || position === "insideEnd" || position === "end")) {
    return renderRadialLabel(props, label, attrs);
  }
  var positionAttrs = isPolarLabel ? getAttrsOfPolarLabel(props) : getAttrsOfCartesianLabel(props);
  return /* @__PURE__ */ React.createElement(Text, _extends$h({
    className: classNames("recharts-label", className)
  }, attrs, positionAttrs, {
    breakAll: textBreakAll
  }), label);
}
Label.displayName = "Label";
Label.defaultProps = {
  offset: 5
};
var parseViewBox = function parseViewBox2(props) {
  var cx = props.cx, cy = props.cy, angle = props.angle, startAngle = props.startAngle, endAngle = props.endAngle, r2 = props.r, radius = props.radius, innerRadius = props.innerRadius, outerRadius = props.outerRadius, x2 = props.x, y2 = props.y, top = props.top, left = props.left, width = props.width, height = props.height, clockWise = props.clockWise, labelViewBox = props.labelViewBox;
  if (labelViewBox) {
    return labelViewBox;
  }
  if (isNumber(width) && isNumber(height)) {
    if (isNumber(x2) && isNumber(y2)) {
      return {
        x: x2,
        y: y2,
        width,
        height
      };
    }
    if (isNumber(top) && isNumber(left)) {
      return {
        x: top,
        y: left,
        width,
        height
      };
    }
  }
  if (isNumber(x2) && isNumber(y2)) {
    return {
      x: x2,
      y: y2,
      width: 0,
      height: 0
    };
  }
  if (isNumber(cx) && isNumber(cy)) {
    return {
      cx,
      cy,
      startAngle: startAngle || angle || 0,
      endAngle: endAngle || angle || 0,
      innerRadius: innerRadius || 0,
      outerRadius: outerRadius || radius || r2 || 0,
      clockWise
    };
  }
  if (props.viewBox) {
    return props.viewBox;
  }
  return {};
};
var parseLabel = function parseLabel2(label, viewBox) {
  if (!label) {
    return null;
  }
  if (label === true) {
    return /* @__PURE__ */ React.createElement(Label, {
      key: "label-implicit",
      viewBox
    });
  }
  if (isNumOrStr(label)) {
    return /* @__PURE__ */ React.createElement(Label, {
      key: "label-implicit",
      viewBox,
      value: label
    });
  }
  if (/* @__PURE__ */ reactExports.isValidElement(label)) {
    if (label.type === Label) {
      return /* @__PURE__ */ reactExports.cloneElement(label, {
        key: "label-implicit",
        viewBox
      });
    }
    return /* @__PURE__ */ React.createElement(Label, {
      key: "label-implicit",
      content: label,
      viewBox
    });
  }
  if (_isFunction(label)) {
    return /* @__PURE__ */ React.createElement(Label, {
      key: "label-implicit",
      content: label,
      viewBox
    });
  }
  if (_isObject(label)) {
    return /* @__PURE__ */ React.createElement(Label, _extends$h({
      viewBox
    }, label, {
      key: "label-implicit"
    }));
  }
  return null;
};
var renderCallByParent$1 = function renderCallByParent(parentProps, viewBox) {
  var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
    return null;
  }
  var children = parentProps.children;
  var parentViewBox = parseViewBox(parentProps);
  var explicitChildren = findAllByType(children, Label).map(function(child, index) {
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      viewBox: viewBox || parentViewBox,
      // eslint-disable-next-line react/no-array-index-key
      key: "label-".concat(index)
    });
  });
  if (!checkPropsLabel) {
    return explicitChildren;
  }
  var implicitLabel = parseLabel(parentProps.label, viewBox || parentViewBox);
  return [implicitLabel].concat(_toConsumableArray$4(explicitChildren));
};
Label.parseViewBox = parseViewBox;
Label.renderCallByParent = renderCallByParent$1;
function last(array2) {
  var length = array2 == null ? 0 : array2.length;
  return length ? array2[length - 1] : void 0;
}
var last_1 = last;
const _last = /* @__PURE__ */ getDefaultExportFromCjs(last_1);
function _typeof$i(obj) {
  "@babel/helpers - typeof";
  return _typeof$i = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$i(obj);
}
var _excluded$8 = ["data", "valueAccessor", "dataKey", "clockWise", "id", "textBreakAll"];
function _toConsumableArray$3(arr) {
  return _arrayWithoutHoles$3(arr) || _iterableToArray$3(arr) || _unsupportedIterableToArray$4(arr) || _nonIterableSpread$3();
}
function _nonIterableSpread$3() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$4(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$4(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$4(o, minLen);
}
function _iterableToArray$3(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$3(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$4(arr);
}
function _arrayLikeToArray$4(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _extends$g() {
  _extends$g = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$g.apply(this, arguments);
}
function ownKeys$e(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$e(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$e(Object(source), true).forEach(function(key) {
      _defineProperty$h(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$e(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$h(obj, key, value) {
  key = _toPropertyKey$i(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$i(arg) {
  var key = _toPrimitive$i(arg, "string");
  return _typeof$i(key) === "symbol" ? key : String(key);
}
function _toPrimitive$i(input2, hint) {
  if (_typeof$i(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$i(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function _objectWithoutProperties$8(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$8(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$8(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var defaultProps = {
  valueAccessor: function valueAccessor(entry) {
    return _isArray(entry.value) ? _last(entry.value) : entry.value;
  }
};
function LabelList(props) {
  var data = props.data, valueAccessor2 = props.valueAccessor, dataKey = props.dataKey, clockWise = props.clockWise, id = props.id, textBreakAll = props.textBreakAll, others = _objectWithoutProperties$8(props, _excluded$8);
  if (!data || !data.length) {
    return null;
  }
  return /* @__PURE__ */ React.createElement(Layer, {
    className: "recharts-label-list"
  }, data.map(function(entry, index) {
    var value = _isNil(dataKey) ? valueAccessor2(entry, index) : getValueByDataKey(entry && entry.payload, dataKey);
    var idProps = _isNil(id) ? {} : {
      id: "".concat(id, "-").concat(index)
    };
    return /* @__PURE__ */ React.createElement(Label, _extends$g({}, filterProps(entry, true), others, idProps, {
      parentViewBox: entry.parentViewBox,
      index,
      value,
      textBreakAll,
      viewBox: Label.parseViewBox(_isNil(clockWise) ? entry : _objectSpread$e(_objectSpread$e({}, entry), {}, {
        clockWise
      })),
      key: "label-".concat(index)
      // eslint-disable-line react/no-array-index-key
    }));
  }));
}
LabelList.displayName = "LabelList";
function parseLabelList(label, data) {
  if (!label) {
    return null;
  }
  if (label === true) {
    return /* @__PURE__ */ React.createElement(LabelList, {
      key: "labelList-implicit",
      data
    });
  }
  if (/* @__PURE__ */ React.isValidElement(label) || _isFunction(label)) {
    return /* @__PURE__ */ React.createElement(LabelList, {
      key: "labelList-implicit",
      data,
      content: label
    });
  }
  if (_isObject(label)) {
    return /* @__PURE__ */ React.createElement(LabelList, _extends$g({
      data
    }, label, {
      key: "labelList-implicit"
    }));
  }
  return null;
}
function renderCallByParent2(parentProps, data) {
  var checkPropsLabel = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : true;
  if (!parentProps || !parentProps.children && checkPropsLabel && !parentProps.label) {
    return null;
  }
  var children = parentProps.children;
  var explicitChildren = findAllByType(children, LabelList).map(function(child, index) {
    return /* @__PURE__ */ reactExports.cloneElement(child, {
      data,
      // eslint-disable-next-line react/no-array-index-key
      key: "labelList-".concat(index)
    });
  });
  if (!checkPropsLabel) {
    return explicitChildren;
  }
  var implicitLabelList = parseLabelList(parentProps.label, data);
  return [implicitLabelList].concat(_toConsumableArray$3(explicitChildren));
}
LabelList.renderCallByParent = renderCallByParent2;
LabelList.defaultProps = defaultProps;
function _typeof$h(obj) {
  "@babel/helpers - typeof";
  return _typeof$h = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$h(obj);
}
function _extends$f() {
  _extends$f = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$f.apply(this, arguments);
}
function _classCallCheck$d(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$d(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$h(descriptor.key), descriptor);
  }
}
function _createClass$d(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$d(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$d(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$c(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$c(subClass, superClass);
}
function _setPrototypeOf$c(o, p2) {
  _setPrototypeOf$c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$c(o, p2);
}
function _createSuper$c(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$c();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$c(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$c(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$c(this, result);
  };
}
function _possibleConstructorReturn$c(self2, call) {
  if (call && (_typeof$h(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$c(self2);
}
function _assertThisInitialized$c(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$c() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$c(o) {
  _getPrototypeOf$c = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$c(o);
}
function _defineProperty$g(obj, key, value) {
  key = _toPropertyKey$h(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$h(arg) {
  var key = _toPrimitive$h(arg, "string");
  return _typeof$h(key) === "symbol" ? key : String(key);
}
function _toPrimitive$h(input2, hint) {
  if (_typeof$h(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$h(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var getDeltaAngle2 = function getDeltaAngle3(startAngle, endAngle) {
  var sign2 = mathSign(endAngle - startAngle);
  var deltaAngle = Math.min(Math.abs(endAngle - startAngle), 359.999);
  return sign2 * deltaAngle;
};
var getTangentCircle = function getTangentCircle2(_ref) {
  var cx = _ref.cx, cy = _ref.cy, radius = _ref.radius, angle = _ref.angle, sign2 = _ref.sign, isExternal = _ref.isExternal, cornerRadius = _ref.cornerRadius, cornerIsExternal = _ref.cornerIsExternal;
  var centerRadius = cornerRadius * (isExternal ? 1 : -1) + radius;
  var theta = Math.asin(cornerRadius / centerRadius) / RADIAN;
  var centerAngle = cornerIsExternal ? angle : angle + sign2 * theta;
  var center = polarToCartesian(cx, cy, centerRadius, centerAngle);
  var circleTangency = polarToCartesian(cx, cy, radius, centerAngle);
  var lineTangencyAngle = cornerIsExternal ? angle - sign2 * theta : angle;
  var lineTangency = polarToCartesian(cx, cy, centerRadius * Math.cos(theta * RADIAN), lineTangencyAngle);
  return {
    center,
    circleTangency,
    lineTangency,
    theta
  };
};
var getSectorPath = function getSectorPath2(_ref2) {
  var cx = _ref2.cx, cy = _ref2.cy, innerRadius = _ref2.innerRadius, outerRadius = _ref2.outerRadius, startAngle = _ref2.startAngle, endAngle = _ref2.endAngle;
  var angle = getDeltaAngle2(startAngle, endAngle);
  var tempEndAngle = startAngle + angle;
  var outerStartPoint = polarToCartesian(cx, cy, outerRadius, startAngle);
  var outerEndPoint = polarToCartesian(cx, cy, outerRadius, tempEndAngle);
  var path = "M ".concat(outerStartPoint.x, ",").concat(outerStartPoint.y, "\n    A ").concat(outerRadius, ",").concat(outerRadius, ",0,\n    ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle > tempEndAngle), ",\n    ").concat(outerEndPoint.x, ",").concat(outerEndPoint.y, "\n  ");
  if (innerRadius > 0) {
    var innerStartPoint = polarToCartesian(cx, cy, innerRadius, startAngle);
    var innerEndPoint = polarToCartesian(cx, cy, innerRadius, tempEndAngle);
    path += "L ".concat(innerEndPoint.x, ",").concat(innerEndPoint.y, "\n            A ").concat(innerRadius, ",").concat(innerRadius, ",0,\n            ").concat(+(Math.abs(angle) > 180), ",").concat(+(startAngle <= tempEndAngle), ",\n            ").concat(innerStartPoint.x, ",").concat(innerStartPoint.y, " Z");
  } else {
    path += "L ".concat(cx, ",").concat(cy, " Z");
  }
  return path;
};
var getSectorWithCorner = function getSectorWithCorner2(_ref3) {
  var cx = _ref3.cx, cy = _ref3.cy, innerRadius = _ref3.innerRadius, outerRadius = _ref3.outerRadius, cornerRadius = _ref3.cornerRadius, forceCornerRadius = _ref3.forceCornerRadius, cornerIsExternal = _ref3.cornerIsExternal, startAngle = _ref3.startAngle, endAngle = _ref3.endAngle;
  var sign2 = mathSign(endAngle - startAngle);
  var _getTangentCircle = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: startAngle,
    sign: sign2,
    cornerRadius,
    cornerIsExternal
  }), soct = _getTangentCircle.circleTangency, solt = _getTangentCircle.lineTangency, sot = _getTangentCircle.theta;
  var _getTangentCircle2 = getTangentCircle({
    cx,
    cy,
    radius: outerRadius,
    angle: endAngle,
    sign: -sign2,
    cornerRadius,
    cornerIsExternal
  }), eoct = _getTangentCircle2.circleTangency, eolt = _getTangentCircle2.lineTangency, eot = _getTangentCircle2.theta;
  var outerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sot - eot;
  if (outerArcAngle < 0) {
    if (forceCornerRadius) {
      return "M ".concat(solt.x, ",").concat(solt.y, "\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(cornerRadius * 2, ",0\n        a").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,1,").concat(-cornerRadius * 2, ",0\n      ");
    }
    return getSectorPath({
      cx,
      cy,
      innerRadius,
      outerRadius,
      startAngle,
      endAngle
    });
  }
  var path = "M ".concat(solt.x, ",").concat(solt.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(soct.x, ",").concat(soct.y, "\n    A").concat(outerRadius, ",").concat(outerRadius, ",0,").concat(+(outerArcAngle > 180), ",").concat(+(sign2 < 0), ",").concat(eoct.x, ",").concat(eoct.y, "\n    A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eolt.x, ",").concat(eolt.y, "\n  ");
  if (innerRadius > 0) {
    var _getTangentCircle3 = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: startAngle,
      sign: sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    }), sict = _getTangentCircle3.circleTangency, silt = _getTangentCircle3.lineTangency, sit = _getTangentCircle3.theta;
    var _getTangentCircle4 = getTangentCircle({
      cx,
      cy,
      radius: innerRadius,
      angle: endAngle,
      sign: -sign2,
      isExternal: true,
      cornerRadius,
      cornerIsExternal
    }), eict = _getTangentCircle4.circleTangency, eilt = _getTangentCircle4.lineTangency, eit = _getTangentCircle4.theta;
    var innerArcAngle = cornerIsExternal ? Math.abs(startAngle - endAngle) : Math.abs(startAngle - endAngle) - sit - eit;
    if (innerArcAngle < 0 && cornerRadius === 0) {
      return "".concat(path, "L").concat(cx, ",").concat(cy, "Z");
    }
    path += "L".concat(eilt.x, ",").concat(eilt.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(eict.x, ",").concat(eict.y, "\n      A").concat(innerRadius, ",").concat(innerRadius, ",0,").concat(+(innerArcAngle > 180), ",").concat(+(sign2 > 0), ",").concat(sict.x, ",").concat(sict.y, "\n      A").concat(cornerRadius, ",").concat(cornerRadius, ",0,0,").concat(+(sign2 < 0), ",").concat(silt.x, ",").concat(silt.y, "Z");
  } else {
    path += "L".concat(cx, ",").concat(cy, "Z");
  }
  return path;
};
var Sector = /* @__PURE__ */ function(_PureComponent) {
  _inherits$c(Sector2, _PureComponent);
  var _super = _createSuper$c(Sector2);
  function Sector2() {
    _classCallCheck$d(this, Sector2);
    return _super.apply(this, arguments);
  }
  _createClass$d(Sector2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, innerRadius = _this$props.innerRadius, outerRadius = _this$props.outerRadius, cornerRadius = _this$props.cornerRadius, forceCornerRadius = _this$props.forceCornerRadius, cornerIsExternal = _this$props.cornerIsExternal, startAngle = _this$props.startAngle, endAngle = _this$props.endAngle, className = _this$props.className;
      if (outerRadius < innerRadius || startAngle === endAngle) {
        return null;
      }
      var layerClass = classNames("recharts-sector", className);
      var deltaRadius = outerRadius - innerRadius;
      var cr = getPercentValue(cornerRadius, deltaRadius, 0, true);
      var path;
      if (cr > 0 && Math.abs(startAngle - endAngle) < 360) {
        path = getSectorWithCorner({
          cx,
          cy,
          innerRadius,
          outerRadius,
          cornerRadius: Math.min(cr, deltaRadius / 2),
          forceCornerRadius,
          cornerIsExternal,
          startAngle,
          endAngle
        });
      } else {
        path = getSectorPath({
          cx,
          cy,
          innerRadius,
          outerRadius,
          startAngle,
          endAngle
        });
      }
      return /* @__PURE__ */ React.createElement("path", _extends$f({}, filterProps(this.props, true), {
        className: layerClass,
        d: path,
        role: "img"
      }));
    }
  }]);
  return Sector2;
}(reactExports.PureComponent);
_defineProperty$g(Sector, "defaultProps", {
  cx: 0,
  cy: 0,
  innerRadius: 0,
  outerRadius: 0,
  startAngle: 0,
  endAngle: 0,
  cornerRadius: 0,
  forceCornerRadius: false,
  cornerIsExternal: false
});
function _typeof$g(obj) {
  "@babel/helpers - typeof";
  return _typeof$g = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$g(obj);
}
function _extends$e() {
  _extends$e = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$e.apply(this, arguments);
}
function ownKeys$d(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$d(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$d(Object(source), true).forEach(function(key) {
      _defineProperty$f(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$d(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$c(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$c(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$g(descriptor.key), descriptor);
  }
}
function _createClass$c(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$c(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$c(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$b(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$b(subClass, superClass);
}
function _setPrototypeOf$b(o, p2) {
  _setPrototypeOf$b = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$b(o, p2);
}
function _createSuper$b(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$b();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$b(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$b(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$b(this, result);
  };
}
function _possibleConstructorReturn$b(self2, call) {
  if (call && (_typeof$g(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$b(self2);
}
function _assertThisInitialized$b(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$b() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$b(o) {
  _getPrototypeOf$b = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$b(o);
}
function _defineProperty$f(obj, key, value) {
  key = _toPropertyKey$g(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$g(arg) {
  var key = _toPrimitive$g(arg, "string");
  return _typeof$g(key) === "symbol" ? key : String(key);
}
function _toPrimitive$g(input2, hint) {
  if (_typeof$g(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$g(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var CURVE_FACTORIES = {
  curveBasisClosed,
  curveBasisOpen,
  curveBasis,
  curveLinearClosed,
  curveLinear,
  curveMonotoneX: monotoneX,
  curveMonotoneY: monotoneY,
  curveNatural,
  curveStep,
  curveStepAfter: stepAfter,
  curveStepBefore: stepBefore
};
var defined = function defined2(p2) {
  return p2.x === +p2.x && p2.y === +p2.y;
};
var getX = function getX2(p2) {
  return p2.x;
};
var getY = function getY2(p2) {
  return p2.y;
};
var getCurveFactory = function getCurveFactory2(type, layout) {
  if (_isFunction(type)) {
    return type;
  }
  var name = "curve".concat(_upperFirst(type));
  if (name === "curveMonotone" && layout) {
    return CURVE_FACTORIES["".concat(name).concat(layout === "vertical" ? "Y" : "X")];
  }
  return CURVE_FACTORIES[name] || curveLinear;
};
var Curve = /* @__PURE__ */ function(_PureComponent) {
  _inherits$b(Curve2, _PureComponent);
  var _super = _createSuper$b(Curve2);
  function Curve2() {
    _classCallCheck$c(this, Curve2);
    return _super.apply(this, arguments);
  }
  _createClass$c(Curve2, [{
    key: "getPath",
    value: (
      /**
       * Calculate the path of curve
       * @return {String} path
       */
      function getPath() {
        var _this$props = this.props, type = _this$props.type, points = _this$props.points, baseLine = _this$props.baseLine, layout = _this$props.layout, connectNulls = _this$props.connectNulls;
        var curveFactory = getCurveFactory(type, layout);
        var formatPoints = connectNulls ? points.filter(function(entry) {
          return defined(entry);
        }) : points;
        var lineFunction;
        if (_isArray(baseLine)) {
          var formatBaseLine = connectNulls ? baseLine.filter(function(base) {
            return defined(base);
          }) : baseLine;
          var areaPoints = formatPoints.map(function(entry, index) {
            return _objectSpread$d(_objectSpread$d({}, entry), {}, {
              base: formatBaseLine[index]
            });
          });
          if (layout === "vertical") {
            lineFunction = shapeArea().y(getY).x1(getX).x0(function(d2) {
              return d2.base.x;
            });
          } else {
            lineFunction = shapeArea().x(getX).y1(getY).y0(function(d2) {
              return d2.base.y;
            });
          }
          lineFunction.defined(defined).curve(curveFactory);
          return lineFunction(areaPoints);
        }
        if (layout === "vertical" && isNumber(baseLine)) {
          lineFunction = shapeArea().y(getY).x1(getX).x0(baseLine);
        } else if (isNumber(baseLine)) {
          lineFunction = shapeArea().x(getX).y1(getY).y0(baseLine);
        } else {
          lineFunction = shapeLine().x(getX).y(getY);
        }
        lineFunction.defined(defined).curve(curveFactory);
        return lineFunction(formatPoints);
      }
    )
  }, {
    key: "render",
    value: function render() {
      var _this$props2 = this.props, className = _this$props2.className, points = _this$props2.points, path = _this$props2.path, pathRef = _this$props2.pathRef;
      if ((!points || !points.length) && !path) {
        return null;
      }
      var realPath = points && points.length ? this.getPath() : path;
      return /* @__PURE__ */ React.createElement("path", _extends$e({}, filterProps(this.props), adaptEventHandlers(this.props), {
        className: classNames("recharts-curve", className),
        d: realPath,
        ref: pathRef
      }));
    }
  }]);
  return Curve2;
}(reactExports.PureComponent);
_defineProperty$f(Curve, "defaultProps", {
  type: "linear",
  points: [],
  connectNulls: false
});
function _typeof$f(obj) {
  "@babel/helpers - typeof";
  return _typeof$f = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$f(obj);
}
function _extends$d() {
  _extends$d = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$d.apply(this, arguments);
}
function _classCallCheck$b(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$b(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$f(descriptor.key), descriptor);
  }
}
function _createClass$b(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$b(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$b(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$a(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$a(subClass, superClass);
}
function _setPrototypeOf$a(o, p2) {
  _setPrototypeOf$a = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$a(o, p2);
}
function _createSuper$a(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$a();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$a(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$a(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$a(this, result);
  };
}
function _possibleConstructorReturn$a(self2, call) {
  if (call && (_typeof$f(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$a(self2);
}
function _assertThisInitialized$a(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$a() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$a(o) {
  _getPrototypeOf$a = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$a(o);
}
function _defineProperty$e(obj, key, value) {
  key = _toPropertyKey$f(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$f(arg) {
  var key = _toPrimitive$f(arg, "string");
  return _typeof$f(key) === "symbol" ? key : String(key);
}
function _toPrimitive$f(input2, hint) {
  if (_typeof$f(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$f(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var getRectanglePath = function getRectanglePath2(x2, y2, width, height, radius) {
  var maxRadius = Math.min(Math.abs(width) / 2, Math.abs(height) / 2);
  var ySign = height >= 0 ? 1 : -1;
  var xSign = width >= 0 ? 1 : -1;
  var clockWise = height >= 0 && width >= 0 || height < 0 && width < 0 ? 1 : 0;
  var path;
  if (maxRadius > 0 && radius instanceof Array) {
    var newRadius = [0, 0, 0, 0];
    for (var i = 0, len = 4; i < len; i++) {
      newRadius[i] = radius[i] > maxRadius ? maxRadius : radius[i];
    }
    path = "M".concat(x2, ",").concat(y2 + ySign * newRadius[0]);
    if (newRadius[0] > 0) {
      path += "A ".concat(newRadius[0], ",").concat(newRadius[0], ",0,0,").concat(clockWise, ",").concat(x2 + xSign * newRadius[0], ",").concat(y2);
    }
    path += "L ".concat(x2 + width - xSign * newRadius[1], ",").concat(y2);
    if (newRadius[1] > 0) {
      path += "A ".concat(newRadius[1], ",").concat(newRadius[1], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width, ",").concat(y2 + ySign * newRadius[1]);
    }
    path += "L ".concat(x2 + width, ",").concat(y2 + height - ySign * newRadius[2]);
    if (newRadius[2] > 0) {
      path += "A ".concat(newRadius[2], ",").concat(newRadius[2], ",0,0,").concat(clockWise, ",\n        ").concat(x2 + width - xSign * newRadius[2], ",").concat(y2 + height);
    }
    path += "L ".concat(x2 + xSign * newRadius[3], ",").concat(y2 + height);
    if (newRadius[3] > 0) {
      path += "A ".concat(newRadius[3], ",").concat(newRadius[3], ",0,0,").concat(clockWise, ",\n        ").concat(x2, ",").concat(y2 + height - ySign * newRadius[3]);
    }
    path += "Z";
  } else if (maxRadius > 0 && radius === +radius && radius > 0) {
    var _newRadius = Math.min(maxRadius, radius);
    path = "M ".concat(x2, ",").concat(y2 + ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + xSign * _newRadius, ",").concat(y2, "\n            L ").concat(x2 + width - xSign * _newRadius, ",").concat(y2, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width, ",").concat(y2 + ySign * _newRadius, "\n            L ").concat(x2 + width, ",").concat(y2 + height - ySign * _newRadius, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2 + width - xSign * _newRadius, ",").concat(y2 + height, "\n            L ").concat(x2 + xSign * _newRadius, ",").concat(y2 + height, "\n            A ").concat(_newRadius, ",").concat(_newRadius, ",0,0,").concat(clockWise, ",").concat(x2, ",").concat(y2 + height - ySign * _newRadius, " Z");
  } else {
    path = "M ".concat(x2, ",").concat(y2, " h ").concat(width, " v ").concat(height, " h ").concat(-width, " Z");
  }
  return path;
};
var isInRectangle = function isInRectangle2(point2, rect) {
  if (!point2 || !rect) {
    return false;
  }
  var px = point2.x, py = point2.y;
  var x2 = rect.x, y2 = rect.y, width = rect.width, height = rect.height;
  if (Math.abs(width) > 0 && Math.abs(height) > 0) {
    var minX = Math.min(x2, x2 + width);
    var maxX = Math.max(x2, x2 + width);
    var minY = Math.min(y2, y2 + height);
    var maxY = Math.max(y2, y2 + height);
    return px >= minX && px <= maxX && py >= minY && py <= maxY;
  }
  return false;
};
var Rectangle = /* @__PURE__ */ function(_PureComponent) {
  _inherits$a(Rectangle2, _PureComponent);
  var _super = _createSuper$a(Rectangle2);
  function Rectangle2() {
    var _this;
    _classCallCheck$b(this, Rectangle2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$e(_assertThisInitialized$a(_this), "state", {
      totalLength: -1
    });
    return _this;
  }
  _createClass$b(Rectangle2, [{
    key: "componentDidMount",
    value: (
      /* eslint-disable  react/no-did-mount-set-state */
      function componentDidMount() {
        if (this.node && this.node.getTotalLength) {
          try {
            var totalLength = this.node.getTotalLength();
            if (totalLength) {
              this.setState({
                totalLength
              });
            }
          } catch (err) {
          }
        }
      }
    )
  }, {
    key: "render",
    value: function render() {
      var _this2 = this;
      var _this$props = this.props, x2 = _this$props.x, y2 = _this$props.y, width = _this$props.width, height = _this$props.height, radius = _this$props.radius, className = _this$props.className;
      var totalLength = this.state.totalLength;
      var _this$props2 = this.props, animationEasing = _this$props2.animationEasing, animationDuration = _this$props2.animationDuration, animationBegin = _this$props2.animationBegin, isAnimationActive = _this$props2.isAnimationActive, isUpdateAnimationActive = _this$props2.isUpdateAnimationActive;
      if (x2 !== +x2 || y2 !== +y2 || width !== +width || height !== +height || width === 0 || height === 0) {
        return null;
      }
      var layerClass = classNames("recharts-rectangle", className);
      if (!isUpdateAnimationActive) {
        return /* @__PURE__ */ React.createElement("path", _extends$d({}, filterProps(this.props, true), {
          className: layerClass,
          d: getRectanglePath(x2, y2, width, height, radius)
        }));
      }
      return /* @__PURE__ */ React.createElement(Animate, {
        canBegin: totalLength > 0,
        from: {
          width,
          height,
          x: x2,
          y: y2
        },
        to: {
          width,
          height,
          x: x2,
          y: y2
        },
        duration: animationDuration,
        animationEasing,
        isActive: isUpdateAnimationActive
      }, function(_ref) {
        var currWidth = _ref.width, currHeight = _ref.height, currX = _ref.x, currY = _ref.y;
        return /* @__PURE__ */ React.createElement(Animate, {
          canBegin: totalLength > 0,
          from: "0px ".concat(totalLength === -1 ? 1 : totalLength, "px"),
          to: "".concat(totalLength, "px 0px"),
          attributeName: "strokeDasharray",
          begin: animationBegin,
          duration: animationDuration,
          isActive: isAnimationActive,
          easing: animationEasing
        }, /* @__PURE__ */ React.createElement("path", _extends$d({}, filterProps(_this2.props, true), {
          className: layerClass,
          d: getRectanglePath(currX, currY, currWidth, currHeight, radius),
          ref: function ref(node) {
            _this2.node = node;
          }
        })));
      });
    }
  }]);
  return Rectangle2;
}(reactExports.PureComponent);
_defineProperty$e(Rectangle, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  // The radius of border
  // The radius of four corners when radius is a number
  // The radius of left-top, right-top, right-bottom, left-bottom when radius is an array
  radius: 0,
  isAnimationActive: false,
  isUpdateAnimationActive: false,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
});
function _typeof$e(obj) {
  "@babel/helpers - typeof";
  return _typeof$e = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$e(obj);
}
function _extends$c() {
  _extends$c = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$c.apply(this, arguments);
}
function _classCallCheck$a(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$a(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$e(descriptor.key), descriptor);
  }
}
function _createClass$a(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$a(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$a(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _toPropertyKey$e(arg) {
  var key = _toPrimitive$e(arg, "string");
  return _typeof$e(key) === "symbol" ? key : String(key);
}
function _toPrimitive$e(input2, hint) {
  if (_typeof$e(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$e(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function _inherits$9(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$9(subClass, superClass);
}
function _setPrototypeOf$9(o, p2) {
  _setPrototypeOf$9 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$9(o, p2);
}
function _createSuper$9(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$9();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$9(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$9(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$9(this, result);
  };
}
function _possibleConstructorReturn$9(self2, call) {
  if (call && (_typeof$e(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$9(self2);
}
function _assertThisInitialized$9(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$9() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$9(o) {
  _getPrototypeOf$9 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$9(o);
}
var Dot = /* @__PURE__ */ function(_PureComponent) {
  _inherits$9(Dot2, _PureComponent);
  var _super = _createSuper$9(Dot2);
  function Dot2() {
    _classCallCheck$a(this, Dot2);
    return _super.apply(this, arguments);
  }
  _createClass$a(Dot2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, cx = _this$props.cx, cy = _this$props.cy, r2 = _this$props.r, className = _this$props.className;
      var layerClass = classNames("recharts-dot", className);
      if (cx === +cx && cy === +cy && r2 === +r2) {
        return /* @__PURE__ */ React.createElement("circle", _extends$c({}, filterProps(this.props), adaptEventHandlers(this.props), {
          className: layerClass,
          cx,
          cy,
          r: r2
        }));
      }
      return null;
    }
  }]);
  return Dot2;
}(reactExports.PureComponent);
function _typeof$d(obj) {
  "@babel/helpers - typeof";
  return _typeof$d = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$d(obj);
}
function _extends$b() {
  _extends$b = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$b.apply(this, arguments);
}
function _classCallCheck$9(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$9(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$d(descriptor.key), descriptor);
  }
}
function _createClass$9(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$9(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$9(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$8(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$8(subClass, superClass);
}
function _setPrototypeOf$8(o, p2) {
  _setPrototypeOf$8 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$8(o, p2);
}
function _createSuper$8(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$8();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$8(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$8(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$8(this, result);
  };
}
function _possibleConstructorReturn$8(self2, call) {
  if (call && (_typeof$d(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$8(self2);
}
function _assertThisInitialized$8(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$8() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$8(o) {
  _getPrototypeOf$8 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$8(o);
}
function _defineProperty$d(obj, key, value) {
  key = _toPropertyKey$d(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$d(arg) {
  var key = _toPrimitive$d(arg, "string");
  return _typeof$d(key) === "symbol" ? key : String(key);
}
function _toPrimitive$d(input2, hint) {
  if (_typeof$d(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$d(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var Cross = /* @__PURE__ */ function(_PureComponent) {
  _inherits$8(Cross2, _PureComponent);
  var _super = _createSuper$8(Cross2);
  function Cross2() {
    _classCallCheck$9(this, Cross2);
    return _super.apply(this, arguments);
  }
  _createClass$9(Cross2, [{
    key: "render",
    value: function render() {
      var _this$props = this.props, x2 = _this$props.x, y2 = _this$props.y, width = _this$props.width, height = _this$props.height, top = _this$props.top, left = _this$props.left, className = _this$props.className;
      if (!isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || !isNumber(top) || !isNumber(left)) {
        return null;
      }
      return /* @__PURE__ */ React.createElement("path", _extends$b({}, filterProps(this.props, true), {
        className: classNames("recharts-cross", className),
        d: Cross2.getPath(x2, y2, width, height, top, left)
      }));
    }
  }], [{
    key: "getPath",
    value: function getPath(x2, y2, width, height, top, left) {
      return "M".concat(x2, ",").concat(top, "v").concat(height, "M").concat(left, ",").concat(y2, "h").concat(width);
    }
  }]);
  return Cross2;
}(reactExports.PureComponent);
_defineProperty$d(Cross, "defaultProps", {
  x: 0,
  y: 0,
  top: 0,
  left: 0,
  width: 0,
  height: 0
});
var nativeCeil = Math.ceil, nativeMax$2 = Math.max;
function baseRange$1(start, end, step, fromRight) {
  var index = -1, length = nativeMax$2(nativeCeil((end - start) / (step || 1)), 0), result = Array(length);
  while (length--) {
    result[fromRight ? length : ++index] = start;
    start += step;
  }
  return result;
}
var _baseRange = baseRange$1;
var reWhitespace = /\s/;
function trimmedEndIndex$1(string2) {
  var index = string2.length;
  while (index-- && reWhitespace.test(string2.charAt(index))) {
  }
  return index;
}
var _trimmedEndIndex = trimmedEndIndex$1;
var trimmedEndIndex = _trimmedEndIndex;
var reTrimStart = /^\s+/;
function baseTrim$1(string2) {
  return string2 ? string2.slice(0, trimmedEndIndex(string2) + 1).replace(reTrimStart, "") : string2;
}
var _baseTrim = baseTrim$1;
var baseTrim = _baseTrim, isObject$2 = isObject_1$1, isSymbol = isSymbol_1$1;
var NAN = 0 / 0;
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
var reIsBinary = /^0b[01]+$/i;
var reIsOctal = /^0o[0-7]+$/i;
var freeParseInt = parseInt;
function toNumber$2(value) {
  if (typeof value == "number") {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject$2(value)) {
    var other = typeof value.valueOf == "function" ? value.valueOf() : value;
    value = isObject$2(other) ? other + "" : other;
  }
  if (typeof value != "string") {
    return value === 0 ? value : +value;
  }
  value = baseTrim(value);
  var isBinary = reIsBinary.test(value);
  return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
var toNumber_1 = toNumber$2;
var toNumber$1 = toNumber_1;
var INFINITY = 1 / 0, MAX_INTEGER = 17976931348623157e292;
function toFinite$2(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber$1(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign2 = value < 0 ? -1 : 1;
    return sign2 * MAX_INTEGER;
  }
  return value === value ? value : 0;
}
var toFinite_1 = toFinite$2;
var baseRange = _baseRange, isIterateeCall$2 = _isIterateeCall, toFinite$1 = toFinite_1;
function createRange$1(fromRight) {
  return function(start, end, step) {
    if (step && typeof step != "number" && isIterateeCall$2(start, end, step)) {
      end = step = void 0;
    }
    start = toFinite$1(start);
    if (end === void 0) {
      end = start;
      start = 0;
    } else {
      end = toFinite$1(end);
    }
    step = step === void 0 ? start < end ? 1 : -1 : toFinite$1(step);
    return baseRange(start, end, step, fromRight);
  };
}
var _createRange = createRange$1;
var createRange = _createRange;
var range2 = createRange();
var range_1 = range2;
const _range = /* @__PURE__ */ getDefaultExportFromCjs(range_1);
function _typeof$c(obj) {
  "@babel/helpers - typeof";
  return _typeof$c = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$c(obj);
}
function ownKeys$c(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$c(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$c(Object(source), true).forEach(function(key) {
      _defineProperty$c(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$c(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$c(obj, key, value) {
  key = _toPropertyKey$c(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$c(arg) {
  var key = _toPrimitive$c(arg, "string");
  return _typeof$c(key) === "symbol" ? key : String(key);
}
function _toPrimitive$c(input2, hint) {
  if (_typeof$c(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$c(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var PREFIX_LIST = ["Webkit", "Moz", "O", "ms"];
var generatePrefixStyle = function generatePrefixStyle3(name, value) {
  if (!name) {
    return null;
  }
  var camelName = name.replace(/(\w)/, function(v2) {
    return v2.toUpperCase();
  });
  var result = PREFIX_LIST.reduce(function(res, entry) {
    return _objectSpread$c(_objectSpread$c({}, res), {}, _defineProperty$c({}, entry + camelName, value));
  }, {});
  result[name] = value;
  return result;
};
function _typeof$b(obj) {
  "@babel/helpers - typeof";
  return _typeof$b = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$b(obj);
}
function _extends$a() {
  _extends$a = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$a.apply(this, arguments);
}
function ownKeys$b(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$b(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$b(Object(source), true).forEach(function(key) {
      _defineProperty$b(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$b(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$8(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$8(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$b(descriptor.key), descriptor);
  }
}
function _createClass$8(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$8(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$8(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$7(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$7(subClass, superClass);
}
function _setPrototypeOf$7(o, p2) {
  _setPrototypeOf$7 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$7(o, p2);
}
function _createSuper$7(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$7();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$7(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$7(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$7(this, result);
  };
}
function _possibleConstructorReturn$7(self2, call) {
  if (call && (_typeof$b(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$7(self2);
}
function _assertThisInitialized$7(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$7() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$7(o) {
  _getPrototypeOf$7 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$7(o);
}
function _defineProperty$b(obj, key, value) {
  key = _toPropertyKey$b(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$b(arg) {
  var key = _toPrimitive$b(arg, "string");
  return _typeof$b(key) === "symbol" ? key : String(key);
}
function _toPrimitive$b(input2, hint) {
  if (_typeof$b(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$b(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var createScale = function createScale2(_ref) {
  var data = _ref.data, startIndex = _ref.startIndex, endIndex = _ref.endIndex, x2 = _ref.x, width = _ref.width, travellerWidth = _ref.travellerWidth;
  if (!data || !data.length) {
    return {};
  }
  var len = data.length;
  var scale2 = point().domain(_range(0, len)).range([x2, x2 + width - travellerWidth]);
  var scaleValues = scale2.domain().map(function(entry) {
    return scale2(entry);
  });
  return {
    isTextActive: false,
    isSlideMoving: false,
    isTravellerMoving: false,
    startX: scale2(startIndex),
    endX: scale2(endIndex),
    scale: scale2,
    scaleValues
  };
};
var isTouch = function isTouch2(e3) {
  return e3.changedTouches && !!e3.changedTouches.length;
};
var Brush = /* @__PURE__ */ function(_PureComponent) {
  _inherits$7(Brush2, _PureComponent);
  var _super = _createSuper$7(Brush2);
  function Brush2(props) {
    var _this;
    _classCallCheck$8(this, Brush2);
    _this = _super.call(this, props);
    _defineProperty$b(_assertThisInitialized$7(_this), "handleDrag", function(e3) {
      if (_this.leaveTimer) {
        clearTimeout(_this.leaveTimer);
        _this.leaveTimer = null;
      }
      if (_this.state.isTravellerMoving) {
        _this.handleTravellerMove(e3);
      } else if (_this.state.isSlideMoving) {
        _this.handleSlideDrag(e3);
      }
    });
    _defineProperty$b(_assertThisInitialized$7(_this), "handleTouchMove", function(e3) {
      if (e3.changedTouches != null && e3.changedTouches.length > 0) {
        _this.handleDrag(e3.changedTouches[0]);
      }
    });
    _defineProperty$b(_assertThisInitialized$7(_this), "handleDragEnd", function() {
      _this.setState({
        isTravellerMoving: false,
        isSlideMoving: false
      });
      _this.detachDragEndListener();
    });
    _defineProperty$b(_assertThisInitialized$7(_this), "handleLeaveWrapper", function() {
      if (_this.state.isTravellerMoving || _this.state.isSlideMoving) {
        _this.leaveTimer = window.setTimeout(_this.handleDragEnd, _this.props.leaveTimeOut);
      }
    });
    _defineProperty$b(_assertThisInitialized$7(_this), "handleEnterSlideOrTraveller", function() {
      _this.setState({
        isTextActive: true
      });
    });
    _defineProperty$b(_assertThisInitialized$7(_this), "handleLeaveSlideOrTraveller", function() {
      _this.setState({
        isTextActive: false
      });
    });
    _defineProperty$b(_assertThisInitialized$7(_this), "handleSlideDragStart", function(e3) {
      var event = isTouch(e3) ? e3.changedTouches[0] : e3;
      _this.setState({
        isTravellerMoving: false,
        isSlideMoving: true,
        slideMoveStartX: event.pageX
      });
      _this.attachDragEndListener();
    });
    _this.travellerDragStartHandlers = {
      startX: _this.handleTravellerDragStart.bind(_assertThisInitialized$7(_this), "startX"),
      endX: _this.handleTravellerDragStart.bind(_assertThisInitialized$7(_this), "endX")
    };
    _this.state = {};
    return _this;
  }
  _createClass$8(Brush2, [{
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      if (this.leaveTimer) {
        clearTimeout(this.leaveTimer);
        this.leaveTimer = null;
      }
      this.detachDragEndListener();
    }
  }, {
    key: "getIndex",
    value: function getIndex(_ref2) {
      var startX = _ref2.startX, endX = _ref2.endX;
      var scaleValues = this.state.scaleValues;
      var _this$props = this.props, gap = _this$props.gap, data = _this$props.data;
      var lastIndex = data.length - 1;
      var min2 = Math.min(startX, endX);
      var max2 = Math.max(startX, endX);
      var minIndex = Brush2.getIndexInRange(scaleValues, min2);
      var maxIndex = Brush2.getIndexInRange(scaleValues, max2);
      return {
        startIndex: minIndex - minIndex % gap,
        endIndex: maxIndex === lastIndex ? lastIndex : maxIndex - maxIndex % gap
      };
    }
  }, {
    key: "getTextOfTick",
    value: function getTextOfTick(index) {
      var _this$props2 = this.props, data = _this$props2.data, tickFormatter = _this$props2.tickFormatter, dataKey = _this$props2.dataKey;
      var text = getValueByDataKey(data[index], dataKey, index);
      return _isFunction(tickFormatter) ? tickFormatter(text, index) : text;
    }
  }, {
    key: "attachDragEndListener",
    value: function attachDragEndListener() {
      window.addEventListener("mouseup", this.handleDragEnd, true);
      window.addEventListener("touchend", this.handleDragEnd, true);
      window.addEventListener("mousemove", this.handleDrag, true);
    }
  }, {
    key: "detachDragEndListener",
    value: function detachDragEndListener() {
      window.removeEventListener("mouseup", this.handleDragEnd, true);
      window.removeEventListener("touchend", this.handleDragEnd, true);
      window.removeEventListener("mousemove", this.handleDrag, true);
    }
  }, {
    key: "handleSlideDrag",
    value: function handleSlideDrag(e3) {
      var _this$state = this.state, slideMoveStartX = _this$state.slideMoveStartX, startX = _this$state.startX, endX = _this$state.endX;
      var _this$props3 = this.props, x2 = _this$props3.x, width = _this$props3.width, travellerWidth = _this$props3.travellerWidth, startIndex = _this$props3.startIndex, endIndex = _this$props3.endIndex, onChange = _this$props3.onChange;
      var delta = e3.pageX - slideMoveStartX;
      if (delta > 0) {
        delta = Math.min(delta, x2 + width - travellerWidth - endX, x2 + width - travellerWidth - startX);
      } else if (delta < 0) {
        delta = Math.max(delta, x2 - startX, x2 - endX);
      }
      var newIndex = this.getIndex({
        startX: startX + delta,
        endX: endX + delta
      });
      if ((newIndex.startIndex !== startIndex || newIndex.endIndex !== endIndex) && onChange) {
        onChange(newIndex);
      }
      this.setState({
        startX: startX + delta,
        endX: endX + delta,
        slideMoveStartX: e3.pageX
      });
    }
  }, {
    key: "handleTravellerDragStart",
    value: function handleTravellerDragStart(id, e3) {
      var event = isTouch(e3) ? e3.changedTouches[0] : e3;
      this.setState({
        isSlideMoving: false,
        isTravellerMoving: true,
        movingTravellerId: id,
        brushMoveStartX: event.pageX
      });
      this.attachDragEndListener();
    }
  }, {
    key: "handleTravellerMove",
    value: function handleTravellerMove(e3) {
      var _this$setState;
      var _this$state2 = this.state, brushMoveStartX = _this$state2.brushMoveStartX, movingTravellerId = _this$state2.movingTravellerId, endX = _this$state2.endX, startX = _this$state2.startX;
      var prevValue = this.state[movingTravellerId];
      var _this$props4 = this.props, x2 = _this$props4.x, width = _this$props4.width, travellerWidth = _this$props4.travellerWidth, onChange = _this$props4.onChange, gap = _this$props4.gap, data = _this$props4.data;
      var params = {
        startX: this.state.startX,
        endX: this.state.endX
      };
      var delta = e3.pageX - brushMoveStartX;
      if (delta > 0) {
        delta = Math.min(delta, x2 + width - travellerWidth - prevValue);
      } else if (delta < 0) {
        delta = Math.max(delta, x2 - prevValue);
      }
      params[movingTravellerId] = prevValue + delta;
      var newIndex = this.getIndex(params);
      var startIndex = newIndex.startIndex, endIndex = newIndex.endIndex;
      var isFullGap = function isFullGap2() {
        var lastIndex = data.length - 1;
        if (movingTravellerId === "startX" && (endX > startX ? startIndex % gap === 0 : endIndex % gap === 0) || endX < startX && endIndex === lastIndex || movingTravellerId === "endX" && (endX > startX ? endIndex % gap === 0 : startIndex % gap === 0) || endX > startX && endIndex === lastIndex) {
          return true;
        }
        return false;
      };
      this.setState((_this$setState = {}, _defineProperty$b(_this$setState, movingTravellerId, prevValue + delta), _defineProperty$b(_this$setState, "brushMoveStartX", e3.pageX), _this$setState), function() {
        if (onChange) {
          if (isFullGap()) {
            onChange(newIndex);
          }
        }
      });
    }
  }, {
    key: "renderBackground",
    value: function renderBackground() {
      var _this$props5 = this.props, x2 = _this$props5.x, y2 = _this$props5.y, width = _this$props5.width, height = _this$props5.height, fill = _this$props5.fill, stroke = _this$props5.stroke;
      return /* @__PURE__ */ React.createElement("rect", {
        stroke,
        fill,
        x: x2,
        y: y2,
        width,
        height
      });
    }
  }, {
    key: "renderPanorama",
    value: function renderPanorama() {
      var _this$props6 = this.props, x2 = _this$props6.x, y2 = _this$props6.y, width = _this$props6.width, height = _this$props6.height, data = _this$props6.data, children = _this$props6.children, padding = _this$props6.padding;
      var chartElement = reactExports.Children.only(children);
      if (!chartElement) {
        return null;
      }
      return /* @__PURE__ */ React.cloneElement(chartElement, {
        x: x2,
        y: y2,
        width,
        height,
        margin: padding,
        compact: true,
        data
      });
    }
  }, {
    key: "renderTravellerLayer",
    value: function renderTravellerLayer(travellerX, id) {
      var _this$props7 = this.props, y2 = _this$props7.y, travellerWidth = _this$props7.travellerWidth, height = _this$props7.height, traveller = _this$props7.traveller;
      var x2 = Math.max(travellerX, this.props.x);
      var travellerProps = _objectSpread$b(_objectSpread$b({}, filterProps(this.props)), {}, {
        x: x2,
        y: y2,
        width: travellerWidth,
        height
      });
      return /* @__PURE__ */ React.createElement(Layer, {
        className: "recharts-brush-traveller",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.travellerDragStartHandlers[id],
        onTouchStart: this.travellerDragStartHandlers[id],
        style: {
          cursor: "col-resize"
        }
      }, Brush2.renderTraveller(traveller, travellerProps));
    }
  }, {
    key: "renderSlide",
    value: function renderSlide(startX, endX) {
      var _this$props8 = this.props, y2 = _this$props8.y, height = _this$props8.height, stroke = _this$props8.stroke, travellerWidth = _this$props8.travellerWidth;
      var x2 = Math.min(startX, endX) + travellerWidth;
      var width = Math.max(Math.abs(endX - startX) - travellerWidth, 0);
      return /* @__PURE__ */ React.createElement("rect", {
        className: "recharts-brush-slide",
        onMouseEnter: this.handleEnterSlideOrTraveller,
        onMouseLeave: this.handleLeaveSlideOrTraveller,
        onMouseDown: this.handleSlideDragStart,
        onTouchStart: this.handleSlideDragStart,
        style: {
          cursor: "move"
        },
        stroke: "none",
        fill: stroke,
        fillOpacity: 0.2,
        x: x2,
        y: y2,
        width,
        height
      });
    }
  }, {
    key: "renderText",
    value: function renderText() {
      var _this$props9 = this.props, startIndex = _this$props9.startIndex, endIndex = _this$props9.endIndex, y2 = _this$props9.y, height = _this$props9.height, travellerWidth = _this$props9.travellerWidth, stroke = _this$props9.stroke;
      var _this$state3 = this.state, startX = _this$state3.startX, endX = _this$state3.endX;
      var offset = 5;
      var attrs = {
        pointerEvents: "none",
        fill: stroke
      };
      return /* @__PURE__ */ React.createElement(Layer, {
        className: "recharts-brush-texts"
      }, /* @__PURE__ */ React.createElement(Text, _extends$a({
        textAnchor: "end",
        verticalAnchor: "middle",
        x: Math.min(startX, endX) - offset,
        y: y2 + height / 2
      }, attrs), this.getTextOfTick(startIndex)), /* @__PURE__ */ React.createElement(Text, _extends$a({
        textAnchor: "start",
        verticalAnchor: "middle",
        x: Math.max(startX, endX) + travellerWidth + offset,
        y: y2 + height / 2
      }, attrs), this.getTextOfTick(endIndex)));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props10 = this.props, data = _this$props10.data, className = _this$props10.className, children = _this$props10.children, x2 = _this$props10.x, y2 = _this$props10.y, width = _this$props10.width, height = _this$props10.height, alwaysShowText = _this$props10.alwaysShowText;
      var _this$state4 = this.state, startX = _this$state4.startX, endX = _this$state4.endX, isTextActive = _this$state4.isTextActive, isSlideMoving = _this$state4.isSlideMoving, isTravellerMoving = _this$state4.isTravellerMoving;
      if (!data || !data.length || !isNumber(x2) || !isNumber(y2) || !isNumber(width) || !isNumber(height) || width <= 0 || height <= 0) {
        return null;
      }
      var layerClass = classNames("recharts-brush", className);
      var isPanoramic = React.Children.count(children) === 1;
      var style = generatePrefixStyle("userSelect", "none");
      return /* @__PURE__ */ React.createElement(Layer, {
        className: layerClass,
        onMouseLeave: this.handleLeaveWrapper,
        onTouchMove: this.handleTouchMove,
        style
      }, this.renderBackground(), isPanoramic && this.renderPanorama(), this.renderSlide(startX, endX), this.renderTravellerLayer(startX, "startX"), this.renderTravellerLayer(endX, "endX"), (isTextActive || isSlideMoving || isTravellerMoving || alwaysShowText) && this.renderText());
    }
  }], [{
    key: "renderDefaultTraveller",
    value: function renderDefaultTraveller(props) {
      var x2 = props.x, y2 = props.y, width = props.width, height = props.height, stroke = props.stroke;
      var lineY = Math.floor(y2 + height / 2) - 1;
      return /* @__PURE__ */ React.createElement(React.Fragment, null, /* @__PURE__ */ React.createElement("rect", {
        x: x2,
        y: y2,
        width,
        height,
        fill: stroke,
        stroke: "none"
      }), /* @__PURE__ */ React.createElement("line", {
        x1: x2 + 1,
        y1: lineY,
        x2: x2 + width - 1,
        y2: lineY,
        fill: "none",
        stroke: "#fff"
      }), /* @__PURE__ */ React.createElement("line", {
        x1: x2 + 1,
        y1: lineY + 2,
        x2: x2 + width - 1,
        y2: lineY + 2,
        fill: "none",
        stroke: "#fff"
      }));
    }
  }, {
    key: "renderTraveller",
    value: function renderTraveller(option, props) {
      var rectangle;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        rectangle = /* @__PURE__ */ React.cloneElement(option, props);
      } else if (_isFunction(option)) {
        rectangle = option(props);
      } else {
        rectangle = Brush2.renderDefaultTraveller(props);
      }
      return rectangle;
    }
  }, {
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      var data = nextProps.data, width = nextProps.width, x2 = nextProps.x, travellerWidth = nextProps.travellerWidth, updateId = nextProps.updateId, startIndex = nextProps.startIndex, endIndex = nextProps.endIndex;
      if (data !== prevState.prevData || updateId !== prevState.prevUpdateId) {
        return _objectSpread$b({
          prevData: data,
          prevTravellerWidth: travellerWidth,
          prevUpdateId: updateId,
          prevX: x2,
          prevWidth: width
        }, data && data.length ? createScale({
          data,
          width,
          x: x2,
          travellerWidth,
          startIndex,
          endIndex
        }) : {
          scale: null,
          scaleValues: null
        });
      }
      if (prevState.scale && (width !== prevState.prevWidth || x2 !== prevState.prevX || travellerWidth !== prevState.prevTravellerWidth)) {
        prevState.scale.range([x2, x2 + width - travellerWidth]);
        var scaleValues = prevState.scale.domain().map(function(entry) {
          return prevState.scale(entry);
        });
        return {
          prevData: data,
          prevTravellerWidth: travellerWidth,
          prevUpdateId: updateId,
          prevX: x2,
          prevWidth: width,
          startX: prevState.scale(nextProps.startIndex),
          endX: prevState.scale(nextProps.endIndex),
          scaleValues
        };
      }
      return null;
    }
  }, {
    key: "getIndexInRange",
    value: function getIndexInRange(range3, x2) {
      var len = range3.length;
      var start = 0;
      var end = len - 1;
      while (end - start > 1) {
        var middle = Math.floor((start + end) / 2);
        if (range3[middle] > x2) {
          end = middle;
        } else {
          start = middle;
        }
      }
      return x2 >= range3[end] ? end : start;
    }
  }]);
  return Brush2;
}(reactExports.PureComponent);
_defineProperty$b(Brush, "displayName", "Brush");
_defineProperty$b(Brush, "defaultProps", {
  height: 40,
  travellerWidth: 5,
  gap: 1,
  fill: "#fff",
  stroke: "#666",
  padding: {
    top: 1,
    right: 1,
    bottom: 1,
    left: 1
  },
  leaveTimeOut: 1e3,
  alwaysShowText: false
});
var baseEach$1 = _baseEach;
function baseSome$1(collection, predicate) {
  var result;
  baseEach$1(collection, function(value, index, collection2) {
    result = predicate(value, index, collection2);
    return !result;
  });
  return !!result;
}
var _baseSome = baseSome$1;
var arraySome = _arraySome, baseIteratee$4 = _baseIteratee, baseSome = _baseSome, isArray$1 = isArray_1, isIterateeCall$1 = _isIterateeCall;
function some(collection, predicate, guard) {
  var func = isArray$1(collection) ? arraySome : baseSome;
  if (guard && isIterateeCall$1(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee$4(predicate));
}
var some_1 = some;
const _some = /* @__PURE__ */ getDefaultExportFromCjs(some_1);
var ifOverflowMatches = function ifOverflowMatches2(props, value) {
  var alwaysShow = props.alwaysShow;
  var ifOverflow = props.ifOverflow;
  if (alwaysShow) {
    ifOverflow = "extendDomain";
  }
  return ifOverflow === value;
};
function arrayEvery$1(array2, predicate) {
  var index = -1, length = array2 == null ? 0 : array2.length;
  while (++index < length) {
    if (!predicate(array2[index], index, array2)) {
      return false;
    }
  }
  return true;
}
var _arrayEvery = arrayEvery$1;
var baseEach = _baseEach;
function baseEvery$1(collection, predicate) {
  var result = true;
  baseEach(collection, function(value, index, collection2) {
    result = !!predicate(value, index, collection2);
    return result;
  });
  return result;
}
var _baseEvery = baseEvery$1;
var arrayEvery = _arrayEvery, baseEvery = _baseEvery, baseIteratee$3 = _baseIteratee, isArray = isArray_1, isIterateeCall = _isIterateeCall;
function every(collection, predicate, guard) {
  var func = isArray(collection) ? arrayEvery : baseEvery;
  if (guard && isIterateeCall(collection, predicate, guard)) {
    predicate = void 0;
  }
  return func(collection, baseIteratee$3(predicate));
}
var every_1 = every;
const _every = /* @__PURE__ */ getDefaultExportFromCjs(every_1);
var defineProperty = _defineProperty$p;
function baseAssignValue$1(object2, key, value) {
  if (key == "__proto__" && defineProperty) {
    defineProperty(object2, key, {
      "configurable": true,
      "enumerable": true,
      "value": value,
      "writable": true
    });
  } else {
    object2[key] = value;
  }
}
var _baseAssignValue = baseAssignValue$1;
var baseAssignValue = _baseAssignValue, baseForOwn = _baseForOwn, baseIteratee$2 = _baseIteratee;
function mapValues(object2, iteratee) {
  var result = {};
  iteratee = baseIteratee$2(iteratee);
  baseForOwn(object2, function(value, key, object3) {
    baseAssignValue(result, key, iteratee(value, key, object3));
  });
  return result;
}
var mapValues_1 = mapValues;
const _mapValues = /* @__PURE__ */ getDefaultExportFromCjs(mapValues_1);
var _excluded$7 = ["value", "background"];
function _typeof$a(obj) {
  "@babel/helpers - typeof";
  return _typeof$a = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$a(obj);
}
function _objectWithoutProperties$7(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$7(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$7(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _extends$9() {
  _extends$9 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$9.apply(this, arguments);
}
function ownKeys$a(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$a(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$a(Object(source), true).forEach(function(key) {
      _defineProperty$a(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$a(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$7(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$7(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$a(descriptor.key), descriptor);
  }
}
function _createClass$7(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$7(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$7(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$6(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$6(subClass, superClass);
}
function _setPrototypeOf$6(o, p2) {
  _setPrototypeOf$6 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$6(o, p2);
}
function _createSuper$6(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$6();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$6(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$6(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$6(this, result);
  };
}
function _possibleConstructorReturn$6(self2, call) {
  if (call && (_typeof$a(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$6(self2);
}
function _assertThisInitialized$6(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$6() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$6(o) {
  _getPrototypeOf$6 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$6(o);
}
function _defineProperty$a(obj, key, value) {
  key = _toPropertyKey$a(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$a(arg) {
  var key = _toPrimitive$a(arg, "string");
  return _typeof$a(key) === "symbol" ? key : String(key);
}
function _toPrimitive$a(input2, hint) {
  if (_typeof$a(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$a(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var Bar = /* @__PURE__ */ function(_PureComponent) {
  _inherits$6(Bar2, _PureComponent);
  var _super = _createSuper$6(Bar2);
  function Bar2() {
    var _this;
    _classCallCheck$7(this, Bar2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$a(_assertThisInitialized$6(_this), "state", {
      isAnimationFinished: false
    });
    _defineProperty$a(_assertThisInitialized$6(_this), "id", uniqueId("recharts-bar-"));
    _defineProperty$a(_assertThisInitialized$6(_this), "handleAnimationEnd", function() {
      var onAnimationEnd2 = _this.props.onAnimationEnd;
      _this.setState({
        isAnimationFinished: true
      });
      if (onAnimationEnd2) {
        onAnimationEnd2();
      }
    });
    _defineProperty$a(_assertThisInitialized$6(_this), "handleAnimationStart", function() {
      var onAnimationStart2 = _this.props.onAnimationStart;
      _this.setState({
        isAnimationFinished: false
      });
      if (onAnimationStart2) {
        onAnimationStart2();
      }
    });
    return _this;
  }
  _createClass$7(Bar2, [{
    key: "renderRectanglesStatically",
    value: function renderRectanglesStatically(data) {
      var _this2 = this;
      var shape = this.props.shape;
      var baseProps = filterProps(this.props);
      return data && data.map(function(entry, i) {
        var props = _objectSpread$a(_objectSpread$a(_objectSpread$a({}, baseProps), entry), {}, {
          index: i
        });
        return /* @__PURE__ */ React.createElement(Layer, _extends$9({
          className: "recharts-bar-rectangle"
        }, adaptEventsOfChild(_this2.props, entry, i), {
          key: "rectangle-".concat(i),
          role: "img"
        }), Bar2.renderRectangle(shape, props));
      });
    }
  }, {
    key: "renderRectanglesWithAnimation",
    value: function renderRectanglesWithAnimation() {
      var _this3 = this;
      var _this$props = this.props, data = _this$props.data, layout = _this$props.layout, isAnimationActive = _this$props.isAnimationActive, animationBegin = _this$props.animationBegin, animationDuration = _this$props.animationDuration, animationEasing = _this$props.animationEasing, animationId = _this$props.animationId;
      var prevData = this.state.prevData;
      return /* @__PURE__ */ React.createElement(Animate, {
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "bar-".concat(animationId),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(_ref) {
        var t2 = _ref.t;
        var stepData = data.map(function(entry, index) {
          var prev = prevData && prevData[index];
          if (prev) {
            var interpolatorX = interpolateNumber$2(prev.x, entry.x);
            var interpolatorY = interpolateNumber$2(prev.y, entry.y);
            var interpolatorWidth = interpolateNumber$2(prev.width, entry.width);
            var interpolatorHeight = interpolateNumber$2(prev.height, entry.height);
            return _objectSpread$a(_objectSpread$a({}, entry), {}, {
              x: interpolatorX(t2),
              y: interpolatorY(t2),
              width: interpolatorWidth(t2),
              height: interpolatorHeight(t2)
            });
          }
          if (layout === "horizontal") {
            var _interpolatorHeight = interpolateNumber$2(0, entry.height);
            var h2 = _interpolatorHeight(t2);
            return _objectSpread$a(_objectSpread$a({}, entry), {}, {
              y: entry.y + entry.height - h2,
              height: h2
            });
          }
          var interpolator = interpolateNumber$2(0, entry.width);
          var w2 = interpolator(t2);
          return _objectSpread$a(_objectSpread$a({}, entry), {}, {
            width: w2
          });
        });
        return /* @__PURE__ */ React.createElement(Layer, null, _this3.renderRectanglesStatically(stepData));
      });
    }
  }, {
    key: "renderRectangles",
    value: function renderRectangles() {
      var _this$props2 = this.props, data = _this$props2.data, isAnimationActive = _this$props2.isAnimationActive;
      var prevData = this.state.prevData;
      if (isAnimationActive && data && data.length && (!prevData || !_isEqual(prevData, data))) {
        return this.renderRectanglesWithAnimation();
      }
      return this.renderRectanglesStatically(data);
    }
  }, {
    key: "renderBackground",
    value: function renderBackground() {
      var _this4 = this;
      var data = this.props.data;
      var backgroundProps = filterProps(this.props.background);
      return data.map(function(entry, i) {
        entry.value;
        var background = entry.background, rest = _objectWithoutProperties$7(entry, _excluded$7);
        if (!background) {
          return null;
        }
        var props = _objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a(_objectSpread$a({}, rest), {}, {
          fill: "#eee"
        }, background), backgroundProps), adaptEventsOfChild(_this4.props, entry, i)), {}, {
          index: i,
          key: "background-bar-".concat(i),
          className: "recharts-bar-background-rectangle"
        });
        return Bar2.renderRectangle(_this4.props.background, props);
      });
    }
  }, {
    key: "renderErrorBar",
    value: function renderErrorBar(needClip, clipPathId) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished) {
        return null;
      }
      var _this$props3 = this.props, data = _this$props3.data, xAxis = _this$props3.xAxis, yAxis = _this$props3.yAxis, layout = _this$props3.layout, children = _this$props3.children;
      var errorBarItems = findAllByType(children, ErrorBar);
      if (!errorBarItems) {
        return null;
      }
      var offset = layout === "vertical" ? data[0].height / 2 : data[0].width / 2;
      function dataPointFormatter(dataPoint, dataKey) {
        return {
          x: dataPoint.x,
          y: dataPoint.y,
          value: dataPoint.value,
          errorVal: getValueByDataKey(dataPoint, dataKey)
        };
      }
      var errorBarProps = {
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      };
      return /* @__PURE__ */ React.createElement(Layer, errorBarProps, errorBarItems.map(function(item, i) {
        return /* @__PURE__ */ React.cloneElement(item, {
          key: "error-bar-".concat(i),
          // eslint-disable-line react/no-array-index-key
          data,
          xAxis,
          yAxis,
          layout,
          offset,
          dataPointFormatter
        });
      }));
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props4 = this.props, hide = _this$props4.hide, data = _this$props4.data, className = _this$props4.className, xAxis = _this$props4.xAxis, yAxis = _this$props4.yAxis, left = _this$props4.left, top = _this$props4.top, width = _this$props4.width, height = _this$props4.height, isAnimationActive = _this$props4.isAnimationActive, background = _this$props4.background, id = _this$props4.id;
      if (hide || !data || !data.length) {
        return null;
      }
      var isAnimationFinished = this.state.isAnimationFinished;
      var layerClass = classNames("recharts-bar", className);
      var needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow;
      var clipPathId = _isNil(id) ? this.id : id;
      return /* @__PURE__ */ React.createElement(Layer, {
        className: layerClass
      }, needClip ? /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
        id: "clipPath-".concat(clipPathId)
      }, /* @__PURE__ */ React.createElement("rect", {
        x: left,
        y: top,
        width,
        height
      }))) : null, /* @__PURE__ */ React.createElement(Layer, {
        className: "recharts-bar-rectangles",
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      }, background ? this.renderBackground() : null, this.renderRectangles()), this.renderErrorBar(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, data));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.animationId !== prevState.prevAnimationId) {
        return {
          prevAnimationId: nextProps.animationId,
          curData: nextProps.data,
          prevData: prevState.curData
        };
      }
      if (nextProps.data !== prevState.curData) {
        return {
          curData: nextProps.data
        };
      }
      return null;
    }
  }, {
    key: "renderRectangle",
    value: function renderRectangle(option, props) {
      var rectangle;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        rectangle = /* @__PURE__ */ React.cloneElement(option, props);
      } else if (_isFunction(option)) {
        rectangle = option(props);
      } else {
        rectangle = /* @__PURE__ */ React.createElement(Rectangle, props);
      }
      return rectangle;
    }
  }]);
  return Bar2;
}(reactExports.PureComponent);
_defineProperty$a(Bar, "displayName", "Bar");
_defineProperty$a(Bar, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  legendType: "rect",
  minPointSize: 0,
  hide: false,
  // data of bar
  data: [],
  layout: "vertical",
  isAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "ease"
});
_defineProperty$a(Bar, "getComposedData", function(_ref2) {
  var props = _ref2.props, item = _ref2.item, barPosition = _ref2.barPosition, bandSize = _ref2.bandSize, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset = _ref2.offset;
  var pos = findPositionOfBar(barPosition, item);
  if (!pos) {
    return null;
  }
  var layout = props.layout;
  var _item$props = item.props, dataKey = _item$props.dataKey, children = _item$props.children, minPointSize = _item$props.minPointSize;
  var numericAxis = layout === "horizontal" ? yAxis : xAxis;
  var stackedDomain = stackedData ? numericAxis.scale.domain() : null;
  var baseValue = getBaseValueOfBar({
    numericAxis
  });
  var cells = findAllByType(children, Cell);
  var rects = displayedData.map(function(entry, index) {
    var value, x2, y2, width, height, background;
    if (stackedData) {
      value = truncateByDomain(stackedData[dataStartIndex + index], stackedDomain);
    } else {
      value = getValueByDataKey(entry, dataKey);
      if (!_isArray(value)) {
        value = [baseValue, value];
      }
    }
    if (layout === "horizontal") {
      var _ref4;
      var _ref3 = [yAxis.scale(value[0]), yAxis.scale(value[1])], baseValueScale = _ref3[0], currentValueScale = _ref3[1];
      x2 = getCateCoordinateOfBar({
        axis: xAxis,
        ticks: xAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index
      });
      y2 = (_ref4 = currentValueScale !== null && currentValueScale !== void 0 ? currentValueScale : baseValueScale) !== null && _ref4 !== void 0 ? _ref4 : void 0;
      width = pos.size;
      var computedHeight = baseValueScale - currentValueScale;
      height = Number.isNaN(computedHeight) ? 0 : computedHeight;
      background = {
        x: x2,
        y: yAxis.y,
        width,
        height: yAxis.height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(height) < Math.abs(minPointSize)) {
        var delta = mathSign(height || minPointSize) * (Math.abs(minPointSize) - Math.abs(height));
        y2 -= delta;
        height += delta;
      }
    } else {
      var _ref5 = [xAxis.scale(value[0]), xAxis.scale(value[1])], _baseValueScale = _ref5[0], _currentValueScale = _ref5[1];
      x2 = _baseValueScale;
      y2 = getCateCoordinateOfBar({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        offset: pos.offset,
        entry,
        index
      });
      width = _currentValueScale - _baseValueScale;
      height = pos.size;
      background = {
        x: xAxis.x,
        y: y2,
        width: xAxis.width,
        height
      };
      if (Math.abs(minPointSize) > 0 && Math.abs(width) < Math.abs(minPointSize)) {
        var _delta = mathSign(width || minPointSize) * (Math.abs(minPointSize) - Math.abs(width));
        width += _delta;
      }
    }
    return _objectSpread$a(_objectSpread$a(_objectSpread$a({}, entry), {}, {
      x: x2,
      y: y2,
      width,
      height,
      value: stackedData ? value : value[1],
      payload: entry,
      background
    }, cells && cells[index] && cells[index].props), {}, {
      tooltipPayload: [getTooltipItem(item, entry)],
      tooltipPosition: {
        x: x2 + width / 2,
        y: y2 + height / 2
      }
    });
  });
  return _objectSpread$a({
    data: rects,
    layout
  }, offset);
});
function _typeof$9(obj) {
  "@babel/helpers - typeof";
  return _typeof$9 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$9(obj);
}
function _classCallCheck$6(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$6(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$9(descriptor.key), descriptor);
  }
}
function _createClass$6(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$6(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$6(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function ownKeys$9(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$9(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$9(Object(source), true).forEach(function(key) {
      _defineProperty$9(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$9(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$9(obj, key, value) {
  key = _toPropertyKey$9(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$9(arg) {
  var key = _toPrimitive$9(arg, "string");
  return _typeof$9(key) === "symbol" ? key : String(key);
}
function _toPrimitive$9(input2, hint) {
  if (_typeof$9(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$9(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var formatAxisMap = function formatAxisMap2(props, axisMap, offset, axisType, chartName) {
  var width = props.width, height = props.height, layout = props.layout, children = props.children;
  var ids = Object.keys(axisMap);
  var steps = {
    left: offset.left,
    leftMirror: offset.left,
    right: width - offset.right,
    rightMirror: width - offset.right,
    top: offset.top,
    topMirror: offset.top,
    bottom: height - offset.bottom,
    bottomMirror: height - offset.bottom
  };
  var hasBar = !!findChildByType(children, Bar);
  return ids.reduce(function(result, id) {
    var axis = axisMap[id];
    var orientation = axis.orientation, domain = axis.domain, _axis$padding = axis.padding, padding = _axis$padding === void 0 ? {} : _axis$padding, mirror = axis.mirror, reversed = axis.reversed;
    var offsetKey = "".concat(orientation).concat(mirror ? "Mirror" : "");
    var calculatedPadding, range3, x2, y2, needSpace;
    if (axis.type === "number" && (axis.padding === "gap" || axis.padding === "no-gap")) {
      var diff = domain[1] - domain[0];
      var smallestDistanceBetweenValues = Infinity;
      var sortedValues = axis.categoricalDomain.sort();
      sortedValues.forEach(function(value, index) {
        if (index > 0) {
          smallestDistanceBetweenValues = Math.min((value || 0) - (sortedValues[index - 1] || 0), smallestDistanceBetweenValues);
        }
      });
      var smallestDistanceInPercent = smallestDistanceBetweenValues / diff;
      var rangeWidth = axis.layout === "vertical" ? offset.height : offset.width;
      if (axis.padding === "gap") {
        calculatedPadding = smallestDistanceInPercent * rangeWidth / 2;
      }
      if (axis.padding === "no-gap") {
        var gap = getPercentValue(props.barCategoryGap, smallestDistanceInPercent * rangeWidth);
        var halfBand = smallestDistanceInPercent * rangeWidth / 2;
        calculatedPadding = halfBand - gap - (halfBand - gap) / rangeWidth * gap;
      }
    }
    if (axisType === "xAxis") {
      range3 = [offset.left + (padding.left || 0) + (calculatedPadding || 0), offset.left + offset.width - (padding.right || 0) - (calculatedPadding || 0)];
    } else if (axisType === "yAxis") {
      range3 = layout === "horizontal" ? [offset.top + offset.height - (padding.bottom || 0), offset.top + (padding.top || 0)] : [offset.top + (padding.top || 0) + (calculatedPadding || 0), offset.top + offset.height - (padding.bottom || 0) - (calculatedPadding || 0)];
    } else {
      range3 = axis.range;
    }
    if (reversed) {
      range3 = [range3[1], range3[0]];
    }
    var _parseScale = parseScale(axis, chartName, hasBar), scale2 = _parseScale.scale, realScaleType = _parseScale.realScaleType;
    scale2.domain(domain).range(range3);
    checkDomainOfScale(scale2);
    var ticks2 = getTicksOfScale(scale2, _objectSpread$9(_objectSpread$9({}, axis), {}, {
      realScaleType
    }));
    if (axisType === "xAxis") {
      needSpace = orientation === "top" && !mirror || orientation === "bottom" && mirror;
      x2 = offset.left;
      y2 = steps[offsetKey] - needSpace * axis.height;
    } else if (axisType === "yAxis") {
      needSpace = orientation === "left" && !mirror || orientation === "right" && mirror;
      x2 = steps[offsetKey] - needSpace * axis.width;
      y2 = offset.top;
    }
    var finalAxis = _objectSpread$9(_objectSpread$9(_objectSpread$9({}, axis), ticks2), {}, {
      realScaleType,
      x: x2,
      y: y2,
      scale: scale2,
      width: axisType === "xAxis" ? offset.width : axis.width,
      height: axisType === "yAxis" ? offset.height : axis.height
    });
    finalAxis.bandSize = getBandSizeOfAxis(finalAxis, ticks2);
    if (!axis.hide && axisType === "xAxis") {
      steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.height;
    } else if (!axis.hide) {
      steps[offsetKey] += (needSpace ? -1 : 1) * finalAxis.width;
    }
    return _objectSpread$9(_objectSpread$9({}, result), {}, _defineProperty$9({}, id, finalAxis));
  }, {});
};
var rectWithPoints = function rectWithPoints2(_ref, _ref2) {
  var x1 = _ref.x, y1 = _ref.y;
  var x2 = _ref2.x, y2 = _ref2.y;
  return {
    x: Math.min(x1, x2),
    y: Math.min(y1, y2),
    width: Math.abs(x2 - x1),
    height: Math.abs(y2 - y1)
  };
};
var rectWithCoords = function rectWithCoords2(_ref3) {
  var x1 = _ref3.x1, y1 = _ref3.y1, x2 = _ref3.x2, y2 = _ref3.y2;
  return rectWithPoints({
    x: x1,
    y: y1
  }, {
    x: x2,
    y: y2
  });
};
var ScaleHelper = /* @__PURE__ */ function() {
  function ScaleHelper2(scale2) {
    _classCallCheck$6(this, ScaleHelper2);
    this.scale = scale2;
  }
  _createClass$6(ScaleHelper2, [{
    key: "domain",
    get: function get3() {
      return this.scale.domain;
    }
  }, {
    key: "range",
    get: function get3() {
      return this.scale.range;
    }
  }, {
    key: "rangeMin",
    get: function get3() {
      return this.range()[0];
    }
  }, {
    key: "rangeMax",
    get: function get3() {
      return this.range()[1];
    }
  }, {
    key: "bandwidth",
    get: function get3() {
      return this.scale.bandwidth;
    }
  }, {
    key: "apply",
    value: function apply2(value) {
      var _ref4 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref4.bandAware, position = _ref4.position;
      if (value === void 0) {
        return void 0;
      }
      if (position) {
        switch (position) {
          case "start": {
            return this.scale(value);
          }
          case "middle": {
            var offset = this.bandwidth ? this.bandwidth() / 2 : 0;
            return this.scale(value) + offset;
          }
          case "end": {
            var _offset = this.bandwidth ? this.bandwidth() : 0;
            return this.scale(value) + _offset;
          }
          default: {
            return this.scale(value);
          }
        }
      }
      if (bandAware) {
        var _offset2 = this.bandwidth ? this.bandwidth() / 2 : 0;
        return this.scale(value) + _offset2;
      }
      return this.scale(value);
    }
  }, {
    key: "isInRange",
    value: function isInRange(value) {
      var range3 = this.range();
      var first = range3[0];
      var last2 = range3[range3.length - 1];
      return first <= last2 ? value >= first && value <= last2 : value >= last2 && value <= first;
    }
  }], [{
    key: "create",
    value: function create(obj) {
      return new ScaleHelper2(obj);
    }
  }]);
  return ScaleHelper2;
}();
_defineProperty$9(ScaleHelper, "EPS", 1e-4);
var createLabeledScales = function createLabeledScales2(options) {
  var scales = Object.keys(options).reduce(function(res, key) {
    return _objectSpread$9(_objectSpread$9({}, res), {}, _defineProperty$9({}, key, ScaleHelper.create(options[key])));
  }, {});
  return _objectSpread$9(_objectSpread$9({}, scales), {}, {
    apply: function apply2(coord) {
      var _ref5 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, bandAware = _ref5.bandAware, position = _ref5.position;
      return _mapValues(coord, function(value, label) {
        return scales[label].apply(value, {
          bandAware,
          position
        });
      });
    },
    isInRange: function isInRange(coord) {
      return _every(coord, function(value, label) {
        return scales[label].isInRange(value);
      });
    }
  });
};
function _typeof$8(obj) {
  "@babel/helpers - typeof";
  return _typeof$8 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$8(obj);
}
var _excluded$6 = ["isFront", "ifOverflow", "xAxisId", "yAxisId", "position", "fill", "fillOpacity", "stroke", "strokeWidth"];
function _slicedToArray$1(arr, i) {
  return _arrayWithHoles$1(arr) || _iterableToArrayLimit$1(arr, i) || _unsupportedIterableToArray$3(arr, i) || _nonIterableRest$1();
}
function _nonIterableRest$1() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$3(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$3(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$3(o, minLen);
}
function _arrayLikeToArray$3(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _iterableToArrayLimit$1(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles$1(arr) {
  if (Array.isArray(arr))
    return arr;
}
function ownKeys$8(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$8(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$8(Object(source), true).forEach(function(key) {
      _defineProperty$8(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$8(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$8(obj, key, value) {
  key = _toPropertyKey$8(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$8(arg) {
  var key = _toPrimitive$8(arg, "string");
  return _typeof$8(key) === "symbol" ? key : String(key);
}
function _toPrimitive$8(input2, hint) {
  if (_typeof$8(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$8(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function _objectWithoutProperties$6(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$6(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$6(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _extends$8() {
  _extends$8 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$8.apply(this, arguments);
}
var renderLine = function renderLine2(option, props) {
  var line;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    line = /* @__PURE__ */ React.cloneElement(option, props);
  } else if (_isFunction(option)) {
    line = option(props);
  } else {
    line = /* @__PURE__ */ React.createElement("line", _extends$8({}, props, {
      className: "recharts-reference-line-line"
    }));
  }
  return line;
};
var getEndPoints = function getEndPoints2(scales, isFixedX, isFixedY, isSegment, props) {
  var _props$viewBox = props.viewBox, x2 = _props$viewBox.x, y2 = _props$viewBox.y, width = _props$viewBox.width, height = _props$viewBox.height, position = props.position;
  if (isFixedY) {
    var yCoord = props.y, orientation = props.yAxis.orientation;
    var coord = scales.y.apply(yCoord, {
      position
    });
    if (ifOverflowMatches(props, "discard") && !scales.y.isInRange(coord)) {
      return null;
    }
    var points = [{
      x: x2 + width,
      y: coord
    }, {
      x: x2,
      y: coord
    }];
    return orientation === "left" ? points.reverse() : points;
  }
  if (isFixedX) {
    var xCoord = props.x, _orientation = props.xAxis.orientation;
    var _coord = scales.x.apply(xCoord, {
      position
    });
    if (ifOverflowMatches(props, "discard") && !scales.x.isInRange(_coord)) {
      return null;
    }
    var _points = [{
      x: _coord,
      y: y2 + height
    }, {
      x: _coord,
      y: y2
    }];
    return _orientation === "top" ? _points.reverse() : _points;
  }
  if (isSegment) {
    var segment = props.segment;
    var _points2 = segment.map(function(p2) {
      return scales.apply(p2, {
        position
      });
    });
    if (ifOverflowMatches(props, "discard") && _some(_points2, function(p2) {
      return !scales.isInRange(p2);
    })) {
      return null;
    }
    return _points2;
  }
  return null;
};
function ReferenceLine(_ref) {
  var _ref$isFront = _ref.isFront, isFront = _ref$isFront === void 0 ? false : _ref$isFront, _ref$ifOverflow = _ref.ifOverflow, ifOverflow = _ref$ifOverflow === void 0 ? "discard" : _ref$ifOverflow, _ref$xAxisId = _ref.xAxisId, xAxisId = _ref$xAxisId === void 0 ? 0 : _ref$xAxisId, _ref$yAxisId = _ref.yAxisId, yAxisId = _ref$yAxisId === void 0 ? 0 : _ref$yAxisId, _ref$position = _ref.position, position = _ref$position === void 0 ? "middle" : _ref$position, _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "none" : _ref$fill, _ref$fillOpacity = _ref.fillOpacity, fillOpacity = _ref$fillOpacity === void 0 ? 1 : _ref$fillOpacity, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? "#ccc" : _ref$stroke, _ref$strokeWidth = _ref.strokeWidth, strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth, restProps = _objectWithoutProperties$6(_ref, _excluded$6);
  var props = _objectSpread$8({
    isFront,
    ifOverflow,
    xAxisId,
    yAxisId,
    fill,
    stroke,
    fillOpacity,
    strokeWidth,
    position
  }, restProps);
  var fixedX = props.x, fixedY = props.y, segment = props.segment, xAxis = props.xAxis, yAxis = props.yAxis, shape = props.shape, className = props.className, alwaysShow = props.alwaysShow, clipPathId = props.clipPathId;
  warn(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  var scales = createLabeledScales({
    x: xAxis.scale,
    y: yAxis.scale
  });
  var isX = isNumOrStr(fixedX);
  var isY = isNumOrStr(fixedY);
  var isSegment = segment && segment.length === 2;
  var endPoints = getEndPoints(scales, isX, isY, isSegment, props);
  if (!endPoints) {
    return null;
  }
  var _endPoints = _slicedToArray$1(endPoints, 2), _endPoints$ = _endPoints[0], x1 = _endPoints$.x, y1 = _endPoints$.y, _endPoints$2 = _endPoints[1], x2 = _endPoints$2.x, y2 = _endPoints$2.y;
  var clipPath = ifOverflowMatches(props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
  var lineProps = _objectSpread$8(_objectSpread$8({
    clipPath
  }, filterProps(props, true)), {}, {
    x1,
    y1,
    x2,
    y2
  });
  return /* @__PURE__ */ React.createElement(Layer, {
    className: classNames("recharts-reference-line", className)
  }, renderLine(shape, lineProps), Label.renderCallByParent(props, rectWithCoords({
    x1,
    y1,
    x2,
    y2
  })));
}
ReferenceLine.displayName = "ReferenceLine";
function _typeof$7(obj) {
  "@babel/helpers - typeof";
  return _typeof$7 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$7(obj);
}
function _extends$7() {
  _extends$7 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$7.apply(this, arguments);
}
function ownKeys$7(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$7(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$7(Object(source), true).forEach(function(key) {
      _defineProperty$7(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$7(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$7(obj, key, value) {
  key = _toPropertyKey$7(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$7(arg) {
  var key = _toPrimitive$7(arg, "string");
  return _typeof$7(key) === "symbol" ? key : String(key);
}
function _toPrimitive$7(input2, hint) {
  if (_typeof$7(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$7(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var getCoordinate = function getCoordinate2(props) {
  var x2 = props.x, y2 = props.y, xAxis = props.xAxis, yAxis = props.yAxis;
  var scales = createLabeledScales({
    x: xAxis.scale,
    y: yAxis.scale
  });
  var result = scales.apply({
    x: x2,
    y: y2
  }, {
    bandAware: true
  });
  if (ifOverflowMatches(props, "discard") && !scales.isInRange(result)) {
    return null;
  }
  return result;
};
function ReferenceDot(props) {
  var x2 = props.x, y2 = props.y, r2 = props.r, alwaysShow = props.alwaysShow, clipPathId = props.clipPathId;
  var isX = isNumOrStr(x2);
  var isY = isNumOrStr(y2);
  warn(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  if (!isX || !isY) {
    return null;
  }
  var coordinate = getCoordinate(props);
  if (!coordinate) {
    return null;
  }
  var cx = coordinate.x, cy = coordinate.y;
  var shape = props.shape, className = props.className;
  var clipPath = ifOverflowMatches(props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
  var dotProps = _objectSpread$7(_objectSpread$7({
    clipPath
  }, filterProps(props, true)), {}, {
    cx,
    cy
  });
  return /* @__PURE__ */ React.createElement(Layer, {
    className: classNames("recharts-reference-dot", className)
  }, ReferenceDot.renderDot(shape, dotProps), Label.renderCallByParent(props, {
    x: cx - r2,
    y: cy - r2,
    width: 2 * r2,
    height: 2 * r2
  }));
}
ReferenceDot.displayName = "ReferenceDot";
ReferenceDot.defaultProps = {
  isFront: false,
  ifOverflow: "discard",
  xAxisId: 0,
  yAxisId: 0,
  r: 10,
  fill: "#fff",
  stroke: "#ccc",
  fillOpacity: 1,
  strokeWidth: 1
};
ReferenceDot.renderDot = function(option, props) {
  var dot;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    dot = /* @__PURE__ */ React.cloneElement(option, props);
  } else if (_isFunction(option)) {
    dot = option(props);
  } else {
    dot = /* @__PURE__ */ React.createElement(Dot, _extends$7({}, props, {
      cx: props.cx,
      cy: props.cy,
      className: "recharts-reference-dot-dot"
    }));
  }
  return dot;
};
function _typeof$6(obj) {
  "@babel/helpers - typeof";
  return _typeof$6 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$6(obj);
}
var _excluded$5 = ["isFront", "ifOverflow", "xAxisId", "yAxisId", "r", "fill", "fillOpacity", "stroke", "strokeWidth"];
function _extends$6() {
  _extends$6 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$6.apply(this, arguments);
}
function ownKeys$6(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$6(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$6(Object(source), true).forEach(function(key) {
      _defineProperty$6(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$6(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty$6(obj, key, value) {
  key = _toPropertyKey$6(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$6(arg) {
  var key = _toPrimitive$6(arg, "string");
  return _typeof$6(key) === "symbol" ? key : String(key);
}
function _toPrimitive$6(input2, hint) {
  if (_typeof$6(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$6(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
function _objectWithoutProperties$5(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$5(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$5(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
var getRect = function getRect2(hasX1, hasX2, hasY1, hasY2, props) {
  var xValue1 = props.x1, xValue2 = props.x2, yValue1 = props.y1, yValue2 = props.y2, xAxis = props.xAxis, yAxis = props.yAxis;
  if (!xAxis || !yAxis)
    return null;
  var scales = createLabeledScales({
    x: xAxis.scale,
    y: yAxis.scale
  });
  var p1 = {
    x: hasX1 ? scales.x.apply(xValue1, {
      position: "start"
    }) : scales.x.rangeMin,
    y: hasY1 ? scales.y.apply(yValue1, {
      position: "start"
    }) : scales.y.rangeMin
  };
  var p2 = {
    x: hasX2 ? scales.x.apply(xValue2, {
      position: "end"
    }) : scales.x.rangeMax,
    y: hasY2 ? scales.y.apply(yValue2, {
      position: "end"
    }) : scales.y.rangeMax
  };
  if (ifOverflowMatches(props, "discard") && (!scales.isInRange(p1) || !scales.isInRange(p2))) {
    return null;
  }
  return rectWithPoints(p1, p2);
};
function ReferenceArea(_ref) {
  var _ref$isFront = _ref.isFront, isFront = _ref$isFront === void 0 ? false : _ref$isFront, _ref$ifOverflow = _ref.ifOverflow, ifOverflow = _ref$ifOverflow === void 0 ? "discard" : _ref$ifOverflow, _ref$xAxisId = _ref.xAxisId, xAxisId = _ref$xAxisId === void 0 ? 0 : _ref$xAxisId, _ref$yAxisId = _ref.yAxisId, yAxisId = _ref$yAxisId === void 0 ? 0 : _ref$yAxisId, _ref$r = _ref.r, r2 = _ref$r === void 0 ? 10 : _ref$r, _ref$fill = _ref.fill, fill = _ref$fill === void 0 ? "#ccc" : _ref$fill, _ref$fillOpacity = _ref.fillOpacity, fillOpacity = _ref$fillOpacity === void 0 ? 0.5 : _ref$fillOpacity, _ref$stroke = _ref.stroke, stroke = _ref$stroke === void 0 ? "none" : _ref$stroke, _ref$strokeWidth = _ref.strokeWidth, strokeWidth = _ref$strokeWidth === void 0 ? 1 : _ref$strokeWidth, restProps = _objectWithoutProperties$5(_ref, _excluded$5);
  var props = _objectSpread$6({
    isFront,
    ifOverflow,
    xAxisId,
    yAxisId,
    r: r2,
    fill,
    fillOpacity,
    stroke,
    strokeWidth
  }, restProps);
  var x1 = props.x1, x2 = props.x2, y1 = props.y1, y2 = props.y2, className = props.className, alwaysShow = props.alwaysShow, clipPathId = props.clipPathId;
  warn(alwaysShow === void 0, 'The alwaysShow prop is deprecated. Please use ifOverflow="extendDomain" instead.');
  var hasX1 = isNumOrStr(x1);
  var hasX2 = isNumOrStr(x2);
  var hasY1 = isNumOrStr(y1);
  var hasY2 = isNumOrStr(y2);
  var shape = props.shape;
  if (!hasX1 && !hasX2 && !hasY1 && !hasY2 && !shape) {
    return null;
  }
  var rect = getRect(hasX1, hasX2, hasY1, hasY2, props);
  if (!rect && !shape) {
    return null;
  }
  var clipPath = ifOverflowMatches(props, "hidden") ? "url(#".concat(clipPathId, ")") : void 0;
  return /* @__PURE__ */ React.createElement(Layer, {
    className: classNames("recharts-reference-area", className)
  }, ReferenceArea.renderRect(shape, _objectSpread$6(_objectSpread$6({
    clipPath
  }, filterProps(props, true)), rect)), Label.renderCallByParent(props, rect));
}
ReferenceArea.displayName = "ReferenceArea";
ReferenceArea.renderRect = function(option, props) {
  var rect;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    rect = /* @__PURE__ */ React.cloneElement(option, props);
  } else if (_isFunction(option)) {
    rect = option(props);
  } else {
    rect = /* @__PURE__ */ React.createElement(Rectangle, _extends$6({}, props, {
      className: "recharts-reference-area-rect"
    }));
  }
  return rect;
};
var _excluded$4 = ["viewBox"], _excluded2$1 = ["viewBox"], _excluded3 = ["ticks"];
function _typeof$5(obj) {
  "@babel/helpers - typeof";
  return _typeof$5 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$5(obj);
}
function _extends$5() {
  _extends$5 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$5.apply(this, arguments);
}
function ownKeys$5(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$5(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$5(Object(source), true).forEach(function(key) {
      _defineProperty$5(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$5(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _objectWithoutProperties$4(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$4(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$4(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck$5(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$5(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$5(descriptor.key), descriptor);
  }
}
function _createClass$5(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$5(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$5(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$5(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$5(subClass, superClass);
}
function _setPrototypeOf$5(o, p2) {
  _setPrototypeOf$5 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$5(o, p2);
}
function _createSuper$5(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$5();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$5(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$5(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$5(this, result);
  };
}
function _possibleConstructorReturn$5(self2, call) {
  if (call && (_typeof$5(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$5(self2);
}
function _assertThisInitialized$5(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$5() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$5(o) {
  _getPrototypeOf$5 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$5(o);
}
function _defineProperty$5(obj, key, value) {
  key = _toPropertyKey$5(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$5(arg) {
  var key = _toPrimitive$5(arg, "string");
  return _typeof$5(key) === "symbol" ? key : String(key);
}
function _toPrimitive$5(input2, hint) {
  if (_typeof$5(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$5(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var CartesianAxis = /* @__PURE__ */ function(_Component) {
  _inherits$5(CartesianAxis2, _Component);
  var _super = _createSuper$5(CartesianAxis2);
  function CartesianAxis2(props) {
    var _this;
    _classCallCheck$5(this, CartesianAxis2);
    _this = _super.call(this, props);
    _this.state = {
      fontSize: "",
      letterSpacing: ""
    };
    return _this;
  }
  _createClass$5(CartesianAxis2, [{
    key: "shouldComponentUpdate",
    value: function shouldComponentUpdate(_ref, nextState) {
      var viewBox = _ref.viewBox, restProps = _objectWithoutProperties$4(_ref, _excluded$4);
      var _this$props = this.props, viewBoxOld = _this$props.viewBox, restPropsOld = _objectWithoutProperties$4(_this$props, _excluded2$1);
      return !shallowEqual(viewBox, viewBoxOld) || !shallowEqual(restProps, restPropsOld) || !shallowEqual(nextState, this.state);
    }
  }, {
    key: "componentDidMount",
    value: function componentDidMount() {
      var htmlLayer = this.layerReference;
      if (!htmlLayer)
        return;
      var tick = htmlLayer.getElementsByClassName("recharts-cartesian-axis-tick-value")[0];
      if (tick) {
        this.setState({
          fontSize: window.getComputedStyle(tick).fontSize,
          letterSpacing: window.getComputedStyle(tick).letterSpacing
        });
      }
    }
    /**
     * Calculate the coordinates of endpoints in ticks
     * @param  {Object} data The data of a simple tick
     * @return {Object} (x1, y1): The coordinate of endpoint close to tick text
     *  (x2, y2): The coordinate of endpoint close to axis
     */
  }, {
    key: "getTickLineCoord",
    value: function getTickLineCoord(data) {
      var _this$props2 = this.props, x2 = _this$props2.x, y2 = _this$props2.y, width = _this$props2.width, height = _this$props2.height, orientation = _this$props2.orientation, tickSize = _this$props2.tickSize, mirror = _this$props2.mirror, tickMargin = _this$props2.tickMargin;
      var x1, x22, y1, y22, tx, ty;
      var sign2 = mirror ? -1 : 1;
      var finalTickSize = data.tickSize || tickSize;
      var tickCoord = isNumber(data.tickCoord) ? data.tickCoord : data.coordinate;
      switch (orientation) {
        case "top":
          x1 = x22 = data.coordinate;
          y22 = y2 + +!mirror * height;
          y1 = y22 - sign2 * finalTickSize;
          ty = y1 - sign2 * tickMargin;
          tx = tickCoord;
          break;
        case "left":
          y1 = y22 = data.coordinate;
          x22 = x2 + +!mirror * width;
          x1 = x22 - sign2 * finalTickSize;
          tx = x1 - sign2 * tickMargin;
          ty = tickCoord;
          break;
        case "right":
          y1 = y22 = data.coordinate;
          x22 = x2 + +mirror * width;
          x1 = x22 + sign2 * finalTickSize;
          tx = x1 + sign2 * tickMargin;
          ty = tickCoord;
          break;
        default:
          x1 = x22 = data.coordinate;
          y22 = y2 + +mirror * height;
          y1 = y22 + sign2 * finalTickSize;
          ty = y1 + sign2 * tickMargin;
          tx = tickCoord;
          break;
      }
      return {
        line: {
          x1,
          y1,
          x2: x22,
          y2: y22
        },
        tick: {
          x: tx,
          y: ty
        }
      };
    }
  }, {
    key: "getTickTextAnchor",
    value: function getTickTextAnchor() {
      var _this$props3 = this.props, orientation = _this$props3.orientation, mirror = _this$props3.mirror;
      var textAnchor;
      switch (orientation) {
        case "left":
          textAnchor = mirror ? "start" : "end";
          break;
        case "right":
          textAnchor = mirror ? "end" : "start";
          break;
        default:
          textAnchor = "middle";
          break;
      }
      return textAnchor;
    }
  }, {
    key: "getTickVerticalAnchor",
    value: function getTickVerticalAnchor() {
      var _this$props4 = this.props, orientation = _this$props4.orientation, mirror = _this$props4.mirror;
      var verticalAnchor = "end";
      switch (orientation) {
        case "left":
        case "right":
          verticalAnchor = "middle";
          break;
        case "top":
          verticalAnchor = mirror ? "start" : "end";
          break;
        default:
          verticalAnchor = mirror ? "end" : "start";
          break;
      }
      return verticalAnchor;
    }
  }, {
    key: "renderAxisLine",
    value: function renderAxisLine() {
      var _this$props5 = this.props, x2 = _this$props5.x, y2 = _this$props5.y, width = _this$props5.width, height = _this$props5.height, orientation = _this$props5.orientation, mirror = _this$props5.mirror, axisLine = _this$props5.axisLine;
      var props = _objectSpread$5(_objectSpread$5(_objectSpread$5({}, filterProps(this.props)), filterProps(axisLine)), {}, {
        fill: "none"
      });
      if (orientation === "top" || orientation === "bottom") {
        var needHeight = +(orientation === "top" && !mirror || orientation === "bottom" && mirror);
        props = _objectSpread$5(_objectSpread$5({}, props), {}, {
          x1: x2,
          y1: y2 + needHeight * height,
          x2: x2 + width,
          y2: y2 + needHeight * height
        });
      } else {
        var needWidth = +(orientation === "left" && !mirror || orientation === "right" && mirror);
        props = _objectSpread$5(_objectSpread$5({}, props), {}, {
          x1: x2 + needWidth * width,
          y1: y2,
          x2: x2 + needWidth * width,
          y2: y2 + height
        });
      }
      return /* @__PURE__ */ React.createElement("line", _extends$5({}, props, {
        className: classNames("recharts-cartesian-axis-line", _get(axisLine, "className"))
      }));
    }
  }, {
    key: "renderTicks",
    value: (
      /**
       * render the ticks
       * @param {Array} ticks The ticks to actually render (overrides what was passed in props)
       * @param {string} fontSize Fontsize to consider for tick spacing
       * @param {string} letterSpacing Letterspacing to consider for tick spacing
       * @return {ReactComponent} renderedTicks
       */
      function renderTicks(ticks2, fontSize, letterSpacing) {
        var _this2 = this;
        var _this$props6 = this.props, tickLine = _this$props6.tickLine, stroke = _this$props6.stroke, tick = _this$props6.tick, tickFormatter = _this$props6.tickFormatter, unit2 = _this$props6.unit;
        var finalTicks = CartesianAxis2.getTicks(_objectSpread$5(_objectSpread$5({}, this.props), {}, {
          ticks: ticks2
        }), fontSize, letterSpacing);
        var textAnchor = this.getTickTextAnchor();
        var verticalAnchor = this.getTickVerticalAnchor();
        var axisProps = filterProps(this.props);
        var customTickProps = filterProps(tick);
        var tickLineProps = _objectSpread$5(_objectSpread$5({}, axisProps), {}, {
          fill: "none"
        }, filterProps(tickLine));
        var items = finalTicks.map(function(entry, i) {
          var _this2$getTickLineCoo = _this2.getTickLineCoord(entry), lineCoord = _this2$getTickLineCoo.line, tickCoord = _this2$getTickLineCoo.tick;
          var tickProps = _objectSpread$5(_objectSpread$5(_objectSpread$5(_objectSpread$5({
            textAnchor,
            verticalAnchor
          }, axisProps), {}, {
            stroke: "none",
            fill: stroke
          }, customTickProps), tickCoord), {}, {
            index: i,
            payload: entry,
            visibleTicksCount: finalTicks.length,
            tickFormatter
          });
          return /* @__PURE__ */ React.createElement(Layer, _extends$5({
            className: "recharts-cartesian-axis-tick",
            key: "tick-".concat(i)
            // eslint-disable-line react/no-array-index-key
          }, adaptEventsOfChild(_this2.props, entry, i)), tickLine && /* @__PURE__ */ React.createElement("line", _extends$5({}, tickLineProps, lineCoord, {
            className: classNames("recharts-cartesian-axis-tick-line", _get(tickLine, "className"))
          })), tick && CartesianAxis2.renderTickItem(tick, tickProps, "".concat(_isFunction(tickFormatter) ? tickFormatter(entry.value, i) : entry.value).concat(unit2 || "")));
        });
        return /* @__PURE__ */ React.createElement("g", {
          className: "recharts-cartesian-axis-ticks"
        }, items);
      }
    )
  }, {
    key: "render",
    value: function render() {
      var _this3 = this;
      var _this$props7 = this.props, axisLine = _this$props7.axisLine, width = _this$props7.width, height = _this$props7.height, ticksGenerator = _this$props7.ticksGenerator, className = _this$props7.className, hide = _this$props7.hide;
      if (hide) {
        return null;
      }
      var _this$props8 = this.props, ticks2 = _this$props8.ticks, noTicksProps = _objectWithoutProperties$4(_this$props8, _excluded3);
      var finalTicks = ticks2;
      if (_isFunction(ticksGenerator)) {
        finalTicks = ticks2 && ticks2.length > 0 ? ticksGenerator(this.props) : ticksGenerator(noTicksProps);
      }
      if (width <= 0 || height <= 0 || !finalTicks || !finalTicks.length) {
        return null;
      }
      return /* @__PURE__ */ React.createElement(Layer, {
        className: classNames("recharts-cartesian-axis", className),
        ref: function ref(_ref2) {
          _this3.layerReference = _ref2;
        }
      }, axisLine && this.renderAxisLine(), this.renderTicks(finalTicks, this.state.fontSize, this.state.letterSpacing), Label.renderCallByParent(this.props));
    }
  }], [{
    key: "getTicks",
    value: function getTicks(props, fontSize, letterSpacing) {
      var tick = props.tick, ticks2 = props.ticks, viewBox = props.viewBox, minTickGap = props.minTickGap, orientation = props.orientation, interval = props.interval, tickFormatter = props.tickFormatter, unit2 = props.unit;
      if (!ticks2 || !ticks2.length || !tick) {
        return [];
      }
      if (isNumber(interval) || Global.isSsr) {
        return CartesianAxis2.getNumberIntervalTicks(ticks2, typeof interval === "number" && isNumber(interval) ? interval : 0);
      }
      if (interval === "preserveStartEnd") {
        return CartesianAxis2.getTicksStart({
          ticks: ticks2,
          tickFormatter,
          viewBox,
          orientation,
          minTickGap,
          unit: unit2,
          fontSize,
          letterSpacing
        }, true);
      }
      if (interval === "preserveStart") {
        return CartesianAxis2.getTicksStart({
          ticks: ticks2,
          tickFormatter,
          viewBox,
          orientation,
          minTickGap,
          unit: unit2,
          fontSize,
          letterSpacing
        });
      }
      return CartesianAxis2.getTicksEnd({
        ticks: ticks2,
        tickFormatter,
        viewBox,
        orientation,
        minTickGap,
        unit: unit2,
        fontSize,
        letterSpacing
      });
    }
  }, {
    key: "getNumberIntervalTicks",
    value: function getNumberIntervalTicks(ticks2, interval) {
      return ticks2.filter(function(entry, i) {
        return i % (interval + 1) === 0;
      });
    }
  }, {
    key: "getTicksStart",
    value: function getTicksStart(_ref3, preserveEnd) {
      var ticks2 = _ref3.ticks, tickFormatter = _ref3.tickFormatter, viewBox = _ref3.viewBox, orientation = _ref3.orientation, minTickGap = _ref3.minTickGap, unit2 = _ref3.unit, fontSize = _ref3.fontSize, letterSpacing = _ref3.letterSpacing;
      var x2 = viewBox.x, y2 = viewBox.y, width = viewBox.width, height = viewBox.height;
      var sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
      var result = (ticks2 || []).slice();
      var unitSize = unit2 && sizeKey === "width" ? getStringSize(unit2, {
        fontSize,
        letterSpacing
      })[sizeKey] : 0;
      var len = result.length;
      var sign2 = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;
      var start, end;
      if (sign2 === 1) {
        start = sizeKey === "width" ? x2 : y2;
        end = sizeKey === "width" ? x2 + width : y2 + height;
      } else {
        start = sizeKey === "width" ? x2 + width : y2 + height;
        end = sizeKey === "width" ? x2 : y2;
      }
      if (preserveEnd) {
        var tail = ticks2[len - 1];
        var tailContent = _isFunction(tickFormatter) ? tickFormatter(tail.value, len - 1) : tail.value;
        var tailSize = getStringSize(tailContent, {
          fontSize,
          letterSpacing
        })[sizeKey] + unitSize;
        var tailGap = sign2 * (tail.coordinate + sign2 * tailSize / 2 - end);
        result[len - 1] = tail = _objectSpread$5(_objectSpread$5({}, tail), {}, {
          tickCoord: tailGap > 0 ? tail.coordinate - tailGap * sign2 : tail.coordinate
        });
        var isTailShow = sign2 * (tail.tickCoord - sign2 * tailSize / 2 - start) >= 0 && sign2 * (tail.tickCoord + sign2 * tailSize / 2 - end) <= 0;
        if (isTailShow) {
          end = tail.tickCoord - sign2 * (tailSize / 2 + minTickGap);
          result[len - 1] = _objectSpread$5(_objectSpread$5({}, tail), {}, {
            isShow: true
          });
        }
      }
      var count = preserveEnd ? len - 1 : len;
      for (var i = 0; i < count; i++) {
        var entry = result[i];
        var content = _isFunction(tickFormatter) ? tickFormatter(entry.value, i) : entry.value;
        var size = getStringSize(content, {
          fontSize,
          letterSpacing
        })[sizeKey] + unitSize;
        if (i === 0) {
          var gap = sign2 * (entry.coordinate - sign2 * size / 2 - start);
          result[i] = entry = _objectSpread$5(_objectSpread$5({}, entry), {}, {
            tickCoord: gap < 0 ? entry.coordinate - gap * sign2 : entry.coordinate
          });
        } else {
          result[i] = entry = _objectSpread$5(_objectSpread$5({}, entry), {}, {
            tickCoord: entry.coordinate
          });
        }
        var isShow = sign2 * (entry.tickCoord - sign2 * size / 2 - start) >= 0 && sign2 * (entry.tickCoord + sign2 * size / 2 - end) <= 0;
        if (isShow) {
          start = entry.tickCoord + sign2 * (size / 2 + minTickGap);
          result[i] = _objectSpread$5(_objectSpread$5({}, entry), {}, {
            isShow: true
          });
        }
      }
      return result.filter(function(entry2) {
        return entry2.isShow;
      });
    }
  }, {
    key: "getTicksEnd",
    value: function getTicksEnd(_ref4) {
      var ticks2 = _ref4.ticks, tickFormatter = _ref4.tickFormatter, viewBox = _ref4.viewBox, orientation = _ref4.orientation, minTickGap = _ref4.minTickGap, unit2 = _ref4.unit, fontSize = _ref4.fontSize, letterSpacing = _ref4.letterSpacing;
      var x2 = viewBox.x, y2 = viewBox.y, width = viewBox.width, height = viewBox.height;
      var sizeKey = orientation === "top" || orientation === "bottom" ? "width" : "height";
      var unitSize = unit2 && sizeKey === "width" ? getStringSize(unit2, {
        fontSize,
        letterSpacing
      })[sizeKey] : 0;
      var result = (ticks2 || []).slice();
      var len = result.length;
      var sign2 = len >= 2 ? mathSign(result[1].coordinate - result[0].coordinate) : 1;
      var start, end;
      if (sign2 === 1) {
        start = sizeKey === "width" ? x2 : y2;
        end = sizeKey === "width" ? x2 + width : y2 + height;
      } else {
        start = sizeKey === "width" ? x2 + width : y2 + height;
        end = sizeKey === "width" ? x2 : y2;
      }
      for (var i = len - 1; i >= 0; i--) {
        var entry = result[i];
        var content = _isFunction(tickFormatter) ? tickFormatter(entry.value, len - i - 1) : entry.value;
        var size = getStringSize(content, {
          fontSize,
          letterSpacing
        })[sizeKey] + unitSize;
        if (i === len - 1) {
          var gap = sign2 * (entry.coordinate + sign2 * size / 2 - end);
          result[i] = entry = _objectSpread$5(_objectSpread$5({}, entry), {}, {
            tickCoord: gap > 0 ? entry.coordinate - gap * sign2 : entry.coordinate
          });
        } else {
          result[i] = entry = _objectSpread$5(_objectSpread$5({}, entry), {}, {
            tickCoord: entry.coordinate
          });
        }
        var isShow = sign2 * (entry.tickCoord - sign2 * size / 2 - start) >= 0 && sign2 * (entry.tickCoord + sign2 * size / 2 - end) <= 0;
        if (isShow) {
          end = entry.tickCoord - sign2 * (size / 2 + minTickGap);
          result[i] = _objectSpread$5(_objectSpread$5({}, entry), {}, {
            isShow: true
          });
        }
      }
      return result.filter(function(entry2) {
        return entry2.isShow;
      });
    }
  }, {
    key: "renderTickItem",
    value: function renderTickItem(option, props, value) {
      var tickItem;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        tickItem = /* @__PURE__ */ React.cloneElement(option, props);
      } else if (_isFunction(option)) {
        tickItem = option(props);
      } else {
        tickItem = /* @__PURE__ */ React.createElement(Text, _extends$5({}, props, {
          className: "recharts-cartesian-axis-tick-value"
        }), value);
      }
      return tickItem;
    }
  }]);
  return CartesianAxis2;
}(reactExports.Component);
_defineProperty$5(CartesianAxis, "displayName", "CartesianAxis");
_defineProperty$5(CartesianAxis, "defaultProps", {
  x: 0,
  y: 0,
  width: 0,
  height: 0,
  viewBox: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  // The orientation of axis
  orientation: "bottom",
  // The ticks
  ticks: [],
  stroke: "#666",
  tickLine: true,
  axisLine: true,
  tick: true,
  mirror: false,
  minTickGap: 5,
  // The width or height of tick
  tickSize: 6,
  tickMargin: 2,
  interval: "preserveEnd"
});
var _excluded$3 = ["x1", "y1", "x2", "y2", "key"];
function _typeof$4(obj) {
  "@babel/helpers - typeof";
  return _typeof$4 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$4(obj);
}
function _extends$4() {
  _extends$4 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$4.apply(this, arguments);
}
function _objectWithoutProperties$3(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$3(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$3(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function ownKeys$4(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$4(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$4(Object(source), true).forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$4(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$4(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$4(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$4(descriptor.key), descriptor);
  }
}
function _createClass$4(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$4(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$4(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$4(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$4(subClass, superClass);
}
function _setPrototypeOf$4(o, p2) {
  _setPrototypeOf$4 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$4(o, p2);
}
function _createSuper$4(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$4();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$4(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$4(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$4(this, result);
  };
}
function _possibleConstructorReturn$4(self2, call) {
  if (call && (_typeof$4(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$4(self2);
}
function _assertThisInitialized$4(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$4() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$4(o) {
  _getPrototypeOf$4 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$4(o);
}
function _defineProperty$4(obj, key, value) {
  key = _toPropertyKey$4(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$4(arg) {
  var key = _toPrimitive$4(arg, "string");
  return _typeof$4(key) === "symbol" ? key : String(key);
}
function _toPrimitive$4(input2, hint) {
  if (_typeof$4(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$4(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var CartesianGrid = /* @__PURE__ */ function(_PureComponent) {
  _inherits$4(CartesianGrid2, _PureComponent);
  var _super = _createSuper$4(CartesianGrid2);
  function CartesianGrid2() {
    _classCallCheck$4(this, CartesianGrid2);
    return _super.apply(this, arguments);
  }
  _createClass$4(CartesianGrid2, [{
    key: "renderHorizontal",
    value: (
      /**
       * Draw the horizontal grid lines
       * @param {Array} horizontalPoints either passed in as props or generated from function
       * @return {Group} Horizontal lines
       */
      function renderHorizontal(horizontalPoints) {
        var _this = this;
        var _this$props = this.props, x2 = _this$props.x, width = _this$props.width, horizontal = _this$props.horizontal;
        if (!horizontalPoints || !horizontalPoints.length) {
          return null;
        }
        var items = horizontalPoints.map(function(entry, i) {
          var props = _objectSpread$4(_objectSpread$4({}, _this.props), {}, {
            x1: x2,
            y1: entry,
            x2: x2 + width,
            y2: entry,
            key: "line-".concat(i),
            index: i
          });
          return CartesianGrid2.renderLineItem(horizontal, props);
        });
        return /* @__PURE__ */ React.createElement("g", {
          className: "recharts-cartesian-grid-horizontal"
        }, items);
      }
    )
    /**
     * Draw vertical grid lines
     * @param {Array} verticalPoints either passed in as props or generated from function
     * @return {Group} Vertical lines
     */
  }, {
    key: "renderVertical",
    value: function renderVertical(verticalPoints) {
      var _this2 = this;
      var _this$props2 = this.props, y2 = _this$props2.y, height = _this$props2.height, vertical = _this$props2.vertical;
      if (!verticalPoints || !verticalPoints.length) {
        return null;
      }
      var items = verticalPoints.map(function(entry, i) {
        var props = _objectSpread$4(_objectSpread$4({}, _this2.props), {}, {
          x1: entry,
          y1: y2,
          x2: entry,
          y2: y2 + height,
          key: "line-".concat(i),
          index: i
        });
        return CartesianGrid2.renderLineItem(vertical, props);
      });
      return /* @__PURE__ */ React.createElement("g", {
        className: "recharts-cartesian-grid-vertical"
      }, items);
    }
    /**
     * Draw vertical grid stripes filled by colors
     * @param {Array} verticalPoints either passed in as props or generated from function
     * @return {Group} Vertical stripes
     */
  }, {
    key: "renderVerticalStripes",
    value: function renderVerticalStripes(verticalPoints) {
      var verticalFill = this.props.verticalFill;
      if (!verticalFill || !verticalFill.length) {
        return null;
      }
      var _this$props3 = this.props, fillOpacity = _this$props3.fillOpacity, x2 = _this$props3.x, y2 = _this$props3.y, width = _this$props3.width, height = _this$props3.height;
      var roundedSortedVerticalPoints = verticalPoints.map(function(e3) {
        return Math.round(e3 + x2 - x2);
      }).sort(function(a2, b2) {
        return a2 - b2;
      });
      if (x2 !== roundedSortedVerticalPoints[0]) {
        roundedSortedVerticalPoints.unshift(0);
      }
      var items = roundedSortedVerticalPoints.map(function(entry, i) {
        var lastStripe = !roundedSortedVerticalPoints[i + 1];
        var lineWidth = lastStripe ? x2 + width - entry : roundedSortedVerticalPoints[i + 1] - entry;
        if (lineWidth <= 0) {
          return null;
        }
        var colorIndex = i % verticalFill.length;
        return /* @__PURE__ */ React.createElement("rect", {
          key: "react-".concat(i),
          x: entry,
          y: y2,
          width: lineWidth,
          height,
          stroke: "none",
          fill: verticalFill[colorIndex],
          fillOpacity,
          className: "recharts-cartesian-grid-bg"
        });
      });
      return /* @__PURE__ */ React.createElement("g", {
        className: "recharts-cartesian-gridstripes-vertical"
      }, items);
    }
    /**
     * Draw horizontal grid stripes filled by colors
     * @param {Array} horizontalPoints either passed in as props or generated from function
     * @return {Group} Horizontal stripes
     */
  }, {
    key: "renderHorizontalStripes",
    value: function renderHorizontalStripes(horizontalPoints) {
      var horizontalFill = this.props.horizontalFill;
      if (!horizontalFill || !horizontalFill.length) {
        return null;
      }
      var _this$props4 = this.props, fillOpacity = _this$props4.fillOpacity, x2 = _this$props4.x, y2 = _this$props4.y, width = _this$props4.width, height = _this$props4.height;
      var roundedSortedHorizontalPoints = horizontalPoints.map(function(e3) {
        return Math.round(e3 + y2 - y2);
      }).sort(function(a2, b2) {
        return a2 - b2;
      });
      if (y2 !== roundedSortedHorizontalPoints[0]) {
        roundedSortedHorizontalPoints.unshift(0);
      }
      var items = roundedSortedHorizontalPoints.map(function(entry, i) {
        var lastStripe = !roundedSortedHorizontalPoints[i + 1];
        var lineHeight = lastStripe ? y2 + height - entry : roundedSortedHorizontalPoints[i + 1] - entry;
        if (lineHeight <= 0) {
          return null;
        }
        var colorIndex = i % horizontalFill.length;
        return /* @__PURE__ */ React.createElement("rect", {
          key: "react-".concat(i),
          y: entry,
          x: x2,
          height: lineHeight,
          width,
          stroke: "none",
          fill: horizontalFill[colorIndex],
          fillOpacity,
          className: "recharts-cartesian-grid-bg"
        });
      });
      return /* @__PURE__ */ React.createElement("g", {
        className: "recharts-cartesian-gridstripes-horizontal"
      }, items);
    }
  }, {
    key: "renderBackground",
    value: function renderBackground() {
      var fill = this.props.fill;
      if (!fill || fill === "none") {
        return null;
      }
      var _this$props5 = this.props, fillOpacity = _this$props5.fillOpacity, x2 = _this$props5.x, y2 = _this$props5.y, width = _this$props5.width, height = _this$props5.height;
      return /* @__PURE__ */ React.createElement("rect", {
        x: x2,
        y: y2,
        width,
        height,
        stroke: "none",
        fill,
        fillOpacity,
        className: "recharts-cartesian-grid-bg"
      });
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props, x2 = _this$props6.x, y2 = _this$props6.y, width = _this$props6.width, height = _this$props6.height, horizontal = _this$props6.horizontal, vertical = _this$props6.vertical, horizontalCoordinatesGenerator = _this$props6.horizontalCoordinatesGenerator, verticalCoordinatesGenerator = _this$props6.verticalCoordinatesGenerator, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, offset = _this$props6.offset, chartWidth = _this$props6.chartWidth, chartHeight = _this$props6.chartHeight;
      if (!isNumber(width) || width <= 0 || !isNumber(height) || height <= 0 || !isNumber(x2) || x2 !== +x2 || !isNumber(y2) || y2 !== +y2) {
        return null;
      }
      var _this$props7 = this.props, horizontalPoints = _this$props7.horizontalPoints, verticalPoints = _this$props7.verticalPoints;
      if ((!horizontalPoints || !horizontalPoints.length) && _isFunction(horizontalCoordinatesGenerator)) {
        horizontalPoints = horizontalCoordinatesGenerator({
          yAxis,
          width: chartWidth,
          height: chartHeight,
          offset
        });
      }
      if ((!verticalPoints || !verticalPoints.length) && _isFunction(verticalCoordinatesGenerator)) {
        verticalPoints = verticalCoordinatesGenerator({
          xAxis,
          width: chartWidth,
          height: chartHeight,
          offset
        });
      }
      return /* @__PURE__ */ React.createElement("g", {
        className: "recharts-cartesian-grid"
      }, this.renderBackground(), horizontal && this.renderHorizontal(horizontalPoints), vertical && this.renderVertical(verticalPoints), horizontal && this.renderHorizontalStripes(horizontalPoints), vertical && this.renderVerticalStripes(verticalPoints));
    }
  }], [{
    key: "renderLineItem",
    value: function renderLineItem(option, props) {
      var lineItem;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        lineItem = /* @__PURE__ */ React.cloneElement(option, props);
      } else if (_isFunction(option)) {
        lineItem = option(props);
      } else {
        var x1 = props.x1, y1 = props.y1, x2 = props.x2, y2 = props.y2, key = props.key, others = _objectWithoutProperties$3(props, _excluded$3);
        lineItem = /* @__PURE__ */ React.createElement("line", _extends$4({}, filterProps(others), {
          x1,
          y1,
          x2,
          y2,
          fill: "none",
          key
        }));
      }
      return lineItem;
    }
  }]);
  return CartesianGrid2;
}(reactExports.PureComponent);
_defineProperty$4(CartesianGrid, "displayName", "CartesianGrid");
_defineProperty$4(CartesianGrid, "defaultProps", {
  horizontal: true,
  vertical: true,
  // The ordinates of horizontal grid lines
  horizontalPoints: [],
  // The abscissas of vertical grid lines
  verticalPoints: [],
  stroke: "#ccc",
  fill: "none",
  // The fill of colors of grid lines
  verticalFill: [],
  horizontalFill: []
});
var _excluded$2 = ["type", "layout", "connectNulls", "ref"];
function _typeof$3(obj) {
  "@babel/helpers - typeof";
  return _typeof$3 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$3(obj);
}
function _objectWithoutProperties$2(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$2(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$2(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _extends$3() {
  _extends$3 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$3.apply(this, arguments);
}
function ownKeys$3(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$3(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$3(Object(source), true).forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _toConsumableArray$2(arr) {
  return _arrayWithoutHoles$2(arr) || _iterableToArray$2(arr) || _unsupportedIterableToArray$2(arr) || _nonIterableSpread$2();
}
function _nonIterableSpread$2() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$2(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$2(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$2(o, minLen);
}
function _iterableToArray$2(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$2(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$2(arr);
}
function _arrayLikeToArray$2(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function _classCallCheck$3(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$3(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$3(descriptor.key), descriptor);
  }
}
function _createClass$3(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$3(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$3(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$3(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$3(subClass, superClass);
}
function _setPrototypeOf$3(o, p2) {
  _setPrototypeOf$3 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$3(o, p2);
}
function _createSuper$3(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$3();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$3(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$3(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$3(this, result);
  };
}
function _possibleConstructorReturn$3(self2, call) {
  if (call && (_typeof$3(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$3(self2);
}
function _assertThisInitialized$3(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$3() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$3(o) {
  _getPrototypeOf$3 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$3(o);
}
function _defineProperty$3(obj, key, value) {
  key = _toPropertyKey$3(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$3(arg) {
  var key = _toPrimitive$3(arg, "string");
  return _typeof$3(key) === "symbol" ? key : String(key);
}
function _toPrimitive$3(input2, hint) {
  if (_typeof$3(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$3(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var Line = /* @__PURE__ */ function(_PureComponent) {
  _inherits$3(Line2, _PureComponent);
  var _super = _createSuper$3(Line2);
  function Line2() {
    var _this;
    _classCallCheck$3(this, Line2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$3(_assertThisInitialized$3(_this), "state", {
      isAnimationFinished: true,
      totalLength: 0
    });
    _defineProperty$3(_assertThisInitialized$3(_this), "getStrokeDasharray", function(length, totalLength, lines) {
      var lineLength = lines.reduce(function(pre, next) {
        return pre + next;
      });
      var count = Math.floor(length / lineLength);
      var remainLength = length % lineLength;
      var restLength = totalLength - length;
      var remainLines = [];
      for (var i = 0, sum2 = 0; ; sum2 += lines[i], ++i) {
        if (sum2 + lines[i] > remainLength) {
          remainLines = [].concat(_toConsumableArray$2(lines.slice(0, i)), [remainLength - sum2]);
          break;
        }
      }
      var emptyLines = remainLines.length % 2 === 0 ? [0, restLength] : [restLength];
      return [].concat(_toConsumableArray$2(Line2.repeat(lines, count)), _toConsumableArray$2(remainLines), emptyLines).map(function(line) {
        return "".concat(line, "px");
      }).join(", ");
    });
    _defineProperty$3(_assertThisInitialized$3(_this), "id", uniqueId("recharts-line-"));
    _defineProperty$3(_assertThisInitialized$3(_this), "pathRef", function(node) {
      _this.mainCurve = node;
    });
    _defineProperty$3(_assertThisInitialized$3(_this), "handleAnimationEnd", function() {
      _this.setState({
        isAnimationFinished: true
      });
      if (_this.props.onAnimationEnd) {
        _this.props.onAnimationEnd();
      }
    });
    _defineProperty$3(_assertThisInitialized$3(_this), "handleAnimationStart", function() {
      _this.setState({
        isAnimationFinished: false
      });
      if (_this.props.onAnimationStart) {
        _this.props.onAnimationStart();
      }
    });
    return _this;
  }
  _createClass$3(Line2, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      if (!this.props.isAnimationActive) {
        return;
      }
      var totalLength = this.getTotalLength();
      this.setState({
        totalLength
      });
    }
  }, {
    key: "getTotalLength",
    value: function getTotalLength() {
      var curveDom = this.mainCurve;
      try {
        return curveDom && curveDom.getTotalLength && curveDom.getTotalLength() || 0;
      } catch (err) {
        return 0;
      }
    }
  }, {
    key: "renderErrorBar",
    value: function renderErrorBar(needClip, clipPathId) {
      if (this.props.isAnimationActive && !this.state.isAnimationFinished) {
        return null;
      }
      var _this$props = this.props, points = _this$props.points, xAxis = _this$props.xAxis, yAxis = _this$props.yAxis, layout = _this$props.layout, children = _this$props.children;
      var errorBarItems = findAllByType(children, ErrorBar);
      if (!errorBarItems) {
        return null;
      }
      function dataPointFormatter(dataPoint, dataKey) {
        return {
          x: dataPoint.x,
          y: dataPoint.y,
          value: dataPoint.value,
          errorVal: getValueByDataKey(dataPoint.payload, dataKey)
        };
      }
      var errorBarProps = {
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      };
      return /* @__PURE__ */ React.createElement(Layer, errorBarProps, errorBarItems.map(function(item, i) {
        return /* @__PURE__ */ React.cloneElement(item, {
          // eslint-disable-next-line react/no-array-index-key
          key: "bar-".concat(i),
          data: points,
          xAxis,
          yAxis,
          layout,
          dataPointFormatter
        });
      }));
    }
  }, {
    key: "renderDots",
    value: function renderDots(needClip, clipPathId) {
      var isAnimationActive = this.props.isAnimationActive;
      if (isAnimationActive && !this.state.isAnimationFinished) {
        return null;
      }
      var _this$props2 = this.props, dot = _this$props2.dot, points = _this$props2.points, dataKey = _this$props2.dataKey;
      var lineProps = filterProps(this.props);
      var customDotProps = filterProps(dot, true);
      var dots = points.map(function(entry, i) {
        var dotProps = _objectSpread$3(_objectSpread$3(_objectSpread$3({
          key: "dot-".concat(i),
          r: 3
        }, lineProps), customDotProps), {}, {
          value: entry.value,
          dataKey,
          cx: entry.x,
          cy: entry.y,
          index: i,
          payload: entry.payload
        });
        return Line2.renderDotItem(dot, dotProps);
      });
      var dotsProps = {
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      };
      return /* @__PURE__ */ React.createElement(Layer, _extends$3({
        className: "recharts-line-dots",
        key: "dots"
      }, dotsProps, {
        role: "img"
      }), dots);
    }
  }, {
    key: "renderCurveStatically",
    value: function renderCurveStatically(points, needClip, clipPathId, props) {
      var _this$props3 = this.props, type = _this$props3.type, layout = _this$props3.layout, connectNulls = _this$props3.connectNulls;
      _this$props3.ref;
      var others = _objectWithoutProperties$2(_this$props3, _excluded$2);
      var curveProps = _objectSpread$3(_objectSpread$3(_objectSpread$3({}, filterProps(others, true)), {}, {
        fill: "none",
        className: "recharts-line-curve",
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null,
        points
      }, props), {}, {
        type,
        layout,
        connectNulls
      });
      return /* @__PURE__ */ React.createElement(Curve, _extends$3({}, curveProps, {
        pathRef: this.pathRef
      }));
    }
  }, {
    key: "renderCurveWithAnimation",
    value: function renderCurveWithAnimation(needClip, clipPathId) {
      var _this2 = this;
      var _this$props4 = this.props, points = _this$props4.points, strokeDasharray = _this$props4.strokeDasharray, isAnimationActive = _this$props4.isAnimationActive, animationBegin = _this$props4.animationBegin, animationDuration = _this$props4.animationDuration, animationEasing = _this$props4.animationEasing, animationId = _this$props4.animationId, animateNewValues = _this$props4.animateNewValues, width = _this$props4.width, height = _this$props4.height;
      var _this$state = this.state, prevPoints = _this$state.prevPoints, totalLength = _this$state.totalLength;
      return /* @__PURE__ */ React.createElement(Animate, {
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "line-".concat(animationId),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(_ref) {
        var t2 = _ref.t;
        if (prevPoints) {
          var prevPointsDiffFactor = prevPoints.length / points.length;
          var stepData = points.map(function(entry, index) {
            var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
            if (prevPoints[prevPointIndex]) {
              var prev = prevPoints[prevPointIndex];
              var interpolatorX = interpolateNumber$2(prev.x, entry.x);
              var interpolatorY = interpolateNumber$2(prev.y, entry.y);
              return _objectSpread$3(_objectSpread$3({}, entry), {}, {
                x: interpolatorX(t2),
                y: interpolatorY(t2)
              });
            }
            if (animateNewValues) {
              var _interpolatorX = interpolateNumber$2(width * 2, entry.x);
              var _interpolatorY = interpolateNumber$2(height / 2, entry.y);
              return _objectSpread$3(_objectSpread$3({}, entry), {}, {
                x: _interpolatorX(t2),
                y: _interpolatorY(t2)
              });
            }
            return _objectSpread$3(_objectSpread$3({}, entry), {}, {
              x: entry.x,
              y: entry.y
            });
          });
          return _this2.renderCurveStatically(stepData, needClip, clipPathId);
        }
        var interpolator = interpolateNumber$2(0, totalLength);
        var curLength = interpolator(t2);
        var currentStrokeDasharray;
        if (strokeDasharray) {
          var lines = "".concat(strokeDasharray).split(/[,\s]+/gim).map(function(num) {
            return parseFloat(num);
          });
          currentStrokeDasharray = _this2.getStrokeDasharray(curLength, totalLength, lines);
        } else {
          currentStrokeDasharray = "".concat(curLength, "px ").concat(totalLength - curLength, "px");
        }
        return _this2.renderCurveStatically(points, needClip, clipPathId, {
          strokeDasharray: currentStrokeDasharray
        });
      });
    }
  }, {
    key: "renderCurve",
    value: function renderCurve(needClip, clipPathId) {
      var _this$props5 = this.props, points = _this$props5.points, isAnimationActive = _this$props5.isAnimationActive;
      var _this$state2 = this.state, prevPoints = _this$state2.prevPoints, totalLength = _this$state2.totalLength;
      if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !_isEqual(prevPoints, points))) {
        return this.renderCurveWithAnimation(needClip, clipPathId);
      }
      return this.renderCurveStatically(points, needClip, clipPathId);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props, hide = _this$props6.hide, dot = _this$props6.dot, points = _this$props6.points, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, top = _this$props6.top, left = _this$props6.left, width = _this$props6.width, height = _this$props6.height, isAnimationActive = _this$props6.isAnimationActive, id = _this$props6.id;
      if (hide || !points || !points.length) {
        return null;
      }
      var isAnimationFinished = this.state.isAnimationFinished;
      var hasSinglePoint = points.length === 1;
      var layerClass = classNames("recharts-line", className);
      var needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow;
      var clipPathId = _isNil(id) ? this.id : id;
      return /* @__PURE__ */ React.createElement(Layer, {
        className: layerClass
      }, needClip ? /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
        id: "clipPath-".concat(clipPathId)
      }, /* @__PURE__ */ React.createElement("rect", {
        x: left,
        y: top,
        width,
        height
      }))) : null, !hasSinglePoint && this.renderCurve(needClip, clipPathId), this.renderErrorBar(needClip, clipPathId), (hasSinglePoint || dot) && this.renderDots(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, points));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.animationId !== prevState.prevAnimationId) {
        return {
          prevAnimationId: nextProps.animationId,
          curPoints: nextProps.points,
          prevPoints: prevState.curPoints
        };
      }
      if (nextProps.points !== prevState.curPoints) {
        return {
          curPoints: nextProps.points
        };
      }
      return null;
    }
  }, {
    key: "repeat",
    value: function repeat(lines, count) {
      var linesUnit = lines.length % 2 !== 0 ? [].concat(_toConsumableArray$2(lines), [0]) : lines;
      var result = [];
      for (var i = 0; i < count; ++i) {
        result = [].concat(_toConsumableArray$2(result), _toConsumableArray$2(linesUnit));
      }
      return result;
    }
  }, {
    key: "renderDotItem",
    value: function renderDotItem(option, props) {
      var dotItem;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        dotItem = /* @__PURE__ */ React.cloneElement(option, props);
      } else if (_isFunction(option)) {
        dotItem = option(props);
      } else {
        var className = classNames("recharts-line-dot", option ? option.className : "");
        dotItem = /* @__PURE__ */ React.createElement(Dot, _extends$3({}, props, {
          className
        }));
      }
      return dotItem;
    }
  }]);
  return Line2;
}(reactExports.PureComponent);
_defineProperty$3(Line, "displayName", "Line");
_defineProperty$3(Line, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  connectNulls: false,
  activeDot: true,
  dot: true,
  legendType: "line",
  stroke: "#3182bd",
  strokeWidth: 1,
  fill: "#fff",
  points: [],
  isAnimationActive: !Global.isSsr,
  animateNewValues: true,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease",
  hide: false,
  label: false
});
_defineProperty$3(Line, "getComposedData", function(_ref2) {
  var props = _ref2.props, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, dataKey = _ref2.dataKey, bandSize = _ref2.bandSize, displayedData = _ref2.displayedData, offset = _ref2.offset;
  var layout = props.layout;
  var points = displayedData.map(function(entry, index) {
    var value = getValueByDataKey(entry, dataKey);
    if (layout === "horizontal") {
      return {
        x: getCateCoordinateOfLine({
          axis: xAxis,
          ticks: xAxisTicks,
          bandSize,
          entry,
          index
        }),
        y: _isNil(value) ? null : yAxis.scale(value),
        value,
        payload: entry
      };
    }
    return {
      x: _isNil(value) ? null : xAxis.scale(value),
      y: getCateCoordinateOfLine({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        entry,
        index
      }),
      value,
      payload: entry
    };
  });
  return _objectSpread$3({
    points,
    layout
  }, offset);
});
var _excluded$1 = ["layout", "type", "stroke", "connectNulls", "isRange", "ref"];
function _typeof$2(obj) {
  "@babel/helpers - typeof";
  return _typeof$2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$2(obj);
}
function _objectWithoutProperties$1(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _extends$2() {
  _extends$2 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$2.apply(this, arguments);
}
function ownKeys$2(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$2(Object(source), true).forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$2(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$2(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$2(descriptor.key), descriptor);
  }
}
function _createClass$2(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$2(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$2(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$2(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$2(subClass, superClass);
}
function _setPrototypeOf$2(o, p2) {
  _setPrototypeOf$2 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$2(o, p2);
}
function _createSuper$2(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$2();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$2(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$2(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$2(this, result);
  };
}
function _possibleConstructorReturn$2(self2, call) {
  if (call && (_typeof$2(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$2(self2);
}
function _assertThisInitialized$2(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$2() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$2(o) {
  _getPrototypeOf$2 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$2(o);
}
function _defineProperty$2(obj, key, value) {
  key = _toPropertyKey$2(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$2(arg) {
  var key = _toPrimitive$2(arg, "string");
  return _typeof$2(key) === "symbol" ? key : String(key);
}
function _toPrimitive$2(input2, hint) {
  if (_typeof$2(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$2(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var Area = /* @__PURE__ */ function(_PureComponent) {
  _inherits$2(Area2, _PureComponent);
  var _super = _createSuper$2(Area2);
  function Area2() {
    var _this;
    _classCallCheck$2(this, Area2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$2(_assertThisInitialized$2(_this), "state", {
      isAnimationFinished: true
    });
    _defineProperty$2(_assertThisInitialized$2(_this), "id", uniqueId("recharts-area-"));
    _defineProperty$2(_assertThisInitialized$2(_this), "handleAnimationEnd", function() {
      var onAnimationEnd2 = _this.props.onAnimationEnd;
      _this.setState({
        isAnimationFinished: true
      });
      if (_isFunction(onAnimationEnd2)) {
        onAnimationEnd2();
      }
    });
    _defineProperty$2(_assertThisInitialized$2(_this), "handleAnimationStart", function() {
      var onAnimationStart2 = _this.props.onAnimationStart;
      _this.setState({
        isAnimationFinished: false
      });
      if (_isFunction(onAnimationStart2)) {
        onAnimationStart2();
      }
    });
    return _this;
  }
  _createClass$2(Area2, [{
    key: "renderDots",
    value: function renderDots(needClip, clipPathId) {
      var isAnimationActive = this.props.isAnimationActive;
      var isAnimationFinished = this.state.isAnimationFinished;
      if (isAnimationActive && !isAnimationFinished) {
        return null;
      }
      var _this$props = this.props, dot = _this$props.dot, points = _this$props.points, dataKey = _this$props.dataKey;
      var areaProps = filterProps(this.props);
      var customDotProps = filterProps(dot, true);
      var dots = points.map(function(entry, i) {
        var dotProps = _objectSpread$2(_objectSpread$2(_objectSpread$2({
          key: "dot-".concat(i),
          r: 3
        }, areaProps), customDotProps), {}, {
          dataKey,
          cx: entry.x,
          cy: entry.y,
          index: i,
          value: entry.value,
          payload: entry.payload
        });
        return Area2.renderDotItem(dot, dotProps);
      });
      var dotsProps = {
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      };
      return /* @__PURE__ */ React.createElement(Layer, _extends$2({
        className: "recharts-area-dots"
      }, dotsProps), dots);
    }
  }, {
    key: "renderHorizontalRect",
    value: function renderHorizontalRect(alpha3) {
      var _this$props2 = this.props, baseLine = _this$props2.baseLine, points = _this$props2.points, strokeWidth = _this$props2.strokeWidth;
      var startX = points[0].x;
      var endX = points[points.length - 1].x;
      var width = alpha3 * Math.abs(startX - endX);
      var maxY = _max(points.map(function(entry) {
        return entry.y || 0;
      }));
      if (isNumber(baseLine) && typeof baseLine === "number") {
        maxY = Math.max(baseLine, maxY);
      } else if (baseLine && _isArray(baseLine) && baseLine.length) {
        maxY = Math.max(_max(baseLine.map(function(entry) {
          return entry.y || 0;
        })), maxY);
      }
      if (isNumber(maxY)) {
        return /* @__PURE__ */ React.createElement("rect", {
          x: startX < endX ? startX : startX - width,
          y: 0,
          width,
          height: Math.floor(maxY + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1))
        });
      }
      return null;
    }
  }, {
    key: "renderVerticalRect",
    value: function renderVerticalRect(alpha3) {
      var _this$props3 = this.props, baseLine = _this$props3.baseLine, points = _this$props3.points, strokeWidth = _this$props3.strokeWidth;
      var startY = points[0].y;
      var endY = points[points.length - 1].y;
      var height = alpha3 * Math.abs(startY - endY);
      var maxX = _max(points.map(function(entry) {
        return entry.x || 0;
      }));
      if (isNumber(baseLine) && typeof baseLine === "number") {
        maxX = Math.max(baseLine, maxX);
      } else if (baseLine && _isArray(baseLine) && baseLine.length) {
        maxX = Math.max(_max(baseLine.map(function(entry) {
          return entry.x || 0;
        })), maxX);
      }
      if (isNumber(maxX)) {
        return /* @__PURE__ */ React.createElement("rect", {
          x: 0,
          y: startY < endY ? startY : startY - height,
          width: maxX + (strokeWidth ? parseInt("".concat(strokeWidth), 10) : 1),
          height: Math.floor(height)
        });
      }
      return null;
    }
  }, {
    key: "renderClipRect",
    value: function renderClipRect(alpha3) {
      var layout = this.props.layout;
      if (layout === "vertical") {
        return this.renderVerticalRect(alpha3);
      }
      return this.renderHorizontalRect(alpha3);
    }
  }, {
    key: "renderAreaStatically",
    value: function renderAreaStatically(points, baseLine, needClip, clipPathId) {
      var _this$props4 = this.props, layout = _this$props4.layout, type = _this$props4.type, stroke = _this$props4.stroke, connectNulls = _this$props4.connectNulls, isRange = _this$props4.isRange;
      _this$props4.ref;
      var others = _objectWithoutProperties$1(_this$props4, _excluded$1);
      return /* @__PURE__ */ React.createElement(Layer, {
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      }, /* @__PURE__ */ React.createElement(Curve, _extends$2({}, filterProps(others, true), {
        points,
        connectNulls,
        type,
        baseLine,
        layout,
        stroke: "none",
        className: "recharts-area-area"
      })), stroke !== "none" && /* @__PURE__ */ React.createElement(Curve, _extends$2({}, filterProps(this.props), {
        className: "recharts-area-curve",
        layout,
        type,
        connectNulls,
        fill: "none",
        points
      })), stroke !== "none" && isRange && /* @__PURE__ */ React.createElement(Curve, _extends$2({}, filterProps(this.props), {
        className: "recharts-area-curve",
        layout,
        type,
        connectNulls,
        fill: "none",
        points: baseLine
      })));
    }
  }, {
    key: "renderAreaWithAnimation",
    value: function renderAreaWithAnimation(needClip, clipPathId) {
      var _this2 = this;
      var _this$props5 = this.props, points = _this$props5.points, baseLine = _this$props5.baseLine, isAnimationActive = _this$props5.isAnimationActive, animationBegin = _this$props5.animationBegin, animationDuration = _this$props5.animationDuration, animationEasing = _this$props5.animationEasing, animationId = _this$props5.animationId;
      var _this$state = this.state, prevPoints = _this$state.prevPoints, prevBaseLine = _this$state.prevBaseLine;
      return /* @__PURE__ */ React.createElement(Animate, {
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "area-".concat(animationId),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(_ref) {
        var t2 = _ref.t;
        if (prevPoints) {
          var prevPointsDiffFactor = prevPoints.length / points.length;
          var stepPoints = points.map(function(entry, index) {
            var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
            if (prevPoints[prevPointIndex]) {
              var prev = prevPoints[prevPointIndex];
              var interpolatorX = interpolateNumber$2(prev.x, entry.x);
              var interpolatorY = interpolateNumber$2(prev.y, entry.y);
              return _objectSpread$2(_objectSpread$2({}, entry), {}, {
                x: interpolatorX(t2),
                y: interpolatorY(t2)
              });
            }
            return entry;
          });
          var stepBaseLine;
          if (isNumber(baseLine) && typeof baseLine === "number") {
            var interpolator = interpolateNumber$2(prevBaseLine, baseLine);
            stepBaseLine = interpolator(t2);
          } else if (_isNil(baseLine) || _isNaN$1(baseLine)) {
            var _interpolator = interpolateNumber$2(prevBaseLine, 0);
            stepBaseLine = _interpolator(t2);
          } else {
            stepBaseLine = baseLine.map(function(entry, index) {
              var prevPointIndex = Math.floor(index * prevPointsDiffFactor);
              if (prevBaseLine[prevPointIndex]) {
                var prev = prevBaseLine[prevPointIndex];
                var interpolatorX = interpolateNumber$2(prev.x, entry.x);
                var interpolatorY = interpolateNumber$2(prev.y, entry.y);
                return _objectSpread$2(_objectSpread$2({}, entry), {}, {
                  x: interpolatorX(t2),
                  y: interpolatorY(t2)
                });
              }
              return entry;
            });
          }
          return _this2.renderAreaStatically(stepPoints, stepBaseLine, needClip, clipPathId);
        }
        return /* @__PURE__ */ React.createElement(Layer, null, /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
          id: "animationClipPath-".concat(clipPathId)
        }, _this2.renderClipRect(t2))), /* @__PURE__ */ React.createElement(Layer, {
          clipPath: "url(#animationClipPath-".concat(clipPathId, ")")
        }, _this2.renderAreaStatically(points, baseLine, needClip, clipPathId)));
      });
    }
  }, {
    key: "renderArea",
    value: function renderArea(needClip, clipPathId) {
      var _this$props6 = this.props, points = _this$props6.points, baseLine = _this$props6.baseLine, isAnimationActive = _this$props6.isAnimationActive;
      var _this$state2 = this.state, prevPoints = _this$state2.prevPoints, prevBaseLine = _this$state2.prevBaseLine, totalLength = _this$state2.totalLength;
      if (isAnimationActive && points && points.length && (!prevPoints && totalLength > 0 || !_isEqual(prevPoints, points) || !_isEqual(prevBaseLine, baseLine))) {
        return this.renderAreaWithAnimation(needClip, clipPathId);
      }
      return this.renderAreaStatically(points, baseLine, needClip, clipPathId);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props7 = this.props, hide = _this$props7.hide, dot = _this$props7.dot, points = _this$props7.points, className = _this$props7.className, top = _this$props7.top, left = _this$props7.left, xAxis = _this$props7.xAxis, yAxis = _this$props7.yAxis, width = _this$props7.width, height = _this$props7.height, isAnimationActive = _this$props7.isAnimationActive, id = _this$props7.id;
      if (hide || !points || !points.length) {
        return null;
      }
      var isAnimationFinished = this.state.isAnimationFinished;
      var hasSinglePoint = points.length === 1;
      var layerClass = classNames("recharts-area", className);
      var needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow;
      var clipPathId = _isNil(id) ? this.id : id;
      return /* @__PURE__ */ React.createElement(Layer, {
        className: layerClass
      }, needClip ? /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
        id: "clipPath-".concat(clipPathId)
      }, /* @__PURE__ */ React.createElement("rect", {
        x: left,
        y: top,
        width,
        height: Math.floor(height)
      }))) : null, !hasSinglePoint ? this.renderArea(needClip, clipPathId) : null, (dot || hasSinglePoint) && this.renderDots(needClip, clipPathId), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, points));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.animationId !== prevState.prevAnimationId) {
        return {
          prevAnimationId: nextProps.animationId,
          curPoints: nextProps.points,
          curBaseLine: nextProps.baseLine,
          prevPoints: prevState.curPoints,
          prevBaseLine: prevState.curBaseLine
        };
      }
      if (nextProps.points !== prevState.curPoints || nextProps.baseLine !== prevState.curBaseLine) {
        return {
          curPoints: nextProps.points,
          curBaseLine: nextProps.baseLine
        };
      }
      return null;
    }
  }]);
  return Area2;
}(reactExports.PureComponent);
_defineProperty$2(Area, "displayName", "Area");
_defineProperty$2(Area, "defaultProps", {
  stroke: "#3182bd",
  fill: "#3182bd",
  fillOpacity: 0.6,
  xAxisId: 0,
  yAxisId: 0,
  legendType: "line",
  connectNulls: false,
  // points of area
  points: [],
  dot: false,
  activeDot: true,
  hide: false,
  isAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 1500,
  animationEasing: "ease"
});
_defineProperty$2(Area, "getBaseValue", function(props, item, xAxis, yAxis) {
  var layout = props.layout, chartBaseValue = props.baseValue;
  var itemBaseValue = item.props.baseValue;
  var baseValue = itemBaseValue !== null && itemBaseValue !== void 0 ? itemBaseValue : chartBaseValue;
  if (isNumber(baseValue) && typeof baseValue === "number") {
    return baseValue;
  }
  var numericAxis = layout === "horizontal" ? yAxis : xAxis;
  var domain = numericAxis.scale.domain();
  if (numericAxis.type === "number") {
    var max2 = Math.max(domain[0], domain[1]);
    var min2 = Math.min(domain[0], domain[1]);
    if (baseValue === "dataMin") {
      return min2;
    }
    if (baseValue === "dataMax") {
      return max2;
    }
    return max2 < 0 ? max2 : Math.max(Math.min(domain[0], domain[1]), 0);
  }
  if (baseValue === "dataMin") {
    return domain[0];
  }
  if (baseValue === "dataMax") {
    return domain[1];
  }
  return domain[0];
});
_defineProperty$2(Area, "getComposedData", function(_ref2) {
  var props = _ref2.props, item = _ref2.item, xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, bandSize = _ref2.bandSize, dataKey = _ref2.dataKey, stackedData = _ref2.stackedData, dataStartIndex = _ref2.dataStartIndex, displayedData = _ref2.displayedData, offset = _ref2.offset;
  var layout = props.layout;
  var hasStack = stackedData && stackedData.length;
  var baseValue = Area.getBaseValue(props, item, xAxis, yAxis);
  var isRange = false;
  var points = displayedData.map(function(entry, index) {
    var originalValue = getValueByDataKey(entry, dataKey);
    var value;
    if (hasStack) {
      value = stackedData[dataStartIndex + index];
    } else {
      value = originalValue;
      if (!_isArray(value)) {
        value = [baseValue, value];
      } else {
        isRange = true;
      }
    }
    var isBreakPoint = _isNil(value[1]) || hasStack && _isNil(originalValue);
    if (layout === "horizontal") {
      return {
        x: getCateCoordinateOfLine({
          axis: xAxis,
          ticks: xAxisTicks,
          bandSize,
          entry,
          index
        }),
        y: isBreakPoint ? null : yAxis.scale(value[1]),
        value,
        payload: entry
      };
    }
    return {
      x: isBreakPoint ? null : xAxis.scale(value[1]),
      y: getCateCoordinateOfLine({
        axis: yAxis,
        ticks: yAxisTicks,
        bandSize,
        entry,
        index
      }),
      value,
      payload: entry
    };
  });
  var baseLine;
  if (hasStack || isRange) {
    baseLine = points.map(function(entry) {
      if (layout === "horizontal") {
        return {
          x: entry.x,
          y: !_isNil(_get(entry, "value[0]")) && !_isNil(_get(entry, "y")) ? yAxis.scale(_get(entry, "value[0]")) : null
        };
      }
      return {
        x: !_isNil(_get(entry, "value[0]")) ? xAxis.scale(_get(entry, "value[0]")) : null,
        y: entry.y
      };
    });
  } else if (layout === "horizontal") {
    baseLine = yAxis.scale(baseValue);
  } else {
    baseLine = xAxis.scale(baseValue);
  }
  return _objectSpread$2({
    points,
    baseLine,
    layout,
    isRange
  }, offset);
});
_defineProperty$2(Area, "renderDotItem", function(option, props) {
  var dotItem;
  if (/* @__PURE__ */ React.isValidElement(option)) {
    dotItem = /* @__PURE__ */ React.cloneElement(option, props);
  } else if (_isFunction(option)) {
    dotItem = option(props);
  } else {
    dotItem = /* @__PURE__ */ React.createElement(Dot, _extends$2({}, props, {
      className: "recharts-area-dot"
    }));
  }
  return dotItem;
});
var ZAxis = function ZAxis2() {
  return null;
};
ZAxis.displayName = "ZAxis";
ZAxis.defaultProps = {
  zAxisId: 0,
  range: [64, 64],
  scale: "auto",
  type: "number"
};
function _typeof$1(obj) {
  "@babel/helpers - typeof";
  return _typeof$1 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof$1(obj);
}
function _extends$1() {
  _extends$1 = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends$1.apply(this, arguments);
}
function ownKeys$1(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread$1(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _classCallCheck$1(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties$1(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey$1(descriptor.key), descriptor);
  }
}
function _createClass$1(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties$1(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties$1(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits$1(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf$1(subClass, superClass);
}
function _setPrototypeOf$1(o, p2) {
  _setPrototypeOf$1 = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf$1(o, p2);
}
function _createSuper$1(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct$1();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf$1(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf$1(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn$1(this, result);
  };
}
function _possibleConstructorReturn$1(self2, call) {
  if (call && (_typeof$1(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized$1(self2);
}
function _assertThisInitialized$1(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct$1() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf$1(o) {
  _getPrototypeOf$1 = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf$1(o);
}
function _defineProperty$1(obj, key, value) {
  key = _toPropertyKey$1(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey$1(arg) {
  var key = _toPrimitive$1(arg, "string");
  return _typeof$1(key) === "symbol" ? key : String(key);
}
function _toPrimitive$1(input2, hint) {
  if (_typeof$1(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof$1(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var Scatter = /* @__PURE__ */ function(_PureComponent) {
  _inherits$1(Scatter2, _PureComponent);
  var _super = _createSuper$1(Scatter2);
  function Scatter2() {
    var _this;
    _classCallCheck$1(this, Scatter2);
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    _this = _super.call.apply(_super, [this].concat(args));
    _defineProperty$1(_assertThisInitialized$1(_this), "state", {
      isAnimationFinished: false
    });
    _defineProperty$1(_assertThisInitialized$1(_this), "handleAnimationEnd", function() {
      _this.setState({
        isAnimationFinished: true
      });
    });
    _defineProperty$1(_assertThisInitialized$1(_this), "handleAnimationStart", function() {
      _this.setState({
        isAnimationFinished: false
      });
    });
    _defineProperty$1(_assertThisInitialized$1(_this), "id", uniqueId("recharts-scatter-"));
    return _this;
  }
  _createClass$1(Scatter2, [{
    key: "renderSymbolsStatically",
    value: function renderSymbolsStatically(points) {
      var _this2 = this;
      var _this$props = this.props, shape = _this$props.shape, activeShape = _this$props.activeShape, activeIndex = _this$props.activeIndex;
      var baseProps = filterProps(this.props);
      return points.map(function(entry, i) {
        var props = _objectSpread$1(_objectSpread$1({
          key: "symbol-".concat(i)
        }, baseProps), entry);
        return /* @__PURE__ */ React.createElement(Layer, _extends$1({
          className: "recharts-scatter-symbol"
        }, adaptEventsOfChild(_this2.props, entry, i), {
          key: "symbol-".concat(i),
          role: "img"
        }), Scatter2.renderSymbolItem(activeIndex === i ? activeShape : shape, props));
      });
    }
  }, {
    key: "renderSymbolsWithAnimation",
    value: function renderSymbolsWithAnimation() {
      var _this3 = this;
      var _this$props2 = this.props, points = _this$props2.points, isAnimationActive = _this$props2.isAnimationActive, animationBegin = _this$props2.animationBegin, animationDuration = _this$props2.animationDuration, animationEasing = _this$props2.animationEasing, animationId = _this$props2.animationId;
      var prevPoints = this.state.prevPoints;
      return /* @__PURE__ */ React.createElement(Animate, {
        begin: animationBegin,
        duration: animationDuration,
        isActive: isAnimationActive,
        easing: animationEasing,
        from: {
          t: 0
        },
        to: {
          t: 1
        },
        key: "pie-".concat(animationId),
        onAnimationEnd: this.handleAnimationEnd,
        onAnimationStart: this.handleAnimationStart
      }, function(_ref) {
        var t2 = _ref.t;
        var stepData = points.map(function(entry, index) {
          var prev = prevPoints && prevPoints[index];
          if (prev) {
            var interpolatorCx = interpolateNumber$2(prev.cx, entry.cx);
            var interpolatorCy = interpolateNumber$2(prev.cy, entry.cy);
            var interpolatorSize = interpolateNumber$2(prev.size, entry.size);
            return _objectSpread$1(_objectSpread$1({}, entry), {}, {
              cx: interpolatorCx(t2),
              cy: interpolatorCy(t2),
              size: interpolatorSize(t2)
            });
          }
          var interpolator = interpolateNumber$2(0, entry.size);
          return _objectSpread$1(_objectSpread$1({}, entry), {}, {
            size: interpolator(t2)
          });
        });
        return /* @__PURE__ */ React.createElement(Layer, null, _this3.renderSymbolsStatically(stepData));
      });
    }
  }, {
    key: "renderSymbols",
    value: function renderSymbols() {
      var _this$props3 = this.props, points = _this$props3.points, isAnimationActive = _this$props3.isAnimationActive;
      var prevPoints = this.state.prevPoints;
      if (isAnimationActive && points && points.length && (!prevPoints || !_isEqual(prevPoints, points))) {
        return this.renderSymbolsWithAnimation();
      }
      return this.renderSymbolsStatically(points);
    }
  }, {
    key: "renderErrorBar",
    value: function renderErrorBar() {
      var isAnimationActive = this.props.isAnimationActive;
      if (isAnimationActive && !this.state.isAnimationFinished) {
        return null;
      }
      var _this$props4 = this.props, points = _this$props4.points, xAxis = _this$props4.xAxis, yAxis = _this$props4.yAxis, children = _this$props4.children;
      var errorBarItems = findAllByType(children, ErrorBar);
      if (!errorBarItems) {
        return null;
      }
      function dataPointFormatterY(dataPoint, dataKey) {
        return {
          x: dataPoint.cx,
          y: dataPoint.cy,
          value: +dataPoint.node.y,
          errorVal: getValueByDataKey(dataPoint, dataKey)
        };
      }
      function dataPointFormatterX(dataPoint, dataKey) {
        return {
          x: dataPoint.cx,
          y: dataPoint.cy,
          value: +dataPoint.node.x,
          errorVal: getValueByDataKey(dataPoint, dataKey)
        };
      }
      return errorBarItems.map(function(item, i) {
        var direction = item.props.direction;
        return /* @__PURE__ */ React.cloneElement(item, {
          key: i,
          // eslint-disable-line react/no-array-index-key
          data: points,
          xAxis,
          yAxis,
          layout: direction === "x" ? "vertical" : "horizontal",
          dataPointFormatter: direction === "x" ? dataPointFormatterX : dataPointFormatterY
        });
      });
    }
  }, {
    key: "renderLine",
    value: function renderLine3() {
      var _this$props5 = this.props, points = _this$props5.points, line = _this$props5.line, lineType = _this$props5.lineType, lineJointType = _this$props5.lineJointType;
      var scatterProps = filterProps(this.props);
      var customLineProps = filterProps(line);
      var linePoints, lineItem;
      if (lineType === "joint") {
        linePoints = points.map(function(entry) {
          return {
            x: entry.cx,
            y: entry.cy
          };
        });
      } else if (lineType === "fitting") {
        var _getLinearRegression = getLinearRegression(points), xmin = _getLinearRegression.xmin, xmax = _getLinearRegression.xmax, a2 = _getLinearRegression.a, b2 = _getLinearRegression.b;
        var linearExp = function linearExp2(x2) {
          return a2 * x2 + b2;
        };
        linePoints = [{
          x: xmin,
          y: linearExp(xmin)
        }, {
          x: xmax,
          y: linearExp(xmax)
        }];
      }
      var lineProps = _objectSpread$1(_objectSpread$1(_objectSpread$1({}, scatterProps), {}, {
        fill: "none",
        stroke: scatterProps && scatterProps.fill
      }, customLineProps), {}, {
        points: linePoints
      });
      if (/* @__PURE__ */ React.isValidElement(line)) {
        lineItem = /* @__PURE__ */ React.cloneElement(line, lineProps);
      } else if (_isFunction(line)) {
        lineItem = line(lineProps);
      } else {
        lineItem = /* @__PURE__ */ React.createElement(Curve, _extends$1({}, lineProps, {
          type: lineJointType
        }));
      }
      return /* @__PURE__ */ React.createElement(Layer, {
        className: "recharts-scatter-line",
        key: "recharts-scatter-line"
      }, lineItem);
    }
  }, {
    key: "render",
    value: function render() {
      var _this$props6 = this.props, hide = _this$props6.hide, points = _this$props6.points, line = _this$props6.line, className = _this$props6.className, xAxis = _this$props6.xAxis, yAxis = _this$props6.yAxis, left = _this$props6.left, top = _this$props6.top, width = _this$props6.width, height = _this$props6.height, id = _this$props6.id, isAnimationActive = _this$props6.isAnimationActive;
      if (hide || !points || !points.length) {
        return null;
      }
      var isAnimationFinished = this.state.isAnimationFinished;
      var layerClass = classNames("recharts-scatter", className);
      var needClip = xAxis && xAxis.allowDataOverflow || yAxis && yAxis.allowDataOverflow;
      var clipPathId = _isNil(id) ? this.id : id;
      return /* @__PURE__ */ React.createElement(Layer, {
        className: layerClass,
        clipPath: needClip ? "url(#clipPath-".concat(clipPathId, ")") : null
      }, needClip ? /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
        id: "clipPath-".concat(clipPathId)
      }, /* @__PURE__ */ React.createElement("rect", {
        x: left,
        y: top,
        width,
        height
      }))) : null, line && this.renderLine(), this.renderErrorBar(), /* @__PURE__ */ React.createElement(Layer, {
        key: "recharts-scatter-symbols"
      }, this.renderSymbols()), (!isAnimationActive || isAnimationFinished) && LabelList.renderCallByParent(this.props, points));
    }
  }], [{
    key: "getDerivedStateFromProps",
    value: function getDerivedStateFromProps(nextProps, prevState) {
      if (nextProps.animationId !== prevState.prevAnimationId) {
        return {
          prevAnimationId: nextProps.animationId,
          curPoints: nextProps.points,
          prevPoints: prevState.curPoints
        };
      }
      if (nextProps.points !== prevState.curPoints) {
        return {
          curPoints: nextProps.points
        };
      }
      return null;
    }
  }, {
    key: "renderSymbolItem",
    value: function renderSymbolItem(option, props) {
      var symbol;
      if (/* @__PURE__ */ React.isValidElement(option)) {
        symbol = /* @__PURE__ */ React.cloneElement(option, props);
      } else if (_isFunction(option)) {
        symbol = option(props);
      } else if (typeof option === "string") {
        symbol = /* @__PURE__ */ React.createElement(Symbols, _extends$1({}, props, {
          type: option
        }));
      }
      return symbol;
    }
  }]);
  return Scatter2;
}(reactExports.PureComponent);
_defineProperty$1(Scatter, "displayName", "Scatter");
_defineProperty$1(Scatter, "defaultProps", {
  xAxisId: 0,
  yAxisId: 0,
  zAxisId: 0,
  legendType: "circle",
  lineType: "joint",
  lineJointType: "linear",
  data: [],
  shape: "circle",
  hide: false,
  isAnimationActive: !Global.isSsr,
  animationBegin: 0,
  animationDuration: 400,
  animationEasing: "linear"
});
_defineProperty$1(Scatter, "getComposedData", function(_ref2) {
  var xAxis = _ref2.xAxis, yAxis = _ref2.yAxis, zAxis = _ref2.zAxis, item = _ref2.item, displayedData = _ref2.displayedData, xAxisTicks = _ref2.xAxisTicks, yAxisTicks = _ref2.yAxisTicks, offset = _ref2.offset;
  var tooltipType = item.props.tooltipType;
  var cells = findAllByType(item.props.children, Cell);
  var xAxisDataKey = _isNil(xAxis.dataKey) ? item.props.dataKey : xAxis.dataKey;
  var yAxisDataKey = _isNil(yAxis.dataKey) ? item.props.dataKey : yAxis.dataKey;
  var zAxisDataKey = zAxis && zAxis.dataKey;
  var defaultRangeZ = zAxis ? zAxis.range : ZAxis.defaultProps.range;
  var defaultZ = defaultRangeZ && defaultRangeZ[0];
  var xBandSize = xAxis.scale.bandwidth ? xAxis.scale.bandwidth() : 0;
  var yBandSize = yAxis.scale.bandwidth ? yAxis.scale.bandwidth() : 0;
  var points = displayedData.map(function(entry, index) {
    var x2 = getValueByDataKey(entry, xAxisDataKey);
    var y2 = getValueByDataKey(entry, yAxisDataKey);
    var z2 = !_isNil(zAxisDataKey) && getValueByDataKey(entry, zAxisDataKey) || "-";
    var tooltipPayload = [{
      name: _isNil(xAxis.dataKey) ? item.props.name : xAxis.name || xAxis.dataKey,
      unit: xAxis.unit || "",
      value: x2,
      payload: entry,
      dataKey: xAxisDataKey,
      type: tooltipType
    }, {
      name: _isNil(yAxis.dataKey) ? item.props.name : yAxis.name || yAxis.dataKey,
      unit: yAxis.unit || "",
      value: y2,
      payload: entry,
      dataKey: yAxisDataKey,
      type: tooltipType
    }];
    if (z2 !== "-") {
      tooltipPayload.push({
        name: zAxis.name || zAxis.dataKey,
        unit: zAxis.unit || "",
        value: z2,
        payload: entry,
        dataKey: zAxisDataKey,
        type: tooltipType
      });
    }
    var cx = getCateCoordinateOfLine({
      axis: xAxis,
      ticks: xAxisTicks,
      bandSize: xBandSize,
      entry,
      index,
      dataKey: xAxisDataKey
    });
    var cy = getCateCoordinateOfLine({
      axis: yAxis,
      ticks: yAxisTicks,
      bandSize: yBandSize,
      entry,
      index,
      dataKey: yAxisDataKey
    });
    var size = z2 !== "-" ? zAxis.scale(z2) : defaultZ;
    var radius = Math.sqrt(Math.max(size, 0) / Math.PI);
    return _objectSpread$1(_objectSpread$1({}, entry), {}, {
      cx,
      cy,
      x: cx - radius,
      y: cy - radius,
      xAxis,
      yAxis,
      zAxis,
      width: 2 * radius,
      height: 2 * radius,
      size,
      node: {
        x: x2,
        y: y2,
        z: z2
      },
      tooltipPayload,
      tooltipPosition: {
        x: cx,
        y: cy
      },
      payload: entry
    }, cells && cells[index] && cells[index].props);
  });
  return _objectSpread$1({
    points
  }, offset);
});
var XAxis = function XAxis2() {
  return null;
};
XAxis.displayName = "XAxis";
XAxis.defaultProps = {
  allowDecimals: true,
  hide: false,
  orientation: "bottom",
  width: 0,
  height: 30,
  mirror: false,
  xAxisId: 0,
  tickCount: 5,
  type: "category",
  padding: {
    left: 0,
    right: 0
  },
  allowDataOverflow: false,
  scale: "auto",
  reversed: false,
  allowDuplicatedCategory: true
};
var YAxis = function YAxis2() {
  return null;
};
YAxis.displayName = "YAxis";
YAxis.defaultProps = {
  allowDuplicatedCategory: true,
  allowDecimals: true,
  hide: false,
  orientation: "left",
  width: 60,
  height: 0,
  mirror: false,
  yAxisId: 0,
  tickCount: 5,
  type: "number",
  padding: {
    top: 0,
    bottom: 0
  },
  allowDataOverflow: false,
  scale: "auto",
  reversed: false
};
var baseIteratee$1 = _baseIteratee, isArrayLike = isArrayLike_1, keys = keys_1;
function createFind$1(findIndexFunc) {
  return function(collection, predicate, fromIndex) {
    var iterable = Object(collection);
    if (!isArrayLike(collection)) {
      var iteratee = baseIteratee$1(predicate);
      collection = keys(collection);
      predicate = function(key) {
        return iteratee(iterable[key], key, iterable);
      };
    }
    var index = findIndexFunc(collection, predicate, fromIndex);
    return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
  };
}
var _createFind = createFind$1;
var toFinite = toFinite_1;
function toInteger$1(value) {
  var result = toFinite(value), remainder = result % 1;
  return result === result ? remainder ? result - remainder : result : 0;
}
var toInteger_1 = toInteger$1;
var baseFindIndex = _baseFindIndex, baseIteratee = _baseIteratee, toInteger = toInteger_1;
var nativeMax$1 = Math.max;
function findIndex$1(array2, predicate, fromIndex) {
  var length = array2 == null ? 0 : array2.length;
  if (!length) {
    return -1;
  }
  var index = fromIndex == null ? 0 : toInteger(fromIndex);
  if (index < 0) {
    index = nativeMax$1(length + index, 0);
  }
  return baseFindIndex(array2, baseIteratee(predicate), index);
}
var findIndex_1 = findIndex$1;
var createFind = _createFind, findIndex = findIndex_1;
var find = createFind(findIndex);
var find_1 = find;
const _find = /* @__PURE__ */ getDefaultExportFromCjs(find_1);
var root = _root$1;
var now$1 = function() {
  return root.Date.now();
};
var now_1 = now$1;
var isObject$1 = isObject_1$1, now = now_1, toNumber = toNumber_1;
var FUNC_ERROR_TEXT$1 = "Expected a function";
var nativeMax = Math.max, nativeMin = Math.min;
function debounce$1(func, wait, options) {
  var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT$1);
  }
  wait = toNumber(wait) || 0;
  if (isObject$1(options)) {
    leading = !!options.leading;
    maxing = "maxWait" in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  function invokeFunc(time2) {
    var args = lastArgs, thisArg = lastThis;
    lastArgs = lastThis = void 0;
    lastInvokeTime = time2;
    result = func.apply(thisArg, args);
    return result;
  }
  function leadingEdge(time2) {
    lastInvokeTime = time2;
    timerId = setTimeout(timerExpired, wait);
    return leading ? invokeFunc(time2) : result;
  }
  function remainingWait(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
    return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
  }
  function shouldInvoke(time2) {
    var timeSinceLastCall = time2 - lastCallTime, timeSinceLastInvoke = time2 - lastInvokeTime;
    return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
  }
  function timerExpired() {
    var time2 = now();
    if (shouldInvoke(time2)) {
      return trailingEdge(time2);
    }
    timerId = setTimeout(timerExpired, remainingWait(time2));
  }
  function trailingEdge(time2) {
    timerId = void 0;
    if (trailing && lastArgs) {
      return invokeFunc(time2);
    }
    lastArgs = lastThis = void 0;
    return result;
  }
  function cancel() {
    if (timerId !== void 0) {
      clearTimeout(timerId);
    }
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = void 0;
  }
  function flush() {
    return timerId === void 0 ? result : trailingEdge(now());
  }
  function debounced() {
    var time2 = now(), isInvoking = shouldInvoke(time2);
    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time2;
    if (isInvoking) {
      if (timerId === void 0) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        clearTimeout(timerId);
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === void 0) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}
var debounce_1 = debounce$1;
var debounce = debounce_1, isObject = isObject_1$1;
var FUNC_ERROR_TEXT = "Expected a function";
function throttle(func, wait, options) {
  var leading = true, trailing = true;
  if (typeof func != "function") {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = "leading" in options ? !!options.leading : leading;
    trailing = "trailing" in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    "leading": leading,
    "maxWait": wait,
    "trailing": trailing
  });
}
var throttle_1 = throttle;
const _throttle = /* @__PURE__ */ getDefaultExportFromCjs(throttle_1);
var baseGetTag = _baseGetTag$1, isObjectLike = isObjectLike_1$1;
var boolTag = "[object Boolean]";
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
}
var isBoolean_1 = isBoolean;
const _isBoolean = /* @__PURE__ */ getDefaultExportFromCjs(isBoolean_1);
function _toConsumableArray$1(arr) {
  return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _unsupportedIterableToArray$1(arr) || _nonIterableSpread$1();
}
function _nonIterableSpread$1() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray$1(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray$1(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray$1(o, minLen);
}
function _iterableToArray$1(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles$1(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray$1(arr);
}
function _arrayLikeToArray$1(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
var detectReferenceElementsDomain = function detectReferenceElementsDomain2(children, domain, axisId, axisType, specifiedTicks) {
  var lines = findAllByType(children, ReferenceLine);
  var dots = findAllByType(children, ReferenceDot);
  var elements = [].concat(_toConsumableArray$1(lines), _toConsumableArray$1(dots));
  var areas = findAllByType(children, ReferenceArea);
  var idKey = "".concat(axisType, "Id");
  var valueKey = axisType[0];
  var finalDomain = domain;
  if (elements.length) {
    finalDomain = elements.reduce(function(result, el) {
      if (el.props[idKey] === axisId && ifOverflowMatches(el.props, "extendDomain") && isNumber(el.props[valueKey])) {
        var value = el.props[valueKey];
        return [Math.min(result[0], value), Math.max(result[1], value)];
      }
      return result;
    }, finalDomain);
  }
  if (areas.length) {
    var key1 = "".concat(valueKey, "1");
    var key2 = "".concat(valueKey, "2");
    finalDomain = areas.reduce(function(result, el) {
      if (el.props[idKey] === axisId && ifOverflowMatches(el.props, "extendDomain") && isNumber(el.props[key1]) && isNumber(el.props[key2])) {
        var value1 = el.props[key1];
        var value2 = el.props[key2];
        return [Math.min(result[0], value1, value2), Math.max(result[1], value1, value2)];
      }
      return result;
    }, finalDomain);
  }
  if (specifiedTicks && specifiedTicks.length) {
    finalDomain = specifiedTicks.reduce(function(result, tick) {
      if (isNumber(tick)) {
        return [Math.min(result[0], tick), Math.max(result[1], tick)];
      }
      return result;
    }, finalDomain);
  }
  return finalDomain;
};
var eventemitter3 = { exports: {} };
(function(module) {
  var has = Object.prototype.hasOwnProperty, prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = /* @__PURE__ */ Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter2() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter2.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter2.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l2 = handlers.length, ee = new Array(l2); i < l2; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter2.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter2.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter2.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter2.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter2.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter2.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter2.prototype.off = EventEmitter2.prototype.removeListener;
  EventEmitter2.prototype.addListener = EventEmitter2.prototype.on;
  EventEmitter2.prefixed = prefix;
  EventEmitter2.EventEmitter = EventEmitter2;
  {
    module.exports = EventEmitter2;
  }
})(eventemitter3);
var eventemitter3Exports = eventemitter3.exports;
const EventEmitter = /* @__PURE__ */ getDefaultExportFromCjs(eventemitter3Exports);
var eventCenter = new EventEmitter();
if (eventCenter.setMaxListeners) {
  eventCenter.setMaxListeners(10);
}
var SYNC_EVENT = "recharts.syncMouseEvents";
var _excluded = ["item"], _excluded2 = ["children", "className", "width", "height", "style", "compact", "title", "desc"];
function _typeof(obj) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj2) {
    return typeof obj2;
  } : function(obj2) {
    return obj2 && "function" == typeof Symbol && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
  }, _typeof(obj);
}
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _iterableToArrayLimit(arr, i) {
  var _i = null == arr ? null : "undefined" != typeof Symbol && arr[Symbol.iterator] || arr["@@iterator"];
  if (null != _i) {
    var _s, _e, _x, _r, _arr = [], _n = true, _d = false;
    try {
      if (_x = (_i = _i.call(arr)).next, 0 === i) {
        if (Object(_i) !== _i)
          return;
        _n = false;
      } else
        for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = true)
          ;
    } catch (err) {
      _d = true, _e = err;
    } finally {
      try {
        if (!_n && null != _i["return"] && (_r = _i["return"](), Object(_r) !== _r))
          return;
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function _objectWithoutProperties(source, excluded) {
  if (source == null)
    return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0)
        continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key))
        continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null)
    return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;
  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0)
      continue;
    target[key] = source[key];
  }
  return target;
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", { writable: false });
  return Constructor;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
  Object.defineProperty(subClass, "prototype", { writable: false });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _setPrototypeOf(o, p2) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf2(o2, p3) {
    o2.__proto__ = p3;
    return o2;
  };
  return _setPrototypeOf(o, p2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _possibleConstructorReturn(self2, call) {
  if (call && (_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }
  return _assertThisInitialized(self2);
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {
    }));
    return true;
  } catch (e3) {
    return false;
  }
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n2 = Object.prototype.toString.call(o).slice(8, -1);
  if (n2 === "Object" && o.constructor)
    n2 = o.constructor.name;
  if (n2 === "Map" || n2 === "Set")
    return Array.from(o);
  if (n2 === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n2))
    return _arrayLikeToArray(o, minLen);
}
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null)
    return Array.from(iter);
}
function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr))
    return _arrayLikeToArray(arr);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}
function ownKeys(object2, enumerableOnly) {
  var keys2 = Object.keys(object2);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object2);
    enumerableOnly && (symbols = symbols.filter(function(sym) {
      return Object.getOwnPropertyDescriptor(object2, sym).enumerable;
    })), keys2.push.apply(keys2, symbols);
  }
  return keys2;
}
function _objectSpread(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }
  return target;
}
function _defineProperty(obj, key, value) {
  key = _toPropertyKey(key);
  if (key in obj) {
    Object.defineProperty(obj, key, { value, enumerable: true, configurable: true, writable: true });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _toPropertyKey(arg) {
  var key = _toPrimitive(arg, "string");
  return _typeof(key) === "symbol" ? key : String(key);
}
function _toPrimitive(input2, hint) {
  if (_typeof(input2) !== "object" || input2 === null)
    return input2;
  var prim = input2[Symbol.toPrimitive];
  if (prim !== void 0) {
    var res = prim.call(input2, hint || "default");
    if (_typeof(res) !== "object")
      return res;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (hint === "string" ? String : Number)(input2);
}
var ORIENT_MAP = {
  xAxis: ["bottom", "top"],
  yAxis: ["left", "right"]
};
var originCoordinate = {
  x: 0,
  y: 0
};
var isFinit = Number.isFinite ? Number.isFinite : isFinite;
var defer = (
  // eslint-disable-next-line no-nested-ternary
  typeof requestAnimationFrame === "function" ? requestAnimationFrame : typeof setImmediate === "function" ? setImmediate : setTimeout
);
var deferClear = (
  // eslint-disable-next-line no-nested-ternary
  typeof cancelAnimationFrame === "function" ? cancelAnimationFrame : typeof clearImmediate === "function" ? clearImmediate : clearTimeout
);
var calculateTooltipPos = function calculateTooltipPos2(rangeObj, layout) {
  if (layout === "horizontal") {
    return rangeObj.x;
  }
  if (layout === "vertical") {
    return rangeObj.y;
  }
  if (layout === "centric") {
    return rangeObj.angle;
  }
  return rangeObj.radius;
};
var getActiveCoordinate = function getActiveCoordinate2(layout, tooltipTicks, activeIndex, rangeObj) {
  var entry = tooltipTicks.find(function(tick) {
    return tick && tick.index === activeIndex;
  });
  if (entry) {
    if (layout === "horizontal") {
      return {
        x: entry.coordinate,
        y: rangeObj.y
      };
    }
    if (layout === "vertical") {
      return {
        x: rangeObj.x,
        y: entry.coordinate
      };
    }
    if (layout === "centric") {
      var _angle = entry.coordinate;
      var _radius = rangeObj.radius;
      return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, _radius, _angle)), {}, {
        angle: _angle,
        radius: _radius
      });
    }
    var radius = entry.coordinate;
    var angle = rangeObj.angle;
    return _objectSpread(_objectSpread(_objectSpread({}, rangeObj), polarToCartesian(rangeObj.cx, rangeObj.cy, radius, angle)), {}, {
      angle,
      radius
    });
  }
  return originCoordinate;
};
var getDisplayedData = function getDisplayedData2(data, _ref, item) {
  var graphicalItems = _ref.graphicalItems, dataStartIndex = _ref.dataStartIndex, dataEndIndex = _ref.dataEndIndex;
  var itemsData = (graphicalItems || []).reduce(function(result, child) {
    var itemData = child.props.data;
    if (itemData && itemData.length) {
      return [].concat(_toConsumableArray(result), _toConsumableArray(itemData));
    }
    return result;
  }, []);
  if (itemsData && itemsData.length > 0) {
    return itemsData;
  }
  if (item && item.props && item.props.data && item.props.data.length > 0) {
    return item.props.data;
  }
  if (data && data.length && isNumber(dataStartIndex) && isNumber(dataEndIndex)) {
    return data.slice(dataStartIndex, dataEndIndex + 1);
  }
  return [];
};
function isDomainSpecifiedByUser(domain, allowDataOverflow, axisType) {
  if (axisType === "number" && allowDataOverflow === true && Array.isArray(domain)) {
    var domainStart = domain === null || domain === void 0 ? void 0 : domain[0];
    var domainEnd = domain === null || domain === void 0 ? void 0 : domain[1];
    if (!!domainStart && !!domainEnd && isNumber(domainStart) && isNumber(domainEnd)) {
      return true;
    }
  }
  return false;
}
function getDefaultDomainByAxisType(axisType) {
  return axisType === "number" ? [0, "auto"] : void 0;
}
var getTooltipContent = function getTooltipContent2(state, chartData, activeIndex, activeLabel) {
  var graphicalItems = state.graphicalItems, tooltipAxis = state.tooltipAxis;
  var displayedData = getDisplayedData(chartData, state);
  if (activeIndex < 0 || !graphicalItems || !graphicalItems.length || activeIndex >= displayedData.length) {
    return null;
  }
  return graphicalItems.reduce(function(result, child) {
    var hide = child.props.hide;
    if (hide) {
      return result;
    }
    var data = child.props.data;
    var payload;
    if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
      var entries = data === void 0 ? displayedData : data;
      payload = findEntryInArray(entries, tooltipAxis.dataKey, activeLabel);
    } else {
      payload = data && data[activeIndex] || displayedData[activeIndex];
    }
    if (!payload) {
      return result;
    }
    return [].concat(_toConsumableArray(result), [getTooltipItem(child, payload)]);
  }, []);
};
var getTooltipData = function getTooltipData2(state, chartData, layout, rangeObj) {
  var rangeData = rangeObj || {
    x: state.chartX,
    y: state.chartY
  };
  var pos = calculateTooltipPos(rangeData, layout);
  var ticks2 = state.orderedTooltipTicks, axis = state.tooltipAxis, tooltipTicks = state.tooltipTicks;
  var activeIndex = calculateActiveTickIndex(pos, ticks2, tooltipTicks, axis);
  if (activeIndex >= 0 && tooltipTicks) {
    var activeLabel = tooltipTicks[activeIndex] && tooltipTicks[activeIndex].value;
    var activePayload = getTooltipContent(state, chartData, activeIndex, activeLabel);
    var activeCoordinate = getActiveCoordinate(layout, ticks2, activeIndex, rangeData);
    return {
      activeTooltipIndex: activeIndex,
      activeLabel,
      activePayload,
      activeCoordinate
    };
  }
  return null;
};
var getAxisMapByAxes = function getAxisMapByAxes2(props, _ref2) {
  var axes = _ref2.axes, graphicalItems = _ref2.graphicalItems, axisType = _ref2.axisType, axisIdKey = _ref2.axisIdKey, stackGroups = _ref2.stackGroups, dataStartIndex = _ref2.dataStartIndex, dataEndIndex = _ref2.dataEndIndex;
  var layout = props.layout, children = props.children, stackOffset = props.stackOffset;
  var isCategorical = isCategoricalAxis(layout, axisType);
  var axisMap = axes.reduce(function(result, child) {
    var _child$props$domain2;
    var _child$props = child.props, type = _child$props.type, dataKey = _child$props.dataKey, allowDataOverflow = _child$props.allowDataOverflow, allowDuplicatedCategory = _child$props.allowDuplicatedCategory, scale2 = _child$props.scale, ticks2 = _child$props.ticks;
    var axisId = child.props[axisIdKey];
    if (result[axisId]) {
      return result;
    }
    var displayedData = getDisplayedData(props.data, {
      graphicalItems: graphicalItems.filter(function(item) {
        return item.props[axisIdKey] === axisId;
      }),
      dataStartIndex,
      dataEndIndex
    });
    var len = displayedData.length;
    var domain, duplicateDomain, categoricalDomain;
    if (isDomainSpecifiedByUser(child.props.domain, allowDataOverflow, type)) {
      domain = parseSpecifiedDomain(child.props.domain, null, allowDataOverflow);
      if (isCategorical && (type === "number" || scale2 !== "auto")) {
        categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
      }
    }
    var defaultDomain = getDefaultDomainByAxisType(type);
    if (!domain || domain.length === 0) {
      var _child$props$domain;
      var childDomain = (_child$props$domain = child.props.domain) !== null && _child$props$domain !== void 0 ? _child$props$domain : defaultDomain;
      if (dataKey) {
        domain = getDomainOfDataByKey(displayedData, dataKey, type);
        if (type === "category" && isCategorical) {
          var duplicate = hasDuplicate(domain);
          if (allowDuplicatedCategory && duplicate) {
            duplicateDomain = domain;
            domain = _range(0, len);
          } else if (!allowDuplicatedCategory) {
            domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
              return finalDomain.indexOf(entry) >= 0 ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
            }, []);
          }
        } else if (type === "category") {
          if (!allowDuplicatedCategory) {
            domain = parseDomainOfCategoryAxis(childDomain, domain, child).reduce(function(finalDomain, entry) {
              return finalDomain.indexOf(entry) >= 0 || entry === "" || _isNil(entry) ? finalDomain : [].concat(_toConsumableArray(finalDomain), [entry]);
            }, []);
          } else {
            domain = domain.filter(function(entry) {
              return entry !== "" && !_isNil(entry);
            });
          }
        } else if (type === "number") {
          var errorBarsDomain = parseErrorBarsOfAxis(displayedData, graphicalItems.filter(function(item) {
            return item.props[axisIdKey] === axisId && !item.props.hide;
          }), dataKey, axisType, layout);
          if (errorBarsDomain) {
            domain = errorBarsDomain;
          }
        }
        if (isCategorical && (type === "number" || scale2 !== "auto")) {
          categoricalDomain = getDomainOfDataByKey(displayedData, dataKey, "category");
        }
      } else if (isCategorical) {
        domain = _range(0, len);
      } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack && type === "number") {
        domain = stackOffset === "expand" ? [0, 1] : getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
      } else {
        domain = getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
          return item.props[axisIdKey] === axisId && !item.props.hide;
        }), type, layout, true);
      }
      if (type === "number") {
        domain = detectReferenceElementsDomain(children, domain, axisId, axisType, ticks2);
        if (childDomain) {
          domain = parseSpecifiedDomain(childDomain, domain, allowDataOverflow);
        }
      } else if (type === "category" && childDomain) {
        var axisDomain = childDomain;
        var isDomainValid = domain.every(function(entry) {
          return axisDomain.indexOf(entry) >= 0;
        });
        if (isDomainValid) {
          domain = axisDomain;
        }
      }
    }
    return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({}, child.props), {}, {
      axisType,
      domain,
      categoricalDomain,
      duplicateDomain,
      originalDomain: (_child$props$domain2 = child.props.domain) !== null && _child$props$domain2 !== void 0 ? _child$props$domain2 : defaultDomain,
      isCategorical,
      layout
    })));
  }, {});
  return axisMap;
};
var getAxisMapByItems = function getAxisMapByItems2(props, _ref3) {
  var graphicalItems = _ref3.graphicalItems, Axis = _ref3.Axis, axisType = _ref3.axisType, axisIdKey = _ref3.axisIdKey, stackGroups = _ref3.stackGroups, dataStartIndex = _ref3.dataStartIndex, dataEndIndex = _ref3.dataEndIndex;
  var layout = props.layout, children = props.children;
  var displayedData = getDisplayedData(props.data, {
    graphicalItems,
    dataStartIndex,
    dataEndIndex
  });
  var len = displayedData.length;
  var isCategorical = isCategoricalAxis(layout, axisType);
  var index = -1;
  var axisMap = graphicalItems.reduce(function(result, child) {
    var axisId = child.props[axisIdKey];
    var originalDomain = getDefaultDomainByAxisType("number");
    if (!result[axisId]) {
      index++;
      var domain;
      if (isCategorical) {
        domain = _range(0, len);
      } else if (stackGroups && stackGroups[axisId] && stackGroups[axisId].hasStack) {
        domain = getDomainOfStackGroups(stackGroups[axisId].stackGroups, dataStartIndex, dataEndIndex);
        domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
      } else {
        domain = parseSpecifiedDomain(originalDomain, getDomainOfItemsWithSameAxis(displayedData, graphicalItems.filter(function(item) {
          return item.props[axisIdKey] === axisId && !item.props.hide;
        }), "number", layout), Axis.defaultProps.allowDataOverflow);
        domain = detectReferenceElementsDomain(children, domain, axisId, axisType);
      }
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, axisId, _objectSpread(_objectSpread({
        axisType
      }, Axis.defaultProps), {}, {
        hide: true,
        orientation: _get(ORIENT_MAP, "".concat(axisType, ".").concat(index % 2), null),
        domain,
        originalDomain,
        isCategorical,
        layout
        // specify scale when no Axis
        // scale: isCategorical ? 'band' : 'linear',
      })));
    }
    return result;
  }, {});
  return axisMap;
};
var getAxisMap = function getAxisMap2(props, _ref4) {
  var _ref4$axisType = _ref4.axisType, axisType = _ref4$axisType === void 0 ? "xAxis" : _ref4$axisType, AxisComp = _ref4.AxisComp, graphicalItems = _ref4.graphicalItems, stackGroups = _ref4.stackGroups, dataStartIndex = _ref4.dataStartIndex, dataEndIndex = _ref4.dataEndIndex;
  var children = props.children;
  var axisIdKey = "".concat(axisType, "Id");
  var axes = findAllByType(children, AxisComp);
  var axisMap = {};
  if (axes && axes.length) {
    axisMap = getAxisMapByAxes(props, {
      axes,
      graphicalItems,
      axisType,
      axisIdKey,
      stackGroups,
      dataStartIndex,
      dataEndIndex
    });
  } else if (graphicalItems && graphicalItems.length) {
    axisMap = getAxisMapByItems(props, {
      Axis: AxisComp,
      graphicalItems,
      axisType,
      axisIdKey,
      stackGroups,
      dataStartIndex,
      dataEndIndex
    });
  }
  return axisMap;
};
var tooltipTicksGenerator = function tooltipTicksGenerator2(axisMap) {
  var axis = getAnyElementOfObject(axisMap);
  var tooltipTicks = getTicksOfAxis(axis, false, true);
  return {
    tooltipTicks,
    orderedTooltipTicks: _sortBy(tooltipTicks, function(o) {
      return o.coordinate;
    }),
    tooltipAxis: axis,
    tooltipAxisBandSize: getBandSizeOfAxis(axis, tooltipTicks)
  };
};
var createDefaultState = function createDefaultState2(props) {
  var _brushItem$props, _brushItem$props2;
  var children = props.children, defaultShowTooltip = props.defaultShowTooltip;
  var brushItem = findChildByType(children, Brush);
  var startIndex = brushItem && brushItem.props && brushItem.props.startIndex || 0;
  var endIndex = (brushItem === null || brushItem === void 0 ? void 0 : (_brushItem$props = brushItem.props) === null || _brushItem$props === void 0 ? void 0 : _brushItem$props.endIndex) !== void 0 ? brushItem === null || brushItem === void 0 ? void 0 : (_brushItem$props2 = brushItem.props) === null || _brushItem$props2 === void 0 ? void 0 : _brushItem$props2.endIndex : props.data && props.data.length - 1 || 0;
  return {
    chartX: 0,
    chartY: 0,
    dataStartIndex: startIndex,
    dataEndIndex: endIndex,
    activeTooltipIndex: -1,
    isTooltipActive: !_isNil(defaultShowTooltip) ? defaultShowTooltip : false
  };
};
var hasGraphicalBarItem = function hasGraphicalBarItem2(graphicalItems) {
  if (!graphicalItems || !graphicalItems.length) {
    return false;
  }
  return graphicalItems.some(function(item) {
    var name = getDisplayName(item && item.type);
    return name && name.indexOf("Bar") >= 0;
  });
};
var getAxisNameByLayout = function getAxisNameByLayout2(layout) {
  if (layout === "horizontal") {
    return {
      numericAxisName: "yAxis",
      cateAxisName: "xAxis"
    };
  }
  if (layout === "vertical") {
    return {
      numericAxisName: "xAxis",
      cateAxisName: "yAxis"
    };
  }
  if (layout === "centric") {
    return {
      numericAxisName: "radiusAxis",
      cateAxisName: "angleAxis"
    };
  }
  return {
    numericAxisName: "angleAxis",
    cateAxisName: "radiusAxis"
  };
};
var calculateOffset = function calculateOffset2(_ref5, prevLegendBBox) {
  var props = _ref5.props, graphicalItems = _ref5.graphicalItems, _ref5$xAxisMap = _ref5.xAxisMap, xAxisMap = _ref5$xAxisMap === void 0 ? {} : _ref5$xAxisMap, _ref5$yAxisMap = _ref5.yAxisMap, yAxisMap = _ref5$yAxisMap === void 0 ? {} : _ref5$yAxisMap;
  var width = props.width, height = props.height, children = props.children;
  var margin = props.margin || {};
  var brushItem = findChildByType(children, Brush);
  var legendItem = findChildByType(children, Legend);
  var offsetH = Object.keys(yAxisMap).reduce(function(result, id) {
    var entry = yAxisMap[id];
    var orientation = entry.orientation;
    if (!entry.mirror && !entry.hide) {
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, result[orientation] + entry.width));
    }
    return result;
  }, {
    left: margin.left || 0,
    right: margin.right || 0
  });
  var offsetV = Object.keys(xAxisMap).reduce(function(result, id) {
    var entry = xAxisMap[id];
    var orientation = entry.orientation;
    if (!entry.mirror && !entry.hide) {
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, orientation, _get(result, "".concat(orientation)) + entry.height));
    }
    return result;
  }, {
    top: margin.top || 0,
    bottom: margin.bottom || 0
  });
  var offset = _objectSpread(_objectSpread({}, offsetV), offsetH);
  var brushBottom = offset.bottom;
  if (brushItem) {
    offset.bottom += brushItem.props.height || Brush.defaultProps.height;
  }
  if (legendItem && prevLegendBBox) {
    offset = appendOffsetOfLegend(offset, graphicalItems, props, prevLegendBBox);
  }
  return _objectSpread(_objectSpread({
    brushBottom
  }, offset), {}, {
    width: width - offset.left - offset.right,
    height: height - offset.top - offset.bottom
  });
};
var generateCategoricalChart = function generateCategoricalChart2(_ref6) {
  var _class;
  var chartName = _ref6.chartName, GraphicalChild = _ref6.GraphicalChild, _ref6$defaultTooltipE = _ref6.defaultTooltipEventType, defaultTooltipEventType = _ref6$defaultTooltipE === void 0 ? "axis" : _ref6$defaultTooltipE, _ref6$validateTooltip = _ref6.validateTooltipEventTypes, validateTooltipEventTypes = _ref6$validateTooltip === void 0 ? ["axis"] : _ref6$validateTooltip, axisComponents = _ref6.axisComponents, legendContent = _ref6.legendContent, formatAxisMap3 = _ref6.formatAxisMap, defaultProps2 = _ref6.defaultProps;
  var getFormatItems = function getFormatItems2(props, currentState) {
    var graphicalItems = currentState.graphicalItems, stackGroups = currentState.stackGroups, offset = currentState.offset, updateId = currentState.updateId, dataStartIndex = currentState.dataStartIndex, dataEndIndex = currentState.dataEndIndex;
    var barSize = props.barSize, layout = props.layout, barGap = props.barGap, barCategoryGap = props.barCategoryGap, globalMaxBarSize = props.maxBarSize;
    var _getAxisNameByLayout = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout.numericAxisName, cateAxisName = _getAxisNameByLayout.cateAxisName;
    var hasBar = hasGraphicalBarItem(graphicalItems);
    var sizeList = hasBar && getBarSizeList({
      barSize,
      stackGroups
    });
    var formattedItems = [];
    graphicalItems.forEach(function(item, index) {
      var displayedData = getDisplayedData(props.data, {
        dataStartIndex,
        dataEndIndex
      }, item);
      var _item$props = item.props, dataKey = _item$props.dataKey, childMaxBarSize = _item$props.maxBarSize;
      var numericAxisId = item.props["".concat(numericAxisName, "Id")];
      var cateAxisId = item.props["".concat(cateAxisName, "Id")];
      var axisObj = axisComponents.reduce(function(result, entry) {
        var _objectSpread6;
        var axisMap = currentState["".concat(entry.axisType, "Map")];
        var id = item.props["".concat(entry.axisType, "Id")];
        var axis = axisMap && axisMap[id];
        return _objectSpread(_objectSpread({}, result), {}, (_objectSpread6 = {}, _defineProperty(_objectSpread6, entry.axisType, axis), _defineProperty(_objectSpread6, "".concat(entry.axisType, "Ticks"), getTicksOfAxis(axis)), _objectSpread6));
      }, {});
      var cateAxis = axisObj[cateAxisName];
      var cateTicks = axisObj["".concat(cateAxisName, "Ticks")];
      var stackedData = stackGroups && stackGroups[numericAxisId] && stackGroups[numericAxisId].hasStack && getStackedDataOfItem(item, stackGroups[numericAxisId].stackGroups);
      var itemIsBar = getDisplayName(item.type).indexOf("Bar") >= 0;
      var bandSize = getBandSizeOfAxis(cateAxis, cateTicks);
      var barPosition = [];
      if (itemIsBar) {
        var _ref7, _getBandSizeOfAxis;
        var maxBarSize = _isNil(childMaxBarSize) ? globalMaxBarSize : childMaxBarSize;
        var barBandSize = (_ref7 = (_getBandSizeOfAxis = getBandSizeOfAxis(cateAxis, cateTicks, true)) !== null && _getBandSizeOfAxis !== void 0 ? _getBandSizeOfAxis : maxBarSize) !== null && _ref7 !== void 0 ? _ref7 : 0;
        barPosition = getBarPosition({
          barGap,
          barCategoryGap,
          bandSize: barBandSize !== bandSize ? barBandSize : bandSize,
          sizeList: sizeList[cateAxisId],
          maxBarSize
        });
        if (barBandSize !== bandSize) {
          barPosition = barPosition.map(function(pos) {
            return _objectSpread(_objectSpread({}, pos), {}, {
              position: _objectSpread(_objectSpread({}, pos.position), {}, {
                offset: pos.position.offset - barBandSize / 2
              })
            });
          });
        }
      }
      var composedFn = item && item.type && item.type.getComposedData;
      if (composedFn) {
        var _objectSpread7;
        formattedItems.push({
          props: _objectSpread(_objectSpread({}, composedFn(_objectSpread(_objectSpread({}, axisObj), {}, {
            displayedData,
            props,
            dataKey,
            item,
            bandSize,
            barPosition,
            offset,
            stackedData,
            layout,
            dataStartIndex,
            dataEndIndex
          }))), {}, (_objectSpread7 = {
            key: item.key || "item-".concat(index)
          }, _defineProperty(_objectSpread7, numericAxisName, axisObj[numericAxisName]), _defineProperty(_objectSpread7, cateAxisName, axisObj[cateAxisName]), _defineProperty(_objectSpread7, "animationId", updateId), _objectSpread7)),
          childIndex: parseChildIndex(item, props.children),
          item
        });
      }
    });
    return formattedItems;
  };
  var updateStateOfAxisMapsOffsetAndStackGroups = function updateStateOfAxisMapsOffsetAndStackGroups2(_ref8, prevState) {
    var props = _ref8.props, dataStartIndex = _ref8.dataStartIndex, dataEndIndex = _ref8.dataEndIndex, updateId = _ref8.updateId;
    if (!validateWidthHeight({
      props
    })) {
      return null;
    }
    var children = props.children, layout = props.layout, stackOffset = props.stackOffset, data = props.data, reverseStackOrder = props.reverseStackOrder;
    var _getAxisNameByLayout2 = getAxisNameByLayout(layout), numericAxisName = _getAxisNameByLayout2.numericAxisName, cateAxisName = _getAxisNameByLayout2.cateAxisName;
    var graphicalItems = findAllByType(children, GraphicalChild);
    var stackGroups = getStackGroupsByAxisId(data, graphicalItems, "".concat(numericAxisName, "Id"), "".concat(cateAxisName, "Id"), stackOffset, reverseStackOrder);
    var axisObj = axisComponents.reduce(function(result, entry) {
      var name = "".concat(entry.axisType, "Map");
      return _objectSpread(_objectSpread({}, result), {}, _defineProperty({}, name, getAxisMap(props, _objectSpread(_objectSpread({}, entry), {}, {
        graphicalItems,
        stackGroups: entry.axisType === numericAxisName && stackGroups,
        dataStartIndex,
        dataEndIndex
      }))));
    }, {});
    var offset = calculateOffset(_objectSpread(_objectSpread({}, axisObj), {}, {
      props,
      graphicalItems
    }), prevState === null || prevState === void 0 ? void 0 : prevState.legendBBox);
    Object.keys(axisObj).forEach(function(key) {
      axisObj[key] = formatAxisMap3(props, axisObj[key], offset, key.replace("Map", ""), chartName);
    });
    var cateAxisMap = axisObj["".concat(cateAxisName, "Map")];
    var ticksObj = tooltipTicksGenerator(cateAxisMap);
    var formattedGraphicalItems = getFormatItems(props, _objectSpread(_objectSpread({}, axisObj), {}, {
      dataStartIndex,
      dataEndIndex,
      updateId,
      graphicalItems,
      stackGroups,
      offset
    }));
    return _objectSpread(_objectSpread({
      formattedGraphicalItems,
      graphicalItems,
      offset,
      stackGroups
    }, ticksObj), axisObj);
  };
  return _class = /* @__PURE__ */ function(_Component) {
    _inherits(CategoricalChartWrapper, _Component);
    var _super = _createSuper(CategoricalChartWrapper);
    function CategoricalChartWrapper(_props) {
      var _this;
      _classCallCheck(this, CategoricalChartWrapper);
      _this = _super.call(this, _props);
      _defineProperty(_assertThisInitialized(_this), "clearDeferId", function() {
        if (!_isNil(_this.deferId) && deferClear) {
          deferClear(_this.deferId);
        }
        _this.deferId = null;
      });
      _defineProperty(_assertThisInitialized(_this), "handleLegendBBoxUpdate", function(box) {
        if (box) {
          var _this$state = _this.state, dataStartIndex = _this$state.dataStartIndex, dataEndIndex = _this$state.dataEndIndex, updateId = _this$state.updateId;
          _this.setState(_objectSpread({
            legendBBox: box
          }, updateStateOfAxisMapsOffsetAndStackGroups({
            props: _this.props,
            dataStartIndex,
            dataEndIndex,
            updateId
          }, _objectSpread(_objectSpread({}, _this.state), {}, {
            legendBBox: box
          }))));
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleReceiveSyncEvent", function(cId, chartId, data) {
        var syncId = _this.props.syncId;
        if (syncId === cId && chartId !== _this.uniqueChartId) {
          _this.clearDeferId();
          _this.deferId = defer && defer(_this.applySyncEvent.bind(_assertThisInitialized(_this), data));
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleBrushChange", function(_ref9) {
        var startIndex = _ref9.startIndex, endIndex = _ref9.endIndex;
        if (startIndex !== _this.state.dataStartIndex || endIndex !== _this.state.dataEndIndex) {
          var updateId = _this.state.updateId;
          _this.setState(function() {
            return _objectSpread({
              dataStartIndex: startIndex,
              dataEndIndex: endIndex
            }, updateStateOfAxisMapsOffsetAndStackGroups({
              props: _this.props,
              dataStartIndex: startIndex,
              dataEndIndex: endIndex,
              updateId
            }, _this.state));
          });
          _this.triggerSyncEvent({
            dataStartIndex: startIndex,
            dataEndIndex: endIndex
          });
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseEnter", function(e3) {
        var onMouseEnter = _this.props.onMouseEnter;
        var mouse = _this.getMouseInfo(e3);
        if (mouse) {
          var _nextState = _objectSpread(_objectSpread({}, mouse), {}, {
            isTooltipActive: true
          });
          _this.setState(_nextState);
          _this.triggerSyncEvent(_nextState);
          if (_isFunction(onMouseEnter)) {
            onMouseEnter(_nextState, e3);
          }
        }
      });
      _defineProperty(_assertThisInitialized(_this), "triggeredAfterMouseMove", function(e3) {
        var onMouseMove = _this.props.onMouseMove;
        var mouse = _this.getMouseInfo(e3);
        var nextState = mouse ? _objectSpread(_objectSpread({}, mouse), {}, {
          isTooltipActive: true
        }) : {
          isTooltipActive: false
        };
        _this.setState(nextState);
        _this.triggerSyncEvent(nextState);
        if (_isFunction(onMouseMove)) {
          onMouseMove(nextState, e3);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleItemMouseEnter", function(el) {
        _this.setState(function() {
          return {
            isTooltipActive: true,
            activeItem: el,
            activePayload: el.tooltipPayload,
            activeCoordinate: el.tooltipPosition || {
              x: el.cx,
              y: el.cy
            }
          };
        });
      });
      _defineProperty(_assertThisInitialized(_this), "handleItemMouseLeave", function() {
        _this.setState(function() {
          return {
            isTooltipActive: false
          };
        });
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseMove", function(e3) {
        if (e3 && _isFunction(e3.persist)) {
          e3.persist();
        }
        _this.triggeredAfterMouseMove(e3);
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseLeave", function(e3) {
        var onMouseLeave = _this.props.onMouseLeave;
        var nextState = {
          isTooltipActive: false
        };
        _this.setState(nextState);
        _this.triggerSyncEvent(nextState);
        if (_isFunction(onMouseLeave)) {
          onMouseLeave(nextState, e3);
        }
        _this.cancelThrottledTriggerAfterMouseMove();
      });
      _defineProperty(_assertThisInitialized(_this), "handleOuterEvent", function(e3) {
        var eventName = getReactEventByType(e3);
        var event = _get(_this.props, "".concat(eventName));
        if (eventName && _isFunction(event)) {
          var mouse;
          if (/.*touch.*/i.test(eventName)) {
            mouse = _this.getMouseInfo(e3.changedTouches[0]);
          } else {
            mouse = _this.getMouseInfo(e3);
          }
          var handler = event;
          handler(mouse, e3);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleClick", function(e3) {
        var onClick = _this.props.onClick;
        var mouse = _this.getMouseInfo(e3);
        if (mouse) {
          var _nextState2 = _objectSpread(_objectSpread({}, mouse), {}, {
            isTooltipActive: true
          });
          _this.setState(_nextState2);
          _this.triggerSyncEvent(_nextState2);
          if (_isFunction(onClick)) {
            onClick(_nextState2, e3);
          }
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseDown", function(e3) {
        var onMouseDown = _this.props.onMouseDown;
        if (_isFunction(onMouseDown)) {
          var _nextState3 = _this.getMouseInfo(e3);
          onMouseDown(_nextState3, e3);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleMouseUp", function(e3) {
        var onMouseUp = _this.props.onMouseUp;
        if (_isFunction(onMouseUp)) {
          var _nextState4 = _this.getMouseInfo(e3);
          onMouseUp(_nextState4, e3);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleTouchMove", function(e3) {
        if (e3.changedTouches != null && e3.changedTouches.length > 0) {
          _this.handleMouseMove(e3.changedTouches[0]);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleTouchStart", function(e3) {
        if (e3.changedTouches != null && e3.changedTouches.length > 0) {
          _this.handleMouseDown(e3.changedTouches[0]);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "handleTouchEnd", function(e3) {
        if (e3.changedTouches != null && e3.changedTouches.length > 0) {
          _this.handleMouseUp(e3.changedTouches[0]);
        }
      });
      _defineProperty(_assertThisInitialized(_this), "verticalCoordinatesGenerator", function(_ref10) {
        var xAxis = _ref10.xAxis, width = _ref10.width, height = _ref10.height, offset = _ref10.offset;
        return getCoordinatesOfGrid(CartesianAxis.getTicks(_objectSpread(_objectSpread(_objectSpread({}, CartesianAxis.defaultProps), xAxis), {}, {
          ticks: getTicksOfAxis(xAxis, true),
          viewBox: {
            x: 0,
            y: 0,
            width,
            height
          }
        })), offset.left, offset.left + offset.width);
      });
      _defineProperty(_assertThisInitialized(_this), "horizontalCoordinatesGenerator", function(_ref11) {
        var yAxis = _ref11.yAxis, width = _ref11.width, height = _ref11.height, offset = _ref11.offset;
        return getCoordinatesOfGrid(CartesianAxis.getTicks(_objectSpread(_objectSpread(_objectSpread({}, CartesianAxis.defaultProps), yAxis), {}, {
          ticks: getTicksOfAxis(yAxis, true),
          viewBox: {
            x: 0,
            y: 0,
            width,
            height
          }
        })), offset.top, offset.top + offset.height);
      });
      _defineProperty(_assertThisInitialized(_this), "axesTicksGenerator", function(axis) {
        return getTicksOfAxis(axis, true);
      });
      _defineProperty(_assertThisInitialized(_this), "renderCursor", function(element) {
        var _this$state2 = _this.state, isTooltipActive = _this$state2.isTooltipActive, activeCoordinate = _this$state2.activeCoordinate, activePayload = _this$state2.activePayload, offset = _this$state2.offset, activeTooltipIndex = _this$state2.activeTooltipIndex;
        var tooltipEventType = _this.getTooltipEventType();
        if (!element || !element.props.cursor || !isTooltipActive || !activeCoordinate || chartName !== "ScatterChart" && tooltipEventType !== "axis") {
          return null;
        }
        var layout = _this.props.layout;
        var restProps;
        var cursorComp = Curve;
        if (chartName === "ScatterChart") {
          restProps = activeCoordinate;
          cursorComp = Cross;
        } else if (chartName === "BarChart") {
          restProps = _this.getCursorRectangle();
          cursorComp = Rectangle;
        } else if (layout === "radial") {
          var _this$getCursorPoints = _this.getCursorPoints(), cx = _this$getCursorPoints.cx, cy = _this$getCursorPoints.cy, radius = _this$getCursorPoints.radius, startAngle = _this$getCursorPoints.startAngle, endAngle = _this$getCursorPoints.endAngle;
          restProps = {
            cx,
            cy,
            startAngle,
            endAngle,
            innerRadius: radius,
            outerRadius: radius
          };
          cursorComp = Sector;
        } else {
          restProps = {
            points: _this.getCursorPoints()
          };
          cursorComp = Curve;
        }
        var key = element.key || "_recharts-cursor";
        var cursorProps = _objectSpread(_objectSpread(_objectSpread(_objectSpread({
          stroke: "#ccc",
          pointerEvents: "none"
        }, offset), restProps), filterProps(element.props.cursor)), {}, {
          payload: activePayload,
          payloadIndex: activeTooltipIndex,
          key,
          className: "recharts-tooltip-cursor"
        });
        return /* @__PURE__ */ reactExports.isValidElement(element.props.cursor) ? /* @__PURE__ */ reactExports.cloneElement(element.props.cursor, cursorProps) : /* @__PURE__ */ reactExports.createElement(cursorComp, cursorProps);
      });
      _defineProperty(_assertThisInitialized(_this), "renderPolarAxis", function(element, displayName, index) {
        var axisType = _get(element, "type.axisType");
        var axisMap = _get(_this.state, "".concat(axisType, "Map"));
        var axisOption = axisMap && axisMap[element.props["".concat(axisType, "Id")]];
        return /* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread({}, axisOption), {}, {
          className: axisType,
          key: element.key || "".concat(displayName, "-").concat(index),
          ticks: getTicksOfAxis(axisOption, true)
        }));
      });
      _defineProperty(_assertThisInitialized(_this), "renderXAxis", function(element, displayName, index) {
        var xAxisMap = _this.state.xAxisMap;
        var axisObj = xAxisMap[element.props.xAxisId];
        return _this.renderAxis(axisObj, element, displayName, index);
      });
      _defineProperty(_assertThisInitialized(_this), "renderYAxis", function(element, displayName, index) {
        var yAxisMap = _this.state.yAxisMap;
        var axisObj = yAxisMap[element.props.yAxisId];
        return _this.renderAxis(axisObj, element, displayName, index);
      });
      _defineProperty(_assertThisInitialized(_this), "renderGrid", function(element) {
        var _this$state3 = _this.state, xAxisMap = _this$state3.xAxisMap, yAxisMap = _this$state3.yAxisMap, offset = _this$state3.offset;
        var _this$props = _this.props, width = _this$props.width, height = _this$props.height;
        var xAxis = getAnyElementOfObject(xAxisMap);
        var yAxisWithFiniteDomain = _find(yAxisMap, function(axis) {
          return _every(axis.domain, isFinit);
        });
        var yAxis = yAxisWithFiniteDomain || getAnyElementOfObject(yAxisMap);
        var props = element.props || {};
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          key: element.key || "grid",
          x: isNumber(props.x) ? props.x : offset.left,
          y: isNumber(props.y) ? props.y : offset.top,
          width: isNumber(props.width) ? props.width : offset.width,
          height: isNumber(props.height) ? props.height : offset.height,
          xAxis,
          yAxis,
          offset,
          chartWidth: width,
          chartHeight: height,
          verticalCoordinatesGenerator: props.verticalCoordinatesGenerator || _this.verticalCoordinatesGenerator,
          horizontalCoordinatesGenerator: props.horizontalCoordinatesGenerator || _this.horizontalCoordinatesGenerator
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderPolarGrid", function(element) {
        var _element$props = element.props, radialLines = _element$props.radialLines, polarAngles = _element$props.polarAngles, polarRadius = _element$props.polarRadius;
        var _this$state4 = _this.state, radiusAxisMap = _this$state4.radiusAxisMap, angleAxisMap = _this$state4.angleAxisMap;
        var radiusAxis = getAnyElementOfObject(radiusAxisMap);
        var angleAxis = getAnyElementOfObject(angleAxisMap);
        var cx = angleAxis.cx, cy = angleAxis.cy, innerRadius = angleAxis.innerRadius, outerRadius = angleAxis.outerRadius;
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          polarAngles: _isArray(polarAngles) ? polarAngles : getTicksOfAxis(angleAxis, true).map(function(entry) {
            return entry.coordinate;
          }),
          polarRadius: _isArray(polarRadius) ? polarRadius : getTicksOfAxis(radiusAxis, true).map(function(entry) {
            return entry.coordinate;
          }),
          cx,
          cy,
          innerRadius,
          outerRadius,
          key: element.key || "polar-grid",
          radialLines
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderLegend", function() {
        var formattedGraphicalItems = _this.state.formattedGraphicalItems;
        var _this$props2 = _this.props, children = _this$props2.children, width = _this$props2.width, height = _this$props2.height;
        var margin = _this.props.margin || {};
        var legendWidth = width - (margin.left || 0) - (margin.right || 0);
        var props = getLegendProps({
          children,
          formattedGraphicalItems,
          legendWidth,
          legendContent
        });
        if (!props) {
          return null;
        }
        var item = props.item, otherProps = _objectWithoutProperties(props, _excluded);
        return /* @__PURE__ */ reactExports.cloneElement(item, _objectSpread(_objectSpread({}, otherProps), {}, {
          chartWidth: width,
          chartHeight: height,
          margin,
          ref: function ref(legend) {
            _this.legendInstance = legend;
          },
          onBBoxUpdate: _this.handleLegendBBoxUpdate
        }));
      });
      _defineProperty(_assertThisInitialized(_this), "renderTooltip", function() {
        var children = _this.props.children;
        var tooltipItem = findChildByType(children, Tooltip);
        if (!tooltipItem) {
          return null;
        }
        var _this$state5 = _this.state, isTooltipActive = _this$state5.isTooltipActive, activeCoordinate = _this$state5.activeCoordinate, activePayload = _this$state5.activePayload, activeLabel = _this$state5.activeLabel, offset = _this$state5.offset;
        return /* @__PURE__ */ reactExports.cloneElement(tooltipItem, {
          viewBox: _objectSpread(_objectSpread({}, offset), {}, {
            x: offset.left,
            y: offset.top
          }),
          active: isTooltipActive,
          label: activeLabel,
          payload: isTooltipActive ? activePayload : [],
          coordinate: activeCoordinate
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderBrush", function(element) {
        var _this$props3 = _this.props, margin = _this$props3.margin, data = _this$props3.data;
        var _this$state6 = _this.state, offset = _this$state6.offset, dataStartIndex = _this$state6.dataStartIndex, dataEndIndex = _this$state6.dataEndIndex, updateId = _this$state6.updateId;
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          key: element.key || "_recharts-brush",
          onChange: combineEventHandlers(_this.handleBrushChange, null, element.props.onChange),
          data,
          x: isNumber(element.props.x) ? element.props.x : offset.left,
          y: isNumber(element.props.y) ? element.props.y : offset.top + offset.height + offset.brushBottom - (margin.bottom || 0),
          width: isNumber(element.props.width) ? element.props.width : offset.width,
          startIndex: dataStartIndex,
          endIndex: dataEndIndex,
          updateId: "brush-".concat(updateId)
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderReferenceElement", function(element, displayName, index) {
        if (!element) {
          return null;
        }
        var _assertThisInitialize = _assertThisInitialized(_this), clipPathId = _assertThisInitialize.clipPathId;
        var _this$state7 = _this.state, xAxisMap = _this$state7.xAxisMap, yAxisMap = _this$state7.yAxisMap, offset = _this$state7.offset;
        var _element$props2 = element.props, xAxisId = _element$props2.xAxisId, yAxisId = _element$props2.yAxisId;
        return /* @__PURE__ */ reactExports.cloneElement(element, {
          key: element.key || "".concat(displayName, "-").concat(index),
          xAxis: xAxisMap[xAxisId !== null && xAxisId !== void 0 ? xAxisId : 0],
          yAxis: yAxisMap[yAxisId !== null && yAxisId !== void 0 ? yAxisId : 0],
          viewBox: {
            x: offset.left,
            y: offset.top,
            width: offset.width,
            height: offset.height
          },
          clipPathId
        });
      });
      _defineProperty(_assertThisInitialized(_this), "renderActivePoints", function(_ref12) {
        var item = _ref12.item, activePoint = _ref12.activePoint, basePoint = _ref12.basePoint, childIndex = _ref12.childIndex, isRange = _ref12.isRange;
        var result = [];
        var key = item.props.key;
        var _item$item$props = item.item.props, activeDot = _item$item$props.activeDot, dataKey = _item$item$props.dataKey;
        var dotProps = _objectSpread(_objectSpread({
          index: childIndex,
          dataKey,
          cx: activePoint.x,
          cy: activePoint.y,
          r: 4,
          fill: getMainColorOfGraphicItem(item.item),
          strokeWidth: 2,
          stroke: "#fff",
          payload: activePoint.payload,
          value: activePoint.value,
          key: "".concat(key, "-activePoint-").concat(childIndex)
        }, filterProps(activeDot)), adaptEventHandlers(activeDot));
        result.push(CategoricalChartWrapper.renderActiveDot(activeDot, dotProps));
        if (basePoint) {
          result.push(CategoricalChartWrapper.renderActiveDot(activeDot, _objectSpread(_objectSpread({}, dotProps), {}, {
            cx: basePoint.x,
            cy: basePoint.y,
            key: "".concat(key, "-basePoint-").concat(childIndex)
          })));
        } else if (isRange) {
          result.push(null);
        }
        return result;
      });
      _defineProperty(_assertThisInitialized(_this), "renderGraphicChild", function(element, displayName, index) {
        var item = _this.filterFormatItem(element, displayName, index);
        if (!item) {
          return null;
        }
        var tooltipEventType = _this.getTooltipEventType();
        var _this$state8 = _this.state, isTooltipActive = _this$state8.isTooltipActive, tooltipAxis = _this$state8.tooltipAxis, activeTooltipIndex = _this$state8.activeTooltipIndex, activeLabel = _this$state8.activeLabel;
        var children = _this.props.children;
        var tooltipItem = findChildByType(children, Tooltip);
        var _item$props2 = item.props, points = _item$props2.points, isRange = _item$props2.isRange, baseLine = _item$props2.baseLine;
        var _item$item$props2 = item.item.props, activeDot = _item$item$props2.activeDot, hide = _item$item$props2.hide;
        var hasActive = !hide && isTooltipActive && tooltipItem && activeDot && activeTooltipIndex >= 0;
        var itemEvents = {};
        if (tooltipEventType !== "axis" && tooltipItem && tooltipItem.props.trigger === "click") {
          itemEvents = {
            onClick: combineEventHandlers(_this.handleItemMouseEnter, null, element.props.onCLick)
          };
        } else if (tooltipEventType !== "axis") {
          itemEvents = {
            onMouseLeave: combineEventHandlers(_this.handleItemMouseLeave, null, element.props.onMouseLeave),
            onMouseEnter: combineEventHandlers(_this.handleItemMouseEnter, null, element.props.onMouseEnter)
          };
        }
        var graphicalItem = /* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread({}, item.props), itemEvents));
        function findWithPayload(entry) {
          return typeof tooltipAxis.dataKey === "function" ? tooltipAxis.dataKey(entry.payload) : null;
        }
        if (hasActive) {
          var activePoint, basePoint;
          if (tooltipAxis.dataKey && !tooltipAxis.allowDuplicatedCategory) {
            var specifiedKey = typeof tooltipAxis.dataKey === "function" ? findWithPayload : "payload.".concat(tooltipAxis.dataKey.toString());
            activePoint = findEntryInArray(points, specifiedKey, activeLabel);
            basePoint = isRange && baseLine && findEntryInArray(baseLine, specifiedKey, activeLabel);
          } else {
            activePoint = points[activeTooltipIndex];
            basePoint = isRange && baseLine && baseLine[activeTooltipIndex];
          }
          if (!_isNil(activePoint)) {
            return [graphicalItem].concat(_toConsumableArray(_this.renderActivePoints({
              item,
              activePoint,
              basePoint,
              childIndex: activeTooltipIndex,
              isRange
            })));
          }
        }
        if (isRange) {
          return [graphicalItem, null, null];
        }
        return [graphicalItem, null];
      });
      _defineProperty(_assertThisInitialized(_this), "renderCustomized", function(element, displayName, index) {
        return /* @__PURE__ */ reactExports.cloneElement(element, _objectSpread(_objectSpread({
          key: "recharts-customized-".concat(index)
        }, _this.props), _this.state));
      });
      _this.uniqueChartId = _isNil(_props.id) ? uniqueId("recharts") : _props.id;
      _this.clipPathId = "".concat(_this.uniqueChartId, "-clip");
      if (_props.throttleDelay) {
        _this.triggeredAfterMouseMove = _throttle(_this.triggeredAfterMouseMove, _props.throttleDelay);
      }
      _this.state = {};
      return _this;
    }
    _createClass(CategoricalChartWrapper, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        if (!_isNil(this.props.syncId)) {
          this.addListener();
        }
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate(prevProps) {
        if (_isNil(prevProps.syncId) && !_isNil(this.props.syncId)) {
          this.addListener();
        }
        if (!_isNil(prevProps.syncId) && _isNil(this.props.syncId)) {
          this.removeListener();
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDeferId();
        if (!_isNil(this.props.syncId)) {
          this.removeListener();
        }
        this.cancelThrottledTriggerAfterMouseMove();
      }
    }, {
      key: "cancelThrottledTriggerAfterMouseMove",
      value: function cancelThrottledTriggerAfterMouseMove() {
        if (typeof this.triggeredAfterMouseMove.cancel === "function") {
          this.triggeredAfterMouseMove.cancel();
        }
      }
    }, {
      key: "getTooltipEventType",
      value: function getTooltipEventType() {
        var tooltipItem = findChildByType(this.props.children, Tooltip);
        if (tooltipItem && _isBoolean(tooltipItem.props.shared)) {
          var eventType = tooltipItem.props.shared ? "axis" : "item";
          return validateTooltipEventTypes.indexOf(eventType) >= 0 ? eventType : defaultTooltipEventType;
        }
        return defaultTooltipEventType;
      }
      /**
       * Get the information of mouse in chart, return null when the mouse is not in the chart
       * @param  {Object} event    The event object
       * @return {Object}          Mouse data
       */
    }, {
      key: "getMouseInfo",
      value: function getMouseInfo(event) {
        if (!this.container) {
          return null;
        }
        var containerOffset = getOffset(this.container);
        var e3 = calculateChartCoordinate(event, containerOffset);
        var rangeObj = this.inRange(e3.chartX, e3.chartY);
        if (!rangeObj) {
          return null;
        }
        var _this$state9 = this.state, xAxisMap = _this$state9.xAxisMap, yAxisMap = _this$state9.yAxisMap;
        var tooltipEventType = this.getTooltipEventType();
        if (tooltipEventType !== "axis" && xAxisMap && yAxisMap) {
          var xScale = getAnyElementOfObject(xAxisMap).scale;
          var yScale = getAnyElementOfObject(yAxisMap).scale;
          var xValue = xScale && xScale.invert ? xScale.invert(e3.chartX) : null;
          var yValue = yScale && yScale.invert ? yScale.invert(e3.chartY) : null;
          return _objectSpread(_objectSpread({}, e3), {}, {
            xValue,
            yValue
          });
        }
        var toolTipData = getTooltipData(this.state, this.props.data, this.props.layout, rangeObj);
        if (toolTipData) {
          return _objectSpread(_objectSpread({}, e3), toolTipData);
        }
        return null;
      }
    }, {
      key: "getCursorRectangle",
      value: function getCursorRectangle() {
        var layout = this.props.layout;
        var _this$state10 = this.state, activeCoordinate = _this$state10.activeCoordinate, offset = _this$state10.offset, tooltipAxisBandSize = _this$state10.tooltipAxisBandSize;
        var halfSize = tooltipAxisBandSize / 2;
        return {
          stroke: "none",
          fill: "#ccc",
          x: layout === "horizontal" ? activeCoordinate.x - halfSize : offset.left + 0.5,
          y: layout === "horizontal" ? offset.top + 0.5 : activeCoordinate.y - halfSize,
          width: layout === "horizontal" ? tooltipAxisBandSize : offset.width - 1,
          height: layout === "horizontal" ? offset.height - 1 : tooltipAxisBandSize
        };
      }
    }, {
      key: "getCursorPoints",
      value: function getCursorPoints() {
        var layout = this.props.layout;
        var _this$state11 = this.state, activeCoordinate = _this$state11.activeCoordinate, offset = _this$state11.offset;
        var x1, y1, x2, y2;
        if (layout === "horizontal") {
          x1 = activeCoordinate.x;
          x2 = x1;
          y1 = offset.top;
          y2 = offset.top + offset.height;
        } else if (layout === "vertical") {
          y1 = activeCoordinate.y;
          y2 = y1;
          x1 = offset.left;
          x2 = offset.left + offset.width;
        } else if (!_isNil(activeCoordinate.cx) || !_isNil(activeCoordinate.cy)) {
          if (layout === "centric") {
            var cx = activeCoordinate.cx, cy = activeCoordinate.cy, innerRadius = activeCoordinate.innerRadius, outerRadius = activeCoordinate.outerRadius, angle = activeCoordinate.angle;
            var innerPoint = polarToCartesian(cx, cy, innerRadius, angle);
            var outerPoint = polarToCartesian(cx, cy, outerRadius, angle);
            x1 = innerPoint.x;
            y1 = innerPoint.y;
            x2 = outerPoint.x;
            y2 = outerPoint.y;
          } else {
            var _cx = activeCoordinate.cx, _cy = activeCoordinate.cy, radius = activeCoordinate.radius, startAngle = activeCoordinate.startAngle, endAngle = activeCoordinate.endAngle;
            var startPoint = polarToCartesian(_cx, _cy, radius, startAngle);
            var endPoint = polarToCartesian(_cx, _cy, radius, endAngle);
            return {
              points: [startPoint, endPoint],
              cx: _cx,
              cy: _cy,
              radius,
              startAngle,
              endAngle
            };
          }
        }
        return [{
          x: x1,
          y: y1
        }, {
          x: x2,
          y: y2
        }];
      }
    }, {
      key: "inRange",
      value: function inRange(x2, y2) {
        var layout = this.props.layout;
        if (layout === "horizontal" || layout === "vertical") {
          var offset = this.state.offset;
          var isInRange = x2 >= offset.left && x2 <= offset.left + offset.width && y2 >= offset.top && y2 <= offset.top + offset.height;
          return isInRange ? {
            x: x2,
            y: y2
          } : null;
        }
        var _this$state12 = this.state, angleAxisMap = _this$state12.angleAxisMap, radiusAxisMap = _this$state12.radiusAxisMap;
        if (angleAxisMap && radiusAxisMap) {
          var angleAxis = getAnyElementOfObject(angleAxisMap);
          return inRangeOfSector({
            x: x2,
            y: y2
          }, angleAxis);
        }
        return null;
      }
    }, {
      key: "parseEventsOfWrapper",
      value: function parseEventsOfWrapper() {
        var children = this.props.children;
        var tooltipEventType = this.getTooltipEventType();
        var tooltipItem = findChildByType(children, Tooltip);
        var tooltipEvents = {};
        if (tooltipItem && tooltipEventType === "axis") {
          if (tooltipItem.props.trigger === "click") {
            tooltipEvents = {
              onClick: this.handleClick
            };
          } else {
            tooltipEvents = {
              onMouseEnter: this.handleMouseEnter,
              onMouseMove: this.handleMouseMove,
              onMouseLeave: this.handleMouseLeave,
              onTouchMove: this.handleTouchMove,
              onTouchStart: this.handleTouchStart,
              onTouchEnd: this.handleTouchEnd
            };
          }
        }
        var outerEvents = adaptEventHandlers(this.props, this.handleOuterEvent);
        return _objectSpread(_objectSpread({}, outerEvents), tooltipEvents);
      }
      /* eslint-disable  no-underscore-dangle */
    }, {
      key: "addListener",
      value: function addListener() {
        eventCenter.on(SYNC_EVENT, this.handleReceiveSyncEvent);
        if (eventCenter.setMaxListeners && eventCenter._maxListeners) {
          eventCenter.setMaxListeners(eventCenter._maxListeners + 1);
        }
      }
    }, {
      key: "removeListener",
      value: function removeListener() {
        eventCenter.removeListener(SYNC_EVENT, this.handleReceiveSyncEvent);
        if (eventCenter.setMaxListeners && eventCenter._maxListeners) {
          eventCenter.setMaxListeners(eventCenter._maxListeners - 1);
        }
      }
    }, {
      key: "triggerSyncEvent",
      value: function triggerSyncEvent(data) {
        var syncId = this.props.syncId;
        if (!_isNil(syncId)) {
          eventCenter.emit(SYNC_EVENT, syncId, this.uniqueChartId, data);
        }
      }
    }, {
      key: "applySyncEvent",
      value: function applySyncEvent(data) {
        var _this$props4 = this.props, layout = _this$props4.layout, syncMethod = _this$props4.syncMethod;
        var updateId = this.state.updateId;
        var dataStartIndex = data.dataStartIndex, dataEndIndex = data.dataEndIndex;
        if (!_isNil(data.dataStartIndex) || !_isNil(data.dataEndIndex)) {
          this.setState(_objectSpread({
            dataStartIndex,
            dataEndIndex
          }, updateStateOfAxisMapsOffsetAndStackGroups({
            props: this.props,
            dataStartIndex,
            dataEndIndex,
            updateId
          }, this.state)));
        } else if (!_isNil(data.activeTooltipIndex)) {
          var chartX = data.chartX, chartY = data.chartY;
          var activeTooltipIndex = data.activeTooltipIndex;
          var _this$state13 = this.state, offset = _this$state13.offset, tooltipTicks = _this$state13.tooltipTicks;
          if (!offset) {
            return;
          }
          if (typeof syncMethod === "function") {
            activeTooltipIndex = syncMethod(tooltipTicks, data);
          } else if (syncMethod === "value") {
            activeTooltipIndex = -1;
            for (var i = 0; i < tooltipTicks.length; i++) {
              if (tooltipTicks[i].value === data.activeLabel) {
                activeTooltipIndex = i;
                break;
              }
            }
          }
          var viewBox = _objectSpread(_objectSpread({}, offset), {}, {
            x: offset.left,
            y: offset.top
          });
          var validateChartX = Math.min(chartX, viewBox.x + viewBox.width);
          var validateChartY = Math.min(chartY, viewBox.y + viewBox.height);
          var activeLabel = tooltipTicks[activeTooltipIndex] && tooltipTicks[activeTooltipIndex].value;
          var activePayload = getTooltipContent(this.state, this.props.data, activeTooltipIndex);
          var activeCoordinate = tooltipTicks[activeTooltipIndex] ? {
            x: layout === "horizontal" ? tooltipTicks[activeTooltipIndex].coordinate : validateChartX,
            y: layout === "horizontal" ? validateChartY : tooltipTicks[activeTooltipIndex].coordinate
          } : originCoordinate;
          this.setState(_objectSpread(_objectSpread({}, data), {}, {
            activeLabel,
            activeCoordinate,
            activePayload,
            activeTooltipIndex
          }));
        } else {
          this.setState(data);
        }
      }
    }, {
      key: "filterFormatItem",
      value: function filterFormatItem(item, displayName, childIndex) {
        var formattedGraphicalItems = this.state.formattedGraphicalItems;
        for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
          var entry = formattedGraphicalItems[i];
          if (entry.item === item || entry.props.key === item.key || displayName === getDisplayName(entry.item.type) && childIndex === entry.childIndex) {
            return entry;
          }
        }
        return null;
      }
    }, {
      key: "renderAxis",
      value: (
        /**
         * Draw axis
         * @param {Object} axisOptions The options of axis
         * @param {Object} element      The axis element
         * @param {String} displayName  The display name of axis
         * @param {Number} index        The index of element
         * @return {ReactElement}       The instance of x-axes
         */
        function renderAxis(axisOptions, element, displayName, index) {
          var _this$props5 = this.props, width = _this$props5.width, height = _this$props5.height;
          return /* @__PURE__ */ React.createElement(CartesianAxis, _extends({}, axisOptions, {
            className: "recharts-".concat(axisOptions.axisType, " ").concat(axisOptions.axisType),
            key: element.key || "".concat(displayName, "-").concat(index),
            viewBox: {
              x: 0,
              y: 0,
              width,
              height
            },
            ticksGenerator: this.axesTicksGenerator
          }));
        }
      )
      /**
       * Draw grid
       * @param  {ReactElement} element the grid item
       * @return {ReactElement} The instance of grid
       */
    }, {
      key: "renderClipPath",
      value: function renderClipPath() {
        var clipPathId = this.clipPathId;
        var _this$state$offset = this.state.offset, left = _this$state$offset.left, top = _this$state$offset.top, height = _this$state$offset.height, width = _this$state$offset.width;
        return /* @__PURE__ */ React.createElement("defs", null, /* @__PURE__ */ React.createElement("clipPath", {
          id: clipPathId
        }, /* @__PURE__ */ React.createElement("rect", {
          x: left,
          y: top,
          height,
          width
        })));
      }
    }, {
      key: "getXScales",
      value: function getXScales() {
        var xAxisMap = this.state.xAxisMap;
        return xAxisMap ? Object.entries(xAxisMap).reduce(function(res, _ref13) {
          var _ref14 = _slicedToArray(_ref13, 2), axisId = _ref14[0], axisProps = _ref14[1];
          return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
        }, {}) : null;
      }
    }, {
      key: "getYScales",
      value: function getYScales() {
        var yAxisMap = this.state.yAxisMap;
        return yAxisMap ? Object.entries(yAxisMap).reduce(function(res, _ref15) {
          var _ref16 = _slicedToArray(_ref15, 2), axisId = _ref16[0], axisProps = _ref16[1];
          return _objectSpread(_objectSpread({}, res), {}, _defineProperty({}, axisId, axisProps.scale));
        }, {}) : null;
      }
    }, {
      key: "getXScaleByAxisId",
      value: function getXScaleByAxisId(axisId) {
        var _this$state$xAxisMap, _this$state$xAxisMap$;
        return (_this$state$xAxisMap = this.state.xAxisMap) === null || _this$state$xAxisMap === void 0 ? void 0 : (_this$state$xAxisMap$ = _this$state$xAxisMap[axisId]) === null || _this$state$xAxisMap$ === void 0 ? void 0 : _this$state$xAxisMap$.scale;
      }
    }, {
      key: "getYScaleByAxisId",
      value: function getYScaleByAxisId(axisId) {
        var _this$state$yAxisMap, _this$state$yAxisMap$;
        return (_this$state$yAxisMap = this.state.yAxisMap) === null || _this$state$yAxisMap === void 0 ? void 0 : (_this$state$yAxisMap$ = _this$state$yAxisMap[axisId]) === null || _this$state$yAxisMap$ === void 0 ? void 0 : _this$state$yAxisMap$.scale;
      }
    }, {
      key: "getItemByXY",
      value: function getItemByXY(chartXY) {
        var formattedGraphicalItems = this.state.formattedGraphicalItems;
        if (formattedGraphicalItems && formattedGraphicalItems.length) {
          for (var i = 0, len = formattedGraphicalItems.length; i < len; i++) {
            var graphicalItem = formattedGraphicalItems[i];
            var props = graphicalItem.props, item = graphicalItem.item;
            var itemDisplayName = getDisplayName(item.type);
            if (itemDisplayName === "Bar") {
              var activeBarItem = (props.data || []).find(function(entry) {
                return isInRectangle(chartXY, entry);
              });
              if (activeBarItem) {
                return {
                  graphicalItem,
                  payload: activeBarItem
                };
              }
            } else if (itemDisplayName === "RadialBar") {
              var _activeBarItem = (props.data || []).find(function(entry) {
                return inRangeOfSector(chartXY, entry);
              });
              if (_activeBarItem) {
                return {
                  graphicalItem,
                  payload: _activeBarItem
                };
              }
            }
          }
        }
        return null;
      }
    }, {
      key: "render",
      value: function render() {
        var _this2 = this;
        if (!validateWidthHeight(this)) {
          return null;
        }
        var _this$props6 = this.props, children = _this$props6.children, className = _this$props6.className, width = _this$props6.width, height = _this$props6.height, style = _this$props6.style, compact = _this$props6.compact, title = _this$props6.title, desc = _this$props6.desc, others = _objectWithoutProperties(_this$props6, _excluded2);
        var attrs = filterProps(others);
        var map2 = {
          CartesianGrid: {
            handler: this.renderGrid,
            once: true
          },
          ReferenceArea: {
            handler: this.renderReferenceElement
          },
          ReferenceLine: {
            handler: this.renderReferenceElement
          },
          ReferenceDot: {
            handler: this.renderReferenceElement
          },
          XAxis: {
            handler: this.renderXAxis
          },
          YAxis: {
            handler: this.renderYAxis
          },
          Brush: {
            handler: this.renderBrush,
            once: true
          },
          Bar: {
            handler: this.renderGraphicChild
          },
          Line: {
            handler: this.renderGraphicChild
          },
          Area: {
            handler: this.renderGraphicChild
          },
          Radar: {
            handler: this.renderGraphicChild
          },
          RadialBar: {
            handler: this.renderGraphicChild
          },
          Scatter: {
            handler: this.renderGraphicChild
          },
          Pie: {
            handler: this.renderGraphicChild
          },
          Funnel: {
            handler: this.renderGraphicChild
          },
          Tooltip: {
            handler: this.renderCursor,
            once: true
          },
          PolarGrid: {
            handler: this.renderPolarGrid,
            once: true
          },
          PolarAngleAxis: {
            handler: this.renderPolarAxis
          },
          PolarRadiusAxis: {
            handler: this.renderPolarAxis
          },
          Customized: {
            handler: this.renderCustomized
          }
        };
        if (compact) {
          return /* @__PURE__ */ React.createElement(Surface, _extends({}, attrs, {
            width,
            height,
            title,
            desc
          }), this.renderClipPath(), renderByOrder(children, map2));
        }
        var events = this.parseEventsOfWrapper();
        return /* @__PURE__ */ React.createElement("div", _extends({
          className: classNames("recharts-wrapper", className),
          style: _objectSpread({
            position: "relative",
            cursor: "default",
            width,
            height
          }, style)
        }, events, {
          ref: function ref(node) {
            _this2.container = node;
          },
          role: "region"
        }), /* @__PURE__ */ React.createElement(Surface, _extends({}, attrs, {
          width,
          height,
          title,
          desc
        }), this.renderClipPath(), renderByOrder(children, map2)), this.renderLegend(), this.renderTooltip());
      }
    }]);
    return CategoricalChartWrapper;
  }(reactExports.Component), _defineProperty(_class, "displayName", chartName), _defineProperty(_class, "defaultProps", _objectSpread({
    layout: "horizontal",
    stackOffset: "none",
    barCategoryGap: "10%",
    barGap: 4,
    margin: {
      top: 5,
      right: 5,
      bottom: 5,
      left: 5
    },
    reverseStackOrder: false,
    syncMethod: "index"
  }, defaultProps2)), _defineProperty(_class, "getDerivedStateFromProps", function(nextProps, prevState) {
    var data = nextProps.data, children = nextProps.children, width = nextProps.width, height = nextProps.height, layout = nextProps.layout, stackOffset = nextProps.stackOffset, margin = nextProps.margin;
    if (_isNil(prevState.updateId)) {
      var defaultState = createDefaultState(nextProps);
      return _objectSpread(_objectSpread(_objectSpread({}, defaultState), {}, {
        updateId: 0
      }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({
        props: nextProps
      }, defaultState), {}, {
        updateId: 0
      }), prevState)), {}, {
        prevData: data,
        prevWidth: width,
        prevHeight: height,
        prevLayout: layout,
        prevStackOffset: stackOffset,
        prevMargin: margin,
        prevChildren: children
      });
    }
    if (data !== prevState.prevData || width !== prevState.prevWidth || height !== prevState.prevHeight || layout !== prevState.prevLayout || stackOffset !== prevState.prevStackOffset || !shallowEqual(margin, prevState.prevMargin)) {
      var _defaultState = createDefaultState(nextProps);
      var keepFromPrevState = {
        // (chartX, chartY) are (0,0) in default state, but we want to keep the last mouse position to avoid
        // any flickering
        chartX: prevState.chartX,
        chartY: prevState.chartY,
        // The tooltip should stay active when it was active in the previous render. If this is not
        // the case, the tooltip disappears and immediately re-appears, causing a flickering effect
        isTooltipActive: prevState.isTooltipActive
      };
      var updatesToState = _objectSpread(_objectSpread({}, getTooltipData(prevState, data, layout)), {}, {
        updateId: prevState.updateId + 1
      });
      var newState = _objectSpread(_objectSpread(_objectSpread({}, _defaultState), keepFromPrevState), updatesToState);
      return _objectSpread(_objectSpread(_objectSpread({}, newState), updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread({
        props: nextProps
      }, newState), prevState)), {}, {
        prevData: data,
        prevWidth: width,
        prevHeight: height,
        prevLayout: layout,
        prevStackOffset: stackOffset,
        prevMargin: margin,
        prevChildren: children
      });
    }
    if (!isChildrenEqual(children, prevState.prevChildren)) {
      var hasGlobalData = !_isNil(data);
      var newUpdateId = hasGlobalData ? prevState.updateId : prevState.updateId + 1;
      return _objectSpread(_objectSpread({
        updateId: newUpdateId
      }, updateStateOfAxisMapsOffsetAndStackGroups(_objectSpread(_objectSpread({
        props: nextProps
      }, prevState), {}, {
        updateId: newUpdateId
      }), prevState)), {}, {
        prevChildren: children
      });
    }
    return null;
  }), _defineProperty(_class, "renderActiveDot", function(option, props) {
    var dot;
    if (/* @__PURE__ */ reactExports.isValidElement(option)) {
      dot = /* @__PURE__ */ reactExports.cloneElement(option, props);
    } else if (_isFunction(option)) {
      dot = option(props);
    } else {
      dot = /* @__PURE__ */ React.createElement(Dot, props);
    }
    return /* @__PURE__ */ React.createElement(Layer, {
      className: "recharts-active-dot",
      key: props.key
    }, dot);
  }), _class;
};
var ComposedChart = generateCategoricalChart({
  chartName: "ComposedChart",
  GraphicalChild: [Line, Area, Bar, Scatter],
  axisComponents: [{
    axisType: "xAxis",
    AxisComp: XAxis
  }, {
    axisType: "yAxis",
    AxisComp: YAxis
  }, {
    axisType: "zAxis",
    AxisComp: ZAxis
  }],
  formatAxisMap
});
function CustomDot({
  cx,
  cy,
  payload,
  selectedPoint,
  radiusSelected = 6,
  radiusUnselected = 3,
  colorSelected = "red",
  colorUnselected,
  shape = "circle"
}) {
  if (!cx || !cy || !payload) {
    return null;
  }
  const isSelected = selectedPoint && selectedPoint.x === payload.x && selectedPoint.y === payload.y;
  return /* @__PURE__ */ jsx(
    "g",
    {
      className: "custom-dot",
      "data-chart-x": cx,
      "data-chart-y": cy,
      "data-x-value": payload.x,
      "data-y-value": payload.y,
      "data-radius": isSelected ? radiusUnselected : radiusSelected,
      children: !isSelected ? /* @__PURE__ */ jsx(
        CustomShape,
        {
          id: "customShapeUnselected",
          shape,
          cx,
          cy,
          r: radiusUnselected,
          fill: colorUnselected
        }
      ) : /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(
          CustomShape,
          {
            id: "customShapeSelected",
            shape,
            cx,
            cy,
            r: radiusSelected / 2,
            fill: colorSelected
          }
        ),
        /* @__PURE__ */ jsx(
          CustomShape,
          {
            id: "customShapeBorder",
            shape,
            cx,
            cy,
            r: radiusSelected,
            fill: "none",
            stroke: colorSelected
          }
        )
      ] })
    }
  );
}
function CustomShape({
  shape,
  id,
  cx,
  cy,
  r: r2,
  fill,
  stroke
}) {
  switch (shape) {
    case "circle":
      return /* @__PURE__ */ jsx("circle", { id, cx, cy, r: r2, fill, stroke });
    case "square":
      return /* @__PURE__ */ jsx(
        "rect",
        {
          id,
          x: cx - r2,
          y: cy - r2,
          width: r2 * 2,
          height: r2 * 2,
          fill,
          stroke
        }
      );
    case "diamond":
      return /* @__PURE__ */ jsx(
        "polygon",
        {
          id,
          points: `${cx},${cy + r2 * 2.5} ${cx + r2 * 1.5},${cy} ${cx},${cy - r2 * 2.5} ${cx - r2 * 1.5},${cy}`,
          fill,
          stroke
        }
      );
  }
}
function CustomTooltip({
  xLabel,
  xUnit,
  yLabel,
  yUnit,
  selectedPoint,
  setSelectedPoint,
  addBuildToList,
  ...tooltipProps
}) {
  var _a, _b, _c, _d;
  const database = useDatabase();
  const { data } = reactExports.useContext(DataContext);
  const { t: t2 } = useTranslation("page_character_optimize");
  const {
    character: { equippedArtifacts, equippedWeapon }
  } = reactExports.useContext(CharacterContext);
  const artifactsBySlot = reactExports.useMemo(
    () => {
      var _a2;
      return ((_a2 = selectedPoint == null ? void 0 : selectedPoint.build) == null ? void 0 : _a2.artifactIds) && objMap(selectedPoint.build.artifactIds, (id) => database.arts.get(id));
    },
    [database.arts, selectedPoint]
  ) ?? objKeyMap(allArtifactSlotKeys, () => void 0);
  const clickAwayHandler = reactExports.useCallback(
    (e3) => {
      if (!(e3.target.id.includes("customShape") || e3.target.id.includes("chartContainer"))) {
        setSelectedPoint(void 0);
      }
    },
    [setSelectedPoint]
  );
  const currentlyEquipped = equippedWeapon === ((_a = selectedPoint == null ? void 0 : selectedPoint.build) == null ? void 0 : _a.weaponId) && allArtifactSlotKeys.every(
    (slotKey) => {
      var _a2;
      return ((_a2 = artifactsBySlot[slotKey]) == null ? void 0 : _a2.id) === equippedArtifacts[slotKey];
    }
  );
  const activeBuild = ((_b = data.get(input.weapon.id).value) == null ? void 0 : _b.toString()) === ((_c = selectedPoint == null ? void 0 : selectedPoint.build) == null ? void 0 : _c.weaponId) && artifactsBySlot && allArtifactSlotKeys.every(
    (slotKey) => {
      var _a2, _b2;
      return ((_a2 = artifactsBySlot[slotKey]) == null ? void 0 : _a2.id) === ((_b2 = data.get(input.art[slotKey].id).value) == null ? void 0 : _b2.toString());
    }
  );
  const generLabel = reactExports.useMemo(
    () => (selectedPoint == null ? void 0 : selectedPoint.generBuildNumber) !== void 0 && `#${selectedPoint == null ? void 0 : selectedPoint.generBuildNumber}`,
    [selectedPoint]
  );
  const graphLabel = reactExports.useMemo(
    () => (selectedPoint == null ? void 0 : selectedPoint.graphBuildNumber) !== void 0 && /* @__PURE__ */ jsxs(
      Trans,
      {
        t: t2,
        i18nKey: "graphBuildLabel",
        count: selectedPoint == null ? void 0 : selectedPoint.graphBuildNumber,
        children: [
          "Graph #",
          { count: (selectedPoint == null ? void 0 : selectedPoint.graphBuildNumber) + 1 }
        ]
      }
    ),
    [selectedPoint, t2]
  );
  if (!tooltipProps.active || !selectedPoint)
    return null;
  return /* @__PURE__ */ jsx(ClickAwayListener, { onClickAway: clickAwayHandler, children: /* @__PURE__ */ jsx(
    CardThemed,
    {
      sx: { minWidth: "400px", maxWidth: "400px", p: 1 },
      onClick: (e3) => e3.stopPropagation(),
      children: /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Stack$3, { gap: 1, children: [
        /* @__PURE__ */ jsxs(Stack$3, { direction: "row", alignItems: "start", gap: 1, children: [
          /* @__PURE__ */ jsxs(Stack$3, { spacing: 0.5, flexGrow: 99, children: [
            currentlyEquipped && /* @__PURE__ */ jsx(SqBadge, { color: "info", children: /* @__PURE__ */ jsx("strong", { children: t2("currentlyEquippedBuild") }) }),
            activeBuild && /* @__PURE__ */ jsx(SqBadge, { color: "success", children: /* @__PURE__ */ jsx("strong", { children: "Active Build" }) }),
            generLabel && /* @__PURE__ */ jsx(SqBadge, { color: "info", children: generLabel }),
            graphLabel && /* @__PURE__ */ jsx(SqBadge, { color: "info", children: graphLabel }),
            /* @__PURE__ */ jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsx(Skeleton, { width: 300, height: 50 }), children: /* @__PURE__ */ jsx(
              ArtifactSetBadges,
              {
                artifacts: Object.values(artifactsBySlot)
              }
            ) })
          ] }),
          /* @__PURE__ */ jsx(
            IconButton,
            {
              onClick: () => setSelectedPoint(void 0),
              sx: { ml: "auto" },
              children: /* @__PURE__ */ jsx(default_1$a, {})
            }
          )
        ] }),
        /* @__PURE__ */ jsxs(Grid, { container: true, direction: "row", spacing: 0.75, columns: 6, children: [
          ((_d = selectedPoint.build) == null ? void 0 : _d.weaponId) && /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsx(Skeleton, { width: 75, height: 75 }), children: /* @__PURE__ */ jsx(WeaponCardPico, { weaponId: selectedPoint.build.weaponId }) }) }),
          allArtifactSlotKeys.map((key) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(reactExports.Suspense, { fallback: /* @__PURE__ */ jsx(Skeleton, { width: 75, height: 75 }), children: /* @__PURE__ */ jsx(
            ArtifactCardPico,
            {
              artifactObj: artifactsBySlot[key],
              slotKey: key
            }
          ) }) }, key))
        ] }),
        /* @__PURE__ */ jsxs(Typography, { children: [
          /* @__PURE__ */ jsx("strong", { children: xLabel }),
          ":",
          " ",
          valueString(
            xUnit === "%" ? selectedPoint.x / 100 : selectedPoint.x,
            xUnit
          )
        ] }),
        /* @__PURE__ */ jsxs(Typography, { children: [
          /* @__PURE__ */ jsx("strong", { children: yLabel }),
          ":",
          " ",
          valueString(
            yUnit === "%" ? selectedPoint.y / 100 : selectedPoint.y,
            yUnit
          )
        ] }),
        /* @__PURE__ */ jsx(
          BootstrapTooltip,
          {
            title: selectedPoint.highlighted ? t2("tcGraph.buildAlreadyInList") : "",
            placement: "top",
            children: /* @__PURE__ */ jsx("span", { children: /* @__PURE__ */ jsx(
              Button,
              {
                sx: { width: "100%" },
                disabled: (selectedPoint == null ? void 0 : selectedPoint.graphBuildNumber) !== void 0,
                color: "info",
                onClick: () => selectedPoint.build && addBuildToList(structuredClone(selectedPoint.build)),
                children: t2("addBuildToList")
              }
            ) })
          }
        )
      ] }) })
    }
  ) });
}
class EnhancedPoint {
  constructor(x2, y2, build) {
    this.x = x2;
    this.trueY = y2;
    this.build = build;
  }
  get y() {
    return this.trueY || this.current || this.highlighted;
  }
  set y(y2) {
    this.trueY = y2;
  }
}
function ChartCard({
  plotBase,
  setPlotBase,
  disabled = false,
  showTooltip = false
}) {
  const { t: t2 } = useTranslation(["page_character_optimize", "ui"]);
  const { data } = reactExports.useContext(DataContext);
  const { chartData } = reactExports.useContext(GraphContext);
  const [showDownload, setshowDownload] = reactExports.useState(false);
  const [showMin, setshowMin] = reactExports.useState(true);
  const { graphBuilds } = reactExports.useContext(GraphContext);
  const {
    teamChar: { optConfigId }
  } = reactExports.useContext(TeamCharacterContext);
  const { builds: generatedBuilds } = useOptConfig(optConfigId) ?? {
    builds: []
  };
  const [sliderLow, setSliderLow] = reactExports.useState(-Infinity);
  const [sliderHigh, setSliderHigh] = reactExports.useState(Infinity);
  const setSlider = reactExports.useCallback(
    (_e, value) => {
      if (typeof value === "number")
        throw new TypeError();
      const [l2, h2] = value;
      if (l2 === h2)
        return;
      setSliderLow(l2);
      setSliderHigh(h2);
    },
    [setSliderLow, setSliderHigh]
  );
  reactExports.useEffect(() => {
    setSliderLow(-Infinity);
    setSliderHigh(Infinity);
  }, [chartData]);
  const { displayData, downloadData, sliderMin, sliderMax } = reactExports.useMemo(() => {
    var _a, _b;
    if (!chartData)
      return { displayData: null, downloadData: null };
    let sliderMin2 = Infinity;
    let sliderMax2 = -Infinity;
    const currentBuild = allArtifactSlotKeys.map(
      (slotKey) => (data == null ? void 0 : data.get(input.art[slotKey].id).value) ?? ""
    );
    const points = chartData.data.map(({ value: y2, plot: x2, artifactIds, weaponId }) => {
      if (x2 === void 0)
        return null;
      if (x2 < sliderMin2)
        sliderMin2 = x2;
      if (x2 > sliderMax2)
        sliderMax2 = x2;
      const artifactIdsArr = Object.values(artifactIds).filter(notEmpty);
      const enhancedDatum = new EnhancedPoint(x2, y2, {
        artifactIds,
        weaponId
      });
      const datumBuildMap = objKeyMap(artifactIdsArr, (_) => true);
      const isCurrentBuild = currentBuild.every((aId) => datumBuildMap[aId]);
      if (isCurrentBuild) {
        enhancedDatum.current = y2;
        enhancedDatum.y = void 0;
      }
      const graphBuildIndex = graphBuilds == null ? void 0 : graphBuilds.findIndex(
        (build) => build.weaponId === weaponId && Object.values(build.artifactIds).every(
          (aId) => aId && datumBuildMap[aId]
        )
      );
      if (graphBuildIndex !== void 0 && graphBuildIndex !== -1) {
        if (enhancedDatum.trueY !== void 0) {
          enhancedDatum.highlighted = y2;
          enhancedDatum.y = void 0;
        }
        enhancedDatum.graphBuildNumber = graphBuildIndex + 1;
      }
      const generBuildIndex = generatedBuilds.findIndex(
        (build) => build.weaponId === weaponId && Object.values(build.artifactIds).every(
          (aId) => aId && datumBuildMap[aId]
        )
      );
      if (generBuildIndex !== -1) {
        if (enhancedDatum.trueY !== void 0) {
          enhancedDatum.highlighted = y2;
          enhancedDatum.y = void 0;
        }
        enhancedDatum.generBuildNumber = generBuildIndex + 1;
      }
      return enhancedDatum;
    }).filter((pt) => pt !== null).sort((a2, b2) => a2.x - b2.x);
    const minimumData = [];
    for (const point2 of points) {
      let last2;
      while (last2 = minimumData.pop()) {
        if (last2.y > point2.y) {
          minimumData.push(last2);
          break;
        }
      }
      minimumData.push(point2);
    }
    if (((_a = minimumData[0]) == null ? void 0 : _a.x) !== ((_b = points[0]) == null ? void 0 : _b.x))
      points[0].min = minimumData[0].y;
    minimumData.forEach((pt) => {
      pt.min = pt.y;
    });
    const downloadData2 = {
      minimum: minimumData.map((point2) => [point2.x, point2.y]),
      allData: points.map((point2) => [point2.x, point2.y])
    };
    return {
      displayData: points.filter(
        (pt) => pt && pt.x >= sliderLow && pt.x <= sliderHigh
      ),
      downloadData: downloadData2,
      sliderMin: sliderMin2,
      sliderMax: sliderMax2
    };
  }, [chartData, generatedBuilds, data, graphBuilds, sliderLow, sliderHigh]);
  const plotBaseNode = plotBase && objPathValue(data == null ? void 0 : data.getDisplay(), plotBase);
  const invalidTarget = plotBase && (!plotBaseNode || plotBaseNode.isEmpty);
  const buttonText = invalidTarget ? t2("page_character_optimize:targetSelector.invalidTarget") : t2("page_character_optimize:targetSelector.selectGraphTarget");
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, alignItems: "center", children: [
      /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(Typography, { children: t2`tcGraph.vs` }) }),
      /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(
        BootstrapTooltip,
        {
          placement: "top",
          title: showTooltip ? t2("page_character_optimize:selectTargetFirst") : "",
          children: /* @__PURE__ */ jsx("span", { children: /* @__PURE__ */ jsx(
            OptimizationTargetSelector,
            {
              optimizationTarget: plotBase,
              setTarget: (target) => setPlotBase(target),
              defaultText: buttonText,
              disabled,
              targetSelectorModalProps: {
                excludeSections: ["character", "bounsStats", "teamBuff"]
              }
            }
          ) })
        }
      ) }),
      /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(
        BootstrapTooltip,
        {
          title: !plotBase ? "" : t2("ui:reset"),
          placement: "top",
          children: /* @__PURE__ */ jsx("span", { children: /* @__PURE__ */ jsx(
            Button,
            {
              color: "secondary",
              onClick: () => setPlotBase(void 0),
              disabled: !plotBase || disabled,
              children: /* @__PURE__ */ jsx(Replay, {})
            }
          ) })
        }
      ) }),
      /* @__PURE__ */ jsx(Grid, { item: true, flexGrow: 1, children: /* @__PURE__ */ jsx(
        InfoTooltip,
        {
          placement: "top",
          title: t2("page_character_optimize:tcGraph.desc")
        }
      ) }),
      !!downloadData && /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(
        Button,
        {
          size: "small",
          startIcon: showMin ? /* @__PURE__ */ jsx(CheckBox, {}) : /* @__PURE__ */ jsx(CheckBoxOutlineBlank, {}),
          color: showMin ? "success" : "secondary",
          onClick: () => setshowMin(!showMin),
          children: t2`tcGraph.showStatThr`
        }
      ) }),
      !!downloadData && /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(
        Button,
        {
          size: "small",
          color: "info",
          startIcon: /* @__PURE__ */ jsx(Download, {}),
          onClick: () => setshowDownload(!showDownload),
          children: t2`tcGraph.downloadData`
        }
      ) })
    ] }) }),
    chartData && !!chartData.data.length && /* @__PURE__ */ jsx(Divider, {}),
    chartData && !!chartData.data.length && displayData && /* @__PURE__ */ jsxs(CardContent, { children: [
      /* @__PURE__ */ jsx(Collapse, { in: !!downloadData && showDownload, children: /* @__PURE__ */ jsx(CardThemed, { sx: { mb: 2 }, children: /* @__PURE__ */ jsxs(CardContent, { children: [
        /* @__PURE__ */ jsx(Typography, { children: "Min Data" }),
        /* @__PURE__ */ jsx(
          ReadOnlyTextArea,
          {
            value: JSON.stringify(downloadData == null ? void 0 : downloadData.minimum)
          }
        ),
        /* @__PURE__ */ jsx(Typography, { children: "All Data" }),
        /* @__PURE__ */ jsx(
          ReadOnlyTextArea,
          {
            value: JSON.stringify(downloadData == null ? void 0 : downloadData.allData)
          }
        )
      ] }) }) }),
      /* @__PURE__ */ jsx(
        Chart,
        {
          displayData,
          plotNode: chartData.plotNode,
          valueNode: chartData.valueNode,
          showMin
        }
      ),
      chartData.data.length > 1 && /* @__PURE__ */ jsx(
        Slider,
        {
          marks: true,
          value: [sliderLow, sliderHigh],
          onChange: setSlider,
          onChangeCommitted: setSlider,
          min: sliderMin,
          max: sliderMax,
          step: (sliderMax - sliderMin) / 20,
          valueLabelDisplay: "auto",
          valueLabelFormat: (n2) => {
            const info = chartData.plotNode.info && resolveInfo(chartData.plotNode.info);
            return valueString((info == null ? void 0 : info.unit) === "%" ? n2 / 100 : n2, info == null ? void 0 : info.unit);
          },
          sx: { ml: "6%", width: "93%" }
        }
      )
    ] })
  ] });
}
const optTargetColor = "#8884d8";
const highlightedColor = "cyan";
const currentColor = "#46a046";
const lineColor = "#ff7300";
function Chart({
  displayData,
  plotNode,
  valueNode,
  showMin
}) {
  const { graphBuilds, setGraphBuilds } = reactExports.useContext(GraphContext);
  const { t: t2 } = useTranslation("page_character_optimize");
  const [selectedPoint, setSelectedPoint] = reactExports.useState();
  const addBuildToList = reactExports.useCallback(
    (build) => {
      setGraphBuilds([...graphBuilds ?? [], build]);
      setSelectedPoint(void 0);
    },
    [setGraphBuilds, graphBuilds]
  );
  const chartOnClick = reactExports.useCallback(
    (props) => {
      if (props && props.chartX && props.chartY)
        setSelectedPoint(
          getNearestPoint(props.chartX, props.chartY, 20, displayData)
        );
    },
    [setSelectedPoint, displayData]
  );
  const plotNodeInfo = plotNode.info && resolveInfo(plotNode.info);
  const valueNodeInfo = valueNode.info && resolveInfo(valueNode.info);
  const xLabelValue = plotNodeInfo && getLabelFromNode(plotNodeInfo, t2);
  const yLabelValue = valueNodeInfo && getLabelFromNode(valueNodeInfo, t2);
  return /* @__PURE__ */ jsx(ResponsiveContainer, { width: "100%", height: 600, children: /* @__PURE__ */ jsxs(
    ComposedChart,
    {
      id: "chartContainer",
      data: displayData,
      onClick: chartOnClick,
      style: { cursor: "pointer" },
      children: [
        /* @__PURE__ */ jsx(CartesianGrid, { strokeDasharray: "3 3" }),
        /* @__PURE__ */ jsx(
          XAxis,
          {
            dataKey: "x",
            scale: "linear",
            unit: plotNodeInfo == null ? void 0 : plotNodeInfo.unit,
            domain: ["auto", "auto"],
            tick: { fill: "white" },
            type: "number",
            tickFormatter: (n2) => n2 > 1e4 ? n2.toFixed() : n2.toFixed(1),
            label: /* @__PURE__ */ jsx(Label, { fill: "white", dy: 10, children: xLabelValue }),
            height: 50
          }
        ),
        /* @__PURE__ */ jsx(
          YAxis,
          {
            name: "DMG",
            domain: ["auto", "auto"],
            unit: valueNodeInfo == null ? void 0 : valueNodeInfo.unit,
            allowDecimals: false,
            tick: { fill: "white" },
            type: "number",
            label: /* @__PURE__ */ jsx(Label, { fill: "white", angle: -90, dx: -40, children: yLabelValue }),
            width: 100
          }
        ),
        /* @__PURE__ */ jsx(
          Tooltip,
          {
            content: /* @__PURE__ */ jsx(
              CustomTooltip,
              {
                xLabel: xLabelValue ?? "",
                xUnit: plotNodeInfo == null ? void 0 : plotNodeInfo.unit,
                yLabel: yLabelValue ?? "",
                yUnit: valueNodeInfo == null ? void 0 : valueNodeInfo.unit,
                selectedPoint,
                setSelectedPoint,
                addBuildToList
              }
            ),
            trigger: "click",
            wrapperStyle: { pointerEvents: "auto", cursor: "auto" },
            cursor: false
          }
        ),
        /* @__PURE__ */ jsx(
          Legend,
          {
            payload: [
              ...showMin ? [
                {
                  id: "min",
                  value: t2`tcGraph.statReqThr`,
                  type: "line",
                  color: lineColor
                }
              ] : [],
              {
                id: "trueY",
                value: t2`tcGraph.generatedBuilds`,
                type: "circle",
                color: optTargetColor
              },
              {
                id: "highlighted",
                value: t2`tcGraph.highlightedBuilds`,
                type: "square",
                color: highlightedColor
              },
              {
                id: "current",
                value: t2`tcGraph.currentBuild`,
                type: "diamond",
                color: currentColor
              }
            ]
          }
        ),
        showMin && /* @__PURE__ */ jsx(
          Line,
          {
            dataKey: "min",
            stroke: lineColor,
            type: "stepBefore",
            connectNulls: true,
            strokeWidth: 2,
            isAnimationActive: false,
            dot: false,
            activeDot: false
          }
        ),
        /* @__PURE__ */ jsx(
          Scatter,
          {
            dataKey: "trueY",
            isAnimationActive: false,
            shape: /* @__PURE__ */ jsx(
              CustomDot,
              {
                selectedPoint,
                colorUnselected: optTargetColor
              }
            )
          }
        ),
        /* @__PURE__ */ jsx(
          Scatter,
          {
            dataKey: "highlighted",
            isAnimationActive: false,
            shape: /* @__PURE__ */ jsx(
              CustomDot,
              {
                shape: "square",
                selectedPoint,
                colorUnselected: highlightedColor
              }
            )
          }
        ),
        /* @__PURE__ */ jsx(
          Scatter,
          {
            dataKey: "current",
            isAnimationActive: false,
            shape: /* @__PURE__ */ jsx(
              CustomDot,
              {
                shape: "diamond",
                selectedPoint,
                colorUnselected: currentColor
              }
            )
          }
        )
      ]
    }
  ) });
}
function getNearestPoint(clickedX, clickedY, threshold2, data) {
  const nearestDomPtData = Array.from(
    document.querySelectorAll(".custom-dot")
  ).reduce((domPtA, domPtB) => {
    const { chartX: aChartX, chartY: aChartY } = domPtA.dataset;
    const aDistance = Math.sqrt(
      (clickedX - aChartX) ** 2 + (clickedY - aChartY) ** 2
    );
    const { chartX: bChartX, chartY: bChartY } = domPtB.dataset;
    const bDistance = Math.sqrt(
      (clickedX - bChartX) ** 2 + (clickedY - bChartY) ** 2
    );
    return aDistance <= bDistance ? domPtA : domPtB;
  })["dataset"];
  const distance = Math.sqrt(
    (clickedX - nearestDomPtData.chartX) ** 2 + (clickedY - nearestDomPtData.chartY) ** 2
  );
  return distance < threshold2 ? data.find(
    (d2) => d2.x === +nearestDomPtData.xValue && d2.y === +nearestDomPtData.yValue
  ) : void 0;
}
function getLabelFromNode(info, t2) {
  const { name, textSuffix } = info;
  return typeof name === "string" ? name : `${t2(`${name == null ? void 0 : name.props.ns}:${name == null ? void 0 : name.props.key18}`)}${textSuffix ? ` ${textSuffix}` : ""}`;
}
function ExcludeArt({
  disabled = false,
  excludedTotal
}) {
  const { t: t2 } = useTranslation("page_character_optimize");
  const database = useDatabase();
  const {
    teamChar: { optConfigId }
  } = reactExports.useContext(TeamCharacterContext);
  const { artExclusion, useExcludedArts } = useOptConfig(optConfigId);
  const [show, onOpen, onClose] = useBoolState(false);
  const numExcludedArt = artExclusion.length;
  const [showSel, onOpenSel, onCloseSel] = useBoolState(false);
  const onExclude = reactExports.useCallback(
    (ids) => {
      database.optConfigs.set(optConfigId, {
        artExclusion: [...artExclusion, ...ids],
        useExcludedArts: false
      });
    },
    [database, optConfigId, artExclusion]
  );
  const onInclude = reactExports.useCallback(
    (ids) => {
      database.optConfigs.set(optConfigId, {
        artExclusion: artExclusion.filter((i) => !ids.includes(i)),
        useExcludedArts: false
      });
    },
    [database, optConfigId, artExclusion]
  );
  const toggleArtExclusion = reactExports.useCallback(
    () => database.optConfigs.set(optConfigId, {
      useExcludedArts: !useExcludedArts
    }),
    [database, optConfigId, useExcludedArts]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      ModalWrapper,
      {
        open: show,
        onClose,
        containerProps: { maxWidth: "xl" },
        children: /* @__PURE__ */ jsxs(CardThemed, { children: [
          /* @__PURE__ */ jsx(
            CardHeader,
            {
              title: /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, alignItems: "center", children: [
                /* @__PURE__ */ jsx(Typography, { variant: "h6", children: t2`excludeArt.title_exclude` }),
                /* @__PURE__ */ jsx(
                  InfoTooltip,
                  {
                    title: /* @__PURE__ */ jsx(Typography, { children: t2`excludeArt.title_tooltip` })
                  }
                )
              ] }),
              action: /* @__PURE__ */ jsx(IconButton, { onClick: onClose, children: /* @__PURE__ */ jsx(default_1$a, {}) })
            }
          ),
          /* @__PURE__ */ jsx(Divider, {}),
          /* @__PURE__ */ jsxs(CardContent, { children: [
            /* @__PURE__ */ jsx(
              ArtifactSelectModal,
              {
                show: showSel,
                onClose: onCloseSel,
                onExclude,
                onInclude,
                artExclusion
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                fullWidth: true,
                onClick: onOpenSel,
                color: "info",
                sx: { mb: 1 },
                startIcon: /* @__PURE__ */ jsx(default_1$i, {}),
                children: t2`excludeArt.addExc`
              }
            ),
            !!numExcludedArt && /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { mb: 1 }, children: /* @__PURE__ */ jsx(Typography, { textAlign: "center", children: t2`excludeArt.deSelectExc` }) }),
            /* @__PURE__ */ jsx(
              Grid,
              {
                container: true,
                columns: { xs: 3, md: 5, lg: 6, xl: 8 },
                spacing: 1,
                children: artExclusion.map((id) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                  CardThemed,
                  {
                    bgt: "light",
                    sx: { height: "100%", maxHeight: "8em" },
                    children: /* @__PURE__ */ jsx(
                      ArtifactCardNano,
                      {
                        artifactId: id,
                        slotKey: "flower",
                        onClick: () => onInclude([id]),
                        showLocation: true
                      }
                    )
                  }
                ) }, id))
              }
            )
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ jsxs(ButtonGroup, { sx: { display: "flex", width: "100%" }, children: [
      /* @__PURE__ */ jsx(
        Button,
        {
          onClick: toggleArtExclusion,
          disabled: disabled || !numExcludedArt,
          startIcon: useExcludedArts ? /* @__PURE__ */ jsx(default_1$n, {}) : /* @__PURE__ */ jsx(default_1$m, {}),
          color: useExcludedArts ? "secondary" : "success",
          sx: { flexGrow: 1 },
          children: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
            /* @__PURE__ */ jsx(Box, { children: t2("excludeArt.button_txt") }),
            /* @__PURE__ */ jsx(
              SqBadge,
              {
                sx: { whiteSpace: "normal" },
                color: !numExcludedArt ? "secondary" : useExcludedArts ? "warning" : "primary",
                children: useExcludedArts ? /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "excludeArt.usingNum", children: [
                  "Using ",
                  { totalStr: excludedTotal },
                  " excluded artifacts"
                ] }) : /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "excludeArt.excNum", count: numExcludedArt, children: [
                  { count: numExcludedArt },
                  " artifacts are excluded"
                ] })
              }
            )
          ] })
        }
      ),
      /* @__PURE__ */ jsx(
        Button,
        {
          color: "info",
          onClick: onOpen,
          disabled,
          sx: { flexShrink: 1 },
          children: /* @__PURE__ */ jsx(default_1$q, {})
        }
      )
    ] })
  ] });
}
function ExcludeArtRedButtons({
  artifactIds,
  artExclusion,
  onExclude,
  onInclude
}) {
  const { t: t2 } = useTranslation(["artifact", "ui"]);
  const { numExclude, numInclude } = reactExports.useMemo(() => {
    const excludedFiltered = artExclusion.filter((i) => artifactIds.includes(i));
    const numExclude2 = artifactIds.length - excludedFiltered.length;
    const numInclude2 = artifactIds.length - numExclude2;
    return { numExclude: numExclude2, numInclude: numInclude2 };
  }, [artifactIds, artExclusion]);
  const excludeArtifacts = () => window.confirm(
    `Are you sure you want to exclude ${numExclude} artifacts from build optimization?`
  ) && onExclude(artifactIds);
  const includeArtifacts = () => window.confirm(
    `Are you sure you want to include ${numInclude} artifacts to build optimization?`
  ) && onInclude(artifactIds);
  return /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, alignItems: "center", children: [
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, sm: 6, md: 6, children: /* @__PURE__ */ jsxs(
      Button,
      {
        fullWidth: true,
        color: "error",
        disabled: !numExclude,
        onClick: excludeArtifacts,
        startIcon: /* @__PURE__ */ jsx(ExcludeIcon, {}),
        children: [
          /* @__PURE__ */ jsx(Trans, { t: t2, i18nKey: "button.excludeArtifacts", children: "Exclude Artifacts" }),
          /* @__PURE__ */ jsx(SqBadge, { sx: { ml: 1 }, color: numExclude ? "success" : "secondary", children: numExclude })
        ]
      }
    ) }),
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, sm: 6, md: 6, children: /* @__PURE__ */ jsxs(
      Button,
      {
        fullWidth: true,
        color: "error",
        disabled: !numInclude,
        onClick: includeArtifacts,
        startIcon: /* @__PURE__ */ jsx(OptimizationIcon, {}),
        children: [
          /* @__PURE__ */ jsx(Trans, { t: t2, i18nKey: "button.includeArtifacts", children: "Include Artifacts" }),
          /* @__PURE__ */ jsx(SqBadge, { sx: { ml: 1 }, color: numInclude ? "success" : "secondary", children: numInclude })
        ]
      }
    ) }),
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, display: "flex", justifyContent: "space-around", children: /* @__PURE__ */ jsx(Typography, { variant: "caption", color: "text.secondary", children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "buttonHint", children: [
      "Note: the red buttons above only apply to",
      /* @__PURE__ */ jsx("b", { children: "currently filtered artifacts" })
    ] }) }) })
  ] });
}
const numToShowMap = { xs: 2 * 3, sm: 2 * 3, md: 3 * 3, lg: 4 * 3, xl: 4 * 3 };
const filterOptionReducer = (state, action) => ({ ...state, ...action });
function ArtifactSelectModal({
  onExclude,
  onInclude,
  show,
  onClose,
  artExclusion
}) {
  const { t: t2 } = useTranslation("page_character_optimize");
  const database = useDatabase();
  const [filterOption, filterOptionDispatch] = reactExports.useReducer(
    filterOptionReducer,
    initialArtifactFilterOption()
  );
  const [dbDirty, forceUpdate] = useForceUpdate();
  reactExports.useEffect(() => {
    return database.arts.followAny(forceUpdate);
  }, [database, forceUpdate]);
  const brPt = useMediaQueryUp();
  const filterConfigs = reactExports.useMemo(
    () => artifactFilterConfigs({ excludedIds: artExclusion }),
    [artExclusion]
  );
  const artifactIds = reactExports.useMemo(() => {
    const filterFunc = filterFunction(filterOption, filterConfigs);
    return dbDirty && database.arts.values.filter(filterFunc).map((art) => art.id);
  }, [dbDirty, database, filterConfigs, filterOption]);
  const { numShow, setTriggerElement } = useInfScroll(
    numToShowMap[brPt],
    artifactIds.length
  );
  const artifactIdsToShow = reactExports.useMemo(
    () => artifactIds.slice(0, numShow),
    [artifactIds, numShow]
  );
  return /* @__PURE__ */ jsx(
    ModalWrapper,
    {
      open: show,
      onClose,
      containerProps: { maxWidth: "xl" },
      children: /* @__PURE__ */ jsxs(CardThemed, { children: [
        /* @__PURE__ */ jsx(
          CardHeader,
          {
            title: t2`excludeArt.selExc`,
            action: /* @__PURE__ */ jsx(IconButton, { onClick: onClose, children: /* @__PURE__ */ jsx(default_1$a, {}) })
          }
        ),
        /* @__PURE__ */ jsx(Divider, {}),
        /* @__PURE__ */ jsxs(CardContent, { children: [
          /* @__PURE__ */ jsx(
            reactExports.Suspense,
            {
              fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 200 }),
              children: /* @__PURE__ */ jsx(
                ArtifactFilterDisplay,
                {
                  filterOption,
                  filterOptionDispatch,
                  filteredIds: artifactIds,
                  enableExclusionFilter: true,
                  excludedIds: artExclusion
                }
              )
            }
          ),
          /* @__PURE__ */ jsx(Box, { mt: 1, children: /* @__PURE__ */ jsx(
            ExcludeArtRedButtons,
            {
              artifactIds,
              artExclusion,
              onExclude,
              onInclude
            }
          ) }),
          /* @__PURE__ */ jsxs(Box, { mt: 1, children: [
            /* @__PURE__ */ jsx(
              reactExports.Suspense,
              {
                fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 300 }),
                children: /* @__PURE__ */ jsx(Grid, { container: true, spacing: 1, columns: { xs: 2, md: 3, lg: 4 }, children: artifactIdsToShow.map((id) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                  ArtifactCard,
                  {
                    artifactId: id,
                    excluded: artExclusion.includes(id),
                    onClick: () => artExclusion.includes(id) ? onInclude([id]) : onExclude([id])
                  }
                ) }, id)) })
              }
            ),
            artifactIds.length !== artifactIdsToShow.length && /* @__PURE__ */ jsx(
              Skeleton,
              {
                ref: (node) => {
                  if (!node)
                    return;
                  setTriggerElement(node);
                },
                sx: { borderRadius: 1, mt: 1 },
                variant: "rectangular",
                width: "100%",
                height: 100
              }
            )
          ] })
        ] })
      ] })
    }
  );
}
const artifactsSlotsToSelectMainStats = ["sands", "goblet", "circlet"];
function MainStatSelectionCard({
  disabled = false,
  filteredArtIdMap
}) {
  const { t: t2 } = useTranslation("artifact");
  const {
    teamChar: { optConfigId }
  } = reactExports.useContext(TeamCharacterContext);
  const { mainStatKeys } = useOptConfig(optConfigId);
  const database = useDatabase();
  const { mainStatSlotTots, slotTots } = reactExports.useMemo(() => {
    const catKeys = {
      flowerMainStatTots: artSlotMainKeys["flower"],
      plumeMainStatTots: artSlotMainKeys["plume"],
      sandsMainStatTots: artSlotMainKeys["sands"],
      gobletMainStatTots: artSlotMainKeys["goblet"],
      circletMainStatTots: artSlotMainKeys["circlet"],
      slotTots: artifactsSlotsToSelectMainStats
    };
    const catTotals = bulkCatTotal(
      catKeys,
      (ctMap) => database.arts.entries.forEach(([id, art]) => {
        const { slotKey, mainStatKey } = art;
        if (artifactsSlotsToSelectMainStats.includes(
          slotKey
        )) {
          ctMap.slotTots[slotKey].total++;
          if (filteredArtIdMap[id])
            ctMap.slotTots[slotKey].current++;
        }
        ctMap[`${slotKey}MainStatTots`][mainStatKey].total++;
        if (filteredArtIdMap[id])
          ctMap[`${slotKey}MainStatTots`][mainStatKey].current++;
      })
    );
    return {
      mainStatSlotTots: {
        flower: catTotals.flowerMainStatTots,
        plume: catTotals.plumeMainStatTots,
        sands: catTotals.sandsMainStatTots,
        goblet: catTotals.gobletMainStatTots,
        circlet: catTotals.circletMainStatTots
      },
      slotTots: catTotals.slotTots
    };
  }, [database, filteredArtIdMap]);
  return /* @__PURE__ */ jsxs(Box, { display: "flex", flexDirection: "column", children: [
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsxs(Box, { display: "flex", children: [
      /* @__PURE__ */ jsx(CardContent, { sx: { flexGrow: 1 }, children: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, alignItems: "center" }, children: [
        /* @__PURE__ */ jsx(
          BootstrapTooltip,
          {
            placement: "top",
            title: /* @__PURE__ */ jsx(Typography, { children: t2(`slotName.flower`) }),
            children: /* @__PURE__ */ jsx(FlowerIcon, { fontSize: "inherit" })
          }
        ),
        /* @__PURE__ */ jsx(Box, { flexGrow: 1, children: /* @__PURE__ */ jsxs(SqBadge, { color: "info", children: [
          /* @__PURE__ */ jsx(HpIcon, { ...iconInlineProps }),
          " ",
          mainStatSlotTots.flower.hp
        ] }) })
      ] }) }),
      /* @__PURE__ */ jsx(Divider, { orientation: "vertical", flexItem: true }),
      /* @__PURE__ */ jsx(CardContent, { sx: { flexGrow: 1 }, children: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, alignItems: "center" }, children: [
        /* @__PURE__ */ jsx(
          BootstrapTooltip,
          {
            placement: "top",
            title: /* @__PURE__ */ jsx(Typography, { children: t2(`slotName.plume`) }),
            children: /* @__PURE__ */ jsx(PlumeIcon, { fontSize: "inherit" })
          }
        ),
        /* @__PURE__ */ jsx(Box, { flexGrow: 1, children: /* @__PURE__ */ jsxs(SqBadge, { color: "info", children: [
          /* @__PURE__ */ jsx(AtkIcon, { ...iconInlineProps }),
          " ",
          mainStatSlotTots.plume.atk
        ] }) })
      ] }) })
    ] }),
    artifactsSlotsToSelectMainStats.map((slotKey) => {
      const selectedMainKeys = mainStatKeys[slotKey];
      const mainKeys = artSlotMainKeys[slotKey];
      const mainKeysHandler = handleMultiSelect([...mainKeys]);
      return /* @__PURE__ */ jsxs(Box, { children: [
        /* @__PURE__ */ jsx(Divider, {}),
        /* @__PURE__ */ jsxs(CardContent, { sx: { pt: 1, pb: 1 }, children: [
          /* @__PURE__ */ jsxs(
            Box,
            {
              sx: { display: "flex", gap: 1, alignItems: "center", pb: 1 },
              children: [
                /* @__PURE__ */ jsx(
                  BootstrapTooltip,
                  {
                    placement: "top",
                    title: /* @__PURE__ */ jsx(Typography, { children: t2(`slotName.${slotKey}`) }),
                    children: /* @__PURE__ */ jsx(Box, { lineHeight: 0, children: /* @__PURE__ */ jsx(
                      SlotIcon,
                      {
                        slotKey,
                        iconProps: { fontSize: "inherit" }
                      }
                    ) })
                  }
                ),
                /* @__PURE__ */ jsx(Box, { flexGrow: 1, children: /* @__PURE__ */ jsx(SqBadge, { color: "info", children: slotTots[slotKey] }) })
              ]
            }
          ),
          /* @__PURE__ */ jsx(Grid, { container: true, spacing: 1, children: mainKeys.map((mainStatKey, i) => {
            const element = allElementWithPhyKeys.find(
              (ele) => mainStatKey.includes(ele)
            );
            const color2 = selectedMainKeys.includes(mainStatKey) ? element ?? "success" : "secondary";
            return /* @__PURE__ */ jsx(
              Grid,
              {
                item: true,
                flexGrow: 1,
                xs: i < 3 && slotKey !== "goblet" || slotKey === "goblet" ? 4 : void 0,
                children: /* @__PURE__ */ jsx(
                  BootstrapTooltip,
                  {
                    placement: "top",
                    title: /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsx(StatColoredWithUnit, { statKey: mainStatKey }) }) }),
                    disableInteractive: true,
                    children: /* @__PURE__ */ jsx(
                      Button,
                      {
                        fullWidth: true,
                        size: "small",
                        color: color2,
                        sx: {
                          height: "100%",
                          pointerEvents: disabled ? "none" : void 0,
                          cursor: disabled ? "none" : void 0
                        },
                        startIcon: /* @__PURE__ */ jsx(StatIcon, { statKey: mainStatKey }),
                        onClick: () => database.optConfigs.set(optConfigId, {
                          mainStatKeys: {
                            ...mainStatKeys,
                            [slotKey]: mainKeysHandler(
                              selectedMainKeys,
                              mainStatKey
                            )
                          }
                        }),
                        children: mainStatSlotTots[slotKey][mainStatKey]
                      }
                    )
                  }
                )
              },
              mainStatKey
            );
          }) })
        ] })
      ] }, slotKey);
    })
  ] });
}
const OptCharacterCard = reactExports.memo(function OptCharacterCard2({
  characterKey
}) {
  return /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsxs(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 600 }),
      children: [
        /* @__PURE__ */ jsx(CharacterCardHeader, { characterKey, children: /* @__PURE__ */ jsx(CharacterCardHeaderContent, { characterKey }) }),
        /* @__PURE__ */ jsx(
          Box,
          {
            sx: {
              p: 1,
              width: "100%",
              display: "flex",
              flexDirection: "column",
              gap: 1
            },
            children: /* @__PURE__ */ jsx(CharacterCardEquipmentRow, {})
          }
        ),
        /* @__PURE__ */ jsx(CharacterCardStats, { bgt: "light" })
      ]
    }
  ) });
});
function OptimizationTargetEditorList({
  statFilters,
  setStatFilters,
  disabled = false
}) {
  const setTarget = reactExports.useCallback(
    (path, oldPath, oldIndex) => {
      const statFilters_ = { ...statFilters };
      const oldPathStr = JSON.stringify(oldPath);
      const oldFilterArr = oldPath ? [...statFilters[oldPathStr]] : void 0;
      const pathStr = JSON.stringify(path);
      const filterArr = [...statFilters[pathStr] ?? []];
      if (oldIndex !== void 0 && oldFilterArr)
        filterArr.push(oldFilterArr[oldIndex]);
      else
        filterArr.push({ value: 0, disabled: false });
      statFilters_[pathStr] = filterArr;
      if (oldIndex !== void 0 && oldFilterArr) {
        oldFilterArr.splice(oldIndex, 1);
        if (oldFilterArr.length)
          statFilters_[oldPathStr] = oldFilterArr;
        else
          delete statFilters_[oldPathStr];
      }
      setStatFilters({ ...statFilters_ });
    },
    [setStatFilters, statFilters]
  );
  const delTarget = reactExports.useCallback(
    (path, index) => {
      const statFilters_ = { ...statFilters };
      const pathStr = JSON.stringify(path);
      const filterArr = [...statFilters[pathStr]];
      filterArr.splice(index, 1);
      if (filterArr.length)
        statFilters_[pathStr] = filterArr;
      else
        delete statFilters_[pathStr];
      setStatFilters({ ...statFilters_ });
    },
    [setStatFilters, statFilters]
  );
  const setTargetValue = reactExports.useCallback(
    (path, index, value) => {
      const statFilters_ = { ...statFilters };
      const pathStr = JSON.stringify(path);
      const filterArr = [...statFilters[pathStr]];
      filterArr[index] = { ...filterArr[index], value };
      statFilters_[pathStr] = filterArr;
      setStatFilters({ ...statFilters_ });
    },
    [setStatFilters, statFilters]
  );
  const setTargetDisabled = reactExports.useCallback(
    (path, index, disabled2) => {
      const statFilters_ = { ...statFilters };
      const pathStr = JSON.stringify(path);
      const filterArr = [...statFilters[pathStr]];
      filterArr[index] = { ...filterArr[index], disabled: disabled2 };
      statFilters_[pathStr] = filterArr;
      setStatFilters({ ...statFilters_ });
    },
    [setStatFilters, statFilters]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    Object.entries(statFilters).flatMap(
      ([pathStr, settings]) => settings == null ? void 0 : settings.map((setting, index) => /* @__PURE__ */ jsx(
        OptimizationTargetEditorItem,
        {
          path: JSON.parse(pathStr),
          setting,
          index,
          setTarget,
          delTarget,
          setValue: setTargetValue,
          setDisabled: setTargetDisabled,
          disabled
        },
        pathStr + index
      ))
    ),
    /* @__PURE__ */ jsx(
      OptimizationTargetEditorItem,
      {
        setTarget,
        delTarget,
        setValue: setTargetValue,
        setDisabled: setTargetDisabled,
        disabled
      }
    )
  ] });
}
function OptimizationTargetEditorItem({
  path,
  setting,
  index,
  setTarget,
  delTarget,
  setValue,
  setDisabled,
  disabled
}) {
  const { t: t2 } = useTranslation("page_character_optimize");
  const { data } = reactExports.useContext(DataContext);
  const onChange = reactExports.useCallback(
    (val) => path && index !== void 0 && setValue(path, index, val ?? 0),
    [setValue, path, index]
  );
  const buttonStyle = { p: 1, flexBasis: 30, flexGrow: 0, flexShrink: 0 };
  const buildConstraintNode = objPathValue(
    data.getDisplay(),
    path ?? []
  );
  const resolvedInfo = (buildConstraintNode == null ? void 0 : buildConstraintNode.info) && resolveInfo(buildConstraintNode == null ? void 0 : buildConstraintNode.info);
  const isPercent3 = (resolvedInfo == null ? void 0 : resolvedInfo.unit) === "%";
  return /* @__PURE__ */ jsxs(
    ButtonGroup,
    {
      sx: { "& .MuiButtonGroup-grouped": { minWidth: 24 }, width: "100%" },
      children: [
        !!setting && !!path && index !== void 0 && /* @__PURE__ */ jsx(
          Button,
          {
            sx: buttonStyle,
            color: setting.disabled ? "secondary" : "success",
            onClick: () => setDisabled(path, index, !setting.disabled),
            disabled,
            children: setting.disabled ? /* @__PURE__ */ jsx(CheckBoxOutlineBlank, {}) : /* @__PURE__ */ jsx(CheckBox, {})
          }
        ),
        /* @__PURE__ */ jsx(
          OptimizationTargetSelector,
          {
            showEmptyTargets: true,
            optimizationTarget: path,
            setTarget: (target) => setTarget(target, path, index),
            defaultText: t2("targetSelector.selectBuildTarget"),
            disabled,
            targetSelectorModalProps: {
              excludeSections: ["custom", "bounsStats", "character", "teamBuff"]
            }
          }
        ),
        /* @__PURE__ */ jsx(CustomNumberInputButtonGroupWrapper, { sx: { flexBasis: 150, flexGrow: 1 }, children: /* @__PURE__ */ jsx(
          CustomNumberInput,
          {
            float: true,
            disabled: !path || disabled,
            value: setting == null ? void 0 : setting.value,
            placeholder: "Stat Value",
            onChange,
            sx: { px: 1 },
            inputProps: { sx: { textAlign: "right" } },
            endAdornment: isPercent3 ? "%" : void 0
          }
        ) }),
        !!path && index !== void 0 && /* @__PURE__ */ jsx(
          Button,
          {
            sx: buttonStyle,
            color: "error",
            onClick: () => delTarget(path, index),
            disabled,
            children: /* @__PURE__ */ jsx(DeleteForever, { fontSize: "small" })
          }
        )
      ]
    }
  );
}
function StatFilterCard({
  disabled = false
}) {
  const { t: t2 } = useTranslation("page_character_optimize");
  const {
    teamChar: { optConfigId }
  } = reactExports.useContext(TeamCharacterContext);
  const { statFilters } = useOptConfig(optConfigId);
  const database = useDatabase();
  const setStatFilters = reactExports.useCallback(
    (statFilters2) => database.optConfigs.set(optConfigId, { statFilters: statFilters2 }),
    [database, optConfigId]
  );
  return /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    /* @__PURE__ */ jsx(
      CardContent,
      {
        sx: {
          display: "flex",
          gap: 1,
          justifyContent: "space-between",
          flexDirection: "column"
        },
        children: /* @__PURE__ */ jsxs(Box, { display: "flex", justifyContent: "space-between", children: [
          /* @__PURE__ */ jsx(
            Typography,
            {
              sx: { fontWeight: "bold" },
              children: t2`constraintFilter.title`
            }
          ),
          /* @__PURE__ */ jsx(
            InfoTooltip,
            {
              title: /* @__PURE__ */ jsx(Typography, { children: t2`constraintFilter.tooltip` })
            }
          )
        ] })
      }
    ),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(Box, { display: "flex", flexDirection: "column", gap: 0.5, children: /* @__PURE__ */ jsx(
      OptimizationTargetEditorList,
      {
        statFilters,
        setStatFilters,
        disabled
      }
    ) })
  ] }) });
}
function UseEquipped({
  disabled = false,
  allowListTotal
}) {
  const { t: t2 } = useTranslation("page_character_optimize");
  const { t: t_pc } = useTranslation("page_character");
  const {
    teamChar: { optConfigId }
  } = reactExports.useContext(TeamCharacterContext);
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const { silly } = reactExports.useContext(SillyContext);
  const { excludedLocations } = useOptConfig(optConfigId);
  const database = useDatabase();
  const [show, onOpen, onClose] = useBoolState(false);
  const [dbDirty, forceUpdate] = useForceUpdate();
  const deferredDbDirty = reactExports.useDeferredValue(dbDirty);
  const [searchTerm, setSearchTerm] = reactExports.useState("");
  const deferredSearchTerm = reactExports.useDeferredValue(searchTerm);
  const [elementKeys, setElementKeys] = reactExports.useState([...allElementKeys]);
  const deferredElementKeys = reactExports.useDeferredValue(elementKeys);
  const [weaponTypeKeys, setWeaponTypeKeys] = reactExports.useState([...allWeaponTypeKeys]);
  const deferredWeaponTypeKeys = reactExports.useDeferredValue(weaponTypeKeys);
  const [characterRarityKeys, setCharacterRarityKeys] = reactExports.useState([
    ...allCharacterRarityKeys
  ]);
  const deferredCharacterRarityKeys = reactExports.useDeferredValue(characterRarityKeys);
  const charKeyMap = reactExports.useMemo(
    () => deferredDbDirty && Object.fromEntries(
      Array.from(
        new Set(
          Object.entries(database.chars.data).filter(
            ([ck]) => charKeyToLocCharKey(ck) !== charKeyToLocCharKey(characterKey)
          ).filter(
            ([ck]) => filterFunction(
              {
                element: deferredElementKeys,
                weaponType: deferredWeaponTypeKeys,
                rarity: deferredCharacterRarityKeys,
                name: deferredSearchTerm
              },
              characterFilterConfigs(database, silly)
            )(ck)
          )
        )
      )
    ),
    [
      deferredDbDirty,
      database,
      characterKey,
      deferredElementKeys,
      deferredWeaponTypeKeys,
      deferredCharacterRarityKeys,
      deferredSearchTerm,
      silly
    ]
  );
  const locListLength = reactExports.useMemo(
    () => deferredDbDirty && new Set(
      Object.keys(database.chars.data).filter(
        (ck) => charKeyToLocCharKey(ck) !== charKeyToLocCharKey(characterKey)
      ).map(charKeyToLocCharKey)
    ).size,
    [characterKey, database.chars.data, deferredDbDirty]
  );
  const locList = Array.from(
    new Set(
      Object.entries(charKeyMap).sort(([ck1, c1], [ck2, c2]) => {
        const [choosec1, choosec2] = [-1, 1];
        const c1f = database.charMeta.get(ck1).favorite;
        const c2f = database.charMeta.get(ck2).favorite;
        if (c1f && !c2f)
          return choosec1;
        else if (c2f && !c1f)
          return choosec2;
        const art1 = Object.values(c1.equippedArtifacts).filter(
          (id) => id
        ).length;
        const art2 = Object.values(c2.equippedArtifacts).filter(
          (id) => id
        ).length;
        if (art1 > art2)
          return choosec1;
        else if (art2 > art1)
          return choosec2;
        return ck1.localeCompare(ck2);
      }).map(([ck]) => charKeyToLocCharKey(ck))
    )
  );
  const {
    elementTotals,
    weaponTypeTotals,
    characterRarityTotals,
    locListTotals
  } = reactExports.useMemo(() => {
    const catKeys = {
      elementTotals: [...allElementKeys],
      weaponTypeTotals: [...allWeaponTypeKeys],
      characterRarityTotals: [...allCharacterRarityKeys],
      locListTotals: ["allowed", "excluded"]
    };
    let travelerProcessed = false;
    return bulkCatTotal(
      catKeys,
      (ctMap) => Object.entries(database.chars.data).filter(
        ([ck]) => charKeyToLocCharKey(ck) !== charKeyToLocCharKey(characterKey)
      ).forEach(([ck]) => {
        const eleKey = getCharEle(ck);
        const charStat = getCharStat(ck);
        const weaponTypeKey = charStat.weaponType;
        const characterRarityKey = charStat.rarity;
        ctMap.elementTotals[eleKey].total++;
        if (charKeyMap[ck])
          ctMap.elementTotals[eleKey].current++;
        if (charKeyToLocCharKey(ck) === "Traveler") {
          if (!charKeyMap[ck] && locList.includes("Traveler")) {
            ctMap.elementTotals[eleKey].current++;
            if (travelerProcessed)
              return;
            ctMap.weaponTypeTotals[weaponTypeKey].current++;
            ctMap.characterRarityTotals[characterRarityKey].current++;
          }
          travelerProcessed = true;
        }
        ctMap.weaponTypeTotals[weaponTypeKey].total++;
        if (charKeyMap[ck])
          ctMap.weaponTypeTotals[weaponTypeKey].current++;
        ctMap.characterRarityTotals[characterRarityKey].total++;
        if (charKeyMap[ck])
          ctMap.characterRarityTotals[characterRarityKey].current++;
        const locKey = charKeyToLocCharKey(ck);
        if (locList.includes(locKey)) {
          ctMap.locListTotals.allowed.total++;
          ctMap.locListTotals.excluded.total++;
          if (!excludedLocations.includes(locKey))
            ctMap.locListTotals.allowed.current++;
          else
            ctMap.locListTotals.excluded.current++;
        }
      })
    );
  }, [charKeyMap, characterKey, database, excludedLocations, locList]);
  reactExports.useEffect(
    () => database.charMeta.followAny((_) => forceUpdate()),
    [forceUpdate, database]
  );
  reactExports.useEffect(
    () => database.chars.followAny((_) => forceUpdate()),
    [forceUpdate, database]
  );
  const [mouseUpDetected, setMouseUpDetected] = reactExports.useState(false);
  const allowAll = reactExports.useCallback(
    () => database.optConfigs.set(optConfigId, {
      excludedLocations: excludedLocations.filter(
        (key) => !locList.includes(key)
      )
    }),
    [database, optConfigId, excludedLocations, locList]
  );
  const disallowAll = reactExports.useCallback(
    () => database.optConfigs.set(optConfigId, {
      excludedLocations: Array.from(
        new Set(excludedLocations.concat(locList))
      )
    }),
    [database, optConfigId, excludedLocations, locList]
  );
  const toggleList = reactExports.useCallback(
    (lkList) => {
      const lkArray = [...lkList];
      const newExcludedLocations = lkArray.filter((lk) => !excludedLocations.includes(lk)).concat(excludedLocations.filter((lk) => !lkArray.includes(lk)));
      database.optConfigs.set(optConfigId, {
        excludedLocations: newExcludedLocations
      });
    },
    [database, optConfigId, excludedLocations]
  );
  const onMouseUp = reactExports.useCallback(() => setMouseUpDetected(true), []);
  const total = locListLength;
  const useTot = total - excludedLocations.length;
  const totalStr = useTot === total ? useTot : `${useTot}/${total}`;
  return /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, children: [
    /* @__PURE__ */ jsx(
      ModalWrapper,
      {
        open: show,
        onClose,
        containerProps: { maxWidth: "xl" },
        draggable: false,
        onMouseUp,
        children: /* @__PURE__ */ jsxs(CardThemed, { children: [
          /* @__PURE__ */ jsx(
            CardHeader,
            {
              title: /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, alignItems: "center", children: [
                /* @__PURE__ */ jsx(Typography, { variant: "h6", children: t2`excludeChar.title` }),
                /* @__PURE__ */ jsx(
                  InfoTooltip,
                  {
                    title: /* @__PURE__ */ jsx(Typography, { children: t2`excludeChar.tooltip` })
                  }
                )
              ] }),
              action: /* @__PURE__ */ jsx(IconButton, { onClick: onClose, children: /* @__PURE__ */ jsx(default_1$a, {}) })
            }
          ),
          /* @__PURE__ */ jsx(Divider, {}),
          /* @__PURE__ */ jsx(CardContent, { sx: { pb: 0 }, children: /* @__PURE__ */ jsx(Stack$3, { gap: 1, children: /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, flexWrap: "wrap", children: [
            /* @__PURE__ */ jsx(
              WeaponToggle,
              {
                sx: { height: "100%" },
                onChange: setWeaponTypeKeys,
                value: deferredWeaponTypeKeys,
                totals: weaponTypeTotals,
                size: "small"
              }
            ),
            /* @__PURE__ */ jsx(
              ElementToggle,
              {
                sx: { height: "100%" },
                onChange: setElementKeys,
                value: deferredElementKeys,
                totals: elementTotals,
                size: "small"
              }
            ),
            /* @__PURE__ */ jsx(
              CharacterRarityToggle,
              {
                sx: { height: "100%" },
                onChange: setCharacterRarityKeys,
                value: deferredCharacterRarityKeys,
                totals: characterRarityTotals,
                size: "small"
              }
            ),
            /* @__PURE__ */ jsx(
              TextField,
              {
                autoFocus: true,
                value: searchTerm,
                onChange: (e3) => setSearchTerm(e3.target.value),
                label: t_pc("characterName"),
                size: "small",
                sx: { height: "100%" },
                InputProps: {
                  sx: { height: "100%" }
                }
              }
            )
          ] }) }) }),
          /* @__PURE__ */ jsxs(CardContent, { children: [
            /* @__PURE__ */ jsxs(Grid, { container: true, pb: 1, gap: 1, flexWrap: "nowrap", children: [
              /* @__PURE__ */ jsx(Grid, { item: true, xs: 6, children: /* @__PURE__ */ jsxs(Button, { color: "success", fullWidth: true, onClick: allowAll, children: [
                t2`excludeChar.modal.allow_all`,
                /* @__PURE__ */ jsx(SqBadge, { sx: { ml: 1 }, children: /* @__PURE__ */ jsx("strong", { children: locListTotals["allowed"] }) })
              ] }) }),
              /* @__PURE__ */ jsx(Grid, { item: true, xs: 6, children: /* @__PURE__ */ jsxs(Button, { fullWidth: true, color: "error", onClick: disallowAll, children: [
                t2`excludeChar.modal.disallow_All`,
                /* @__PURE__ */ jsx(SqBadge, { sx: { ml: 1 }, children: /* @__PURE__ */ jsx("strong", { children: locListTotals["excluded"] }) })
              ] }) })
            ] }),
            /* @__PURE__ */ jsx(
              SelectItemGrid,
              {
                locList,
                excludedLocations,
                mouseUpDetected,
                setMouseUpDetected,
                toggleList
              }
            )
          ] })
        ] })
      }
    ),
    /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", sx: { display: "flex", width: "100%" }, children: [
      /* @__PURE__ */ jsx(CardContent, { sx: { flexGrow: 1 }, children: /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, children: [
        /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx("strong", { children: t2("excludeChar.title") }) }),
        /* @__PURE__ */ jsxs(Typography, { children: [
          t2("excludeChar.chars"),
          " ",
          /* @__PURE__ */ jsxs(SqBadge, { color: "success", children: [
            totalStr,
            " ",
            /* @__PURE__ */ jsx(default_1$o, { ...iconInlineProps }),
            t2("artSetConfig.allowed")
          ] })
        ] }),
        /* @__PURE__ */ jsxs(Typography, { children: [
          t2("excludeChar.artis"),
          " ",
          /* @__PURE__ */ jsxs(SqBadge, { color: "success", children: [
            allowListTotal,
            " ",
            /* @__PURE__ */ jsx(default_1$o, { ...iconInlineProps }),
            t2("artSetConfig.allowed")
          ] })
        ] })
      ] }) }),
      /* @__PURE__ */ jsx(
        Button,
        {
          sx: { borderRadius: 0, flexShrink: 1, minWidth: 40 },
          onClick: onOpen,
          disabled,
          color: "info",
          children: /* @__PURE__ */ jsx(default_1$q, {})
        }
      )
    ] })
  ] });
}
function SelectItemGrid({
  locList,
  excludedLocations,
  mouseUpDetected,
  setMouseUpDetected,
  toggleList
}) {
  const [charList, setCharList] = reactExports.useState(/* @__PURE__ */ new Set());
  const [charListMode, setCharListMode] = reactExports.useState();
  reactExports.useEffect(() => {
    if (mouseUpDetected) {
      setMouseUpDetected(false);
      if (charList.size > 0) {
        toggleList(charList);
        setCharList(/* @__PURE__ */ new Set());
        setCharListMode(void 0);
      }
    }
  }, [charList, setCharList, setMouseUpDetected, mouseUpDetected, toggleList]);
  return /* @__PURE__ */ jsx(
    Grid,
    {
      container: true,
      spacing: 1,
      columns: { xs: 6, sm: 7, md: 10, lg: 12, xl: 16 },
      children: locList.map((lk) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
        SelectItem,
        {
          locKey: lk,
          charList,
          charListMode,
          setCharList,
          setCharListMode,
          selected: !excludedLocations.includes(lk)
        }
      ) }, lk))
    }
  );
}
function SelectItem({
  locKey,
  selected,
  charList,
  charListMode,
  setCharList,
  setCharListMode
}) {
  const database = useDatabase();
  const char = database.chars.get(database.chars.LocationToCharacterKey(locKey));
  const onMouseEnter = reactExports.useCallback(
    (e3) => (
      // Mouse 1 being held down
      e3.buttons === 1 && // Only select characters with the same exclusion state as the rest of the list
      (charListMode === 0 && !selected || charListMode === 1 && selected) && setCharList((/* @__PURE__ */ new Set([...charList])).add(locKey))
    ),
    [charListMode, selected, setCharList, charList, locKey]
  );
  const onMouseDown = reactExports.useCallback(() => {
    const mode = selected ? 1 : 0;
    setCharListMode(mode);
    setCharList((/* @__PURE__ */ new Set([...charList])).add(locKey));
  }, [selected, setCharListMode, setCharList, charList, locKey]);
  const allowed = (
    // Character is already allowed, and not selected to be excluded
    selected && !(charListMode === 1 && charList.has(locKey)) || // Or character is selected to be allowed
    charListMode === 0 && charList.has(locKey)
  );
  const sx = {
    opacity: allowed ? void 0 : 0.6,
    borderColor: allowed ? "rgb(100,200,100)" : "rgb(200,100,100)",
    borderWidth: "3px",
    borderStyle: "solid",
    borderRadius: "8px"
  };
  const content = reactExports.useMemo(
    () => /* @__PURE__ */ jsx(
      Box,
      {
        fontSize: "0.85em",
        display: "flex",
        justifyContent: "space-between",
        p: 0.3,
        children: allArtifactSlotKeys.map((s2) => /* @__PURE__ */ jsx(
          SlotIcon,
          {
            slotKey: s2,
            iconProps: {
              fontSize: "inherit",
              sx: { opacity: (char == null ? void 0 : char.equippedArtifacts[s2]) ? void 0 : 0.5 }
            }
          },
          s2
        ))
      }
    ),
    [char == null ? void 0 : char.equippedArtifacts]
  );
  const characterKey = database.chars.LocationToCharacterKey(locKey);
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", sx, children: [
    /* @__PURE__ */ jsx(
      CharacterCardPico,
      {
        characterKey,
        onMouseDown,
        onMouseEnter,
        hoverChild: /* @__PURE__ */ jsx(Box, { sx: { width: 300, m: -1 }, children: /* @__PURE__ */ jsx(CharacterCard, { hideStats: true, characterKey }) })
      }
    ),
    content
  ] });
}
const UseTeammateArt = reactExports.memo(function UseTeammateArt2({
  totalTally,
  useTeammateBuild,
  disabled = false
}) {
  const database = useDatabase();
  const {
    teamCharId,
    teamChar: { optConfigId },
    team: { loadoutData }
  } = reactExports.useContext(TeamCharacterContext);
  return /* @__PURE__ */ jsx(
    Tooltip$1,
    {
      arrow: true,
      title: /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
        reactExports.Suspense,
        {
          fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: 400, height: 400 }),
          children: /* @__PURE__ */ jsx(
            Box,
            {
              sx: {
                display: "flex",
                flexDirection: "column",
                gap: 1
              },
              children: loadoutData.filter(notEmpty).filter(
                (loadoutDatum) => loadoutDatum.teamCharId !== teamCharId
              ).map((loadoutDatum) => {
                var _a;
                const characterKey = (_a = database.teamChars.get(
                  loadoutDatum == null ? void 0 : loadoutDatum.teamCharId
                )) == null ? void 0 : _a.key;
                const artifacts = loadoutDatum.buildType === "tc" ? void 0 : database.teams.getLoadoutArtifacts(loadoutDatum);
                return /* @__PURE__ */ jsxs(
                  CardThemed,
                  {
                    sx: {
                      p: 1,
                      display: "flex",
                      flexDirection: "column",
                      gap: 1
                    },
                    children: [
                      /* @__PURE__ */ jsxs(Box, { display: "flex", alignItems: "center", gap: 1, children: [
                        characterKey && /* @__PURE__ */ jsx(CharIconSide, { characterKey }),
                        /* @__PURE__ */ jsx(Typography, { children: database.teams.getActiveBuildName(loadoutDatum) })
                      ] }),
                      artifacts ? /* @__PURE__ */ jsx(Grid, { container: true, columns: 5, spacing: 1, children: Object.entries(artifacts).map(([slotKey, art]) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                        ArtifactCardPico,
                        {
                          artifactObj: art,
                          slotKey
                        }
                      ) }, slotKey)) }) : /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx(SqBadge, { sx: { width: "100%" }, children: "TC build" }) })
                    ]
                  },
                  loadoutDatum.teamCharId
                );
              })
            }
          )
        }
      ) }),
      children: /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
        Button,
        {
          fullWidth: true,
          startIcon: useTeammateBuild ? /* @__PURE__ */ jsx(default_1$m, {}) : /* @__PURE__ */ jsx(default_1$n, {}),
          endIcon: /* @__PURE__ */ jsx(default_1$s, {}),
          color: useTeammateBuild ? "success" : "secondary",
          onClick: () => {
            database.optConfigs.set(optConfigId, {
              useTeammateBuild: !useTeammateBuild
            });
          },
          disabled,
          children: /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, children: [
            /* @__PURE__ */ jsx("span", { children: "Use artifacts in teammates' active builds" }),
            /* @__PURE__ */ jsx(Chip, { label: totalTally, size: "small" })
          ] })
        }
      ) })
    }
  );
});
const audio = new Audio("assets/notification.mp3");
function TabBuild() {
  const { t: t2 } = useTranslation("page_character_optimize");
  const {
    loadoutDatum,
    teamCharId,
    teamChar: { optConfigId, key: characterKey },
    teamId
  } = reactExports.useContext(TeamCharacterContext);
  const database = useDatabase();
  const { setChartData, graphBuilds, setGraphBuilds } = reactExports.useContext(GraphContext);
  const { gender } = useDBMeta();
  const activeCharKey = database.teams.getActiveTeamChar(teamId).key;
  const [notification, setnotification] = reactExports.useState(false);
  const notificationRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    notificationRef.current = notification;
  }, [notification]);
  const [buildStatus, setBuildStatus] = reactExports.useState({
    type: "inactive",
    tested: 0,
    failed: 0,
    skipped: 0,
    total: 0
  });
  const generatingBuilds = buildStatus.type !== "inactive";
  const [artsDirty, setArtsDirty] = useForceUpdate();
  const [maxWorkers, nativeThreads, setMaxWorkers] = useNumWorkers();
  reactExports.useEffect(() => {
    setBuildStatus({
      type: "inactive",
      tested: 0,
      failed: 0,
      skipped: 0,
      total: 0
    });
  }, [characterKey]);
  const noArtifact = reactExports.useMemo(() => !database.arts.values.length, [database]);
  const buildSetting = useOptConfig(optConfigId);
  const {
    plotBase,
    optimizationTarget: optimizationTargetDb,
    mainStatAssumptionLevel,
    allowPartial,
    maxBuildsToShow,
    levelLow,
    levelHigh,
    builds: buildsDb,
    buildDate,
    useTeammateBuild
  } = buildSetting;
  const builds = useConstObj(buildsDb);
  const optimizationTarget = useConstObj(optimizationTargetDb);
  const { data } = reactExports.useContext(DataContext);
  const compareData = useCompareData();
  const optimizationTargetNode = optimizationTarget && objPathValue(data == null ? void 0 : data.getDisplay(), optimizationTarget);
  const isSM = ["xs", "sm"].includes(useMediaQueryUp());
  reactExports.useEffect(
    () => database.arts.followAny(setArtsDirty),
    [setArtsDirty, database]
  );
  const deferredArtsDirty = reactExports.useDeferredValue(artsDirty);
  const deferredBuildSetting = reactExports.useDeferredValue(buildSetting);
  const teammateArtifactIds = useTeammateArtifactIds();
  const filteredArts = reactExports.useMemo(() => {
    const {
      mainStatKeys,
      excludedLocations,
      artExclusion,
      levelLow: levelLow2,
      levelHigh: levelHigh2,
      useExcludedArts,
      useTeammateBuild: useTeammateBuild2
    } = deferredArtsDirty && deferredBuildSetting;
    return database.arts.values.filter((art) => {
      if (!useExcludedArts && artExclusion.includes(art.id))
        return false;
      if (!useTeammateBuild2 && teammateArtifactIds.includes(art.id))
        return false;
      if (art.level < levelLow2)
        return false;
      if (art.level > levelHigh2)
        return false;
      const mainStats = mainStatKeys[art.slotKey];
      if ((mainStats == null ? void 0 : mainStats.length) && !mainStats.includes(art.mainStatKey))
        return false;
      const locKey = charKeyToLocCharKey(characterKey);
      if (art.location && art.location !== locKey && excludedLocations.includes(art.location))
        return false;
      return true;
    });
  }, [
    deferredArtsDirty,
    deferredBuildSetting,
    database,
    teammateArtifactIds,
    characterKey
  ]);
  const filteredArtIdMap = reactExports.useMemo(
    () => objKeyMap(
      filteredArts.map(({ id }) => id),
      (_) => true
    ),
    [filteredArts]
  );
  const { levelTotal, allowListTotal, excludedTotal, teammateBuildTotal } = reactExports.useMemo(() => {
    const catKeys = {
      levelTotal: ["in"],
      allowListTotal: ["in"],
      excludedTotal: ["in"],
      teammateBuildTotal: ["in"]
    };
    return bulkCatTotal(
      catKeys,
      (ctMap) => database.arts.entries.forEach(([id, art]) => {
        const { level, location } = art;
        const { levelLow: levelLow2, levelHigh: levelHigh2, excludedLocations, artExclusion } = deferredArtsDirty && deferredBuildSetting;
        if (level >= levelLow2 && level <= levelHigh2) {
          ctMap.levelTotal.in.total++;
          if (filteredArtIdMap[id])
            ctMap.levelTotal.in.current++;
        }
        const locKey = charKeyToLocCharKey(characterKey);
        if (location && location !== locKey && !excludedLocations.includes(location)) {
          ctMap.allowListTotal.in.total++;
          if (filteredArtIdMap[id])
            ctMap.allowListTotal.in.current++;
        }
        if (artExclusion.includes(id)) {
          ctMap.excludedTotal.in.total++;
          if (filteredArtIdMap[id])
            ctMap.excludedTotal.in.current++;
        }
        if (teammateArtifactIds.includes(id)) {
          ctMap.teammateBuildTotal.in.total++;
          if (filteredArtIdMap[id])
            ctMap.teammateBuildTotal.in.current++;
        }
      })
    );
  }, [
    characterKey,
    database,
    deferredArtsDirty,
    deferredBuildSetting,
    filteredArtIdMap,
    teammateArtifactIds
  ]);
  const tabFocused = reactExports.useRef(true);
  reactExports.useEffect(() => {
    const onFocus = () => tabFocused.current = true;
    const onBlur = () => tabFocused.current = false;
    window.addEventListener("focus", onFocus);
    window.addEventListener("blur", onBlur);
    return () => {
      window.removeEventListener("focus", onFocus);
      window.removeEventListener("blur", onBlur);
    };
  }, [tabFocused]);
  const cancelToken = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => () => cancelToken.current(), []);
  const throwGlobalError = useGlobalError();
  const generateBuilds = reactExports.useCallback(async () => {
    var _a;
    const {
      artSetExclusion,
      plotBase: plotBase2,
      statFilters,
      optimizationTarget: optimizationTarget2,
      mainStatAssumptionLevel: mainStatAssumptionLevel2,
      allowPartial: allowPartial2,
      maxBuildsToShow: maxBuildsToShow2
    } = buildSetting;
    if (!characterKey || !optimizationTarget2)
      return;
    const split = compactArtifacts(
      filteredArts,
      mainStatAssumptionLevel2,
      allowPartial2
    );
    const teamData = getTeamData(
      database,
      teamId,
      teamCharId,
      mainStatAssumptionLevel2,
      []
    );
    if (!teamData)
      return;
    const workerData = (_a = uiDataForTeam(teamData.teamData, gender, activeCharKey)[characterKey]) == null ? void 0 : _a.target.data[0];
    if (!workerData)
      return;
    Object.assign(workerData, mergeData([workerData, dynamicData]));
    const unoptimizedOptimizationTargetNode = objPathValue(
      workerData.display ?? {},
      optimizationTarget2
    );
    if (!unoptimizedOptimizationTargetNode)
      return;
    const targetNode = unoptimizedOptimizationTargetNode;
    const valueFilter = Object.entries(
      statFilters
    ).flatMap(
      ([pathStr, settings]) => settings.filter((setting) => !setting.disabled).map((setting) => {
        const filterNode = objPathValue(
          workerData.display ?? {},
          JSON.parse(pathStr)
        );
        const infoResolved = (filterNode == null ? void 0 : filterNode.info) && resolveInfo(filterNode.info);
        const minimum2 = (infoResolved == null ? void 0 : infoResolved.unit) === "%" ? setting.value / 100 : setting.value;
        return { value: filterNode, minimum: minimum2 };
      })
    ).filter((x2) => x2.value && x2.minimum > -Infinity);
    setChartData(void 0);
    const cancelled = new Promise((r2) => cancelToken.current = r2);
    const unoptimizedNodes = [
      ...valueFilter.map((x2) => x2.value),
      unoptimizedOptimizationTargetNode
    ];
    const minimum = [...valueFilter.map((x2) => x2.minimum), -Infinity];
    const plotBaseNumNode = plotBase2 && objPathValue(workerData.display ?? {}, plotBase2);
    if (plotBaseNumNode) {
      unoptimizedNodes.push(plotBaseNumNode);
      minimum.push(-Infinity);
    }
    const nodes = optimize(
      unoptimizedNodes,
      workerData,
      ({ path: [p2] }) => p2 !== "dyn"
    );
    const plotBaseNode = plotBaseNumNode ? nodes.pop() : void 0;
    const optimizationTargetNode2 = nodes.pop();
    const problem = {
      arts: split,
      optimizationTarget: optimizationTargetNode2,
      exclusion: artSetExclusion,
      constraints: nodes.map((value, i) => ({ value, min: minimum[i] })),
      topN: maxBuildsToShow2,
      plotBase: plotBaseNode
    };
    const status = {
      tested: 0,
      failed: 0,
      skipped: 0,
      total: 0,
      startTime: performance.now()
    };
    const statusUpdateTimer = setInterval(
      () => setBuildStatus({ type: "active", ...status }),
      100
    );
    const cancellationError = new Error();
    try {
      const solver = new GOSolver(problem, status, maxWorkers);
      cancelled.then(() => solver.cancel(cancellationError));
      const results = await solver.solve();
      solver.cancel();
      cancelToken.current = () => {
      };
      const weaponId = database.teams.getLoadoutWeapon(loadoutDatum).id;
      if (plotBaseNumNode) {
        const plotData = mergePlot(results.map((x2) => x2.plotData));
        const solverBuilds = Object.values(plotData);
        const targetNodeinfo = targetNode.info && resolveInfo(targetNode.info);
        const plotBaseNumNodeInfo = plotBaseNumNode.info && resolveInfo(plotBaseNumNode.info);
        if ((targetNodeinfo == null ? void 0 : targetNodeinfo.unit) === "%")
          solverBuilds.forEach(
            (dataEntry) => dataEntry && (dataEntry.value = dataEntry.value * 100)
          );
        if ((plotBaseNumNodeInfo == null ? void 0 : plotBaseNumNodeInfo.unit) === "%")
          solverBuilds.forEach(
            (dataEntry) => dataEntry && (dataEntry.plot = (dataEntry.plot ?? 0) * 100)
          );
        setChartData({
          valueNode: targetNode,
          plotNode: plotBaseNumNode,
          data: solverBuilds.filter(notEmpty).map(({ value, plot, artifactIds }) => ({
            artifactIds: objKeyMap(
              allArtifactSlotKeys,
              (slotKey) => artifactIds.find(
                (aId) => {
                  var _a2;
                  return ((_a2 = database.arts.get(aId)) == null ? void 0 : _a2.slotKey) === slotKey;
                }
              )
            ),
            weaponId,
            value,
            plot
          }))
        });
      }
      const builds2 = mergeBuilds(
        results.map((x2) => x2.builds),
        maxBuildsToShow2
      );
      if (false)
        ;
      database.optConfigs.set(optConfigId, {
        builds: builds2.map((build) => ({
          artifactIds: objKeyMap(
            allArtifactSlotKeys,
            (slotKey) => build.artifactIds.find(
              (aId) => {
                var _a2;
                return ((_a2 = database.arts.get(aId)) == null ? void 0 : _a2.slotKey) === slotKey;
              }
            )
          ),
          weaponId
        })),
        buildDate: Date.now()
      });
      setTimeout(() => {
        if (results && notificationRef.current) {
          audio.play();
          if (!tabFocused.current)
            setTimeout(() => window.alert(t2`buildCompleted`), 1);
        }
      }, 100);
    } catch (e3) {
      if (e3 !== cancellationError) {
        console.log("Failed to load worker");
        console.log(e3);
        if (e3 instanceof Error)
          throwGlobalError(e3);
      }
      cancelToken.current();
      status.tested = 0;
      status.failed = 0;
      status.skipped = 0;
      status.total = 0;
    } finally {
      clearInterval(statusUpdateTimer);
      setBuildStatus({
        type: "inactive",
        ...status,
        finishTime: performance.now()
      });
    }
  }, [
    buildSetting,
    characterKey,
    filteredArts,
    database,
    teamId,
    teamCharId,
    gender,
    activeCharKey,
    setChartData,
    maxWorkers,
    loadoutDatum,
    optConfigId,
    t2,
    throwGlobalError
  ]);
  const characterName = /* @__PURE__ */ jsx(CharacterName, { characterKey, gender });
  const setPlotBase = reactExports.useCallback(
    (plotBase2) => {
      database.optConfigs.set(optConfigId, { plotBase: plotBase2 });
      setChartData(void 0);
    },
    [database, optConfigId, setChartData]
  );
  const targetSelector = /* @__PURE__ */ jsx(
    OptimizationTargetSelector,
    {
      optimizationTarget,
      setTarget: (target) => database.optConfigs.set(optConfigId, { optimizationTarget: target }),
      disabled: !!generatingBuilds,
      targetSelectorModalProps: {
        excludeSections: ["character", "bounsStats", "teamBuff"]
      }
    }
  );
  const getGraphBuildLabel = reactExports.useCallback(
    (index) => /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "graphBuildLabel", count: index + 1, children: [
      "Graph #",
      { count: index + 1 }
    ] }),
    [t2]
  );
  const getNormBuildLabel = reactExports.useCallback((index) => `#${index + 1}`, []);
  return /* @__PURE__ */ jsxs(Box, { display: "flex", flexDirection: "column", gap: 1, children: [
    noArtifact && /* @__PURE__ */ jsx(NoArtWarning, {}),
    /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, children: [
      /* @__PURE__ */ jsxs(
        Grid,
        {
          item: true,
          xs: 12,
          sm: 6,
          lg: 3,
          display: "flex",
          flexDirection: "column",
          gap: 1,
          children: [
            /* @__PURE__ */ jsx(OptCharacterCard, { characterKey }),
            /* @__PURE__ */ jsx(BonusStatsCard, {})
          ]
        }
      ),
      /* @__PURE__ */ jsxs(
        Grid,
        {
          item: true,
          xs: 12,
          sm: 6,
          lg: 4,
          display: "flex",
          flexDirection: "column",
          gap: 1,
          children: [
            /* @__PURE__ */ jsx(
              LevelFilter$1,
              {
                levelTotal: levelTotal.in,
                levelLow,
                levelHigh,
                disabled: generatingBuilds,
                optConfigId
              }
            ),
            /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
              /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsx(
                Typography,
                {
                  sx: { fontWeight: "bold" },
                  children: t2`mainStat.title`
                }
              ) }),
              /* @__PURE__ */ jsx(Divider, {}),
              /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsxs(Box, { display: "flex", alignItems: "center", gap: 1, children: [
                /* @__PURE__ */ jsx(
                  AssumeFullLevelToggle,
                  {
                    mainStatAssumptionLevel,
                    setmainStatAssumptionLevel: (mainStatAssumptionLevel2) => database.optConfigs.set(optConfigId, {
                      mainStatAssumptionLevel: mainStatAssumptionLevel2
                    }),
                    disabled: generatingBuilds
                  }
                ),
                /* @__PURE__ */ jsx(
                  InfoTooltip,
                  {
                    title: /* @__PURE__ */ jsxs(Box, { children: [
                      /* @__PURE__ */ jsx(Typography, { variant: "h6", children: t2`mainStat.levelAssTooltip.title` }),
                      /* @__PURE__ */ jsx(Typography, { children: t2`mainStat.levelAssTooltip.desc` })
                    ] })
                  }
                )
              ] }) }),
              /* @__PURE__ */ jsx(
                MainStatSelectionCard,
                {
                  disabled: generatingBuilds,
                  filteredArtIdMap
                }
              )
            ] }),
            /* @__PURE__ */ jsx(
              ExcludeArt,
              {
                disabled: generatingBuilds,
                excludedTotal: excludedTotal["in"]
              }
            ),
            /* @__PURE__ */ jsx(
              UseTeammateArt,
              {
                totalTally: teammateBuildTotal["in"],
                useTeammateBuild,
                disabled: generatingBuilds
              }
            ),
            /* @__PURE__ */ jsx(
              Button,
              {
                fullWidth: true,
                startIcon: allowPartial ? /* @__PURE__ */ jsx(CheckBox, {}) : /* @__PURE__ */ jsx(CheckBoxOutlineBlank, {}),
                color: allowPartial ? "success" : "secondary",
                onClick: () => database.optConfigs.set(optConfigId, {
                  allowPartial: !allowPartial
                }),
                disabled: generatingBuilds,
                children: t2`allowPartial`
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxs(
        Grid,
        {
          item: true,
          xs: 12,
          sm: 6,
          lg: 5,
          display: "flex",
          flexDirection: "column",
          gap: 1,
          children: [
            /* @__PURE__ */ jsx(ArtifactSetConfig, { disabled: generatingBuilds }),
            /* @__PURE__ */ jsx(
              UseEquipped,
              {
                disabled: generatingBuilds,
                allowListTotal: allowListTotal.in
              }
            ),
            /* @__PURE__ */ jsx(StatFilterCard, { disabled: generatingBuilds }),
            /* @__PURE__ */ jsx(AdResponsive, { dataAdSlot: "7724855772", bgt: "light" })
          ]
        }
      )
    ] }),
    isSM && targetSelector,
    /* @__PURE__ */ jsxs(ButtonGroup, { children: [
      !isSM && targetSelector,
      /* @__PURE__ */ jsxs(
        DropdownButton,
        {
          disabled: generatingBuilds || !characterKey || !optimizationTarget,
          title: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "build", count: maxBuildsToShow, children: [
            { count: maxBuildsToShow },
            " Builds"
          ] }),
          children: [
            /* @__PURE__ */ jsx(MenuItem, { children: /* @__PURE__ */ jsx(Typography, { variant: "caption", color: "info.main", children: t2("buildDropdownDesc") }) }),
            /* @__PURE__ */ jsx(Divider, {}),
            maxBuildsToShowList.map((v2) => /* @__PURE__ */ jsx(
              MenuItem,
              {
                onClick: () => database.optConfigs.set(optConfigId, { maxBuildsToShow: v2 }),
                children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "build", count: v2, children: [
                  { count: v2 },
                  " Builds"
                ] })
              },
              v2
            ))
          ]
        }
      ),
      /* @__PURE__ */ jsxs(
        DropdownButton,
        {
          disabled: generatingBuilds || !characterKey || !optimizationTarget,
          sx: { borderRadius: "4px 0px 0px 4px" },
          title: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "thread", count: maxWorkers, children: [
            { count: maxWorkers },
            " Threads"
          ] }),
          children: [
            /* @__PURE__ */ jsx(MenuItem, { children: /* @__PURE__ */ jsx(Typography, { variant: "caption", color: "info.main", children: t2("threadDropdownDesc") }) }),
            /* @__PURE__ */ jsx(Divider, {}),
            range$3(1, nativeThreads).reverse().map((v2) => /* @__PURE__ */ jsx(MenuItem, { onClick: () => setMaxWorkers(v2), children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "thread", count: v2, children: [
              { count: v2 },
              " Threads"
            ] }) }, v2))
          ]
        }
      ),
      /* @__PURE__ */ jsx(BootstrapTooltip, { placement: "top", title: t2`notifyTooltip`, children: /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
        Button,
        {
          sx: { borderRadius: 0 },
          color: "warning",
          onClick: () => setnotification((n2) => !n2),
          disabled: !optimizationTarget,
          children: notification ? /* @__PURE__ */ jsx(default_1$3, {}) : /* @__PURE__ */ jsx(default_1$2, {})
        }
      ) }) }),
      /* @__PURE__ */ jsx(
        BootstrapTooltip,
        {
          placement: "top",
          title: !optimizationTarget ? t2("selectTargetFirst") : "",
          children: /* @__PURE__ */ jsx("span", { children: /* @__PURE__ */ jsx(
            Button,
            {
              disabled: !characterKey || !optimizationTarget || !optimizationTargetNode,
              color: generatingBuilds ? "error" : "success",
              onClick: generatingBuilds ? () => cancelToken.current() : generateBuilds,
              startIcon: generatingBuilds ? /* @__PURE__ */ jsx(Close, {}) : /* @__PURE__ */ jsx(TrendingUp, {}),
              sx: { borderRadius: "0px 4px 4px 0px" },
              children: generatingBuilds ? t2("generateButton.cancel") : t2("generateButton.generateBuilds")
            }
          ) })
        }
      )
    ] }),
    !!characterKey && /* @__PURE__ */ jsx(
      BuildAlert,
      {
        ...{ status: buildStatus, characterName, maxBuildsToShow }
      }
    ),
    optimizationTarget && /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
      ChartCard,
      {
        disabled: generatingBuilds || !optimizationTarget,
        plotBase,
        setPlotBase,
        showTooltip: !optimizationTarget
      }
    ) }),
    optimizationTarget && /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsxs(CardContent, { children: [
      /* @__PURE__ */ jsxs(Box, { display: "flex", alignItems: "center", gap: 1, mb: 1, children: [
        /* @__PURE__ */ jsx(Typography, { sx: { flexGrow: 1 }, children: builds ? /* @__PURE__ */ jsxs("span", { children: [
          "Showing",
          " ",
          /* @__PURE__ */ jsx("strong", { children: builds.length + (graphBuilds ? graphBuilds.length : 0) }),
          " ",
          "build generated for ",
          characterName,
          ".",
          " ",
          !!buildDate && /* @__PURE__ */ jsxs("span", { children: [
            "Build generated on:",
            " ",
            /* @__PURE__ */ jsx("strong", { children: new Date(buildDate).toLocaleString() })
          ] })
        ] }) : /* @__PURE__ */ jsx("span", { children: "Select a character to generate builds." }) }),
        /* @__PURE__ */ jsx(
          Button,
          {
            disabled: !builds.length,
            color: "error",
            onClick: () => {
              setGraphBuilds(void 0);
              database.optConfigs.set(optConfigId, {
                builds: [],
                buildDate: 0
              });
            },
            children: "Clear Builds"
          }
        )
      ] }),
      /* @__PURE__ */ jsxs(Grid, { container: true, display: "flex", spacing: 1, children: [
        /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(HitModeToggle, { size: "small" }) }),
        /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(ReactionToggle, { size: "small" }) }),
        /* @__PURE__ */ jsx(Grid, { item: true, flexGrow: 1 }),
        /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(CompareBtn, {}) })
      ] })
    ] }) }),
    /* @__PURE__ */ jsxs(OptimizationTargetContext.Provider, { value: optimizationTarget, children: [
      graphBuilds && /* @__PURE__ */ jsx(
        BuildList,
        {
          builds: graphBuilds,
          compareData,
          disabled: !!generatingBuilds,
          getLabel: getGraphBuildLabel,
          setBuilds: setGraphBuilds,
          mainStatAssumptionLevel
        }
      ),
      /* @__PURE__ */ jsx(
        BuildList,
        {
          builds,
          compareData,
          disabled: !!generatingBuilds,
          getLabel: getNormBuildLabel,
          mainStatAssumptionLevel
        }
      )
    ] })
  ] });
}
const LevelFilter$1 = reactExports.memo(function LevelFilter2({
  levelTotal,
  levelLow,
  levelHigh,
  disabled,
  optConfigId
}) {
  const database = useDatabase();
  const { t: t2 } = useTranslation("page_character_optimize");
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", gap: 1 }, children: [
      /* @__PURE__ */ jsx(Typography, { sx: { fontWeight: "bold" }, children: t2`levelFilter` }),
      /* @__PURE__ */ jsx(SqBadge, { color: "info", children: levelTotal })
    ] }),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(
      ArtifactLevelSlider,
      {
        levelLow,
        levelHigh,
        setLow: (levelLow2) => database.optConfigs.set(optConfigId, { levelLow: levelLow2 }),
        setHigh: (levelHigh2) => database.optConfigs.set(optConfigId, { levelHigh: levelHigh2 }),
        setBoth: (levelLow2, levelHigh2) => database.optConfigs.set(optConfigId, {
          levelLow: levelLow2,
          levelHigh: levelHigh2
        }),
        disabled
      }
    )
  ] });
});
const BuildList = reactExports.memo(function BuildList2({
  builds,
  setBuilds,
  compareData,
  disabled,
  getLabel: getLabel3,
  mainStatAssumptionLevel
}) {
  const deleteBuild = reactExports.useCallback(
    (index) => {
      if (setBuilds) {
        const builds_ = [...builds];
        builds_.splice(index, 1);
        setBuilds(builds_);
      }
    },
    [builds, setBuilds]
  );
  const teamCharacterContextValue = reactExports.useContext(TeamCharacterContext);
  const {
    teamChar: { key: characterKey }
  } = teamCharacterContextValue;
  return /* @__PURE__ */ jsx(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 600 }),
      children: builds == null ? void 0 : builds.map((build, index) => /* @__PURE__ */ jsx(
        DataContextWrapper,
        {
          characterKey,
          build,
          compareData,
          mainStatAssumptionLevel,
          children: /* @__PURE__ */ jsx(
            BuildItemWrapper,
            {
              index,
              label: getLabel3(index),
              build,
              disabled,
              deleteBuild: setBuilds ? deleteBuild : void 0,
              mainStatAssumptionLevel
            }
          )
        },
        index + Object.values(build.artifactIds).join()
      ))
    }
  );
});
const BuildItemWrapper = reactExports.memo(function BuildItemWrapper2({
  index,
  label,
  build,
  disabled,
  deleteBuild,
  mainStatAssumptionLevel
}) {
  const { t: t2 } = useTranslation("page_character_optimize");
  const extraButtonsLeft = reactExports.useMemo(() => {
    return /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(CopyTcButton, { build }),
      /* @__PURE__ */ jsx(CopyBuildButton, { build }),
      deleteBuild && /* @__PURE__ */ jsx(
        Button,
        {
          color: "error",
          size: "small",
          startIcon: /* @__PURE__ */ jsx(DeleteForever, {}),
          onClick: () => deleteBuild(index),
          children: t2("removeBuildButton")
        }
      )
    ] });
  }, [build, deleteBuild, index, t2]);
  return /* @__PURE__ */ jsx(
    BuildDisplayItem,
    {
      label,
      disabled,
      extraButtonsLeft,
      mainStatAssumptionLevel
    }
  );
});
function CopyTcButton({ build }) {
  const [name, setName] = reactExports.useState("");
  const [showTcPrompt, onShowTcPrompt, OnHideTcPrompt] = useBoolState();
  const database = useDatabase();
  const {
    teamCharId,
    loadoutDatum,
    teamChar: { key: characterKey }
  } = reactExports.useContext(TeamCharacterContext);
  const toTc = () => {
    const weaponTypeKey = getCharStat(characterKey).weaponType;
    const weapon = database.teams.getLoadoutWeapon(loadoutDatum);
    const buildTcId = database.teamChars.newBuildTcFromBuild(
      teamCharId,
      weaponTypeKey,
      weapon,
      Object.values(build.artifactIds).map((id) => database.arts.get(id))
    );
    if (buildTcId)
      database.buildTcs.set(buildTcId, {
        name
      });
    setName("");
    OnHideTcPrompt();
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        color: "info",
        size: "small",
        startIcon: /* @__PURE__ */ jsx(Science, {}),
        onClick: onShowTcPrompt,
        children: "New TC Build"
      }
    ),
    /* @__PURE__ */ jsx(ModalWrapper, { open: showTcPrompt, onClose: OnHideTcPrompt, children: /* @__PURE__ */ jsxs(CardThemed, { children: [
      /* @__PURE__ */ jsx(
        CardHeader,
        {
          title: "New Theorycraft Build",
          action: /* @__PURE__ */ jsx(IconButton, { onClick: OnHideTcPrompt, children: /* @__PURE__ */ jsx(default_1$a, {}) })
        }
      ),
      /* @__PURE__ */ jsx(Divider, {}),
      /* @__PURE__ */ jsxs(
        CardContent,
        {
          sx: { display: "flex", flexDirection: "column", gap: 1 },
          children: [
            /* @__PURE__ */ jsx(Typography, { children: "Copy over this build to a new TC Build" }),
            /* @__PURE__ */ jsx(
              TextField,
              {
                value: name,
                onChange: (e3) => setName(e3.target.value),
                autoFocus: true,
                margin: "dense",
                label: "TC Build Name",
                fullWidth: true
              }
            ),
            /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", justifyContent: "flex-end", gap: 1 }, children: [
              /* @__PURE__ */ jsx(Button, { onClick: OnHideTcPrompt, children: "Cancel" }),
              /* @__PURE__ */ jsx(Button, { color: "success", disabled: !name, onClick: toTc, children: "Create" })
            ] })
          ]
        }
      )
    ] }) })
  ] });
}
function CopyBuildButton({
  build: { artifactIds, weaponId }
}) {
  const [name, setName] = reactExports.useState("");
  const [showPrompt, onShowPrompt, OnHidePrompt] = useBoolState();
  const database = useDatabase();
  const { teamCharId } = reactExports.useContext(TeamCharacterContext);
  const toLoadout = (e3) => {
    e3.preventDefault();
    database.teamChars.newBuild(teamCharId, {
      name,
      artifactIds,
      weaponId
    });
    setName("");
    OnHidePrompt();
  };
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        color: "info",
        size: "small",
        startIcon: /* @__PURE__ */ jsx(default_1$l, {}),
        onClick: onShowPrompt,
        children: "New Build"
      }
    ),
    /* @__PURE__ */ jsx(
      ModalWrapper,
      {
        open: showPrompt,
        onClose: OnHidePrompt,
        disableRestoreFocus: true,
        children: /* @__PURE__ */ jsxs(CardThemed, { children: [
          /* @__PURE__ */ jsx(
            CardHeader,
            {
              title: "New Build",
              action: /* @__PURE__ */ jsx(IconButton, { onClick: OnHidePrompt, children: /* @__PURE__ */ jsx(default_1$a, {}) })
            }
          ),
          /* @__PURE__ */ jsx(Divider, {}),
          /* @__PURE__ */ jsxs(
            CardContent,
            {
              sx: { display: "flex", flexDirection: "column", gap: 1 },
              children: [
                /* @__PURE__ */ jsx(Typography, { children: "Copy over this build to a new build" }),
                /* @__PURE__ */ jsxs("form", { onSubmit: toLoadout, children: [
                  /* @__PURE__ */ jsx(
                    TextField,
                    {
                      value: name,
                      onChange: (e3) => setName(e3.target.value),
                      autoFocus: true,
                      margin: "dense",
                      label: "Build Name",
                      fullWidth: true
                    }
                  ),
                  /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", justifyContent: "flex-end", gap: 1 }, children: [
                    /* @__PURE__ */ jsx(Button, { onClick: OnHidePrompt, children: "Cancel" }),
                    /* @__PURE__ */ jsx(Button, { type: "submit", color: "success", disabled: !name, children: "Create" })
                  ] })
                ] })
              ]
            }
          )
        ] })
      }
    )
  ] });
}
const DataContextWrapper = reactExports.memo(function DataContextWrapper2({
  children,
  characterKey,
  build,
  compareData,
  mainStatAssumptionLevel
}) {
  const { artifactIds, weaponId } = build;
  const database = useDatabase();
  const [dirty, setDirty] = useForceUpdate();
  reactExports.useEffect(() => {
    const unfollowArts = Object.values(artifactIds).filter(notEmpty).map((id) => database.arts.follow(id, () => setDirty()));
    return () => {
      unfollowArts.forEach((unfollow) => unfollow());
    };
  }, [database, artifactIds, setDirty]);
  reactExports.useEffect(
    () => weaponId ? database.weapons.follow(weaponId, () => setDirty()) : () => {
    },
    [database, weaponId, setDirty]
  );
  const buildsArts = reactExports.useMemo(
    () => dirty && Object.values(artifactIds).map((i) => database.arts.get(i)).filter((a2) => a2),
    [dirty, artifactIds, database]
  );
  const buildWeapon = reactExports.useMemo(
    () => dirty && database.weapons.get(weaponId),
    [dirty, weaponId, database]
  );
  const teamData = useTeamData(mainStatAssumptionLevel, buildsArts, buildWeapon);
  const providerValue = reactExports.useMemo(() => {
    const tdc = teamData == null ? void 0 : teamData[characterKey];
    if (!tdc)
      return void 0;
    return { data: tdc.target, teamData, compareData };
  }, [teamData, compareData, characterKey]);
  if (!providerValue)
    return null;
  return /* @__PURE__ */ jsx(DataContext.Provider, { value: providerValue, children });
});
var DriveFileRenameOutline = {};
var _interopRequireDefault$1 = interopRequireDefaultExports;
Object.defineProperty(DriveFileRenameOutline, "__esModule", {
  value: true
});
var default_1$1 = DriveFileRenameOutline.default = void 0;
var _createSvgIcon$1 = _interopRequireDefault$1(requireCreateSvgIcon());
var _jsxRuntime$1 = jsxRuntimeExports;
var _default$1 = (0, _createSvgIcon$1.default)(/* @__PURE__ */ (0, _jsxRuntime$1.jsx)("path", {
  d: "M18.41 5.8 17.2 4.59c-.78-.78-2.05-.78-2.83 0l-2.68 2.68L3 15.96V20h4.04l8.74-8.74 2.63-2.63c.79-.78.79-2.05 0-2.83zM6.21 18H5v-1.21l8.66-8.66 1.21 1.21L6.21 18zM11 20l4-4h6v4H11z"
}), "DriveFileRenameOutline");
default_1$1 = DriveFileRenameOutline.default = _default$1;
function CharProfileCharEditor({
  show,
  onClose
}) {
  return /* @__PURE__ */ jsx(
    ModalWrapper,
    {
      open: show,
      onClose,
      containerProps: { maxWidth: "sm" },
      children: /* @__PURE__ */ jsx(CardThemed, { children: /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsx(
        reactExports.Suspense,
        {
          fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 1e3 }),
          children: /* @__PURE__ */ jsx(Content$2, { onClose })
        }
      ) }) })
    }
  );
}
function Content$2({ onClose }) {
  const { t: t2 } = useTranslation(["page_team"]);
  const database = useDatabase();
  const {
    character: charContext,
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const { buildTc, setBuildTc } = reactExports.useContext(BuildTcContext);
  const character = (buildTc == null ? void 0 : buildTc.character) ?? charContext;
  const { level, ascension } = character;
  const { gender } = useDBMeta();
  const characterSheet = getCharSheet(characterKey, gender);
  return /* @__PURE__ */ jsxs(Box, { display: "flex", flexDirection: "column", gap: 1, children: [
    /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, children: [
      !!buildTc && /* @__PURE__ */ jsx(
        BootstrapTooltip,
        {
          title: /* @__PURE__ */ jsx(Typography, { children: "Set a specific level, constellation, ascension, or talent level for this TC build, that is different from the base character" }),
          children: /* @__PURE__ */ jsx(
            Button,
            {
              sx: { flexGrow: 1 },
              startIcon: (buildTc == null ? void 0 : buildTc.character) ? /* @__PURE__ */ jsx(CheckIcon, {}) : /* @__PURE__ */ jsx(UnCheckIcon, {}),
              color: (buildTc == null ? void 0 : buildTc.character) ? "warning" : "primary",
              onClick: () => {
                setBuildTc((buildTc2) => {
                  if (buildTc2 == null ? void 0 : buildTc2.character)
                    buildTc2.character = void 0;
                  else
                    buildTc2.character = { ...character };
                });
              },
              children: t2`buildTcCharOverride.btn`
            }
          )
        }
      ),
      !!onClose && /* @__PURE__ */ jsx(IconButton, { onClick: onClose, children: /* @__PURE__ */ jsx(default_1$a, {}) })
    ] }),
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, sx: { justifyContent: "center" }, children: [
      /* @__PURE__ */ jsx(Grid, { item: true, xs: 5, children: /* @__PURE__ */ jsx(
        CardThemed,
        {
          bgt: "light",
          sx: {
            height: "100%",
            display: "flex",
            flexDirection: "column",
            gap: 1
          },
          children: /* @__PURE__ */ jsx(CharacterCoverArea, {})
        }
      ) }),
      /* @__PURE__ */ jsx(
        Grid,
        {
          item: true,
          xs: 7,
          sx: { display: "flex", flexDirection: "column", gap: 1 },
          children: /* @__PURE__ */ jsxs(Box, { display: "flex", flexDirection: "column", gap: 1, children: [
            /* @__PURE__ */ jsx(Grid, { container: true, columns: 1, spacing: 1, children: ["auto", "skill", "burst"].map((talentKey) => {
              var _a;
              return /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
                TalentDropdown,
                {
                  talentKey,
                  dropDownButtonProps: {
                    startIcon: /* @__PURE__ */ jsx(
                      ImgIcon,
                      {
                        src: (_a = characterSheet.getTalentOfKey(talentKey)) == null ? void 0 : _a.img,
                        size: 1.75,
                        sideMargin: true
                      }
                    ),
                    sx: {
                      color: (buildTc == null ? void 0 : buildTc.character) ? "yellow" : void 0
                    }
                  },
                  setTalent: (talent) => (buildTc == null ? void 0 : buildTc.character) ? setBuildTc((buildTc2) => {
                    if (buildTc2.character)
                      buildTc2.character.talent[talentKey] = talent;
                  }) : database.chars.set(characterKey, (char) => {
                    char.talent[talentKey] = talent;
                  })
                },
                talentKey
              ) }, talentKey);
            }) }),
            /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { p: 1 }, children: /* @__PURE__ */ jsx(
              LevelSelect,
              {
                warning: !!(buildTc == null ? void 0 : buildTc.character),
                level,
                ascension,
                setBoth: (data) => (buildTc == null ? void 0 : buildTc.character) ? setBuildTc((buildTc2) => {
                  if (buildTc2.character)
                    buildTc2.character = {
                      ...buildTc2.character,
                      ...data
                    };
                }) : database.chars.set(characterKey, data)
              }
            ) }),
            /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", sx: { p: 1 }, children: [
              /* @__PURE__ */ jsx(Typography, { sx: { textAlign: "center", pb: -1 }, variant: "h6", children: /* @__PURE__ */ jsx(
                CharacterConstellationName,
                {
                  characterKey,
                  gender
                }
              ) }),
              /* @__PURE__ */ jsx(Box, { sx: { px: 1 }, children: /* @__PURE__ */ jsx(
                CharacterCompactConstSelector,
                {
                  warning: !!(buildTc == null ? void 0 : buildTc.character),
                  setConstellation: (constellation) => (buildTc == null ? void 0 : buildTc.character) ? setBuildTc((buildTc2) => {
                    if (buildTc2.character)
                      buildTc2.character.constellation = constellation;
                  }) : database.chars.set(characterKey, {
                    constellation
                  })
                }
              ) })
            ] })
          ] })
        }
      )
    ] }) })
  ] });
}
function CharacterProfileCard() {
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const { gender } = useDBMeta();
  const [showEditor, onShowEditor, onHideEditor] = useBoolState();
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", sx: { height: "100%" }, children: [
    /* @__PURE__ */ jsx(CharacterCoverArea, {}),
    /* @__PURE__ */ jsxs(Box, { p: 1, children: [
      /* @__PURE__ */ jsx(CharProfileCharEditor, { show: showEditor, onClose: onHideEditor }),
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
        Button,
        {
          fullWidth: true,
          color: "info",
          onClick: onShowEditor,
          startIcon: /* @__PURE__ */ jsx(default_1$1, {}),
          children: "EDIT"
        }
      ) }),
      /* @__PURE__ */ jsx(CharacterCompactTalent, {}),
      /* @__PURE__ */ jsx(Typography, { sx: { textAlign: "center", mt: 1 }, variant: "h6", children: /* @__PURE__ */ jsx(
        CharacterConstellationName,
        {
          characterKey,
          gender
        }
      ) }),
      /* @__PURE__ */ jsx(CharacterCompactConstellation, {})
    ] })
  ] });
}
function CharacterCompactConstellation() {
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const { data } = reactExports.useContext(DataContext);
  const constellation = data.get(input.constellation).value;
  const { gender } = useDBMeta();
  const characterSheet = getCharSheet(characterKey, gender);
  return /* @__PURE__ */ jsx(Grid, { container: true, spacing: 1, children: range$3(1, 6).map((i) => {
    var _a;
    return /* @__PURE__ */ jsx(Grid, { item: true, xs: 4, children: /* @__PURE__ */ jsx(
      Box,
      {
        component: NextImage ? NextImage : "img",
        src: (_a = characterSheet.getTalentOfKey(
          `constellation${i}`
        )) == null ? void 0 : _a.img,
        sx: {
          ...constellation >= i ? {} : { filter: "brightness(50%)" }
        },
        width: "100%",
        height: "auto"
      }
    ) }, i);
  }) });
}
function EquipmentSection() {
  var _a;
  const database = useDatabase();
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const {
    loadoutDatum: { buildType, buildId }
  } = reactExports.useContext(TeamCharacterContext);
  const loadoutEquip = buildId && buildType === "real";
  const { teamData, data } = reactExports.useContext(DataContext);
  const weaponSheet = (_a = teamData[characterKey]) == null ? void 0 : _a.weaponSheet;
  const theme = useTheme();
  const breakpoint = useMediaQuery(theme.breakpoints.up("lg"));
  const weaponDoc = reactExports.useMemo(
    () => weaponSheet && weaponSheet.document.length > 0 && /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(Box, { p: 1, children: /* @__PURE__ */ jsx(DocumentDisplay, { sections: weaponSheet.document }) }) }),
    [weaponSheet]
  );
  const weaponTypeKey = getCharStat(characterKey).weaponType;
  const weaponId = data.get(uiInput.weapon.id).value;
  const artifactIds = reactExports.useMemo(
    () => objKeyMap(
      allArtifactSlotKeys,
      (slotKey) => data.get(uiInput.art[slotKey].id).value
    ),
    [data]
  );
  return /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, children: [
    breakpoint && /* @__PURE__ */ jsxs(
      Grid,
      {
        item: true,
        xs: 12,
        md: 12,
        lg: 3,
        xl: 3,
        sx: { display: "flex", flexDirection: "column", gap: 1 },
        children: [
          weaponDoc && weaponDoc,
          /* @__PURE__ */ jsx(ArtifactSectionCard, {})
        ]
      }
    ),
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, md: 12, lg: 9, xl: 9, children: /* @__PURE__ */ jsx(
      EquippedGrid,
      {
        weaponTypeKey,
        weaponId,
        artifactIds,
        setWeapon: (id) => {
          if (loadoutEquip)
            database.builds.set(buildId, { weaponId: id });
          else
            database.weapons.set(id, {
              location: charKeyToLocCharKey(characterKey)
            });
        },
        setArtifact: (slotKey, id) => {
          if (loadoutEquip)
            database.builds.set(buildId, (build) => {
              build.artifactIds[slotKey] = id;
            });
          else
            database.arts.set(id, {
              location: charKeyToLocCharKey(characterKey)
            });
        }
      }
    ) }),
    !breakpoint && /* @__PURE__ */ jsxs(Grid, { item: true, xs: 12, md: 12, xl: 3, container: true, spacing: 1, children: [
      weaponDoc && /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, md: 6, lg: 4, children: weaponDoc }),
      /* @__PURE__ */ jsx(
        Grid,
        {
          item: true,
          xs: 12,
          md: 6,
          lg: 4,
          sx: { display: "flex", flexDirection: "column", gap: 1 },
          children: /* @__PURE__ */ jsx(ArtifactSectionCard, {})
        }
      )
    ] })
  ] }) });
}
function ArtifactSectionCard() {
  const { t: t2 } = useTranslation(["page_character", "artifact"]);
  const database = useDatabase();
  const {
    character: { equippedArtifacts }
  } = reactExports.useContext(CharacterContext);
  const {
    loadoutDatum: { buildType, buildId }
  } = reactExports.useContext(TeamCharacterContext);
  const { data } = reactExports.useContext(DataContext);
  const hasEquipped = !!Object.values(equippedArtifacts).filter((i) => i).length;
  const buildEquip = buildId && buildType === "real";
  const unequipArts = () => {
    const confirmMsg = buildEquip ? "Do you want to unequip all artifacts in this build?" : "Do you want to move all currently equipped artifacts to inventory?";
    if (!window.confirm(confirmMsg))
      return;
    if (buildEquip)
      database.builds.set(buildId, {
        artifactIds: objKeyMap(allArtifactSlotKeys, () => void 0)
      });
    else
      Object.values(equippedArtifacts).forEach(
        (aid) => database.arts.set(aid, { location: "" })
      );
  };
  const setEffects = reactExports.useMemo(() => dataSetEffects(data), [data]);
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    hasEquipped && /* @__PURE__ */ jsx(
      Button,
      {
        color: "error",
        onClick: unequipArts,
        fullWidth: true,
        sx: { borderBottomRightRadius: 0, borderBottomLeftRadius: 0 },
        children: t2`tabEquip.unequipArts`
      }
    ),
    /* @__PURE__ */ jsx(Box, { p: 1, children: /* @__PURE__ */ jsx(Stack$3, { spacing: 1, children: setEffects && Object.entries(setEffects).flatMap(
      ([setKey, setNumKeyArr]) => setNumKeyArr.map((setNumKey) => /* @__PURE__ */ jsx(
        SetEffectDisplay,
        {
          setKey,
          setNumKey
        },
        setKey + setNumKey
      ))
    ) }) })
  ] });
}
function TabOverview() {
  const scrollRef = reactExports.useRef();
  const onScroll = reactExports.useCallback(
    () => {
      var _a, _b;
      return (_b = (_a = scrollRef == null ? void 0 : scrollRef.current) == null ? void 0 : _a.scrollIntoView) == null ? void 0 : _b.call(_a, { behavior: "smooth" });
    },
    [scrollRef]
  );
  const data = reactExports.useContext(DataContext);
  const compareData = useCompareData();
  const dataContextObj = reactExports.useMemo(
    () => ({
      ...data,
      compareData
    }),
    [data, compareData]
  );
  return /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, children: [
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, sx: { justifyContent: "center" }, children: [
      /* @__PURE__ */ jsx(Grid, { item: true, xs: 8, sm: 8, md: 3, lg: 2.3, children: /* @__PURE__ */ jsx(CharacterProfileCard, {}) }),
      /* @__PURE__ */ jsxs(
        Grid,
        {
          item: true,
          xs: 12,
          sm: 12,
          md: 9,
          lg: 9.7,
          sx: { display: "flex", flexDirection: "column", gap: 1 },
          children: [
            /* @__PURE__ */ jsx(EquipmentRow$1, { onClick: onScroll }),
            /* @__PURE__ */ jsxs(
              CardThemed,
              {
                bgt: "light",
                sx: {
                  flexGrow: 1,
                  p: 1,
                  display: "flex",
                  flexDirection: "column",
                  gap: 1
                },
                children: [
                  /* @__PURE__ */ jsxs(
                    Box,
                    {
                      sx: {
                        display: "flex",
                        justifyContent: "flex-end",
                        gap: 1,
                        flexWrap: "wrap"
                      },
                      children: [
                        /* @__PURE__ */ jsx(HitModeToggle, { size: "small" }),
                        /* @__PURE__ */ jsx(ReactionToggle, { size: "small" }),
                        /* @__PURE__ */ jsx(CompareBtn, { buttonGroupProps: { sx: { marginLeft: "auto" } } })
                      ]
                    }
                  ),
                  /* @__PURE__ */ jsx(DataContext.Provider, { value: dataContextObj, children: /* @__PURE__ */ jsx(
                    StatDisplayComponent,
                    {
                      columns: { xs: 1, sm: 1, md: 2, lg: 2, xl: 3 }
                    }
                  ) })
                ]
              }
            )
          ]
        }
      )
    ] }) }),
    /* @__PURE__ */ jsx(Box, { ref: scrollRef, children: /* @__PURE__ */ jsx(EquipmentSection, {}) })
  ] });
}
function EquipmentRow$1({ onClick }) {
  const { data } = reactExports.useContext(DataContext);
  return /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, columns: { xs: 2, sm: 2, md: 3, lg: 6, xl: 6 }, children: [
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { height: "100%", maxHeight: "8em" }, children: /* @__PURE__ */ jsx(
      WeaponCardNano,
      {
        weaponId: data.get(uiInput.weapon.id).value,
        onClick
      }
    ) }) }),
    allArtifactSlotKeys.map((slotKey) => {
      var _a;
      return /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { height: "100%", maxHeight: "8em" }, children: /* @__PURE__ */ jsx(
        ArtifactCardNano,
        {
          artifactId: (_a = data.get(uiInput.art[slotKey].id).value) == null ? void 0 : _a.toString(),
          slotKey,
          onClick
        }
      ) }) }, slotKey);
    })
  ] });
}
function isTalentKey(tKey) {
  return ["auto", "skill", "burst"].includes(
    tKey
  );
}
const talentSpacing = {
  xs: 12,
  sm: 6,
  md: 4
};
function CharacterTalentPane() {
  const { t: t2 } = useTranslation("sheet_gen");
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const { gender } = useDBMeta();
  const characterSheet = getCharSheet(characterKey, gender);
  const { data } = reactExports.useContext(DataContext);
  const { buildTc, setBuildTc } = reactExports.useContext(BuildTcContext);
  const database = useDatabase();
  const skillBurstList = [
    ["auto", t2("talents.auto")],
    ["skill", t2("talents.skill")],
    ["burst", t2("talents.burst")]
  ];
  const passivesList = [
    ["passive1", t2("unlockPassive1"), 1],
    ["passive2", t2("unlockPassive2"), 4],
    ["passive3", t2("unlockPassive3"), 0]
  ];
  const ascension = data.get(uiInput.asc).value;
  const constellation = data.get(uiInput.constellation).value;
  const theme = useTheme();
  const grlg = useMediaQuery(theme.breakpoints.up("lg"));
  const constellationCards = reactExports.useMemo(
    () => range$3(1, maxConstellationCount).map((i) => /* @__PURE__ */ jsx(
      SkillDisplayCard,
      {
        talentKey: `constellation${i}`,
        subtitle: t2("constellationLvl", { level: i }),
        onClickTitle: () => (buildTc == null ? void 0 : buildTc.character) ? setBuildTc((buildTc2) => {
          if (buildTc2.character)
            buildTc2.character.constellation = i;
        }) : database.chars.set(characterKey, {
          constellation: i === constellation ? i - 1 : i
        })
      }
    )),
    [
      t2,
      buildTc == null ? void 0 : buildTc.character,
      setBuildTc,
      database.chars,
      characterKey,
      constellation
    ]
  );
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsxs(
      Box,
      {
        sx: {
          display: "flex",
          justifyContent: "flex-end",
          gap: 1,
          flexWrap: "wrap"
        },
        children: [
          /* @__PURE__ */ jsx(HitModeToggle, { size: "small" }),
          /* @__PURE__ */ jsx(ReactionToggle, { size: "small" })
        ]
      }
    ) }) }),
    /* @__PURE__ */ jsx(ReactionDisplay, {}),
    /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, children: [
      grlg && /* @__PURE__ */ jsxs(
        Grid,
        {
          item: true,
          xs: 12,
          md: 12,
          lg: 3,
          sx: { display: "flex", flexDirection: "column", gap: 1 },
          children: [
            /* @__PURE__ */ jsx(ConstellationDropdown, {}),
            constellationCards.map((c2, i) => /* @__PURE__ */ jsx(Box, { sx: { opacity: constellation >= i + 1 ? 1 : 0.5 }, children: c2 }, i))
          ]
        }
      ),
      /* @__PURE__ */ jsxs(Grid, { item: true, xs: 12, md: 12, lg: 9, container: true, spacing: 1, children: [
        skillBurstList.map(([tKey, tText]) => /* @__PURE__ */ jsx(Grid, { item: true, ...talentSpacing, children: /* @__PURE__ */ jsx(SkillDisplayCard, { talentKey: tKey, subtitle: tText }) }, tKey)),
        !!characterSheet.getTalentOfKey("sprint") && /* @__PURE__ */ jsx(Grid, { item: true, ...talentSpacing, children: /* @__PURE__ */ jsx(
          SkillDisplayCard,
          {
            talentKey: "sprint",
            subtitle: t2("talents.altSprint")
          }
        ) }),
        !!characterSheet.getTalentOfKey("passive") && /* @__PURE__ */ jsx(Grid, { item: true, ...talentSpacing, children: /* @__PURE__ */ jsx(SkillDisplayCard, { talentKey: "passive", subtitle: "Passive" }) }),
        passivesList.map(([tKey, tText, asc]) => {
          const enabled = ascension >= asc;
          if (!characterSheet.getTalentOfKey(tKey))
            return null;
          return /* @__PURE__ */ jsx(
            Grid,
            {
              item: true,
              style: { opacity: enabled ? 1 : 0.5 },
              ...talentSpacing,
              children: /* @__PURE__ */ jsx(SkillDisplayCard, { talentKey: tKey, subtitle: tText })
            },
            tKey
          );
        })
      ] }),
      !grlg && /* @__PURE__ */ jsxs(Grid, { item: true, xs: 12, md: 12, lg: 3, container: true, spacing: 1, children: [
        /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, children: /* @__PURE__ */ jsx(ConstellationDropdown, {}) }),
        constellationCards.map((c2, i) => /* @__PURE__ */ jsx(
          Grid,
          {
            item: true,
            sx: { opacity: constellation >= i + 1 ? 1 : 0.5 },
            ...talentSpacing,
            children: c2
          },
          i
        ))
      ] })
    ] })
  ] });
}
function ReactionDisplay() {
  const { data } = reactExports.useContext(DataContext);
  const reaction = data.getDisplay()["reaction"];
  return /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsx(Grid, { container: true, spacing: 1, children: Object.entries(reaction).filter(([_, node]) => !node.isEmpty).map(([key, node]) => {
    return /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(CardThemed, { children: /* @__PURE__ */ jsx(CardContent, { sx: { p: 1, "&:last-child": { pb: 1 } }, children: /* @__PURE__ */ jsx(NodeFieldDisplay, { calcRes: node }) }) }) }, key);
  }) }) }) });
}
function SkillDisplayCard({
  talentKey,
  subtitle,
  onClickTitle
}) {
  const database = useDatabase();
  const {
    teamChar: { key: characterKey }
  } = reactExports.useContext(TeamCharacterContext);
  const { buildTc, setBuildTc } = reactExports.useContext(BuildTcContext);
  const { gender } = useDBMeta();
  const characterSheet = getCharSheet(characterKey, gender);
  const actionWrapperFunc = reactExports.useCallback(
    (children) => /* @__PURE__ */ jsx(CardActionArea, { onClick: onClickTitle, children }),
    [onClickTitle]
  );
  let header = null;
  if (isTalentKey(talentKey)) {
    header = /* @__PURE__ */ jsx(
      TalentDropdown,
      {
        talentKey,
        dropDownButtonProps: {
          sx: {
            borderRadius: 0,
            color: (buildTc == null ? void 0 : buildTc.character) ? "yellow" : void 0
          }
        },
        setTalent: (talent) => (buildTc == null ? void 0 : buildTc.character) ? setBuildTc((buildTc2) => {
          var _a;
          if ((_a = buildTc2.character) == null ? void 0 : _a.talent[talentKey])
            buildTc2.character.talent[talentKey] = talent;
        }) : database.chars.set(characterKey, (char) => {
          char.talent[talentKey] = talent;
        })
      }
    );
  }
  const talentSheet = characterSheet.getTalentOfKey(talentKey);
  const hideHeader = (section) => {
    var _a;
    const headerAction = (_a = section.header) == null ? void 0 : _a.action;
    if (headerAction && typeof headerAction !== "string") {
      const key = headerAction.props.children.props.key18;
      return key.includes(talentKey);
    }
    return false;
  };
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", sx: { height: "100%" }, children: [
    header,
    /* @__PURE__ */ jsxs(CardContent, { children: [
      /* @__PURE__ */ jsx(
        ConditionalWrapper,
        {
          condition: !!onClickTitle,
          wrapper: actionWrapperFunc,
          children: /* @__PURE__ */ jsxs(Grid, { container: true, sx: { flexWrap: "nowrap" }, children: [
            /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(
              Box,
              {
                component: NextImage ? NextImage : "img",
                src: talentSheet == null ? void 0 : talentSheet.img,
                sx: { width: 60, height: "auto" }
              }
            ) }),
            /* @__PURE__ */ jsxs(Grid, { item: true, flexGrow: 1, sx: { pl: 1 }, children: [
              /* @__PURE__ */ jsx(Typography, { variant: "h6", children: talentSheet == null ? void 0 : talentSheet.name }),
              /* @__PURE__ */ jsx(Typography, { variant: "subtitle1", children: subtitle })
            ] })
          ] })
        }
      ),
      (talentSheet == null ? void 0 : talentSheet.sections) ? /* @__PURE__ */ jsx(
        DocumentDisplay,
        {
          sections: talentSheet.sections,
          hideDesc: true,
          hideHeader,
          collapse: true
        }
      ) : null
    ] })
  ] });
}
function ConstellationDropdown() {
  const {
    character: { key: characterKey }
  } = reactExports.useContext(CharacterContext);
  const { data } = reactExports.useContext(DataContext);
  const { buildTc, setBuildTc } = reactExports.useContext(BuildTcContext);
  const { t: t2 } = useTranslation("sheet_gen");
  const database = useDatabase();
  const constellation = data.get(uiInput.constellation).value;
  return /* @__PURE__ */ jsx(
    DropdownButton,
    {
      fullWidth: true,
      title: t2("constellationLvl", { level: constellation }),
      color: "primary",
      sx: { color: (buildTc == null ? void 0 : buildTc.character) ? "yellow" : void 0 },
      children: range$3(0, maxConstellationCount).map((i) => /* @__PURE__ */ jsx(
        MenuItem,
        {
          selected: constellation === i,
          disabled: constellation === i,
          onClick: () => (buildTc == null ? void 0 : buildTc.character) ? setBuildTc((buildTc2) => {
            if (buildTc2.character)
              buildTc2.character.constellation = i;
          }) : database.chars.set(characterKey, {
            constellation: i
          }),
          children: t2(`constellationLvl`, { level: i })
        },
        i
      ))
    }
  );
}
function ArtifactMainLevelSlot({
  slotKey,
  disabled = false
}) {
  const {
    buildTc: {
      artifact: { slots }
    },
    setBuildTc
  } = reactExports.useContext(BuildTcContext);
  const { level, statKey, rarity } = slots[slotKey];
  const keys2 = artSlotMainKeys[slotKey];
  const setSlot = reactExports.useCallback(
    (action) => {
      setBuildTc((buildTc) => {
        const slot = buildTc.artifact.slots[slotKey];
        buildTc.artifact.slots[slotKey] = { ...slot, ...action };
      });
    },
    [setBuildTc, slotKey]
  );
  const setRarity = reactExports.useCallback(
    (r2) => {
      const mLvl = artMaxLevel[r2] ?? 0;
      if (level > mLvl)
        setSlot({ rarity: r2, level: mLvl });
      else
        setSlot({ rarity: r2 });
    },
    [level, setSlot]
  );
  return /* @__PURE__ */ jsxs(
    Box,
    {
      display: "flex",
      gap: 1,
      justifyContent: "space-between",
      alignItems: "center",
      children: [
        /* @__PURE__ */ jsx(SlotIcon, { slotKey }),
        /* @__PURE__ */ jsx(
          CardThemed,
          {
            sx: { height: "100%", minWidth: "5em", flexGrow: 1, display: "flex" },
            children: keys2.length === 1 ? /* @__PURE__ */ jsxs(
              Box,
              {
                p: 1,
                justifyContent: "center",
                alignItems: "center",
                width: "100%",
                display: "flex",
                gap: 1,
                children: [
                  /* @__PURE__ */ jsx(StatIcon, { statKey: keys2[0], iconProps: iconInlineProps }),
                  " ",
                  KeyMap.getStr(keys2[0])
                ]
              }
            ) : /* @__PURE__ */ jsx(
              DropdownButton,
              {
                sx: { px: 0 },
                fullWidth: true,
                title: /* @__PURE__ */ jsx(StatWithUnit, { statKey }),
                color: KeyMap.getVariant(statKey) ?? "success",
                disabled,
                children: keys2.map((msk) => /* @__PURE__ */ jsx(
                  MenuItem,
                  {
                    disabled: statKey === msk,
                    onClick: () => setSlot({ statKey: msk }),
                    children: /* @__PURE__ */ jsx(StatColoredWithUnit, { statKey: msk })
                  },
                  msk
                ))
              }
            )
          }
        ),
        /* @__PURE__ */ jsx(
          DropdownButton,
          {
            sx: { px: 0 },
            title: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", alignItems: "center" }, children: [
              rarity,
              " ",
              /* @__PURE__ */ jsx(default_1$r, { fontSize: "inherit" })
            ] }),
            disabled,
            children: [5, 4, 3].map((r2) => /* @__PURE__ */ jsx(
              MenuItem,
              {
                disabled: rarity === r2,
                onClick: () => setRarity(r2),
                children: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", alignItems: "center" }, children: [
                  r2,
                  " ",
                  /* @__PURE__ */ jsx(default_1$r, { fontSize: "inherit" })
                ] })
              },
              r2
            ))
          }
        ),
        /* @__PURE__ */ jsx(
          NumberInputLazy,
          {
            value: level,
            onChange: (l2) => l2 !== void 0 && setSlot({ level: l2 }),
            color: artifactLevelVariant(level),
            size: "small",
            inputProps: {
              sx: { width: "2ch" },
              max: 20,
              min: 0
            },
            InputProps: {
              startAdornment: /* @__PURE__ */ jsx(InputAdornment, { position: "start", children: "+" })
            },
            focused: true
          }
        ),
        /* @__PURE__ */ jsx(CardThemed, { sx: { height: "100%", minWidth: "4em" }, children: /* @__PURE__ */ jsx(Box, { p: 1, textAlign: "center", children: `${artDisplayValue(
          getMainStatDisplayValue(statKey, rarity, level),
          getUnitStr(statKey)
        )}${getUnitStr(statKey)}` }) })
      ]
    }
  );
}
var Clear = {};
var _interopRequireDefault = interopRequireDefaultExports;
Object.defineProperty(Clear, "__esModule", {
  value: true
});
var default_1 = Clear.default = void 0;
var _createSvgIcon = _interopRequireDefault(requireCreateSvgIcon());
var _jsxRuntime = jsxRuntimeExports;
var _default = (0, _createSvgIcon.default)(/* @__PURE__ */ (0, _jsxRuntime.jsx)("path", {
  d: "M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
}), "Clear");
default_1 = Clear.default = _default;
function ArtifactSetEditor({
  setKey,
  remaining,
  disabled = false
}) {
  const {
    buildTc: {
      artifact: { sets }
    },
    setBuildTc
  } = reactExports.useContext(BuildTcContext);
  const value = sets[setKey];
  const setValue = reactExports.useCallback(
    (value2) => {
      setBuildTc((buildTc) => {
        buildTc.artifact.sets[setKey] = value2;
      });
    },
    [setBuildTc, setKey]
  );
  const deleteValue = reactExports.useCallback(() => {
    setBuildTc((buildTc) => {
      const { [setKey]: _, ...rest } = buildTc.artifact.sets;
      buildTc.artifact.sets = rest;
    });
  }, [setBuildTc, setKey]);
  const artifactSheet = getArtSheet(setKey);
  const set4CondNums = reactExports.useMemo(() => {
    if (!value || value < 4)
      return [];
    return Object.keys(artifactSheet.setEffects).filter(
      (setNumKey) => {
        var _a;
        return (_a = artifactSheet.setEffects[setNumKey]) == null ? void 0 : _a.document.some(
          (doc) => "states" in doc
        );
      }
    );
  }, [artifactSheet, value]);
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    /* @__PURE__ */ jsxs(Box, { display: "flex", children: [
      /* @__PURE__ */ jsx(ArtifactSetTooltip, { setKey, numInSet: value, children: /* @__PURE__ */ jsxs(Box, { flexGrow: 1, p: 1, display: "flex", gap: 1, alignItems: "center", children: [
        /* @__PURE__ */ jsx(ImgIcon, { size: 2, src: artifactDefIcon(setKey) }),
        /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(ArtifactSetName, { setKey }) }),
        /* @__PURE__ */ jsx(default_1$s, { ...iconInlineProps })
      ] }) }),
      /* @__PURE__ */ jsxs(ButtonGroup, { children: [
        /* @__PURE__ */ jsx(
          DropdownButton,
          {
            size: "small",
            title: /* @__PURE__ */ jsxs(Box, { whiteSpace: "nowrap", children: [
              value,
              "-set"
            ] }),
            disabled,
            children: Object.keys(artifactSheet.setEffects).map((setKey2) => parseInt(setKey2)).map((setKey2) => /* @__PURE__ */ jsxs(
              MenuItem,
              {
                disabled: value === setKey2 || setKey2 > remaining + (value ?? 0),
                onClick: () => setValue(setKey2),
                children: [
                  setKey2,
                  "-set"
                ]
              },
              setKey2
            ))
          }
        ),
        /* @__PURE__ */ jsx(
          Button,
          {
            color: "error",
            size: "small",
            onClick: deleteValue,
            disabled,
            children: /* @__PURE__ */ jsx(default_1, {})
          }
        )
      ] })
    ] }),
    !!set4CondNums.length && /* @__PURE__ */ jsx(Stack$3, { spacing: 1, sx: { p: 1 }, children: set4CondNums.map((setNumKey) => /* @__PURE__ */ jsx(
      SetEffectDisplay,
      {
        setKey,
        setNumKey: parseInt(setNumKey),
        hideHeader: true,
        conditionalsOnly: true,
        disabled
      },
      setNumKey
    )) })
  ] });
}
function ArtifactSetsEditor({
  disabled = false
}) {
  const {
    buildTc: {
      artifact: { sets: artSet }
    },
    setBuildTc
  } = reactExports.useContext(BuildTcContext);
  const setSet = reactExports.useCallback(
    (setKey) => {
      if (!setKey)
        return;
      setBuildTc((buildTc) => {
        buildTc.artifact.sets[setKey] = parseInt(
          Object.keys(getArtSheet(setKey).setEffects)[0]
        );
      });
    },
    [setBuildTc]
  );
  const remaining = 5 - Object.values(artSet).reduce((a2, b2) => a2 + b2, 0);
  return /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, sx: { flexGrow: 1 }, children: [
    Object.keys(artSet).map((setKey) => /* @__PURE__ */ jsx(
      ArtifactSetEditor,
      {
        setKey,
        remaining,
        disabled
      },
      setKey
    )),
    /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { flexGrow: 1, overflow: "visible" }, children: /* @__PURE__ */ jsx(
      ArtifactSetAutocomplete,
      {
        artSetKey: "",
        setArtSetKey: setSet,
        label: "New Artifact Set",
        getOptionDisabled: ({ key }) => Object.keys(artSet).includes(key) || !key || Object.keys(getArtSheet(key).setEffects).every(
          (n2) => parseInt(n2) > remaining
        ),
        disabled
      }
    ) })
  ] });
}
function ArtifactMainStatAndSetEditor({
  disabled = false
}) {
  return /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, children: [
    /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { p: 1 }, children: /* @__PURE__ */ jsx(Stack$3, { spacing: 1, children: allArtifactSlotKeys.map((s2) => /* @__PURE__ */ jsx(ArtifactMainLevelSlot, { slotKey: s2, disabled }, s2)) }) }),
    /* @__PURE__ */ jsx(
      reactExports.Suspense,
      {
        fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 200 }),
        children: /* @__PURE__ */ jsx(ArtifactSetsEditor, { disabled })
      }
    )
  ] });
}
function getMinRoll(charTC) {
  const {
    artifact: {
      substats: { stats, rarity, type }
    }
  } = charTC;
  return Math.floor(
    Math.min(
      ...Object.entries(stats).map(
        ([k2, v2]) => v2 / getSubstatValue(k2, rarity, type)
      )
    )
  );
}
function getMinMax(buildTc) {
  return Math.floor(
    Math.min(...Object.values(buildTc.optimization.maxSubstats))
  );
}
function ArtifactAllSubstatEditor({
  disabled = false
}) {
  const { t: t2 } = useTranslation("page_character");
  const { buildTc, setBuildTc } = reactExports.useContext(BuildTcContext);
  const [rollsData, setRolls] = reactExports.useState(() => [getMinRoll(buildTc)]);
  const [maxSubstatData, setMaxSubstat] = reactExports.useState(() => [getMinMax(buildTc)]);
  const [rolls] = rollsData;
  const [maxSubstat] = maxSubstatData;
  const rollsDeferred = reactExports.useDeferredValue(rollsData);
  const isMount = useIsMount();
  reactExports.useEffect(() => {
    if (isMount)
      return;
    setBuildTc((buildTc2) => {
      const {
        artifact: {
          substats: { stats, type, rarity }
        }
      } = buildTc2;
      buildTc2.artifact.substats.stats = objMap(stats, (val, statKey) => {
        const old = val;
        const substatValue = getSubstatValue(statKey, rarity, type);
        const newVal = substatValue * rollsDeferred[0];
        const statDiff = Math.round(old / substatValue - rollsDeferred[0]);
        buildTc2.optimization.distributedSubstats = clamp(
          buildTc2.optimization.distributedSubstats + statDiff,
          0,
          45
        );
        return newVal;
      });
    });
  }, [rollsDeferred]);
  const maxSubstatDeferred = reactExports.useDeferredValue(maxSubstatData);
  reactExports.useEffect(() => {
    if (isMount)
      return;
    setBuildTc((charTC) => {
      charTC.optimization.maxSubstats = objMap(
        charTC.optimization.maxSubstats,
        (_val, _statKey) => maxSubstatDeferred[0]
      );
    });
  }, [maxSubstatDeferred]);
  const maxRollsPerSub = (artSubstatRollData[buildTc.artifact.substats.rarity].numUpgrades + 1) * 5;
  const invalid = (rolls ?? 0 - 1e-4) > maxRollsPerSub;
  return /* @__PURE__ */ jsxs(
    Box,
    {
      display: "flex",
      gap: 1,
      justifyContent: "space-between",
      alignItems: "center",
      children: [
        /* @__PURE__ */ jsx(
          CardThemed,
          {
            sx: {
              px: 2,
              flexGrow: 1,
              display: "flex",
              gap: 1,
              alignItems: "center",
              justifyContent: "center",
              overflow: "visible"
            },
            children: /* @__PURE__ */ jsx(
              Slider,
              {
                size: "small",
                value: rolls ?? 0,
                max: maxRollsPerSub,
                min: 0,
                step: 1,
                marks: true,
                valueLabelDisplay: "auto",
                onChange: (e3, v2) => setRolls([v2]),
                onChangeCommitted: (e3, v2) => setRolls([v2]),
                disabled
              }
            )
          }
        ),
        /* @__PURE__ */ jsx(
          NumberInputLazy,
          {
            value: parseFloat((rolls ?? 0).toFixed(2)),
            float: true,
            onChange: (v2) => v2 !== void 0 && setRolls([v2]),
            color: rolls && invalid ? "warning" : "primary",
            size: "small",
            inputProps: {
              sx: { textAlign: "right", width: "1.5em" },
              min: 0,
              max: 99
            },
            InputProps: {
              startAdornment: /* @__PURE__ */ jsx(
                Box,
                {
                  sx: { whiteSpace: "nowrap" },
                  children: t2`tabTheorycraft.all.rolls`
                }
              )
            },
            focused: true
          }
        ),
        /* @__PURE__ */ jsx(
          NumberInputLazy,
          {
            value: maxSubstat ?? 0,
            onChange: (v2) => v2 !== void 0 && setMaxSubstat([v2]),
            color: (maxSubstat ?? 0) > maxRollsPerSub ? "warning" : "primary",
            size: "small",
            inputProps: {
              sx: { textAlign: "right", width: "1.5em" },
              min: 0,
              max: 99
            },
            InputProps: {
              startAdornment: /* @__PURE__ */ jsx(Box, { sx: { whiteSpace: "nowrap" }, children: t2`tabTheorycraft.all.max` })
            },
            focused: true
          }
        )
      ]
    }
  );
}
function ArtifactSubstatEditor({
  statKey,
  disabled = false
}) {
  const { t: t2 } = useTranslation("page_character");
  const {
    buildTc: {
      artifact: {
        slots,
        substats: { type: substatsType, stats: substats, rarity }
      },
      optimization: { maxSubstats }
    },
    setBuildTc
  } = reactExports.useContext(BuildTcContext);
  const mainStatKeys = Object.values(slots).map((s2) => s2.statKey);
  const value = substats[statKey];
  const setValue = reactExports.useCallback(
    (v2) => {
      setBuildTc((charTC) => {
        const old = charTC.artifact.substats.stats[statKey];
        charTC.artifact.substats.stats[statKey] = v2;
        const statDiff = Math.round(
          (old - v2) / getSubstatValue(
            statKey,
            charTC.artifact.substats.rarity,
            charTC.artifact.substats.type
          )
        );
        charTC.optimization.distributedSubstats = clamp(
          charTC.optimization.distributedSubstats + statDiff,
          0,
          45
        );
      });
    },
    [setBuildTc, statKey]
  );
  const maxSubstat = maxSubstats[statKey];
  const setMaxSubstat = reactExports.useCallback(
    (v2) => {
      setBuildTc((charTC) => {
        charTC.optimization.maxSubstats[statKey] = v2;
      });
    },
    [setBuildTc, statKey]
  );
  const substatValue = getSubstatValue(statKey, rarity, substatsType);
  const [rolls, setRolls] = reactExports.useState(() => value / substatValue);
  reactExports.useEffect(() => setRolls(value / substatValue), [value, substatValue]);
  const unit2 = getUnitStr(statKey);
  const displayValue = rolls * substatValue;
  const rv = rolls * substatValue / getSubstatValue(statKey) * 100;
  const numMains = mainStatKeys.reduce(
    (t22, ms) => t22 + (ms === statKey ? 1 : 0),
    0
  );
  const maxRolls = (5 - numMains) * (artMaxLevel[rarity] / 4 + 1);
  const invalid = rolls - 1e-4 > maxRolls;
  const setRValue = reactExports.useCallback(
    (r2) => setValue(r2 * substatValue),
    [setValue, substatValue]
  );
  return /* @__PURE__ */ jsxs(Stack$3, { spacing: 0.5, children: [
    /* @__PURE__ */ jsxs(
      Box,
      {
        display: "flex",
        gap: 1,
        justifyContent: "space-between",
        alignItems: "center",
        children: [
          /* @__PURE__ */ jsx(
            NumberInputLazy,
            {
              color: displayValue ? "success" : "primary",
              float: getUnitStr(statKey) === "%",
              value: parseFloat(displayValue.toFixed(2)),
              onChange: (v2) => v2 !== void 0 && setValue(v2),
              size: "small",
              inputProps: {
                sx: {
                  width: "4em",
                  textAlign: "right"
                },
                min: 0,
                max: 9999
              },
              InputProps: {
                endAdornment: getUnitStr(statKey) || /* @__PURE__ */ jsx(Box, { width: "0.8em", component: "span" })
              },
              focused: true
            }
          ),
          /* @__PURE__ */ jsxs(
            CardThemed,
            {
              sx: {
                p: 0.5,
                minWidth: "11em",
                flexGrow: 1,
                display: "flex",
                gap: 1,
                alignItems: "center",
                justifyContent: "center"
              },
              children: [
                /* @__PURE__ */ jsx(StatIcon, { statKey, iconProps: { fontSize: "inherit" } }),
                KeyMap.getStr(statKey),
                getUnitStr(statKey)
              ]
            }
          ),
          /* @__PURE__ */ jsx(
            NumberInputLazy,
            {
              color: value ? invalid ? "warning" : "success" : "primary",
              float: true,
              value: parseFloat(rolls.toFixed(2)),
              onChange: (v2) => v2 !== void 0 && setValue(v2 * substatValue),
              size: "small",
              inputProps: {
                sx: {
                  width: "2em",
                  textAlign: "right"
                },
                min: 0,
                max: 99
                // 3 digits aren't visible
              },
              InputProps: {
                startAdornment: /* @__PURE__ */ jsx(InputAdornment, { position: "start", children: /* @__PURE__ */ jsxs(
                  Box,
                  {
                    sx: {
                      whiteSpace: "nowrap",
                      width: "3em",
                      display: "flex",
                      justifyContent: "space-between"
                    },
                    children: [
                      /* @__PURE__ */ jsxs("span", { children: [
                        artDisplayValue(substatValue, unit2),
                        unit2
                      ] }),
                      /* @__PURE__ */ jsx("span", { children: "x" })
                    ]
                  }
                ) })
              },
              focused: true
            }
          ),
          /* @__PURE__ */ jsx(CardThemed, { sx: { textAlign: "center", p: 0.5, minWidth: "6em" }, children: /* @__PURE__ */ jsxs(ColorText, { color: invalid ? "warning" : void 0, children: [
            "RV: ",
            /* @__PURE__ */ jsxs("strong", { children: [
              rv.toFixed(),
              "%"
            ] }),
            /* @__PURE__ */ jsx(
              BootstrapTooltip,
              {
                title: /* @__PURE__ */ jsx(Typography, { children: t2(
                  numMains ? `tabTheorycraft.maxRollsMain` : `tabTheorycraft.maxRolls`,
                  { value: maxRolls }
                ) }),
                placement: "top",
                children: /* @__PURE__ */ jsx(default_1$s, { fontSize: "inherit", sx: { verticalAlign: "-10%" } })
              }
            )
          ] }) })
        ]
      }
    ),
    /* @__PURE__ */ jsxs(
      Box,
      {
        display: "flex",
        gap: 1,
        justifyContent: "space-between",
        alignItems: "center",
        children: [
          /* @__PURE__ */ jsx(
            CardThemed,
            {
              sx: {
                px: 2,
                flexGrow: 1,
                display: "flex",
                gap: 1,
                alignItems: "center",
                justifyContent: "center",
                overflow: "visible"
              },
              children: /* @__PURE__ */ jsx(
                Slider,
                {
                  size: "small",
                  value: rolls,
                  max: Math.min(maxRolls, maxSubstat),
                  min: 0,
                  step: 1,
                  marks: true,
                  valueLabelDisplay: "auto",
                  onChange: (e3, v2) => setRolls(v2),
                  onChangeCommitted: (e3, v2) => setRValue(v2),
                  disabled
                }
              )
            }
          ),
          /* @__PURE__ */ jsx(
            NumberInputLazy,
            {
              value: maxSubstat,
              onChange: (v2) => v2 !== void 0 && setMaxSubstat(v2),
              size: "small",
              color: (
                // 0.0001 to nudge float comparasion
                rolls - 1e-4 > maxSubstat ? "error" : maxSubstat > maxRolls ? "warning" : "success"
              ),
              focused: true,
              inputProps: {
                sx: { width: "2ch" },
                min: 0,
                max: 99
                // 3 digits aren't visible
              },
              InputProps: {
                startAdornment: /* @__PURE__ */ jsx(InputAdornment, { position: "start", children: t2`tabTheorycraft.substat.max` })
              }
            }
          )
        ]
      }
    )
  ] });
}
function ArtifactSubCard({
  maxTotalRolls,
  disabled = false
}) {
  const { t: t2 } = useTranslation("page_character");
  const {
    buildTc: {
      artifact: {
        substats: { type: substatsType, stats: substats, rarity }
      }
    },
    setBuildTc
  } = reactExports.useContext(BuildTcContext);
  const setSubstatsType = reactExports.useCallback(
    (t22) => {
      setBuildTc((charTC) => {
        charTC.artifact.substats.type = t22;
      });
    },
    [setBuildTc]
  );
  const setRarity = reactExports.useCallback(
    (r2) => {
      setBuildTc((charTC) => {
        charTC.artifact.substats.rarity = r2;
      });
    },
    [setBuildTc]
  );
  const rv = Object.entries(substats).reduce(
    (t22, [k2, v2]) => t22 + v2 / getSubstatValue(k2),
    0
  ) * 100;
  const rolls = Object.entries(substats).reduce(
    (t22, [k2, v2]) => t22 + v2 / getSubstatValue(k2, rarity, substatsType),
    0
  );
  const { high, numUpgrades } = artSubstatRollData[rarity];
  const maxRolls = (high + numUpgrades) * 5;
  return /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { p: 1, height: "100%" }, children: /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, children: [
    /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
      /* @__PURE__ */ jsx(
        DropdownButton,
        {
          sx: { flexGrow: 1 },
          title: t2(`tabTheorycraft.substatType.${substatsType}`),
          disabled,
          children: substatTypeKeys.map((st) => /* @__PURE__ */ jsx(
            MenuItem,
            {
              disabled: substatsType === st,
              onClick: () => setSubstatsType(st),
              children: t2(`tabTheorycraft.substatType.${st}`)
            },
            st
          ))
        }
      ),
      /* @__PURE__ */ jsx(
        ArtifactRarityDropdown,
        {
          rarity,
          onChange: (r2) => setRarity(r2),
          filter: (r2) => r2 !== rarity,
          disabled
        }
      ),
      /* @__PURE__ */ jsx(
        BootstrapTooltip,
        {
          title: /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "tabTheorycraft.maxTotalRolls", children: [
            "The current build can only have a maximum of ",
            /* @__PURE__ */ jsx("strong", { children: { value: maxTotalRolls } }),
            " rolls."
          ] }) }),
          placement: "top",
          children: /* @__PURE__ */ jsxs(
            CardThemed,
            {
              sx: {
                textAlign: "center",
                py: 0.5,
                px: 1,
                whiteSpace: "nowrap",
                display: "flex",
                gap: 2,
                justifyContent: "flex-end",
                alignItems: "center",
                flexShrink: 1
              },
              children: [
                /* @__PURE__ */ jsxs(ColorText, { color: rolls > maxRolls ? "error" : void 0, children: [
                  "Rolls: ",
                  /* @__PURE__ */ jsx("strong", { children: rolls.toFixed(0) })
                ] }),
                /* @__PURE__ */ jsxs(ColorText, { color: rolls > maxRolls ? "error" : void 0, children: [
                  "RV: ",
                  /* @__PURE__ */ jsxs("strong", { children: [
                    rv.toFixed(),
                    "%"
                  ] })
                ] })
              ]
            }
          )
        }
      )
    ] }),
    /* @__PURE__ */ jsx(ArtifactAllSubstatEditor, { disabled }),
    Object.entries(substats).map(([k2]) => /* @__PURE__ */ jsx(ArtifactSubstatEditor, { statKey: k2, disabled }, k2))
  ] }) });
}
function BuildConstaintCard({ disabled }) {
  const { t: t2 } = useTranslation("page_character");
  const {
    buildTc: {
      optimization: { minTotal }
    },
    setBuildTc
  } = reactExports.useContext(BuildTcContext);
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        titleTypographyProps: { variant: "body1", sx: { fontWeight: "bold" } },
        title: t2`tabTheorycraft.constraint.title`
      }
    ),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(Box, { sx: { p: 1 }, children: /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, children: [
      Object.entries(minTotal).map(([k2, v2]) => /* @__PURE__ */ jsx(Selector, { statKey: k2, value: v2, disabled }, k2)),
      /* @__PURE__ */ jsx(
        DropdownButton,
        {
          disabled,
          title: t2`tabTheorycraft.constraint.add`,
          children: minTotalStatKeys.map((k2) => /* @__PURE__ */ jsxs(
            MenuItem,
            {
              disabled: Object.keys(minTotal).includes(k2),
              onClick: () => setBuildTc((charTC) => {
                charTC.optimization.minTotal[k2] = 0;
              }),
              children: [
                /* @__PURE__ */ jsx(ListItemIcon, { children: /* @__PURE__ */ jsx(StatIcon, { statKey: k2 }) }),
                /* @__PURE__ */ jsx(ListItemText, { children: /* @__PURE__ */ jsx(ArtifactStatWithUnit, { statKey: k2 }) })
              ]
            },
            k2
          ))
        }
      )
    ] }) })
  ] });
}
function Selector({
  statKey,
  value,
  disabled
}) {
  const { setBuildTc } = reactExports.useContext(BuildTcContext);
  const unit2 = statKey ? getUnitStr(statKey) : " ";
  return /* @__PURE__ */ jsxs(ButtonGroup, { size: "small", children: [
    /* @__PURE__ */ jsx(CustomNumberInputButtonGroupWrapper, { sx: { flexBasis: 30, flexGrow: 1 }, children: /* @__PURE__ */ jsx(
      CustomNumberInput,
      {
        float: unit2 === "%",
        value: statKey ? value : void 0,
        onChange: (value2) => statKey && setBuildTc((charTC) => {
          charTC.optimization.minTotal[statKey] = value2;
        }),
        endAdornment: /* @__PURE__ */ jsx(Box, { width: "1em", component: "span", children: unit2 }),
        startAdornment: /* @__PURE__ */ jsxs(Box, { component: "span", sx: { whiteSpace: "nowrap" }, children: [
          statKey && /* @__PURE__ */ jsx(
            StatIcon,
            {
              statKey,
              iconProps: {
                fontSize: "inherit",
                sx: {
                  verticalAlign: "-10%",
                  mr: 1
                }
              }
            }
          ),
          statKey && /* @__PURE__ */ jsx(ArtifactStatWithUnit, { statKey })
        ] }),
        disabled: !statKey || disabled,
        sx: {
          px: 1
        },
        inputProps: {
          sx: { textAlign: "right" }
        }
      }
    ) }),
    !!statKey && /* @__PURE__ */ jsx(
      Button,
      {
        color: "error",
        disabled,
        size: "small",
        onClick: () => setBuildTc((charTC) => {
          delete charTC.optimization.minTotal[statKey];
        }),
        children: /* @__PURE__ */ jsx(default_1, {})
      }
    )
  ] });
}
const gcsimIcon = "" + new URL("gcsim-DHutm7Sy.png", import.meta.url).href;
const GOODtoSRL = {
  def_: "def%",
  def: "def",
  hp: "hp",
  hp_: "hp%",
  atk: "atk",
  atk_: "atk%",
  enerRech_: "er",
  eleMas: "em",
  critRate_: "cr",
  critDMG_: "cd",
  heal_: "heal",
  pyro_dmg_: "pyro%",
  hydro_dmg_: "hydro%",
  cryo_dmg_: "cryo%",
  electro_dmg_: "electro%",
  anemo_dmg_: "anemo%",
  geo_dmg_: "geo%",
  dendro_dmg_: "dendro%",
  physical_dmg_: "phys%"
  // "atkspd%",
  // "dmg%",
};
function GcsimButton({ disabled }) {
  const { t: t2 } = useTranslation(["page_character", "settings"]);
  const [open, onOpen, onClose] = useBoolState();
  const {
    character: {
      key: characterKey,
      level,
      ascension,
      constellation,
      talent: { auto, skill, burst }
    }
  } = reactExports.useContext(CharacterContext);
  const {
    buildTc: {
      weapon: {
        key: weaponKey,
        level: wLevel,
        ascension: wAscension,
        refinement: wRefinement
      },
      artifact: {
        slots,
        substats: { stats: substats },
        sets
      }
    }
  } = reactExports.useContext(BuildTcContext);
  const charKeyLow = characterKey.toLowerCase();
  const setText = Object.entries(sets).map(
    ([key, num]) => `${charKeyLow} add set="${key.toLowerCase()}" count=${num};`
  ).join("\n");
  const mainStatsText = Object.entries(slots).map(
    ([_, { level: level2, statKey, rarity }]) => `${GOODtoSRL[statKey]}=${getMainStatValue(statKey, rarity, level2)}`
  ).join(" ");
  const substatsText = Object.entries(substats).map(
    ([key, value]) => `${GOODtoSRL[key]}=${toDecimal$1(value, key).toFixed(
      key.endsWith("_") ? 4 : 2
    )}`
  ).join(" ");
  const text = `# Generated by Genshin Optimizer

# Character
${charKeyLow} char lvl=${level}/${ascensionMaxLevel[ascension]} cons=${constellation} talent=${auto},${skill},${burst};

# Weapon
${charKeyLow} add weapon="${weaponKey.toLowerCase()}" refine=${wRefinement} lvl=${wLevel}/${ascensionMaxLevel[wAscension]};

# Artifact Set
${setText ? setText : "# No Artifact Sets"}

# Main stats
${charKeyLow} add stats ${mainStatsText};

# Sub stats
${charKeyLow} add stats ${substatsText};`;
  const copyToClipboard = () => navigator.clipboard.writeText(text).then(() => alert(t2("tabTheorycraft.gcsimDialog.copied"))).catch(console.error);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        onClick: onOpen,
        startIcon: /* @__PURE__ */ jsx(ImgIcon, { src: gcsimIcon }),
        disabled,
        children: t2("tabTheorycraft.gcsimDialog.title")
      }
    ),
    /* @__PURE__ */ jsxs(Dialog$1, { open, onClose, maxWidth: "lg", children: [
      /* @__PURE__ */ jsx(DialogTitle$1, { children: t2("tabTheorycraft.gcsimDialog.title") }),
      /* @__PURE__ */ jsxs(DialogContent$1, { children: [
        /* @__PURE__ */ jsx(DialogContentText$1, { children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "tabTheorycraft.gcsimDialog.content", children: [
          "Import this build into",
          " ",
          /* @__PURE__ */ jsx(Link, { href: "https://gcsim.app/", target: "_blank", children: "gcsim" }),
          " ",
          "by copying the code below."
        ] }) }),
        /* @__PURE__ */ jsx(CardThemed, { children: /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsx(CodeBlock, { text }) }) })
      ] }),
      /* @__PURE__ */ jsx(DialogActions$1, { children: /* @__PURE__ */ jsx(
        Button,
        {
          fullWidth: true,
          color: "info",
          onClick: copyToClipboard,
          startIcon: /* @__PURE__ */ jsx(default_1$h, {}),
          children: /* @__PURE__ */ jsx(Trans, { t: t2, i18nKey: "settings:DatabaseCard.button.copy" })
        }
      ) })
    ] })
  ] });
}
const kqmIcon = "" + new URL("kqm-DWFBjd02.png", import.meta.url).href;
function KQMSButton({
  action,
  disabled
}) {
  const { t: t2 } = useTranslation(["page_character", "ui"]);
  const [open, onOpen, onClose] = useBoolState();
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      Button,
      {
        color: "keqing",
        onClick: onOpen,
        startIcon: /* @__PURE__ */ jsx(ImgIcon, { src: kqmIcon }),
        disabled,
        children: t2("tabTheorycraft.kqmsDialog.kqmsBtn")
      }
    ),
    /* @__PURE__ */ jsx(ModalWrapper, { open, onClose, children: /* @__PURE__ */ jsxs(CardThemed, { sx: { maxWidth: "sm", alignSelf: "center" }, children: [
      /* @__PURE__ */ jsx(DialogTitle$1, { children: t2("tabTheorycraft.kqmsDialog.title") }),
      /* @__PURE__ */ jsx(DialogContent$1, { children: /* @__PURE__ */ jsx(DialogContentText$1, { children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "tabTheorycraft.kqmsDialog.content", children: [
        "This will replace your current ",
        /* @__PURE__ */ jsx("strong", { children: "substat setup" }),
        " ",
        "with one that adheres to the",
        " ",
        /* @__PURE__ */ jsx(
          Link,
          {
            href: "https://compendium.keqingmains.com/",
            target: "_blank",
            children: "KQM Standards"
          }
        ),
        "."
      ] }) }) }),
      /* @__PURE__ */ jsxs(DialogActions$1, { children: [
        /* @__PURE__ */ jsx(Button, { onClick: onClose, color: "error", children: t2("ui:close") }),
        /* @__PURE__ */ jsx(
          Button,
          {
            color: "success",
            onClick: () => {
              onClose();
              action();
            },
            autoFocus: true,
            children: t2("tabTheorycraft.kqmsDialog.kqmsBtn")
          }
        )
      ] })
    ] }) })
  ] });
}
function WeaponEditorCard({
  weaponTypeKey,
  disabled
}) {
  const { buildTc, setBuildTc: setCharTC } = reactExports.useContext(BuildTcContext);
  const setWeapon = reactExports.useCallback(
    (weapon2) => {
      setCharTC((charTC) => {
        charTC.weapon = { ...charTC.weapon, ...weapon2 };
      });
    },
    [setCharTC]
  );
  const weapon = reactExports.useMemo(
    () => ({
      ...buildTc.weapon,
      location: "",
      lock: false,
      id: ""
    }),
    [buildTc]
  );
  const { key, level = 0, refinement = 1, ascension = 0 } = weapon;
  const weaponSheet = getWeaponSheet(key);
  const [show, onShow, onHide] = useBoolState();
  const { data } = reactExports.useContext(DataContext);
  const weaponUIData = reactExports.useMemo(
    () => weapon && computeUIData([weaponSheet.data, dataObjForWeapon(weapon)]),
    [weaponSheet, weapon]
  );
  const hasRefinement = weaponHasRefinement(weapon.key);
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", sx: { p: 1, mb: 1 }, children: [
    /* @__PURE__ */ jsx(
      WeaponSelectionModal,
      {
        ascension,
        show,
        onHide,
        onSelect: (k2) => setWeapon({ key: k2 }),
        weaponTypeFilter: weaponTypeKey
      }
    ),
    /* @__PURE__ */ jsxs(Box, { display: "flex", flexDirection: "column", gap: 1, children: [
      /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, children: [
        /* @__PURE__ */ jsx(
          Box,
          {
            className: `grad-${getWeaponStat(weapon.key).rarity}star`,
            component: "img",
            src: weaponAsset(weapon.key, ascension >= 2),
            sx: {
              flexshrink: 1,
              flexBasis: 0,
              maxWidth: "30%",
              borderRadius: 1
            }
          }
        ),
        /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, flexGrow: 1, children: [
          /* @__PURE__ */ jsx(
            Button,
            {
              fullWidth: true,
              color: "info",
              sx: { flexGrow: 1 },
              onClick: onShow,
              disabled,
              children: /* @__PURE__ */ jsx(Box, { sx: { maxWidth: "10em" }, children: /* @__PURE__ */ jsx(WeaponName, { weaponKey: key }) })
            }
          ),
          hasRefinement && /* @__PURE__ */ jsx(
            RefinementDropdown,
            {
              disabled,
              refinement,
              setRefinement: (r2) => setWeapon({ refinement: r2 })
            }
          )
        ] })
      ] }),
      /* @__PURE__ */ jsx(
        LevelSelect,
        {
          level,
          ascension,
          setBoth: setWeapon,
          useLow: !hasRefinement,
          disabled
        }
      ),
      /* @__PURE__ */ jsxs(CardThemed, { children: [
        /* @__PURE__ */ jsx(
          CardHeader,
          {
            title: "Main Stats",
            titleTypographyProps: { variant: "subtitle2" }
          }
        ),
        /* @__PURE__ */ jsx(Divider, {}),
        weaponUIData && /* @__PURE__ */ jsx(FieldDisplayList, { children: [uiInput.weapon.main, uiInput.weapon.sub, uiInput.weapon.sub2].map(
          (node) => {
            const n2 = weaponUIData.get(node);
            if (n2.isEmpty || !n2.value)
              return null;
            return /* @__PURE__ */ jsx(
              NodeFieldDisplay,
              {
                calcRes: n2,
                component: ListItem
              },
              JSON.stringify(n2.info)
            );
          }
        ) })
      ] }),
      data && (weaponSheet == null ? void 0 : weaponSheet.document) && /* @__PURE__ */ jsx(
        DocumentDisplay,
        {
          sections: weaponSheet.document,
          disabled
        }
      )
    ] })
  ] });
}
function TabTheorycraft() {
  const { t: t2 } = useTranslation("page_character");
  const database = useDatabase();
  const { gender } = useDBMeta();
  const {
    teamId,
    teamCharId,
    teamChar: { key: characterKey, optConfigId }
  } = reactExports.useContext(TeamCharacterContext);
  const { buildTc, setBuildTc } = reactExports.useContext(BuildTcContext);
  const { optimizationTarget } = useOptConfig(optConfigId);
  const weaponTypeKey = getCharStat(characterKey).weaponType;
  const dataContextValue = reactExports.useContext(DataContext);
  const compareData = useCompareData();
  const dataContextValueWithCompare = reactExports.useMemo(() => {
    if (!dataContextValue)
      return void 0;
    return {
      ...dataContextValue,
      compareData
    };
  }, [dataContextValue, compareData]);
  const setOptimizationTarget = reactExports.useCallback(
    (optimizationTarget2) => {
      database.optConfigs.set(optConfigId, { optimizationTarget: optimizationTarget2 });
    },
    [database, optConfigId]
  );
  const distributedSubstats = buildTc.optimization.distributedSubstats;
  const setDistributedSubstats = reactExports.useCallback(
    (distributedSubstats2) => {
      setBuildTc((data_) => {
        data_.optimization.distributedSubstats = distributedSubstats2;
      });
    },
    [setBuildTc]
  );
  const workerRef = reactExports.useRef(null);
  if (workerRef.current === null)
    workerRef.current = TCWorker();
  const [status, setStatus] = reactExports.useState(initialBuildStatus());
  const solving = status.type === "active";
  const terminateWorker = reactExports.useCallback(() => {
    var _a;
    (_a = workerRef.current) == null ? void 0 : _a.terminate();
    workerRef.current = null;
    setStatus(initialBuildStatus());
  }, [workerRef]);
  const { minSubLines, minOtherRolls } = reactExports.useMemo(
    () => getMinSubAndOtherRolls(buildTc),
    [buildTc]
  );
  const maxTotalRolls = reactExports.useMemo(
    () => Object.values(buildTc.artifact.slots).reduce(
      (accu, { level, rarity }) => accu + artSubstatRollData[rarity].high + Math.floor(level / 4),
      0
    ),
    [buildTc]
  );
  const { scalesWith } = reactExports.useMemo(() => {
    const { nodes } = optimizeTcGetNodes(
      dataContextValue.teamData,
      characterKey,
      buildTc,
      optimizationTarget
    );
    const scalesWith2 = nodes ? getScalesWith(nodes) : /* @__PURE__ */ new Set();
    return {
      nodes,
      scalesWith: scalesWith2
    };
  }, [dataContextValue.teamData, characterKey, buildTc, optimizationTarget]);
  const optimizeSubstats = (apply2) => {
    if (!workerRef.current)
      return;
    const tempTeamData = getTeamDataCalc(
      database,
      teamId,
      gender,
      teamCharId,
      0,
      getBuildTcArtifactData(buildTc),
      getBuildTcWeaponData(buildTc)
    );
    if (!tempTeamData)
      return;
    const { nodes } = optimizeTcGetNodes(
      tempTeamData,
      characterKey,
      buildTc,
      optimizationTarget
    );
    workerRef.current.postMessage({ buildTc, nodes });
    setStatus((s2) => ({
      ...s2,
      type: "active",
      startTime: performance.now(),
      finishTime: void 0
    }));
    workerRef.current.onmessage = ({ data }) => {
      const { resultType } = data;
      switch (resultType) {
        case "total":
          setStatus((s2) => ({ ...s2, total: data.total }));
          break;
        case "count":
          setStatus((s2) => ({
            ...s2,
            tested: data.tested,
            failed: data.failed
          }));
          break;
        case "finalize": {
          const { maxBuffer, distributed, tested, failed, skipped } = data;
          setStatus((s2) => ({
            ...s2,
            type: "inactive",
            tested,
            failed,
            skipped,
            finishTime: performance.now()
          }));
          if (!apply2) {
            console.log({
              maxBuffer,
              distributed,
              tested,
              failed,
              skipped
            });
            break;
          }
          setBuildTc((buildTc2) => {
            buildTc2.artifact.substats.stats = objMap(
              buildTc2.artifact.substats.stats,
              (v2, k2) => v2 + toPercent(maxBuffer[k2] ?? 0, k2)
            );
            buildTc2.optimization.distributedSubstats = distributedSubstats - distributed;
            return buildTc2;
          });
          break;
        }
      }
    };
  };
  const kqms = reactExports.useCallback(() => {
    setBuildTc((buildTc2) => {
      buildTc2.artifact.substats.type = "mid";
      const {
        artifact: {
          slots,
          substats: { stats, type, rarity }
        }
      } = buildTc2;
      buildTc2.optimization.distributedSubstats = 20 - (rarity === 5 ? 0 : rarity === 4 ? 10 : 15);
      buildTc2.artifact.substats.stats = objMap(stats, (val, statKey) => {
        const substatValue = getSubstatValue(statKey, rarity, type);
        return substatValue * 2;
      });
      buildTc2.optimization.maxSubstats = objMap(
        buildTc2.optimization.maxSubstats,
        (_val, statKey) => {
          const rollsPerSlot = 2;
          const diffSlot = 5;
          const sameSlot = Object.entries(slots).filter(
            ([_slotKey, { statKey: mainStatKey }]) => mainStatKey === statKey
          ).length;
          return 2 + (diffSlot - sameSlot) * rollsPerSlot;
        }
      );
    });
  }, [setBuildTc]);
  return /* @__PURE__ */ jsxs(Stack$3, { spacing: 1, children: [
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, sx: { justifyContent: "center" }, children: [
      /* @__PURE__ */ jsx(Grid, { item: true, xs: 8, sm: 8, md: 3, lg: 2.3, children: /* @__PURE__ */ jsx(CharacterProfileCard, {}) }),
      /* @__PURE__ */ jsx(
        Grid,
        {
          item: true,
          xs: 12,
          sm: 12,
          md: 9,
          lg: 9.7,
          sx: { display: "flex", flexDirection: "column", gap: 1 },
          children: /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { flexGrow: 1, p: 1 }, children: /* @__PURE__ */ jsx(OptimizationTargetContext.Provider, { value: optimizationTarget, children: dataContextValueWithCompare ? /* @__PURE__ */ jsx(DataContext.Provider, { value: dataContextValueWithCompare, children: /* @__PURE__ */ jsx(
            StatDisplayComponent,
            {
              columns: { xs: 1, sm: 1, md: 2, lg: 2, xl: 3 }
            }
          ) }) : /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 500 }) }) })
        }
      )
    ] }) }),
    /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, p: 1, flexWrap: "wrap" }, children: [
      /* @__PURE__ */ jsx(KQMSButton, { action: kqms, disabled: solving }),
      /* @__PURE__ */ jsx(GcsimButton, { disabled: solving }),
      /* @__PURE__ */ jsx(HitModeToggle, { size: "small" }),
      /* @__PURE__ */ jsx(ReactionToggle, { size: "small" }),
      /* @__PURE__ */ jsx(CompareBtn, { buttonGroupProps: { sx: { marginLeft: "auto" } } })
    ] }) }),
    dataContextValue ? /* @__PURE__ */ jsxs(DataContext.Provider, { value: dataContextValue, children: [
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, sx: { justifyContent: "center" }, children: [
        /* @__PURE__ */ jsxs(Grid, { item: true, sx: { flexGrow: -1, maxWidth: "350px" }, children: [
          /* @__PURE__ */ jsx(
            WeaponEditorCard,
            {
              weaponTypeKey,
              disabled: solving
            }
          ),
          /* @__PURE__ */ jsx(BuildConstaintCard, { disabled: solving })
        ] }),
        /* @__PURE__ */ jsx(Grid, { item: true, sx: { flexGrow: -1 }, children: /* @__PURE__ */ jsx(ArtifactMainStatAndSetEditor, { disabled: solving }) }),
        /* @__PURE__ */ jsx(Grid, { item: true, sx: { flexGrow: 1 }, children: /* @__PURE__ */ jsx(
          ArtifactSubCard,
          {
            disabled: solving,
            maxTotalRolls
          }
        ) })
      ] }) }),
      /* @__PURE__ */ jsxs(Box, { display: "flex", flexDirection: "column", gap: 1, children: [
        minOtherRolls > 0 && /* @__PURE__ */ jsx(Alert, { severity: "warning", variant: "filled", children: /* @__PURE__ */ jsxs(
          Trans,
          {
            t: t2,
            i18nKey: "tabTheorycraft.feasibilityAlert",
            values: { minSubLines, minOtherRolls },
            children: [
              "The current substat distribution requires at least",
              " ",
              /* @__PURE__ */ jsx("strong", { children: { minSubLines } }),
              " lines of substats. Need to assign ",
              /* @__PURE__ */ jsx("strong", { children: { minOtherRolls } }),
              " ",
              "rolls to other substats for this solution to be feasible."
            ]
          }
        ) }),
        /* @__PURE__ */ jsxs(Box, { display: "flex", gap: 1, children: [
          /* @__PURE__ */ jsx(
            OptimizationTargetSelector,
            {
              disabled: solving,
              optimizationTarget,
              setTarget: (target) => setOptimizationTarget(target),
              targetSelectorModalProps: {
                excludeSections: ["character", "bounsStats", "teamBuff"]
              }
            }
          ),
          /* @__PURE__ */ jsx(
            CustomNumberInput,
            {
              value: distributedSubstats,
              disabled: !optimizationTarget || solving,
              onChange: (v2) => v2 !== void 0 && setDistributedSubstats(v2),
              endAdornment: "Substats",
              sx: {
                borderRadius: 1,
                px: 1,
                textWrap: "nowrap",
                flexShrink: 1
              },
              inputProps: {
                sx: {
                  textAlign: "right",
                  px: 1,
                  width: "3em",
                  minWidth: "3em"
                },
                min: 0
              }
            }
          ),
          !solving ? /* @__PURE__ */ jsx(
            Button,
            {
              onClick: () => optimizeSubstats(true),
              disabled: !optimizationTarget || !distributedSubstats || distributedSubstats > maxTotalRolls,
              color: "success",
              startIcon: /* @__PURE__ */ jsx(default_1$5, {}),
              children: t2`tabTheorycraft.distribute`
            }
          ) : /* @__PURE__ */ jsx(
            Button,
            {
              onClick: terminateWorker,
              color: "error",
              startIcon: /* @__PURE__ */ jsx(default_1$a, {}),
              children: "Cancel"
            }
          )
        ] }),
        isDev,
        !!scalesWith.size && /* @__PURE__ */ jsxs(Alert, { severity: "info", variant: "filled", children: [
          /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "tabTheorycraft.optAlert.scalesWith", children: [
            "The selected Optimization target and constraints scales with:",
            " "
          ] }),
          [...scalesWith].map((k2) => /* @__PURE__ */ jsxs("strong", { children: [
            /* @__PURE__ */ jsx(StatIcon, { statKey: k2, iconProps: iconInlineProps }),
            /* @__PURE__ */ jsx(ArtifactStatWithUnit, { statKey: k2 })
          ] }, k2)).flatMap((value, index, array2) => {
            if (index === array2.length - 2)
              return [value, /* @__PURE__ */ jsx("span", { children: ", and " }, "and")];
            if (index === array2.length - 1)
              return value;
            return [value, /* @__PURE__ */ jsx("span", { children: ", " }, index)];
          }),
          /* @__PURE__ */ jsx(Trans, { t: t2, i18nKey: "tabTheorycraft.optAlert.distribute", children: ". The solver will only distribute stats to these substats." }),
          " ",
          minOtherRolls > 0 && /* @__PURE__ */ jsx(Trans, { t: t2, i18nKey: "tabTheorycraft.optAlert.feasibilty", children: "There may be additional leftover substats that should be distributed to non-scaling stats to ensure the solution is feasible." })
        ] }),
        /* @__PURE__ */ jsx(
          BuildAlert$1,
          {
            status,
            characterKey,
            gender
          }
        )
      ] })
    ] }) : /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 500 })
  ] });
}
const LevelFilter = reactExports.memo(function LevelFilter22({
  levelTotal,
  upOptLevelLow,
  upOptLevelHigh,
  disabled,
  optConfigId
}) {
  const database = useDatabase();
  const { t: t2 } = useTranslation("page_character_optimize");
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", gap: 1 }, children: [
      /* @__PURE__ */ jsx(
        Typography,
        {
          sx: { fontWeight: "bold" },
          children: t2`upOptLevelFilter`
        }
      ),
      /* @__PURE__ */ jsx(SqBadge, { color: "info", children: levelTotal }),
      /* @__PURE__ */ jsx(Tooltip$1, { title: t2`upOptLevelFilterTooltip`, children: /* @__PURE__ */ jsx(default_1$s, {}) })
    ] }),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(
      ArtifactLevelSlider,
      {
        levelLow: upOptLevelLow,
        levelHigh: upOptLevelHigh,
        setLow: (upOptLevelLow2) => database.optConfigs.set(optConfigId, { upOptLevelLow: upOptLevelLow2 }),
        setHigh: (upOptLevelHigh2) => database.optConfigs.set(optConfigId, { upOptLevelHigh: upOptLevelHigh2 }),
        setBoth: (upOptLevelLow2, upOptLevelHigh2) => database.optConfigs.set(optConfigId, {
          upOptLevelLow: upOptLevelLow2,
          upOptLevelHigh: upOptLevelHigh2
        }),
        disabled
      }
    )
  ] });
});
const quadrinomials = [
  [1],
  [1, 1, 1, 1],
  [1, 2, 3, 4, 3, 2, 1],
  [1, 3, 6, 10, 12, 12, 10, 6, 3, 1],
  [1, 4, 10, 20, 31, 40, 44, 40, 31, 20, 10, 4, 1],
  [1, 5, 15, 35, 65, 101, 135, 155, 155, 135, 101, 65, 35, 15, 5, 1]
];
function quadrinomial(n2, k2) {
  if (n2 >= quadrinomials.length)
    throw Error("Input to `quadrinomial` leaves expected range 0 <= n <= 5");
  return quadrinomials[n2][k2] ?? 0;
}
function erf(x2) {
  const a1 = 0.254829592, a2 = -0.284496736, a3 = 1.421413741;
  const a4 = -1.453152027, a5 = 1.061405429, p2 = 0.3275911;
  let sign2 = 1;
  if (x2 < 0)
    sign2 = -1;
  x2 = Math.abs(x2);
  const t2 = 1 / (1 + p2 * x2);
  const y2 = 1 - ((((a5 * t2 + a4) * t2 + a3) * t2 + a2) * t2 + a1) * t2 * Math.exp(-x2 * x2);
  return sign2 * y2;
}
function gaussPDF(x2, mu, sig2) {
  if (mu === void 0)
    mu = 0;
  if (sig2 === void 0)
    sig2 = 1;
  if (sig2 <= 0)
    return 0;
  return Math.exp(-(mu - x2) * (mu - x2) / sig2 / 2) / Math.sqrt(2 * Math.PI * sig2);
}
const facts = [1, 1, 2, 6, 24, 120, 720];
function factorial(n2) {
  while (n2 >= facts.length)
    facts.push(facts.length * facts[facts.length - 1]);
  return facts[n2];
}
function multinomial4(n1, n2, n3, n4, N) {
  if (n1 + n2 + n3 + n4 !== N)
    return 0;
  return factorial(N) / factorial(n1) / factorial(n2) / factorial(n3) / factorial(n4) * 4 ** -N;
}
function crawlUpgrades(n2, fn) {
  if (n2 === 0) {
    fn([0, 0, 0, 0], 1);
    return;
  }
  for (let i1 = n2; i1 >= 0; i1--) {
    for (let i2 = n2 - i1; i2 >= 0; i2--) {
      for (let i3 = n2 - i1 - i2; i3 >= 0; i3--) {
        const i4 = n2 - i1 - i2 - i3;
        const p_combination = multinomial4(i1, i2, i3, i4, n2);
        fn([i1, i2, i3, i4], p_combination);
      }
    }
  }
}
function gaussianPE(mu, variance, x2) {
  if (variance < 1e-5) {
    if (mu > x2)
      return { p: 1, upAvg: mu - x2 };
    return { p: 0, upAvg: 0 };
  }
  const z2 = (x2 - mu) / Math.sqrt(variance);
  const p2 = (1 - erf(z2 / Math.sqrt(2))) / 2;
  const phi = gaussPDF(z2);
  const y2 = 1 / (z2 * z2);
  const ppz = z2 < 5 ? phi / p2 - z2 : (1 - 2 * y2 * (1 - y2 * (5 + 37 * y2))) / z2;
  return { p: p2, upAvg: Math.sqrt(variance) * ppz };
}
function mvnPE_bad(mu, cov, x2) {
  let ptot = 1;
  let cptot = 1;
  for (let i = 0; i < mu.length; ++i) {
    if (cov[i][i] < 1e-5) {
      if (mu[i] < x2[i])
        return { p: 0, upAvg: 0, cp: 0 };
      continue;
    }
    const z2 = (x2[i] - mu[i]) / Math.sqrt(cov[i][i]);
    const p2 = (1 - erf(z2 / Math.sqrt(2))) / 2;
    ptot *= p2;
    if (i !== 0)
      cptot *= p2;
  }
  const { upAvg } = gaussianPE(mu[0], cov[0][0], x2[0]);
  return { p: ptot, upAvg, cp: cptot };
}
const up_rv_mean = 17 / 2;
const up_rv_stdev = 5 / 4;
const Q = (up_rv_stdev + up_rv_mean ** 2) / 4;
const W = (up_rv_mean / 4) ** 2;
var ResultType = /* @__PURE__ */ ((ResultType2) => {
  ResultType2[ResultType2["Fast"] = 0] = "Fast";
  ResultType2[ResultType2["Slow"] = 1] = "Slow";
  ResultType2[ResultType2["Exact"] = 2] = "Exact";
  return ResultType2;
})(ResultType || {});
const fWeight = {
  hp: 6,
  atk: 6,
  def: 6,
  hp_: 4,
  atk_: 4,
  def_: 4,
  eleMas: 4,
  enerRech_: 4,
  critRate_: 3,
  critDMG_: 3
};
function scale(key, rarity = 5) {
  return toDecimal(key, getSubstatValue(key, rarity) / 10);
}
function toDecimal(key, value) {
  return key.endsWith("_") ? value / 100 : value;
}
class UpOptCalculator {
  /**
   * Constructs UpOptCalculator.
   * @param nodes Formulas to find upgrades for. nodes[0] is main objective, the rest are constraints.
   * @param thresholds Constraint values. thresholds[0] will be auto-populated with current objective value.
   * @param build Build to check 1-swaps against.
   * @param artifacts List of artifacts to consider upgrading.
   */
  constructor(nodes, thresholds, equippedBuild, artifacts, calc4th = true) {
    this.artifacts = [];
    this.fixedIx = 0;
    this.baseBuild = objMap(
      equippedBuild,
      (art) => art ? this.toArtifact(art) : { id: "", values: {} }
    );
    this.nodes = nodes;
    this.thresholds = thresholds;
    this.calc4th = calc4th;
    const toEval = [];
    nodes.forEach((n2) => {
      toEval.push(
        n2,
        ...allSubstatKeys.map((sub) => ddx(n2, (fo) => fo.path[1], sub))
      );
    });
    const evalOpt = optimize(toEval, {}, ({ path: [p2] }) => p2 !== "dyn");
    const evalFn = precompute(evalOpt, {}, (f2) => f2.path[1], 5);
    thresholds[0] = evalFn(
      Object.values(this.baseBuild)
    )[0];
    this.skippableDerivatives = allSubstatKeys.map(
      (sub) => nodes.every((n2) => zero_deriv(n2, (f2) => f2.path[1], sub))
    );
    this.eval = (stats, slot) => {
      const b2 = { ...this.baseBuild, [slot]: { id: "", values: stats } };
      const out = evalFn(
        Object.values(b2)
      );
      return nodes.map((_, i) => {
        const ix = i * (1 + allSubstatKeys.length);
        return {
          v: out[ix],
          grads: allSubstatKeys.map((sub, si) => out[ix + 1 + si])
        };
      });
    };
    artifacts.forEach((art) => this._addArtifact(art));
    this.initCalc();
  }
  /** Adds an artifact to be tracked by UpOptCalc. It is initially un-evaluated. */
  _addArtifact(art) {
    this.artifacts.push(this.toUpOptArtifact(art));
  }
  toUpOptArtifact(art) {
    const maxLevel = artMaxLevel[art.rarity];
    const mainStatVal = getMainStatValue(art.mainStatKey, art.rarity, maxLevel);
    return {
      id: art.id,
      rollsLeft: getRollsRemaining(art.level, art.rarity),
      slotKey: art.slotKey,
      mainStat: art.mainStatKey,
      subs: art.substats.map(({ key }) => key).filter((v2) => v2 !== ""),
      values: {
        [art.setKey]: 1,
        [art.mainStatKey]: mainStatVal,
        ...Object.fromEntries(
          art.substats.filter(({ key }) => key !== "").map((substat) => [
            substat.key,
            toDecimal(substat.key, substat.accurateValue)
          ])
        )
        // Assumes substats cannot match main stat key
      }
    };
  }
  reCalc(ix, art) {
    this.artifacts[ix] = this.toUpOptArtifact(art);
    this.calcFast(ix, this.calc4th);
  }
  /** Calcs all artifacts using Fast method */
  initCalc() {
    function score(a2) {
      return a2.result.p * a2.result.upAvg;
    }
    this.artifacts.forEach((_, i) => this.calcFast(i, this.calc4th));
    this.calcSlowToIndex(5);
    this.artifacts = this.artifacts.filter((a2) => score(a2) > 0);
    this.artifacts.sort((a2, b2) => score(b2) - score(a2));
    this.fixedIx = 0;
  }
  calcSlowToIndex(ix, lookahead = 5) {
    const fixedList = this.artifacts.slice(0, this.fixedIx);
    const arr = this.artifacts.slice(this.fixedIx);
    function score(a2) {
      return a2.result.p * a2.result.upAvg;
    }
    function compare(a2, b2) {
      if (score(a2) > 1e-5 || score(b2) > 1e-5)
        return score(b2) - score(a2);
      const meanA = a2.result.distr.gmm.reduce(
        (pv, { phi, mu }) => pv + phi * mu,
        0
      );
      const meanB = b2.result.distr.gmm.reduce(
        (pv, { phi, mu }) => pv + phi * mu,
        0
      );
      return meanB - meanA;
    }
    let i = 0;
    const end = Math.min(ix - this.fixedIx + lookahead, arr.length);
    do {
      for (; i < end; i++)
        this.calcSlow(this.fixedIx + i, this.calc4th);
      arr.sort(compare);
      this.artifacts = [...fixedList, ...arr];
      for (i = 0; i < end; i++) {
        if (arr[i].result.evalMode === 0)
          break;
      }
    } while (i < end);
  }
  /**
   * Convert Fast method numbers to Result type.
   *
   * Each target/constraint is treated as an independent 1D Gaussian, but we try
   *   to over-estimate the true constraint probability by using the min() probability
   *   of each constraint (rather than their product). If multiple Gaussians are
   *   present in `distr[]`, they are aggregated following standard mixture distribution methods.
   */
  _toResultFast(distr) {
    let ptot = 0;
    let upAvgtot = 0;
    const gmm = distr.map(({ prob, mu, cov }) => {
      const z2 = mu.map((mui, i) => {
        return gaussianPE(mui, cov[i], this.thresholds[i]);
      });
      const p2 = Math.min(...z2.map(({ p: p22 }) => p22));
      const cp = Math.min(...z2.slice(1).map(({ p: p22 }) => p22));
      ptot += p2 * prob;
      upAvgtot += p2 * prob * z2[0].upAvg;
      return { phi: prob, cp, mu: mu[0], sig2: cov[0] };
    });
    const lowers = gmm.map(({ mu, sig2 }) => mu - 4 * Math.sqrt(sig2));
    const uppers = gmm.map(({ mu, sig2 }) => mu + 4 * Math.sqrt(sig2));
    return {
      p: ptot,
      upAvg: ptot < 1e-6 ? 0 : upAvgtot / ptot,
      distr: { gmm, lower: Math.min(...lowers), upper: Math.max(...uppers) },
      evalMode: 0
      /* Fast */
    };
  }
  /**
   * Evaluates artifact using Fast method.
   * Selection details based on artifacts[ix]
   */
  calcFast(ix, calc4th = true) {
    if (this.artifacts[ix].subs.length === 4)
      calc4th = false;
    if (calc4th)
      this._calcFast4th(ix);
    else
      this._calcFast(ix);
  }
  /**
   * Fast evaluation of 4-line artifact.
   * If a 3-line artifact is passed, the 4th substat possibilities are ignored.
   */
  _calcFast(ix) {
    const { subs, slotKey, rollsLeft } = this.artifacts[ix];
    const N = rollsLeft - (subs.length < 4 ? 1 : 0);
    const stats = { ...this.artifacts[ix].values };
    subs.forEach((subKey) => {
      stats[subKey] += up_rv_mean * (N / 4) * scale(subKey);
    });
    const objective = this.eval(stats, slotKey);
    const gaussians = objective.map(({ v: mu, grads }) => {
      const ks = subs.map(
        (sub) => grads[allSubstatKeys.indexOf(sub)] * scale(sub)
      );
      const ksum = ks.reduce((a2, b2) => a2 + b2, 0);
      const ksum2 = ks.reduce((a2, b2) => a2 + b2 * b2, 0);
      const sig2 = (Q * ksum2 - W * ksum ** 2) * N;
      return { mu, sig2 };
    });
    this.artifacts[ix].result = this._toResultFast([
      {
        prob: 1,
        mu: gaussians.map(({ mu }) => mu),
        cov: gaussians.map(({ sig2 }) => sig2)
      }
    ]);
  }
  /**
   * Fast evaluation of a 3-line artifact, considering all possiblilties for its 4th stats.
   * Passing a 4-line artifact will result in inaccurate results.
   */
  _calcFast4th(ix) {
    const { mainStat, subs, slotKey, rollsLeft } = this.artifacts[ix];
    const N = rollsLeft - 1;
    const subsToConsider = allSubstatKeys.filter(
      (s2) => !subs.includes(s2) && s2 !== mainStat
    );
    const Z = subsToConsider.reduce((tot, sub) => tot + fWeight[sub], 0);
    const distr = subsToConsider.map((subKey4) => {
      const prob = fWeight[subKey4] / Z;
      const stats = { ...this.artifacts[ix].values };
      subs.forEach((subKey) => {
        stats[subKey] += up_rv_mean * (N / 4) * scale(subKey);
      });
      stats[subKey4] = (stats[subKey4] ?? 0) + up_rv_mean * (N / 4 + 1) * scale(subKey4);
      const objective = this.eval(stats, slotKey);
      const gaussians = objective.map(({ v: mu, grads }) => {
        const ks = subs.map(
          (sub) => grads[allSubstatKeys.indexOf(sub)] * scale(sub)
        );
        const k4 = grads[allSubstatKeys.indexOf(subKey4)] * scale(subKey4);
        const ksum = ks.reduce((a2, b2) => a2 + b2, k4);
        const ksum2 = ks.reduce((a2, b2) => a2 + b2 * b2, k4 * k4);
        const sig2 = (Q * ksum2 - W * ksum ** 2) * N + up_rv_stdev * k4 * k4;
        return { mu, sig2 };
      });
      return {
        prob,
        mu: gaussians.map(({ mu }) => mu),
        cov: gaussians.map(({ sig2 }) => sig2)
      };
    });
    this.artifacts[ix].result = this._toResultFast(distr);
  }
  /**
   * Convert Slow method numbers to Result type.
   * Here, targets and constraints are treated as multi-dimensional Gaussians with
   *   non-zero covariances. The probabilities are evaluated using `mvncdf` and aggregated
   *   following standard mixture distribution methods.
   */
  _toResultSlow(distr) {
    let ptot = 0;
    let upAvgtot = 0;
    const gmm = distr.map(({ prob, mu, cov }) => {
      const { p: p2, upAvg, cp } = mvnPE_bad(mu, cov, this.thresholds);
      ptot += prob * p2;
      upAvgtot += prob * p2 * upAvg;
      return { phi: prob, cp, mu: mu[0], sig2: cov[0][0] };
    });
    const lowers = gmm.map(({ mu, sig2 }) => mu - 4 * Math.sqrt(sig2));
    const uppers = gmm.map(({ mu, sig2 }) => mu + 4 * Math.sqrt(sig2));
    return {
      p: ptot,
      upAvg: ptot < 1e-6 ? 0 : upAvgtot / ptot,
      distr: {
        gmm,
        lower: Math.min(...lowers, this.thresholds[0]),
        upper: Math.max(...uppers, this.thresholds[0])
      },
      evalMode: 1
      /* Slow */
    };
  }
  /** Selects evaluation method based on details of artifacts[ix] */
  calcSlow(ix, calc4th = true) {
    var _a, _b;
    if (((_a = this.artifacts[ix].result) == null ? void 0 : _a.evalMode) === 1 || ((_b = this.artifacts[ix].result) == null ? void 0 : _b.evalMode) === 2)
      return;
    if (this.artifacts[ix].subs.length === 4)
      calc4th = false;
    if (calc4th)
      this._calcSlow4th(ix);
    else
      this._calcSlow(ix);
  }
  /**
   * Slow evaluation of 4-line artifact.
   * If a 3-line artifact is passed, the 4th substat possibilities are ignored.
   */
  _calcSlow(ix) {
    const { subs, slotKey, rollsLeft } = this.artifacts[ix];
    const N = rollsLeft - (subs.length < 4 ? 1 : 0);
    const distrs = [];
    crawlUpgrades(N, (ns, prob) => {
      const stats = { ...this.artifacts[ix].values };
      subs.forEach((subKey, i) => {
        stats[subKey] += up_rv_mean * ns[i] * scale(subKey);
      });
      const objective = this.eval(stats, slotKey);
      const obj_ks = objective.map(
        ({ grads }) => subs.map((sub) => grads[allSubstatKeys.indexOf(sub)] * scale(sub))
      );
      const mu = objective.map((o) => o.v);
      const cov = obj_ks.map(
        (k1) => obj_ks.map(
          (k2) => k1.reduce((pv, cv, j) => pv + k1[j] * k2[j] * ns[j], 0)
        )
      );
      distrs.push({ prob, mu, cov });
    });
    this.artifacts[ix].result = this._toResultSlow(distrs);
  }
  /**
   * Slow evaluation of a 3-line artifact, considering all possiblilties for its 4th stats.
   * Passing a 4-line artifact will result in inaccurate results.
   */
  _calcSlow4th(ix) {
    const { mainStat, subs, slotKey, rollsLeft } = this.artifacts[ix];
    const N = rollsLeft - 1;
    const subsToConsider = allSubstatKeys.filter(
      (s2) => !subs.includes(s2) && s2 !== mainStat
    );
    const Z = subsToConsider.reduce((tot, sub) => tot + fWeight[sub], 0);
    const distrs = [];
    subsToConsider.forEach((subKey4) => {
      crawlUpgrades(N, (ns, prob) => {
        prob = prob * (fWeight[subKey4] / Z);
        const stats = { ...this.artifacts[ix].values };
        ns[3] += 1;
        subs.forEach((subKey, i) => {
          stats[subKey] += up_rv_mean * ns[i] * scale(subKey);
        });
        stats[subKey4] = (stats[subKey4] ?? 0) + up_rv_mean * ns[3] * scale(subKey4);
        const objective = this.eval(stats, slotKey);
        const obj_ks = objective.map(({ grads }) => {
          const ks = subs.map(
            (sub) => grads[allSubstatKeys.indexOf(sub)] * scale(sub)
          );
          ks.push(grads[allSubstatKeys.indexOf(subKey4)] * scale(subKey4));
          return ks;
        });
        const mu = objective.map((o) => o.v);
        const cov = obj_ks.map(
          (k1) => obj_ks.map(
            (k2) => k1.reduce((pv, cv, j) => pv + k1[j] * k2[j] * ns[j], 0)
          )
        );
        distrs.push({ prob, mu, cov });
      });
    });
    this.artifacts[ix].result = this._toResultSlow(distrs);
  }
  /**
   * Convert Exact method numbers to Result type.
   *
   * Exact results have no variance, so we can directly check each upgrade branch
   *   to compute the exact probability and upgrade value.
   */
  _toResultExact(distr) {
    let ptot = 0;
    let upAvgtot = 0;
    const gmm = distr.map(({ prob, val }) => {
      if (val.every((vi, i) => vi >= this.thresholds[i])) {
        ptot += prob;
        upAvgtot += prob * (val[0] - this.thresholds[0]);
        return { phi: prob, cp: 1, mu: val[0], sig2: 0 };
      }
      const consOK = val.slice(1).every((vi, i) => vi >= this.thresholds[i]);
      return { phi: prob, cp: consOK ? 1 : 0, mu: val[0], sig2: 0 };
    });
    const vals = gmm.map(({ mu }) => mu);
    return {
      p: ptot,
      upAvg: ptot < 1e-6 ? 0 : upAvgtot / ptot,
      distr: { gmm, lower: Math.min(...vals), upper: Math.max(...vals) },
      evalMode: 2
      /* Exact */
    };
  }
  /**
   * Evaluates artifact using Exact method.
   * Selection details based on artifacts[ix]
   */
  calcExact(ix, calc4th = true) {
    var _a;
    if (((_a = this.artifacts[ix].result) == null ? void 0 : _a.evalMode) === 2)
      return;
    if (this.artifacts[ix].subs.length === 4)
      calc4th = false;
    if (calc4th)
      this._calcExact4th(ix);
    else
      this._calcExact(ix);
  }
  /**
   * Exact evaluation of 4-line artifact.
   * If a 3-line artifact is passed, the 4th substat possibilities are ignored.
   */
  _calcExact(ix) {
    const { subs, slotKey, rollsLeft } = this.artifacts[ix];
    const N = rollsLeft - (subs.length < 4 ? 1 : 0);
    const distrs = [];
    crawlUpgrades(N, (ns, prob) => {
      const base = { ...this.artifacts[ix].values };
      const vals = ns.map(
        (ni, i) => subs[i] && !this.skippableDerivatives[allSubstatKeys.indexOf(subs[i])] ? range$3(7 * ni, 10 * ni) : [NaN]
      );
      cartesian(...vals).forEach((upVals) => {
        const stats = { ...base };
        let p_upVals = 1;
        for (let i = 0; i < 4; i++) {
          if (isNaN(upVals[i]))
            continue;
          const key = subs[i];
          const val = upVals[i];
          const ni = ns[i];
          stats[key] = (stats[key] ?? 0) + val * scale(key);
          const p_val = 4 ** -ni * quadrinomial(ni, val - 7 * ni);
          p_upVals *= p_val;
        }
        distrs.push({
          prob: prob * p_upVals,
          val: this.eval(stats, slotKey).map((n2) => n2.v)
        });
      });
    });
    this.artifacts[ix].result = this._toResultExact(distrs);
  }
  /**
   * Exact evaluation of a 3-line artifact, considering all possiblilties for its 4th stats.
   * Passing a 4-line artifact will result in inaccurate results.
   */
  _calcExact4th(ix) {
    const { mainStat, subs, slotKey, rollsLeft } = this.artifacts[ix];
    const N = rollsLeft - 1;
    const subsToConsider = allSubstatKeys.filter(
      (s2) => !subs.includes(s2) && s2 !== mainStat
    );
    const Z = subsToConsider.reduce((tot, sub) => tot + fWeight[sub], 0);
    const distrs = [];
    subsToConsider.forEach((subKey4) => {
      const prob_sub = fWeight[subKey4] / Z;
      crawlUpgrades(N, (ns, prob) => {
        const vals = ns.map((ni, i) => {
          if (i === 3) {
            ni += 1;
            return !this.skippableDerivatives[allSubstatKeys.indexOf(subKey4)] ? range$3(7 * ni, 10 * ni) : [NaN];
          }
          return subs[i] && !this.skippableDerivatives[allSubstatKeys.indexOf(subs[i])] ? range$3(7 * ni, 10 * ni) : [NaN];
        });
        cartesian(...vals).forEach((upVals) => {
          const stats = { ...this.artifacts[ix].values };
          let p_upVals = 1;
          for (let i = 0; i < 3; i++) {
            if (isNaN(upVals[i]))
              continue;
            const key = subs[i];
            const val = upVals[i];
            const ni = ns[i];
            stats[key] = (stats[key] ?? 0) + val * scale(key);
            const p_val = 4 ** -ni * quadrinomial(ni, val - 7 * ni);
            p_upVals *= p_val;
          }
          if (!isNaN(upVals[3])) {
            const key = subKey4;
            const val = upVals[3];
            const ni = ns[3] + 1;
            stats[key] = (stats[key] ?? 0) + val * scale(key);
            const p_val = 4 ** -ni * quadrinomial(ni, val - 7 * ni);
            p_upVals *= p_val;
          }
          distrs.push({
            prob: prob_sub * prob * p_upVals,
            val: this.eval(stats, slotKey).map((n2) => n2.v)
          });
        });
      });
    });
    this.artifacts[ix].result = this._toResultExact(distrs);
  }
  /* ICachedArtifact to ArtifactBuildData. */
  toArtifact(art) {
    const mainStatVal = getMainStatValue(art.mainStatKey, art.rarity, art.level);
    const buildData = {
      id: art.id,
      slot: art.slotKey,
      level: art.level,
      rarity: art.rarity,
      values: {
        [art.setKey]: 1,
        [art.mainStatKey]: mainStatVal,
        ...Object.fromEntries(
          art.substats.map((substat) => [
            substat.key,
            toDecimal(substat.key, substat.accurateValue)
          ]).filter(([, value]) => value !== 0)
        )
      },
      subs: art.substats.reduce((sub, x2) => {
        if (x2.key !== "")
          sub.push(x2.key);
        return sub;
      }, [])
    };
    delete buildData.values[""];
    return buildData;
  }
}
const nbins = 50;
function UpgradeOptChartCard(props) {
  var _a;
  const database = useDatabase();
  const id = (_a = props.upOptCalc.artifacts[props.ix]) == null ? void 0 : _a.id;
  const upArt = database.arts.get(id);
  const { data } = reactExports.useContext(DataContext);
  const currentlyEquippedArtId = (upArt == null ? void 0 : upArt.slotKey) && data.get(uiInput.art[upArt.slotKey].id).value;
  const isEquipped = id === currentlyEquippedArtId;
  return /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, children: [
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, sm: 5, md: 4, lg: 3, xl: 3, children: /* @__PURE__ */ jsx(
      ArtifactCard,
      {
        artifactId: id,
        onEdit: () => props.setArtifactIdToEdit(id),
        extraButtons: /* @__PURE__ */ jsx(EquipButton, { newArtId: id, disabled: isEquipped })
      }
    ) }),
    /* @__PURE__ */ jsx(Grid, { item: true, xs: 12, sm: 7, md: 8, lg: 9, xl: 9, children: /* @__PURE__ */ jsx(UpgradeOptChartCardGraph, { ...props }) })
  ] }) });
}
function EquipButton({
  newArtId,
  disabled
}) {
  const database = useDatabase();
  const {
    loadoutDatum,
    loadoutDatum: { buildType, buildId },
    teamChar: { key: characterKey }
  } = reactExports.useContext(TeamCharacterContext);
  const [show, onShow, onHide] = useBoolState();
  const weapon = database.teams.getLoadoutWeapon(loadoutDatum);
  const artifactids = objMap(
    database.teams.getLoadoutArtifacts(loadoutDatum),
    (art) => art == null ? void 0 : art.id
  );
  const newArt = database.arts.get(newArtId);
  if (!newArt)
    return;
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(
      EquipBuildModal,
      {
        currentName: buildType === "real" ? database.builds.get(buildId).name : "Equipped",
        currentWeaponId: weapon == null ? void 0 : weapon.id,
        currentArtifactIds: artifactids,
        newWeaponId: weapon == null ? void 0 : weapon.id,
        newArtifactIds: objMap(
          artifactids,
          (art, slotKey) => slotKey === newArt.slotKey ? newArtId : art
        ),
        show,
        onEquip: () => {
          if (buildType === "equipped")
            database.arts.set(newArtId, {
              location: charKeyToLocCharKey(characterKey)
            });
          else if (buildType === "real")
            database.builds.set(buildId, (build) => {
              build.artifactIds[newArt.slotKey] = newArtId;
            });
        },
        onHide
      }
    ),
    /* @__PURE__ */ jsx(Tooltip$1, { title: /* @__PURE__ */ jsx(Typography, { children: "Equip" }), placement: "top", arrow: true, children: /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(
      Button,
      {
        color: "info",
        size: "small",
        onClick: onShow,
        disabled,
        children: /* @__PURE__ */ jsx(default_1$l, {})
      }
    ) }) })
  ] });
}
function UpgradeOptChartCardGraph({
  thresholds,
  objMin,
  objMax,
  upOptCalc,
  ix
}) {
  const upArt = upOptCalc.artifacts[ix];
  const database = useDatabase();
  const [, forceUpdate] = useForceUpdate();
  const equippedArt = database.arts.get(upArt.id);
  const updateUpOpt = reactExports.useCallback(() => {
    const art = database.arts.get(upArt.id);
    if (!art)
      return;
    upOptCalc.reCalc(ix, art);
    forceUpdate();
  }, [database, forceUpdate, ix, upOptCalc, upArt.id]);
  reactExports.useEffect(
    () => database.arts.follow(
      upArt.id,
      (_, reason) => reason === "update" && updateUpOpt()
    ),
    [database, updateUpOpt, upArt.id]
  );
  const constrained = thresholds.length > 1;
  const integral = (a2, b2) => upArt.result.distr.gmm.reduce((pv, { phi, mu, sig2 }) => {
    const sig = Math.sqrt(sig2);
    if (sig < 1e-3)
      return a2 <= mu && mu < b2 ? phi + pv : pv;
    const P2 = erf((mu - a2) / sig) - erf((mu - b2) / sig);
    return pv + phi * P2 / 2;
  }, 0);
  const integralCons = (a2, b2) => upArt.result.distr.gmm.reduce((pv, { cp, phi, mu, sig2 }) => {
    const sig = Math.sqrt(sig2);
    if (sig < 1e-3)
      return a2 <= mu && mu < b2 ? cp * phi + pv : pv;
    const P2 = erf((mu - a2) / sig) - erf((mu - b2) / sig);
    return pv + cp * phi * P2 / 2;
  }, 0);
  const thr0 = thresholds[0];
  const perc = reactExports.useCallback((x2) => 100 * (x2 - thr0) / thr0, [thr0]);
  const step = (objMax - objMin) / nbins;
  const dataHist = linspace(objMin, objMax, nbins, false).flatMap(
    (v2) => {
      return [
        {
          x: perc(v2),
          est: integral(v2, v2 + step),
          estCons: integralCons(v2, v2 + step)
        },
        {
          x: perc(v2 + step),
          est: integral(v2, v2 + step),
          estCons: integralCons(v2, v2 + step)
        }
      ];
    }
  );
  dataHist.unshift({ x: perc(objMin), est: 0, estCons: 0 });
  dataHist.push({ x: perc(objMax), est: 0, estCons: 0 });
  const ymax = dataHist.reduce((max2, { est }) => Math.max(max2, est), 0) || 1;
  const xpercent = (thr0 - objMin) / (objMax - objMin);
  const reportP = upArt.result.p;
  const reportD = upArt.result.upAvg;
  const chartData = dataHist;
  const isExact = upArt.result.evalMode === ResultType.Exact;
  reactExports.useEffect(() => {
    if (isExact)
      return;
    upOptCalc.calcExact(ix);
    forceUpdate();
  }, [upOptCalc, isExact, ix, forceUpdate]);
  const probUpgradeText = /* @__PURE__ */ jsxs("span", { children: [
    "Prob. upgrade",
    isExact ? "" : " (est.)",
    ":",
    " ",
    /* @__PURE__ */ jsxs("strong", { children: [
      (100 * reportP).toFixed(1),
      "%"
    ] })
  ] });
  const avgIncText = /* @__PURE__ */ jsxs("span", { children: [
    "Average increase",
    isExact ? "" : " (est.)",
    ":",
    " ",
    /* @__PURE__ */ jsxs("strong", { children: [
      reportD <= 0 ? "" : "+",
      (100 * reportD / thr0).toFixed(1),
      "%"
    ] })
  ] });
  const { data } = reactExports.useContext(DataContext);
  const currentlyEquippedArtId = (equippedArt == null ? void 0 : equippedArt.slotKey) && data.get(uiInput.art[equippedArt.slotKey].id).value;
  const isCurrentlyEquipped = currentlyEquippedArtId === upArt.id;
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", sx: { height: "100%" }, children: [
    /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", flexDirection: "row" }, children: [
      /* @__PURE__ */ jsx(Box, { sx: { height: 50, width: 50 }, children: !!(equippedArt == null ? void 0 : equippedArt.slotKey) && /* @__PURE__ */ jsx(EquippedArtifact, { slotKey: equippedArt.slotKey }) }),
      /* @__PURE__ */ jsxs(
        Box,
        {
          sx: {
            flexGrow: 1,
            display: "flex",
            flexDirection: "row",
            alignItems: "center",
            gap: 2,
            px: 2,
            py: 1
          },
          children: [
            /* @__PURE__ */ jsx(Box, { flexGrow: 1, children: isCurrentlyEquipped ? /* @__PURE__ */ jsx(SqBadge, { color: "secondary", children: "Equipped" }) : /* @__PURE__ */ jsx(Typography, { children: "Current on Build" }) }),
            /* @__PURE__ */ jsx(Typography, { children: probUpgradeText }),
            /* @__PURE__ */ jsx(Typography, { children: avgIncText })
          ]
        }
      )
    ] }),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(
      ResponsiveContainer,
      {
        width: "100%",
        height: "100%",
        maxHeight: 300,
        children: /* @__PURE__ */ jsxs(
          ComposedChart,
          {
            data: chartData,
            margin: { top: 5, right: 30, left: 20, bottom: 20 },
            children: [
              /* @__PURE__ */ jsx(
                XAxis,
                {
                  dataKey: "x",
                  type: "number",
                  domain: ["auto", "auto"],
                  allowDecimals: false,
                  tickFormatter: (v2) => `${v2 <= 0 ? "" : "+"}${v2}%`,
                  children: /* @__PURE__ */ jsx(
                    Label,
                    {
                      value: "Relative Increase to Target",
                      position: "insideBottom",
                      style: { fill: "#eaebed" },
                      offset: -10
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsx(
                YAxis,
                {
                  type: "number",
                  domain: [0, ymax],
                  tickFormatter: (v2) => `${(v2 * 100).toFixed()}%`,
                  children: /* @__PURE__ */ jsx(
                    Label,
                    {
                      value: "Probability",
                      position: "insideLeft",
                      angle: -90,
                      style: { fill: "#eaebed" }
                    }
                  )
                }
              ),
              /* @__PURE__ */ jsx(Legend, { verticalAlign: "top", height: 36 }),
              /* @__PURE__ */ jsx("defs", { children: /* @__PURE__ */ jsxs(
                "linearGradient",
                {
                  id: `splitOpacity${upArt.id}`,
                  x1: "0",
                  y1: "0",
                  x2: xpercent,
                  y2: "0",
                  children: [
                    /* @__PURE__ */ jsx(
                      "stop",
                      {
                        offset: 1,
                        stopColor: isExact ? "#f17704" : "orange",
                        stopOpacity: 0
                      }
                    ),
                    /* @__PURE__ */ jsx(
                      "stop",
                      {
                        offset: 0,
                        stopColor: isExact ? "#f17704" : "orange",
                        stopOpacity: 1
                      }
                    )
                  ]
                }
              ) }),
              /* @__PURE__ */ jsx(Line, { dataKey: "dne", stroke: "red", name: "Current Target Value" }),
              /* @__PURE__ */ jsx(Line, { dataKey: "dne", stroke: "rgba(0,200,0)", name: "Average Increase" }),
              constrained && /* @__PURE__ */ jsx(
                Area,
                {
                  type: "monotone",
                  dataKey: "est",
                  stroke: "grey",
                  dot: false,
                  fill: "grey",
                  legendType: "none",
                  tooltipType: "none",
                  opacity: 0.5,
                  activeDot: false
                }
              ),
              /* @__PURE__ */ jsx(
                Area,
                {
                  type: "monotone",
                  dataKey: "estCons",
                  stroke: isExact ? "#f17704" : "orange",
                  dot: false,
                  fill: `url(#splitOpacity${upArt.id})`,
                  opacity: 0.5,
                  name: isExact ? `Exact${constrained ? " Constrained" : ""} Distribution` : `Estimated Distribution`,
                  activeDot: false
                }
              ),
              /* @__PURE__ */ jsx(
                ReferenceLine,
                {
                  x: perc(thr0),
                  stroke: "red",
                  strokeDasharray: "3 3",
                  name: "Current Target"
                }
              ),
              /* @__PURE__ */ jsx(
                ReferenceLine,
                {
                  x: perc(thr0 + reportD),
                  stroke: "rgba(0,200,0,1)",
                  strokeDasharray: "3 3",
                  name: "Current Target"
                }
              )
            ]
          }
        )
      },
      upArt.id
    )
  ] });
}
function EquippedArtifact({ slotKey }) {
  const database = useDatabase();
  const { data } = reactExports.useContext(DataContext);
  const artifact = reactExports.useMemo(
    () => database.arts.get(data.get(uiInput.art[slotKey].id).value),
    [slotKey, data, database]
  );
  return /* @__PURE__ */ jsx(ArtifactCardPico, { slotKey, artifactObj: artifact });
}
function AddArtifactButton({ onClick }) {
  const { t: t2 } = useTranslation(["artifact", "ui"]);
  return /* @__PURE__ */ jsx(Button, { fullWidth: true, onClick, color: "info", startIcon: /* @__PURE__ */ jsx(default_1$i, {}), children: t2`addNew` });
}
function TabUpopt() {
  const { t: t2 } = useTranslation("page_character_optimize");
  const {
    teamId,
    teamCharId,
    teamChar: { optConfigId, key: characterKey },
    loadoutDatum
  } = reactExports.useContext(TeamCharacterContext);
  const database = useDatabase();
  const { gender } = useDBMeta();
  const [artifactIdToEdit, setArtifactIdToEdit] = reactExports.useState();
  const activeCharKey = database.teams.getActiveTeamChar(teamId).key;
  const noArtifact = reactExports.useMemo(() => !database.arts.values.length, [database]);
  const optConfig = useOptConfig(optConfigId);
  const { optimizationTarget, upOptLevelLow, upOptLevelHigh } = optConfig;
  const teamData = useTeamData();
  const { target: data } = (teamData == null ? void 0 : teamData[characterKey]) ?? {};
  const [artsDirty, setArtsDirty] = useForceUpdate();
  reactExports.useEffect(
    () => database.arts.followAny(
      (_, reason) => (reason === "new" || reason === "remove") && setArtsDirty()
    ),
    [setArtsDirty, database]
  );
  const filteredArts = reactExports.useMemo(() => {
    const {
      mainStatKeys,
      excludedLocations,
      artExclusion,
      upOptLevelLow: upOptLevelLow2,
      upOptLevelHigh: upOptLevelHigh2,
      useExcludedArts
    } = optConfig;
    return artsDirty && database.arts.values.filter((art) => {
      if (!useExcludedArts && artExclusion.includes(art.id))
        return false;
      if (art.level < upOptLevelLow2)
        return false;
      if (art.level > upOptLevelHigh2)
        return false;
      const mainStats = mainStatKeys[art.slotKey];
      if ((mainStats == null ? void 0 : mainStats.length) && !mainStats.includes(art.mainStatKey))
        return false;
      const locKey = charKeyToLocCharKey(characterKey);
      if (art.location && art.location !== locKey && excludedLocations.includes(art.location))
        return false;
      return true;
    });
  }, [optConfig, artsDirty, database, characterKey]);
  const filteredArtIdMap = reactExports.useMemo(
    () => objKeyMap(
      filteredArts.map(({ id }) => id),
      (_) => true
    ),
    [filteredArts]
  );
  const { levelTotal } = reactExports.useMemo(() => {
    const catKeys = {
      levelTotal: ["in"]
    };
    return bulkCatTotal(
      catKeys,
      (ctMap) => database.arts.entries.forEach(([id, art]) => {
        const { level } = art;
        const { upOptLevelLow: upOptLevelLow2, upOptLevelHigh: upOptLevelHigh2 } = optConfig;
        if (level >= upOptLevelLow2 && level <= upOptLevelHigh2) {
          ctMap["levelTotal"]["in"].total++;
          if (filteredArtIdMap[id])
            ctMap["levelTotal"]["in"].current++;
        }
      })
    );
  }, [database, optConfig, filteredArtIdMap]);
  const equippedArts = useBuildArtifacts(loadoutDatum);
  const upOptCalc = reactExports.useMemo(() => {
    var _a;
    const {
      statFilters,
      optimizationTarget: optimizationTarget2,
      mainStatKeys,
      upOptLevelLow: upOptLevelLow2,
      upOptLevelHigh: upOptLevelHigh2,
      artSetExclusion
    } = optConfig;
    if (!optimizationTarget2)
      return;
    const teamDataLocal = teamData && getTeamData(database, teamId, teamCharId, 0, []);
    if (!teamDataLocal)
      return;
    const workerData = (_a = uiDataForTeam(
      teamDataLocal.teamData,
      gender,
      activeCharKey
    )[characterKey]) == null ? void 0 : _a.target.data[0];
    if (!workerData)
      return;
    Object.assign(workerData, mergeData([workerData, dynamicData]));
    const optimizationTargetNode = objPathValue(
      workerData.display ?? {},
      optimizationTarget2
    );
    if (!optimizationTargetNode)
      return;
    const valueFilter = Object.entries(
      statFilters
    ).flatMap(
      ([pathStr, settings]) => settings.filter((setting) => !setting.disabled).map((setting) => {
        const filterNode = objPathValue(
          workerData.display ?? {},
          JSON.parse(pathStr)
        );
        const infoResolved = (filterNode == null ? void 0 : filterNode.info) && resolveInfo(filterNode.info);
        const minimum = (infoResolved == null ? void 0 : infoResolved.unit) === "%" ? setting.value / 100 : setting.value;
        return { value: filterNode, minimum };
      })
    );
    const curEquipSetKeys = objKeyMap(
      allArtifactSlotKeys,
      (slotKey) => {
        var _a2;
        return (_a2 = equippedArts[slotKey]) == null ? void 0 : _a2.setKey;
      }
    );
    function respectSexExclusion(art) {
      const newSK = { ...curEquipSetKeys };
      newSK[art.slotKey] = art.setKey;
      const skc = {};
      allArtifactSlotKeys.forEach((slotKey) => {
        const setKey = newSK[slotKey];
        if (!setKey)
          return;
        if (setKey.startsWith("Prayers"))
          return;
        skc[setKey] = (skc[setKey] ?? 0) + 1;
      });
      const pass = Object.entries(skc).every(([setKey, num]) => {
        const ex = artSetExclusion[setKey];
        if (!ex)
          return true;
        switch (num) {
          case 0:
          case 1:
            return true;
          case 2:
          case 3:
            return !ex.includes(2);
          case 4:
          case 5:
            return !ex.includes(4);
          default:
            throw Error("error in respectSetExclude: num > 5");
        }
      });
      if (!pass)
        return false;
      if (!artSetExclusion["rainbow"])
        return true;
      const nRainbow = Object.values(skc).reduce((a2, b2) => a2 + b2 % 2, 0);
      switch (nRainbow) {
        case 0:
        case 1:
          return true;
        case 2:
        case 3:
          return !artSetExclusion["rainbow"].includes(2);
        case 4:
        case 5:
          return !artSetExclusion["rainbow"].includes(4);
        default:
          throw Error("error in respectSex: nRainbow > 5");
      }
    }
    const artifactsToConsider = filteredArts.map((art) => database.arts.get(art.id)).filter(notEmpty).filter((art) => art.rarity === 5).filter(respectSexExclusion).filter(
      (art) => {
        var _a2, _b;
        return !((_a2 = mainStatKeys[art.slotKey]) == null ? void 0 : _a2.length) || ((_b = mainStatKeys[art.slotKey]) == null ? void 0 : _b.includes(art.mainStatKey));
      }
    ).filter(
      (art) => upOptLevelLow2 <= art.level && art.level <= upOptLevelHigh2
    );
    if (!artifactsToConsider.length)
      return;
    const nodes = optimize(
      [optimizationTargetNode, ...valueFilter.map((x2) => x2.value)],
      workerData,
      ({ path: [p2] }) => p2 !== "dyn"
    );
    return new UpOptCalculator(
      nodes,
      [-Infinity, ...valueFilter.map((x2) => x2.minimum)],
      equippedArts,
      artifactsToConsider
    );
  }, [
    optConfig,
    teamData,
    database,
    teamId,
    teamCharId,
    gender,
    activeCharKey,
    characterKey,
    filteredArts,
    equippedArts
  ]);
  const [pageIdex, setpageIdex] = reactExports.useState(0);
  reactExports.useEffect(() => {
    setpageIdex(0);
  }, [upOptCalc]);
  const artifactsToDisplayPerPage = 5;
  const { indexes, numPages, currentPageIndex, minObj0, maxObj0 } = reactExports.useMemo(() => {
    if (!upOptCalc)
      return {
        indexes: [],
        numPages: 0,
        currentPageIndex: 0,
        toShow: 0,
        minObj0: 0,
        maxObj0: 0
      };
    const numPages2 = Math.ceil(
      upOptCalc.artifacts.length / artifactsToDisplayPerPage
    );
    const currentPageIndex2 = clamp(pageIdex, 0, numPages2 - 1);
    const toShow = upOptCalc.artifacts.slice(
      currentPageIndex2 * artifactsToDisplayPerPage,
      (currentPageIndex2 + 1) * artifactsToDisplayPerPage
    );
    const thr = upOptCalc.thresholds[0];
    return {
      indexes: range$3(
        currentPageIndex2 * artifactsToDisplayPerPage,
        Math.min(
          (currentPageIndex2 + 1) * artifactsToDisplayPerPage - 1,
          upOptCalc.artifacts.length - 1
        )
      ),
      numPages: numPages2,
      currentPageIndex: currentPageIndex2,
      minObj0: toShow.reduce(
        (a2, b2) => Math.min(b2.result.distr.lower, a2),
        thr
      ),
      maxObj0: toShow.reduce(
        (a2, b2) => Math.max(b2.result.distr.upper, a2),
        thr
      )
    };
  }, [pageIdex, upOptCalc]);
  const setPage = reactExports.useCallback(
    (e3, value) => {
      if (!upOptCalc)
        return;
      const end = value * artifactsToDisplayPerPage;
      upOptCalc.calcSlowToIndex(end);
      setpageIdex(value - 1);
    },
    [upOptCalc]
  );
  const dataContext = reactExports.useMemo(() => {
    return data && teamData && { data, teamData };
  }, [data, teamData]);
  const pagination = numPages > 1 && /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsxs(Grid, { container: true, children: [
    /* @__PURE__ */ jsx(Grid, { item: true, flexGrow: 1, children: /* @__PURE__ */ jsx(
      Pagination$1,
      {
        count: numPages,
        page: currentPageIndex + 1,
        onChange: setPage
      }
    ) }),
    /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(
      ShowingArt,
      {
        numShowing: indexes.length,
        total: (upOptCalc == null ? void 0 : upOptCalc.artifacts.length) ?? 0
      }
    ) })
  ] }) }) });
  return /* @__PURE__ */ jsxs(Box, { display: "flex", flexDirection: "column", gap: 1, children: [
    noArtifact && /* @__PURE__ */ jsx(NoArtWarning, {}),
    dataContext && /* @__PURE__ */ jsx(DataContext.Provider, { value: dataContext, children: /* @__PURE__ */ jsxs(Stack$4, { spacing: 1, children: [
      /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, children: [
        /* @__PURE__ */ jsxs(
          Grid,
          {
            item: true,
            xs: 12,
            sm: 6,
            lg: 3,
            display: "flex",
            flexDirection: "column",
            gap: 1,
            children: [
              /* @__PURE__ */ jsx(OptCharacterCard, { characterKey }),
              /* @__PURE__ */ jsx(BonusStatsCard, {})
            ]
          }
        ),
        /* @__PURE__ */ jsxs(
          Grid,
          {
            item: true,
            xs: 12,
            sm: 6,
            lg: 4,
            display: "flex",
            flexDirection: "column",
            gap: 1,
            children: [
              /* @__PURE__ */ jsx(
                LevelFilter,
                {
                  levelTotal: levelTotal["in"],
                  upOptLevelLow,
                  upOptLevelHigh,
                  optConfigId
                }
              ),
              /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(
                MainStatSelectionCard,
                {
                  disabled: false,
                  filteredArtIdMap
                }
              ) })
            ]
          }
        ),
        /* @__PURE__ */ jsxs(
          Grid,
          {
            item: true,
            xs: 12,
            sm: 6,
            lg: 5,
            display: "flex",
            flexDirection: "column",
            gap: 1,
            children: [
              /* @__PURE__ */ jsx(ArtifactSetConfig, { disabled: false }),
              /* @__PURE__ */ jsx(
                AddArtifactButton,
                {
                  onClick: () => setArtifactIdToEdit("new")
                }
              ),
              /* @__PURE__ */ jsx(StatFilterCard, { disabled: false }),
              /* @__PURE__ */ jsx(AdResponsive, { bgt: "light", dataAdSlot: "3955015620" })
            ]
          }
        )
      ] }) }),
      /* @__PURE__ */ jsx(ButtonGroup, { children: /* @__PURE__ */ jsx(
        OptimizationTargetSelector,
        {
          optimizationTarget,
          setTarget: (target) => database.optConfigs.set(optConfigId, {
            optimizationTarget: target
          }),
          disabled: false,
          targetSelectorModalProps: {
            excludeSections: ["character", "bounsStats", "teamBuff"]
          }
        }
      ) }),
      /* @__PURE__ */ jsx(Alert, { severity: "info", children: /* @__PURE__ */ jsxs(Trans, { t: t2, i18nKey: "upOptInfo", children: [
        "The Artifact Upgrader identifies artifacts with high potential to boost the Optimization Target's value, guiding you to artifacts worth leveling up.",
        /* @__PURE__ */ jsx("br", {}),
        "As it only swaps one artifact at a time, for the best overall build across all artifacts, use the main artifact optimizer."
      ] }) }),
      Object.values(equippedArts).some((a2) => !a2) && /* @__PURE__ */ jsx(Alert, { severity: "warning", children: /* @__PURE__ */ jsx(Trans, { t: t2, i18nKey: "upOptEmptyBuild", children: "You're using a partially empty build. Since the Artifact Upgrader only swaps artifacts individually, completing a set is unlikely. It's recommended to begin with a base build, preferably generated from the main Optimizer." }) }),
      /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsxs(Grid, { container: true, spacing: 1, children: [
        /* @__PURE__ */ jsx(Grid, { item: true }),
        /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(HitModeToggle, { size: "small" }) }),
        /* @__PURE__ */ jsx(Grid, { item: true, children: /* @__PURE__ */ jsx(ReactionToggle, { size: "small" }) })
      ] }) }) }),
      pagination,
      noArtifact && /* @__PURE__ */ jsx(AddArtInfo, {}),
      /* @__PURE__ */ jsx(reactExports.Suspense, { fallback: false, children: /* @__PURE__ */ jsx(
        ArtifactEditor,
        {
          artifactIdToEdit,
          cancelEdit: () => setArtifactIdToEdit(void 0),
          allowUpload: true
        }
      ) }),
      !(upOptCalc == null ? void 0 : upOptCalc.artifacts.length) && /* @__PURE__ */ jsx(Alert, { severity: "warning", children: t2`upOptNoResults` }),
      /* @__PURE__ */ jsx(
        reactExports.Suspense,
        {
          fallback: /* @__PURE__ */ jsx(
            Skeleton,
            {
              variant: "rectangular",
              sx: { width: "100%", height: 600, minHeight: 5e3 }
            }
          ),
          children: !!upOptCalc && indexes.map(
            (i) => upOptCalc.artifacts[i] && /* @__PURE__ */ jsx(
              UpgradeOptChartCard,
              {
                upOptCalc,
                ix: i,
                setArtifactIdToEdit,
                thresholds: upOptCalc.thresholds ?? [],
                objMax: maxObj0,
                objMin: minObj0
              },
              `${i}+${upOptCalc.artifacts[i].id}`
            )
          )
        }
      ),
      pagination
    ] }) })
  ] });
}
function ShowingArt({
  numShowing,
  total
}) {
  return /* @__PURE__ */ jsx(Typography, { color: "text.secondary", children: /* @__PURE__ */ jsxs(Trans, { i18nKey: "showingNum", count: numShowing, value: total, children: [
    "Showing ",
    { count: numShowing },
    " out of ",
    { value: total },
    " Artifacts"
  ] }) });
}
function Content$1({ tab }) {
  const {
    loadoutDatum,
    teamChar: { key: characterKey }
  } = reactExports.useContext(TeamCharacterContext);
  const isTCBuild = !!(loadoutDatum.buildTcId && loadoutDatum.buildType === "tc");
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(FormulaModal, {}),
    /* @__PURE__ */ jsx(TabNav, { tab, characterKey, isTCBuild }),
    /* @__PURE__ */ jsx(CharacterPanel, { isTCBuild }),
    /* @__PURE__ */ jsx(
      TabNav,
      {
        tab,
        characterKey,
        isTCBuild,
        hideTitle: true
      }
    )
  ] });
}
function CharacterPanel({ isTCBuild }) {
  return /* @__PURE__ */ jsx(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 500 }),
      children: /* @__PURE__ */ jsxs(Routes, { children: [
        /* @__PURE__ */ jsx(Route, { path: "", index: true, element: /* @__PURE__ */ jsx(LoadoutSettingElement, {}) }),
        isTCBuild ? /* @__PURE__ */ jsx(Route, { path: "theorycraft", element: /* @__PURE__ */ jsx(TabTheorycraft, {}) }) : /* @__PURE__ */ jsx(Route, { path: "overview", element: /* @__PURE__ */ jsx(TabOverview, {}) }),
        /* @__PURE__ */ jsx(Route, { path: "talent", element: /* @__PURE__ */ jsx(CharacterTalentPane, {}) }),
        !isTCBuild && /* @__PURE__ */ jsx(Route, { path: "optimize", element: /* @__PURE__ */ jsx(TabBuild, {}) }),
        !isTCBuild && /* @__PURE__ */ jsx(Route, { path: "upopt", element: /* @__PURE__ */ jsx(TabUpopt, {}) }),
        /* @__PURE__ */ jsx(Route, { path: "*", element: /* @__PURE__ */ jsx(Navigate, { to: "", replace: true }) })
      ] })
    }
  );
}
function TabNav({
  tab,
  characterKey,
  isTCBuild,
  hideTitle = false
}) {
  const { teamChar, loadoutDatum, teamCharId } = reactExports.useContext(TeamCharacterContext);
  const database = useDatabase();
  const { t: t2 } = useTranslation("page_team");
  const { gender } = useDBMeta();
  const elementKey = getCharEle(characterKey);
  const banner = characterAsset(characterKey, "banner", gender);
  const [editMode, setEditMode] = reactExports.useState(false);
  const [, setloadoutName] = reactExports.useState(teamChar.name);
  const [, setloadoutDesc] = reactExports.useState(teamChar.description);
  const handleName = (loadoutName) => {
    setloadoutName(loadoutName);
    database.teamChars.set(teamCharId, { name: loadoutName });
  };
  const handleDesc = (loudoutDesc) => {
    setloadoutDesc(loudoutDesc);
    database.teamChars.set(teamCharId, { description: loudoutDesc });
  };
  return /* @__PURE__ */ jsxs(
    CardThemed,
    {
      sx: (theme) => {
        return {
          position: "relative",
          boxShadow: elementKey ? `0px 0px 0px 0.5px ${theme.palette[elementKey].main} inset` : void 0,
          "&::before": {
            content: '""',
            display: "block",
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            height: "100%",
            opacity: 0.4,
            backgroundImage: `url(${banner})`,
            backgroundPosition: "center",
            backgroundSize: "cover"
          }
        };
      },
      children: [
        !hideTitle && /* @__PURE__ */ jsxs(Fragment, { children: [
          /* @__PURE__ */ jsx(CardActionArea, { onClick: () => setEditMode(true), children: /* @__PURE__ */ jsx(
            BootstrapTooltip,
            {
              placement: "top",
              title: /* @__PURE__ */ jsxs(Box, { children: [
                /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", color: "info.light", gap: 1 }, children: [
                  /* @__PURE__ */ jsx(default_1$8, {}),
                  /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx("strong", { children: t2`loadout.editNameDesc` }) })
                ] }),
                !!teamChar.description && /* @__PURE__ */ jsx(Typography, { children: teamChar.description })
              ] }),
              children: /* @__PURE__ */ jsx(
                CardContent,
                {
                  sx: {
                    display: "flex",
                    justifyContent: "center",
                    position: "relative",
                    "&:hover": {
                      color: "info.light"
                    }
                  },
                  children: /* @__PURE__ */ jsxs(
                    Typography,
                    {
                      variant: "h6",
                      sx: {
                        display: "flex",
                        gap: 1,
                        alignItems: "center",
                        justifyContent: "center",
                        textShadow: "#000 0 0 10px !important"
                      },
                      children: [
                        /* @__PURE__ */ jsx(default_1$c, {}),
                        /* @__PURE__ */ jsx("strong", { children: teamChar.name }),
                        /* @__PURE__ */ jsx(Divider, { orientation: "vertical", variant: "middle", flexItem: true }),
                        /* @__PURE__ */ jsx(default_1$l, {}),
                        database.teams.getActiveBuildName(loadoutDatum)
                      ]
                    }
                  )
                }
              )
            }
          ) }),
          /* @__PURE__ */ jsx(ModalWrapper, { open: editMode, onClose: () => setEditMode(false), children: /* @__PURE__ */ jsxs(CardThemed, { children: [
            /* @__PURE__ */ jsx(
              CardHeader,
              {
                title: t2`loadout.editNameDesc`,
                avatar: /* @__PURE__ */ jsx(LoadoutIcon, {}),
                titleTypographyProps: { variant: "h6" },
                action: /* @__PURE__ */ jsx(IconButton, { onClick: () => setEditMode(false), children: /* @__PURE__ */ jsx(default_1$a, {}) })
              }
            ),
            /* @__PURE__ */ jsx(Divider, {}),
            /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsxs(
              Box,
              {
                display: "flex",
                flexDirection: "column",
                gap: 2,
                sx: { mt: 2 },
                children: [
                  /* @__PURE__ */ jsx(
                    TextFieldLazy,
                    {
                      label: t2`loadout.name`,
                      value: teamChar.name,
                      onChange: handleName,
                      autoFocus: true
                    }
                  ),
                  /* @__PURE__ */ jsx(
                    TextFieldLazy,
                    {
                      label: t2`loadout.desc`,
                      value: teamChar.description,
                      onChange: handleDesc,
                      multiline: true,
                      minRows: 4
                    }
                  )
                ]
              }
            ) })
          ] }) }),
          /* @__PURE__ */ jsx(Divider, {})
        ] }),
        /* @__PURE__ */ jsx(LoadoutTabs, { tab, isTCBuild, elementKey })
      ]
    }
  );
}
function LoadoutTabs({
  tab,
  elementKey,
  isTCBuild
}) {
  const { t: t2 } = useTranslation("page_character");
  const theme = useTheme();
  const isXs = useMediaQuery(theme.breakpoints.down("md"));
  return /* @__PURE__ */ jsxs(
    Tabs,
    {
      value: tab ?? "setting",
      variant: isXs ? "scrollable" : "fullWidth",
      allowScrollButtonsMobile: true,
      sx: (theme2) => {
        var _a;
        return {
          position: "relative",
          "& .MuiTab-root:hover": {
            transition: "background-color 0.25s ease",
            backgroundColor: "rgba(255,255,255,0.1)"
          },
          "& .MuiTab-root.Mui-selected": {
            color: "white !important"
          },
          "& .MuiTab-root": {
            textShadow: "#000 0 0 10px !important"
          },
          "& .MuiTabs-indicator": {
            backgroundColor: elementKey && ((_a = theme2.palette[elementKey]) == null ? void 0 : _a.main),
            height: "4px"
          }
        };
      },
      children: [
        /* @__PURE__ */ jsx(
          Tab,
          {
            value: "setting",
            label: t2("tabs.setting"),
            icon: /* @__PURE__ */ jsx(default_1$l, {}),
            component: Link$1,
            to: ""
          }
        ),
        isTCBuild ? /* @__PURE__ */ jsx(
          Tab,
          {
            value: "theorycraft",
            label: t2("tabs.theorycraft"),
            icon: /* @__PURE__ */ jsx(default_1$t, {}),
            component: Link$1,
            to: "theorycraft"
          }
        ) : /* @__PURE__ */ jsx(
          Tab,
          {
            value: "overview",
            label: t2("tabs.overview"),
            icon: /* @__PURE__ */ jsx(default_1$c, {}),
            component: Link$1,
            to: "overview"
          }
        ),
        /* @__PURE__ */ jsx(
          Tab,
          {
            value: "talent",
            label: t2("tabs.talent"),
            icon: /* @__PURE__ */ jsx(default_1$7, {}),
            component: Link$1,
            to: "talent"
          }
        ),
        !isTCBuild && /* @__PURE__ */ jsx(
          Tab,
          {
            value: "optimize",
            label: t2("tabs.optimize"),
            icon: /* @__PURE__ */ jsx(default_1$u, {}),
            component: Link$1,
            to: "optimize"
          }
        ),
        !isTCBuild && /* @__PURE__ */ jsx(
          Tab,
          {
            value: "upopt",
            label: t2("tabs.upopt"),
            icon: /* @__PURE__ */ jsx(default_1$6, {}),
            component: Link$1,
            to: "upopt"
          }
        )
      ]
    }
  );
}
function TeamCharacterSelector({
  teamId,
  characterKey,
  tab = ""
}) {
  const { t: t2 } = useTranslation("page_team");
  const navigate = useNavigate();
  const database = useDatabase();
  const { gender } = useDBMeta();
  const team = useTeam(teamId);
  const { loadoutData } = team;
  const elementArray = loadoutData.map(
    (loadoutDatum) => {
      if (!loadoutDatum)
        return;
      const teamChar = database.teamChars.get(loadoutDatum.teamCharId);
      if (!teamChar)
        return;
      return getCharEle(teamChar.key);
    }
  );
  const selectedIndex = loadoutData.findIndex(
    (loadoutDatum) => {
      var _a;
      return loadoutDatum && ((_a = database.teamChars.get(loadoutDatum == null ? void 0 : loadoutDatum.teamCharId)) == null ? void 0 : _a.key) === characterKey;
    }
  );
  const selectedEle = elementArray[selectedIndex];
  const theme = useTheme();
  const isXs = useMediaQuery(theme.breakpoints.down("md"));
  const [editMode, setEditMode] = reactExports.useState(false);
  const handleName = (teamName) => {
    database.teams.set(teamId, { name: teamName });
  };
  const handleDesc = (teamDesc) => {
    database.teams.set(teamId, { description: teamDesc });
  };
  return /* @__PURE__ */ jsxs(
    Box,
    {
      sx: (theme2) => {
        var _a;
        const backrgba = colorToRgbaString(
          hexToColor(theme2.palette["contentLight"].main),
          !characterKey ? 1 : 0.5
        );
        const rgbas = [
          // color for team setting
          ...isXs ? [backrgba, backrgba] : [backrgba],
          ...elementArray.map((ele, i) => {
            if (!ele)
              return `rgba(0,0,0,0)`;
            const hex2 = theme2.palette[ele].main;
            const color2 = hexToColor(hex2);
            if (!color2)
              return `rgba(0,0,0,0)`;
            return colorToRgbaString(color2, selectedIndex === i ? 0.5 : 0.15);
          })
        ];
        const selectedRgb = selectedEle && hexToColor(theme2.palette[selectedEle].main);
        const rgba2 = selectedRgb && colorToRgbaString(selectedRgb, 0.3);
        return {
          // will be in the form of `linear-gradient(to right, red xx%, orange xx%, yellow xx%, green xx%)`
          background: `linear-gradient(to ${isXs ? "bottom" : "right"}, ${rgbas.map(
            (rgba22, i, arr) => `${rgba22} ${i * (100 / arr.length) + 50 / arr.length}%`
          ).join(", ")})`,
          borderBottom: `1px ${rgba2 ?? "rgb(200,200,200,0.3)"} solid`,
          "& .MuiTab-root:hover": {
            transition: "background-color 0.25s ease",
            backgroundColor: "rgba(255,255,255,0.1)"
          },
          "& .Mui-selected": {
            color: "white !important"
          },
          "& .MuiTabs-indicator": {
            height: "4px",
            backgroundColor: (selectedEle && ((_a = theme2.palette[selectedEle]) == null ? void 0 : _a.main)) ?? "rgb(200,200,200,0.5)"
            //team settings
          }
        };
      },
      children: [
        /* @__PURE__ */ jsx(CardActionArea, { onClick: () => setEditMode(true), children: /* @__PURE__ */ jsx(
          BootstrapTooltip,
          {
            placement: "top",
            title: /* @__PURE__ */ jsxs(Box, { children: [
              /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", color: "info.light", gap: 1 }, children: [
                /* @__PURE__ */ jsx(default_1$8, {}),
                /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx("strong", { children: t2`team.editNameDesc` }) })
              ] }),
              !!team.description && /* @__PURE__ */ jsx(Typography, { children: team.description })
            ] }),
            children: /* @__PURE__ */ jsx(
              CardContent,
              {
                sx: {
                  display: "flex",
                  justifyContent: "center",
                  "&:hover": {
                    color: "info.light"
                  }
                },
                children: /* @__PURE__ */ jsxs(
                  Typography,
                  {
                    variant: "h5",
                    sx: {
                      display: "flex",
                      gap: 1,
                      alignItems: "center",
                      justifyContent: "center",
                      textShadow: "#000 0 0 10px !important"
                    },
                    children: [
                      /* @__PURE__ */ jsx(TeamIcon, {}),
                      team.name
                    ]
                  }
                )
              }
            )
          }
        ) }),
        /* @__PURE__ */ jsx(ModalWrapper, { open: editMode, onClose: () => setEditMode(false), children: /* @__PURE__ */ jsxs(CardThemed, { children: [
          /* @__PURE__ */ jsx(
            CardHeader,
            {
              title: t2`team.editNameDesc`,
              avatar: /* @__PURE__ */ jsx(TeamIcon, {}),
              titleTypographyProps: { variant: "h6" },
              action: /* @__PURE__ */ jsx(IconButton, { onClick: () => setEditMode(false), children: /* @__PURE__ */ jsx(default_1$a, {}) })
            }
          ),
          /* @__PURE__ */ jsx(Divider, {}),
          /* @__PURE__ */ jsx(CardContent, { children: /* @__PURE__ */ jsxs(Box, { display: "flex", flexDirection: "column", gap: 2, sx: { mt: 2 }, children: [
            /* @__PURE__ */ jsx(
              TextFieldLazy,
              {
                label: t2`team.name`,
                value: team.name,
                onChange: (teamName) => handleName(teamName),
                autoFocus: true
              }
            ),
            /* @__PURE__ */ jsx(
              TextFieldLazy,
              {
                label: t2`team.desc`,
                value: team.description,
                onChange: (teamDesc) => handleDesc(teamDesc),
                multiline: true,
                minRows: 4
              }
            )
          ] }) })
        ] }) }),
        /* @__PURE__ */ jsx(Divider, {}),
        /* @__PURE__ */ jsxs(
          Tabs,
          {
            variant: "fullWidth",
            value: characterKey ?? "team",
            orientation: isXs ? "vertical" : "horizontal",
            children: [
              /* @__PURE__ */ jsx(
                Tab,
                {
                  icon: /* @__PURE__ */ jsx(default_1$v, {}),
                  iconPosition: "start",
                  value: "team",
                  label: "Team Settings",
                  onClick: () => navigate(`/teams/${teamId}/`)
                }
              ),
              loadoutData.map((loadoutDatum, ind) => {
                var _a;
                const teamCharKey = loadoutDatum && ((_a = database.teamChars.get(loadoutDatum == null ? void 0 : loadoutDatum.teamCharId)) == null ? void 0 : _a.key);
                return /* @__PURE__ */ jsx(
                  Tab,
                  {
                    icon: teamCharKey ? /* @__PURE__ */ jsx(CharIconSide, { characterKey: teamCharKey, sideMargin: true }) : /* @__PURE__ */ jsx(default_1$c, {}),
                    iconPosition: "start",
                    value: teamCharKey ?? ind,
                    disabled: !loadoutData[ind],
                    label: teamCharKey ? /* @__PURE__ */ jsx(CharacterName, { characterKey: teamCharKey, gender }) : `Character ${ind + 1}`,
                    onClick: () => (
                      // conserve the current tab when switching to another character
                      teamCharKey && navigate(`/teams/${teamId}/${teamCharKey}/${tab}`)
                    )
                  },
                  ind
                );
              })
            ]
          }
        )
      ]
    }
  );
}
function BuildDropdown({
  teamId,
  loadoutDatum,
  dropdownBtnProps = {}
}) {
  const database = useDatabase();
  const { teamCharId, buildType, buildId, buildTcId } = loadoutDatum;
  const teamChar = database.teamChars.get(teamCharId);
  const { buildIds, buildTcIds } = teamChar;
  const onChangeLoadoutDatum = (l2) => database.teams.setLoadoutDatum(teamId, teamCharId, l2);
  return /* @__PURE__ */ jsxs(
    DropdownButton,
    {
      startIcon: /* @__PURE__ */ jsx(default_1$l, {}),
      title: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, flexWrap: "wrap" }, children: [
        /* @__PURE__ */ jsx("span", { children: database.teams.getActiveBuildName(loadoutDatum) }),
        buildType === "tc" && /* @__PURE__ */ jsx(SqBadge, { color: "success", children: "TC" })
      ] }),
      ...dropdownBtnProps,
      children: [
        /* @__PURE__ */ jsx(
          MenuItem,
          {
            disabled: buildType === "equipped",
            onClick: () => onChangeLoadoutDatum({ buildType: "equipped" }),
            sx: { display: "flex", gap: 1 },
            children: "Equipped Build"
          }
        ),
        buildIds.map((bId) => {
          const { name } = database.builds.get(bId);
          return /* @__PURE__ */ jsx(
            MenuItem,
            {
              disabled: buildType === "real" && bId === buildId,
              onClick: () => onChangeLoadoutDatum({ buildType: "real", buildId: bId }),
              sx: { display: "flex", gap: 1 },
              children: name
            },
            bId
          );
        }),
        buildTcIds.map((btcId) => {
          const { name } = database.buildTcs.get(btcId);
          return /* @__PURE__ */ jsxs(
            MenuItem,
            {
              disabled: buildType === "tc" && btcId === buildTcId,
              onClick: () => onChangeLoadoutDatum({ buildType: "tc", buildTcId: btcId }),
              sx: { display: "flex", gap: 1 },
              children: [
                /* @__PURE__ */ jsx("span", { children: name }),
                /* @__PURE__ */ jsx(SqBadge, { color: "success", children: "TC" })
              ]
            },
            btcId
          );
        })
      ]
    }
  );
}
function ResonanceDisplay({
  teamId,
  team,
  dataContextValue
}) {
  const { t: t2 } = useTranslation("page_character");
  const { loadoutData } = useTeam(teamId);
  const teamCount = loadoutData.reduce((a2, t22) => a2 + (t22 ? 1 : 0), 0);
  const teamCharContextObj = reactExports.useMemo(
    () => ({
      teamId,
      team,
      teamCharId: "",
      // can be left blank since its only modifying team conditional
      teamChar: {}
    }),
    [team, teamId]
  );
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: /* @__PURE__ */ jsxs("span", { children: [
          t2("tabTeambuff.team_reso"),
          " ",
          /* @__PURE__ */ jsx("strong", { children: /* @__PURE__ */ jsxs(ColorText, { color: teamCount >= 4 ? "success" : "warning", children: [
            "(",
            teamCount,
            "/4)"
          ] }) }),
          " ",
          /* @__PURE__ */ jsx(
            InfoTooltipInline,
            {
              title: /* @__PURE__ */ jsx(Typography, { children: t2`tabTeambuff.resonance_tip` })
            }
          )
        ] }),
        titleTypographyProps: { variant: "h6" }
      }
    ),
    dataContextValue && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsx(Divider, {}),
      /* @__PURE__ */ jsx(
        CardContent,
        {
          sx: { display: "flex", flexDirection: "column", gap: 1 },
          children: /* @__PURE__ */ jsx(DataContext.Provider, { value: dataContextValue, children: /* @__PURE__ */ jsx(TeamCharacterContext.Provider, { value: teamCharContextObj, children: /* @__PURE__ */ jsx(Content, {}) }) })
        }
      )
    ] })
  ] });
}
function Content() {
  const { data } = reactExports.useContext(DataContext);
  const hasReso = resonanceSheets.some((res) => res.canShow(data));
  return /* @__PURE__ */ jsx(Fragment, { children: resonanceSheets.map((res, i) => {
    const show = res.canShow(data);
    if (!show && hasReso)
      return null;
    return /* @__PURE__ */ jsxs(CardThemed, { sx: { opacity: show ? 1 : 0.5 }, children: [
      /* @__PURE__ */ jsx(
        CardHeader,
        {
          title: /* @__PURE__ */ jsxs("span", { children: [
            res.name,
            " ",
            /* @__PURE__ */ jsx(
              InfoTooltipInline,
              {
                title: /* @__PURE__ */ jsx(Typography, { children: res.desc })
              }
            )
          ] }),
          action: res.icon,
          titleTypographyProps: { variant: "subtitle2" }
        }
      ),
      res.canShow(data) && /* @__PURE__ */ jsx(Divider, {}),
      res.canShow(data) && /* @__PURE__ */ jsx(DocumentDisplay, { sections: res.sections, teamBuffOnly: true, hideDesc: true })
    ] }, i);
  }) });
}
function TeamBuffDisplay() {
  const { data } = reactExports.useContext(DataContext);
  const nodes = reactExports.useMemo(() => {
    const teamBuffs = data.getTeamBuff();
    const nodes2 = [
      ...Object.values(teamBuffs.total ?? {}),
      ...Object.values(teamBuffs.premod ?? {}),
      ...Object.values(teamBuffs.enemy ?? {})
    ];
    return nodes2.filter((node) => !node.isEmpty && node.value !== 0);
  }, [data]);
  if (!nodes.length)
    return null;
  return /* @__PURE__ */ jsxs(
    Accordion$1,
    {
      sx: (theme) => ({
        bgcolor: theme.palette.contentLight.main,
        borderRadius: "4px",
        "&:before": {
          display: "none"
        }
      }),
      disableGutters: true,
      children: [
        /* @__PURE__ */ jsx(AccordionSummary$1, { expandIcon: /* @__PURE__ */ jsx(default_1$b, {}), children: /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", alignItems: "center" }, children: [
          /* @__PURE__ */ jsx(Typography, { children: "Received Team Buffs" }),
          /* @__PURE__ */ jsx(SqBadge, { sx: { ml: 1 }, color: nodes.length ? "success" : "info", children: nodes.length })
        ] }) }),
        /* @__PURE__ */ jsxs(AccordionDetails$1, { sx: { p: 0 }, children: [
          /* @__PURE__ */ jsx(Divider, {}),
          /* @__PURE__ */ jsx(FieldDisplayList, { bgt: "light", children: nodes.map((n2) => /* @__PURE__ */ jsx(NodeFieldDisplay, { calcRes: n2 }, JSON.stringify(n2.info))) })
        ] })
      ]
    }
  );
}
function TeammateDisplay({
  teamCharId,
  dataContextValue,
  teamId
}) {
  var _a;
  const database = useDatabase();
  const { teamData } = dataContextValue;
  const team = useTeam(teamId);
  const teamChar = useTeamChar(teamCharId);
  const loadoutDatum = database.teams.getLoadoutDatum(teamId, teamCharId);
  const teamMateKey = teamChar == null ? void 0 : teamChar.key;
  const character = useCharacter(teamMateKey);
  const { key: characterKey } = character;
  const dataBundle = teamData[teamMateKey];
  const teammateCharacterContext = reactExports.useMemo(
    () => dataBundle && {
      teamId,
      team,
      teamCharId,
      teamChar,
      loadoutDatum
    },
    [teamId, team, teamCharId, teamChar, dataBundle, loadoutDatum]
  );
  const characterContext = reactExports.useMemo(
    () => ({
      character
    }),
    [character]
  );
  const teamMateDataContext = reactExports.useMemo(
    () => dataBundle && {
      data: dataBundle.target,
      teamData
    },
    [dataBundle, teamData]
  );
  if (!teamMateKey || !teammateCharacterContext || !teamMateDataContext || !characterContext)
    return null;
  const isTCCharOverride = loadoutDatum.buildType === "tc" && !!((_a = database.buildTcs.get(loadoutDatum.buildTcId)) == null ? void 0 : _a.character);
  return /* @__PURE__ */ jsx(TeamCharacterContext.Provider, { value: teammateCharacterContext, children: /* @__PURE__ */ jsx(DataContext.Provider, { value: teamMateDataContext, children: /* @__PURE__ */ jsx(CharacterContext.Provider, { value: characterContext, children: /* @__PURE__ */ jsxs(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 600 }),
      children: [
        /* @__PURE__ */ jsx(CardThemed, { bgt: "light", children: /* @__PURE__ */ jsx(
          CardActionArea,
          {
            component: Link$1,
            to: `${characterKey}`,
            onClick: () => window.scrollTo({ top: 0, behavior: "smooth" }),
            children: /* @__PURE__ */ jsx(CharacterCardHeader, { characterKey, children: /* @__PURE__ */ jsx(
              CharacterCardHeaderContent,
              {
                characterKey,
                tcOverride: isTCCharOverride
              }
            ) })
          }
        ) }),
        /* @__PURE__ */ jsx(EquipmentRow, { loadoutDatum }),
        /* @__PURE__ */ jsx(CharacterCardWeaponFull, { loadoutDatum }),
        /* @__PURE__ */ jsx(TeamBuffDisplay, {}),
        /* @__PURE__ */ jsx(CharArtifactCondDisplay, {}),
        /* @__PURE__ */ jsx(CharWeaponCondDisplay, {}),
        /* @__PURE__ */ jsx(CharTalentCondDisplay, {})
      ]
    }
  ) }) }) });
}
function EquipmentRow({
  loadoutDatum,
  loadoutDatum: { buildType }
}) {
  if (buildType !== "tc")
    return /* @__PURE__ */ jsx(CharacterCardEquipmentRow, { hideWeapon: true });
  else
    return /* @__PURE__ */ jsx(TcEquipmentRow, { loadoutDatum });
}
function TcEquipmentRow({
  loadoutDatum: { buildTcId }
}) {
  const {
    artifact: { sets }
  } = useBuildTc(buildTcId);
  return /* @__PURE__ */ jsx(CardThemed, { bgt: "light", sx: { flexGrow: 1 }, children: /* @__PURE__ */ jsxs(
    Box,
    {
      sx: {
        p: 1,
        display: "flex",
        flexDirection: "column",
        gap: 1
      },
      children: [
        /* @__PURE__ */ jsx(SqBadge, { color: "info", children: "TC Build" }),
        Object.entries(sets).map(([setKey, number2]) => /* @__PURE__ */ jsxs(
          Box,
          {
            sx: { display: "flex", alignItems: "center", gap: 1 },
            children: [
              /* @__PURE__ */ jsx(ImgIcon, { size: 2, src: artifactAsset(setKey, "flower") }),
              /* @__PURE__ */ jsx("span", { children: /* @__PURE__ */ jsx(ArtifactSetName, { setKey }) }),
              /* @__PURE__ */ jsxs(SqBadge, { children: [
                "x",
                number2
              ] })
            ]
          },
          setKey
        ))
      ]
    }
  ) });
}
function CharacterCardWeaponFull({
  loadoutDatum
}) {
  const { data } = reactExports.useContext(DataContext);
  const database = useDatabase();
  const weapon = reactExports.useMemo(() => {
    var _a;
    const weaponId = ((_a = data.get(input.weapon.id).value) == null ? void 0 : _a.toString()) ?? "invalid";
    if (weaponId && weaponId !== "invalid")
      return database.weapons.get(weaponId);
    else
      return database.teams.getLoadoutWeapon(loadoutDatum);
  }, [database, data, loadoutDatum]);
  if (!weapon)
    return null;
  return /* @__PURE__ */ jsx(WeaponFullCardObj, { weapon, bgt: "light" });
}
function CharArtifactCondDisplay() {
  const { data } = reactExports.useContext(DataContext);
  const sections = reactExports.useMemo(
    () => Object.entries(dataSetEffects(data)).flatMap(
      ([setKey, setNums]) => setNums.flatMap((sn) => getArtSheet(setKey).setEffectDocument(sn) ?? [])
    ),
    [data]
  );
  if (!sections)
    return null;
  return /* @__PURE__ */ jsx(DocumentDisplay, { bgt: "light", sections, teamBuffOnly: true });
}
function CharWeaponCondDisplay() {
  const {
    character: { key: charKey }
  } = reactExports.useContext(CharacterContext);
  const { teamData } = reactExports.useContext(DataContext);
  const weaponSheet = teamData[charKey].weaponSheet;
  if (!weaponSheet.document)
    return null;
  return /* @__PURE__ */ jsx(
    DocumentDisplay,
    {
      bgt: "light",
      sections: weaponSheet.document,
      teamBuffOnly: true
    }
  );
}
function CharTalentCondDisplay() {
  const {
    character: { key: charKey }
  } = reactExports.useContext(CharacterContext);
  const { teamData } = reactExports.useContext(DataContext);
  const characterSheet = teamData[charKey].characterSheet;
  const sections = Object.values(characterSheet.talent).flatMap(
    (sts) => sts.sections
  );
  if (!sections)
    return null;
  return /* @__PURE__ */ jsx(DocumentDisplay, { bgt: "light", sections, teamBuffOnly: true });
}
function TeamExportModal({
  show,
  onHide,
  teamId
}) {
  const database = useDatabase();
  const team = useTeam(teamId);
  const { loadoutData } = team;
  const enforceOptTargetMtarget = (loadoutDatum, setting) => {
    const teamChar = database.teamChars.get(loadoutDatum.teamCharId);
    const optConfig = database.optConfigs.get(teamChar.optConfigId);
    const { optimizationTarget } = optConfig;
    if (!optimizationTarget)
      return setting;
    if (optimizationTarget[0] !== "custom")
      return setting;
    const ind = parseInt(optimizationTarget[1]);
    if (isNaN(ind))
      return setting;
    if (setting.exportCustomMultiTarget.includes(ind))
      return setting;
    setting.exportCustomMultiTarget.push(ind);
    return setting;
  };
  const [loadoutDataExportSetting, setLoadoutDataExportSetting] = reactExports.useState(
    () => loadoutData.map(
      (loadoutDatum) => loadoutDatum ? enforceOptTargetMtarget(loadoutDatum, defLoadoutExportSetting()) : defLoadoutExportSetting()
    )
  );
  const onExport = () => {
    const data = database.teams.export(teamId, loadoutDataExportSetting);
    const dataStr = JSON.stringify(data);
    navigator.clipboard.writeText(dataStr).then(() => alert("Copied team data to clipboard.")).catch(console.error);
  };
  const [selAll, setSelAll] = reactExports.useState(true);
  const onUnselAll = () => {
    setSelAll(true);
    setLoadoutDataExportSetting(
      loadoutData.map(
        (loadoutDatum) => loadoutDatum ? enforceOptTargetMtarget(loadoutDatum, defLoadoutExportSetting()) : defLoadoutExportSetting()
      )
    );
  };
  const onSelAll = () => {
    setSelAll(false);
    setLoadoutDataExportSetting(
      loadoutData.map((loadoutDatum) => {
        if (!loadoutDatum)
          return defLoadoutExportSetting();
        const loadout = database.teamChars.get(loadoutDatum.teamCharId);
        if (!loadout)
          return defLoadoutExportSetting();
        const { buildIds, buildTcIds, customMultiTargets } = loadout;
        return enforceOptTargetMtarget(loadoutDatum, {
          convertEquipped: true,
          convertbuilds: buildIds,
          convertTcBuilds: buildTcIds,
          exportCustomMultiTarget: (customMultiTargets == null ? void 0 : customMultiTargets.map((_, i) => i)) ?? []
        });
      })
    );
  };
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down("md"));
  return /* @__PURE__ */ jsx(ModalWrapper, { open: show, onClose: onHide, children: /* @__PURE__ */ jsxs(CardThemed, { children: [
    /* @__PURE__ */ jsx(
      CardHeader,
      {
        title: "Team Export",
        action: /* @__PURE__ */ jsx(IconButton, { onClick: onHide, children: /* @__PURE__ */ jsx(default_1$a, {}) })
      }
    ),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", flexDirection: "column", gap: 1 }, children: [
      /* @__PURE__ */ jsxs(
        Box,
        {
          sx: {
            display: "flex",
            gap: 1,
            flexDirection: isMobile ? "column" : "row"
          },
          children: [
            /* @__PURE__ */ jsx(Alert, { severity: "info", children: "Export the team data to be imported by another user. All the team and loadout data (bonus stats, enemy config, optimize config) are exported. All exported non-TC builds are converted to TC builds." }),
            /* @__PURE__ */ jsx(Button, { color: "info", onClick: selAll ? onSelAll : onUnselAll, children: selAll ? "Select All" : "Unselect All" })
          ]
        }
      ),
      /* @__PURE__ */ jsx(Grid, { container: true, columns: { xs: 1, sm: 2, md: 4 }, spacing: 1, children: loadoutData.map(
        (loadout, i) => !!loadout && /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
          LoadoutSetting,
          {
            loadout,
            setting: loadoutDataExportSetting[i],
            setSetting: (loadoutExportSetting) => setLoadoutDataExportSetting((settings) => {
              const data = structuredClone(settings);
              data[i] = {
                ...data[i],
                ...loadoutExportSetting
              };
              return data;
            })
          }
        ) }, i)
      ) })
    ] }),
    /* @__PURE__ */ jsx(Divider, {}),
    /* @__PURE__ */ jsx(
      CardContent,
      {
        sx: { display: "flex", gap: 2, justifyContent: "flex-end" },
        children: /* @__PURE__ */ jsx(Button, { color: "success", onClick: onExport, children: "Export" })
      }
    )
  ] }) });
}
function LoadoutSetting({
  loadout,
  setting,
  setSetting
}) {
  const database = useDatabase();
  const teamChar = useTeamChar(loadout.teamCharId);
  const {
    key: characterKey,
    name,
    description,
    buildIds,
    buildTcIds,
    customMultiTargets
  } = teamChar;
  const optConfig = useOptConfig(teamChar.optConfigId);
  const { optimizationTarget } = optConfig;
  const selMtargetInd = optimizationTarget && optimizationTarget[0] === "custom" ? parseInt(optimizationTarget[1]) : -1;
  const teamData = useCharData(characterKey);
  const { target: charUIData } = (teamData == null ? void 0 : teamData[characterKey]) ?? {};
  const dataContextValue = reactExports.useMemo(() => {
    if (!teamData || !charUIData)
      return void 0;
    return {
      data: charUIData,
      teamData,
      compareData: void 0
    };
  }, [charUIData, teamData]);
  return /* @__PURE__ */ jsxs(CardThemed, { bgt: "light", children: [
    /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: [
      /* @__PURE__ */ jsx(CharIconSide, { characterKey }),
      /* @__PURE__ */ jsx(Typography, { children: name }),
      !!description && /* @__PURE__ */ jsx(BootstrapTooltip, { title: description, children: /* @__PURE__ */ jsx(default_1$s, {}) })
    ] }),
    /* @__PURE__ */ jsx(Divider, {}),
    dataContextValue && /* @__PURE__ */ jsx(DataContext.Provider, { value: dataContextValue, children: optimizationTarget && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs(CardContent, { children: [
        /* @__PURE__ */ jsxs(
          Typography,
          {
            sx: { display: "flex", gap: 1, alignItems: "center" },
            children: [
              /* @__PURE__ */ jsx(OptimizationIcon, {}),
              /* @__PURE__ */ jsx(Box, { children: "Optimization Target:" })
            ]
          }
        ),
        /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx(
          OptimizationTargetDisplay$1,
          {
            customMultiTargets,
            optimizationTarget
          }
        ) })
      ] }),
      /* @__PURE__ */ jsx(Divider, {})
    ] }) }),
    !!customMultiTargets.length && /* @__PURE__ */ jsxs(Fragment, { children: [
      /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: [
        /* @__PURE__ */ jsx(CustomMultiTargetIcon, {}),
        /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx("strong", { children: "Mtargets to Export" }) })
      ] }),
      /* @__PURE__ */ jsx(FieldDisplayList, { bgt: "light", children: customMultiTargets.map((mtarget, i) => {
        const { name: name2, description: description2 } = mtarget;
        return /* @__PURE__ */ jsx(
          ListItem,
          {
            sx: {
              p: 0,
              border: selMtargetInd === i ? "2px solid green" : void 0
            },
            children: /* @__PURE__ */ jsxs(
              ListItemButton$1,
              {
                disabled: selMtargetInd === i,
                onClick: () => setSetting({
                  exportCustomMultiTarget: toggleInArr(
                    setting.exportCustomMultiTarget,
                    i
                  )
                }),
                children: [
                  /* @__PURE__ */ jsx(
                    Checkbox,
                    {
                      edge: "start",
                      checked: setting.exportCustomMultiTarget.includes(i),
                      tabIndex: -1,
                      disableRipple: true
                    }
                  ),
                  /* @__PURE__ */ jsx(ListItemText, { primary: name2 }),
                  !!description2 && /* @__PURE__ */ jsx(BootstrapTooltip, { title: description2, children: /* @__PURE__ */ jsx(default_1$s, {}) })
                ]
              }
            )
          },
          i
        );
      }) }),
      /* @__PURE__ */ jsx(Divider, {})
    ] }),
    /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", alignItems: "center", gap: 1 }, children: [
      /* @__PURE__ */ jsx(BuildIcon, {}),
      /* @__PURE__ */ jsx(Typography, { children: /* @__PURE__ */ jsx("strong", { children: "Builds to Export" }) })
    ] }),
    /* @__PURE__ */ jsxs(FieldDisplayList, { bgt: "light", children: [
      /* @__PURE__ */ jsx(ListItem, { sx: { p: 0 }, children: /* @__PURE__ */ jsxs(
        ListItemButton$1,
        {
          onClick: () => setSetting({ convertEquipped: !setting.convertEquipped }),
          children: [
            /* @__PURE__ */ jsx(
              Checkbox,
              {
                edge: "start",
                checked: setting.convertEquipped,
                tabIndex: -1,
                disableRipple: true
              }
            ),
            /* @__PURE__ */ jsx(ListItemText, { primary: `Equipped Build` })
          ]
        }
      ) }),
      buildIds.map((buildId) => {
        const build = database.builds.get(buildId);
        return /* @__PURE__ */ jsx(ListItem, { sx: { p: 0 }, children: /* @__PURE__ */ jsxs(
          ListItemButton$1,
          {
            onClick: () => setSetting({
              convertbuilds: toggleInArr(setting.convertbuilds, buildId)
            }),
            children: [
              /* @__PURE__ */ jsx(
                Checkbox,
                {
                  edge: "start",
                  checked: setting.convertbuilds.includes(buildId),
                  tabIndex: -1,
                  disableRipple: true
                }
              ),
              /* @__PURE__ */ jsx(ListItemText, { primary: build.name }),
              !!build.description && /* @__PURE__ */ jsx(BootstrapTooltip, { title: build.description, children: /* @__PURE__ */ jsx(default_1$s, {}) })
            ]
          }
        ) }, buildId);
      }),
      buildTcIds.map((buildTcId) => {
        const buildTc = database.buildTcs.get(buildTcId);
        return /* @__PURE__ */ jsx(ListItem, { sx: { p: 0 }, children: /* @__PURE__ */ jsxs(
          ListItemButton$1,
          {
            onClick: () => setSetting({
              convertTcBuilds: toggleInArr(
                setting.convertTcBuilds,
                buildTcId
              )
            }),
            children: [
              /* @__PURE__ */ jsx(
                Checkbox,
                {
                  edge: "start",
                  checked: setting.convertTcBuilds.includes(buildTcId),
                  tabIndex: -1,
                  disableRipple: true
                }
              ),
              /* @__PURE__ */ jsx(
                ListItemText,
                {
                  primary: /* @__PURE__ */ jsxs(Box, { children: [
                    buildTc.name,
                    " ",
                    /* @__PURE__ */ jsx(SqBadge, { children: "TC Build" })
                  ] })
                }
              ),
              !!buildTc.description && /* @__PURE__ */ jsx(BootstrapTooltip, { title: buildTc.description, children: /* @__PURE__ */ jsx(default_1$s, {}) })
            ]
          }
        ) }, buildTcId);
      })
    ] })
  ] });
}
function TeamSetting({
  teamId,
  teamData
}) {
  const navigate = useNavigate();
  const database = useDatabase();
  const [show, onShow, onHide] = useBoolState();
  const team = database.teams.get(teamId);
  const noChars = team.loadoutData.every((id) => !id);
  const onDelNoChars = () => {
    database.teams.remove(teamId);
    navigate(`/teams`);
  };
  const onDup = () => {
    const newTeamId = database.teams.duplicate(teamId);
    navigate(`/teams/${newTeamId}`);
  };
  const [showDel, onShowDel, onHideDel] = useBoolState();
  return /* @__PURE__ */ jsxs(CardContent, { sx: { display: "flex", flexDirection: "column", gap: 2 }, children: [
    /* @__PURE__ */ jsx(TeamInfoAlert, {}),
    /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
      /* @__PURE__ */ jsx(TeamExportModal, { show, teamId, onHide }),
      /* @__PURE__ */ jsx(
        Button,
        {
          color: "info",
          sx: { flexGrow: 1 },
          startIcon: /* @__PURE__ */ jsx(default_1$h, {}),
          disabled: noChars,
          onClick: onShow,
          children: "Export Team"
        }
      ),
      /* @__PURE__ */ jsx(
        Button,
        {
          color: "info",
          sx: { flexGrow: 1 },
          disabled: noChars,
          onClick: onDup,
          startIcon: /* @__PURE__ */ jsx(default_1$g, {}),
          children: "Duplicate Team"
        }
      ),
      /* @__PURE__ */ jsx(
        TeamDelModal,
        {
          teamId,
          show: showDel,
          onHide: onHideDel,
          onDel: () => navigate(`/teams`)
        }
      ),
      /* @__PURE__ */ jsx(
        Button,
        {
          color: "error",
          sx: { flexGrow: 1 },
          onClick: noChars ? onDelNoChars : onShowDel,
          startIcon: /* @__PURE__ */ jsx(default_1$9, {}),
          children: "Delete Team"
        }
      )
    ] }),
    /* @__PURE__ */ jsx(EnemyExpandCard, { teamId }),
    /* @__PURE__ */ jsx(TeamEditor, { teamId, teamData })
  ] });
}
function TeamEditor({
  teamId,
  teamData
}) {
  var _a, _b, _c, _d;
  const database = useDatabase();
  const team = database.teams.get(teamId);
  const { loadoutData } = team;
  const [charSelectIndex, setCharSelectIndex] = reactExports.useState(
    void 0
  );
  const onSelect = (cKey) => {
    if (charSelectIndex === void 0)
      return;
    database.chars.getWithInitWeapon(cKey);
    const existingIndex = loadoutData.findIndex(
      (loadoutDatum) => {
        var _a2;
        return loadoutDatum && ((_a2 = database.teamChars.get(loadoutDatum.teamCharId)) == null ? void 0 : _a2.key) === cKey;
      }
    );
    if (existingIndex < 0) {
      let teamCharId = database.teamChars.keys.find(
        (k2) => database.teamChars.get(k2).key === cKey
      );
      if (!teamCharId)
        teamCharId = database.teamChars.new(cKey);
      database.teams.set(teamId, (team2) => {
        if (!teamCharId)
          return;
        team2.loadoutData[charSelectIndex] = { teamCharId };
      });
    } else {
      if (charSelectIndex === existingIndex)
        return;
      if (loadoutData[charSelectIndex]) {
        const existingLoadoutDatum = loadoutData[existingIndex];
        const destinationLoadoutDatum = loadoutData[charSelectIndex];
        database.teams.set(teamId, (team2) => {
          team2.loadoutData[charSelectIndex] = existingLoadoutDatum;
          team2.loadoutData[existingIndex] = destinationLoadoutDatum;
        });
      }
    }
  };
  const charKeyAtIndex = (_b = database.teamChars.get(
    (_a = loadoutData[charSelectIndex]) == null ? void 0 : _a.teamCharId
  )) == null ? void 0 : _b.key;
  const firstTeamCharId = (_c = loadoutData[0]) == null ? void 0 : _c.teamCharId;
  const firstTeamCharKey = firstTeamCharId && ((_d = database.teamChars.get(firstTeamCharId)) == null ? void 0 : _d.key);
  const charData = firstTeamCharKey && (teamData == null ? void 0 : teamData[firstTeamCharKey]);
  const charUIData = charData ? charData.target : void 0;
  const dataContextValue = reactExports.useMemo(() => {
    if (!teamData || !charUIData)
      return void 0;
    return {
      data: charUIData,
      teamData,
      compareData: void 0
    };
  }, [charUIData, teamData]);
  return /* @__PURE__ */ jsxs(Fragment, { children: [
    /* @__PURE__ */ jsx(reactExports.Suspense, { fallback: false, children: /* @__PURE__ */ jsx(
      CharacterSelectionModal,
      {
        filter: (c2) => c2 !== charKeyAtIndex,
        show: charSelectIndex !== void 0,
        onHide: () => setCharSelectIndex(void 0),
        onSelect
      }
    ) }),
    /* @__PURE__ */ jsxs(Grid, { container: true, columns: { xs: 1, md: 2 }, spacing: 2, children: [
      /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(
        ResonanceDisplay,
        {
          teamId,
          team,
          dataContextValue
        }
      ) }),
      /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: /* @__PURE__ */ jsx(AdResponsive, { bgt: "light", dataAdSlot: "5102492054", maxHeight: 400 }) })
    ] }),
    /* @__PURE__ */ jsx(Alert, { severity: "info", children: 'The first character in the team receives any "active on-field character" buffs, and cannot be empty.' }),
    /* @__PURE__ */ jsx(Grid, { container: true, columns: { xs: 1, md: 2, lg: 4 }, spacing: 2, children: loadoutData.map((loadoutDatum, ind) => /* @__PURE__ */ jsx(Grid, { item: true, xs: 1, children: loadoutDatum ? /* @__PURE__ */ jsx(
      CharSelButton,
      {
        index: ind,
        teamId,
        loadoutDatum,
        onClickChar: () => setCharSelectIndex(ind),
        teamData
      },
      loadoutDatum == null ? void 0 : loadoutDatum.teamCharId
    ) : /* @__PURE__ */ jsx(
      Button,
      {
        onClick: () => setCharSelectIndex(ind),
        fullWidth: true,
        disabled: !!ind && !loadoutData.some((id) => id),
        startIcon: /* @__PURE__ */ jsx(default_1$i, {}),
        children: "Add Character"
      },
      ind
    ) }, (loadoutDatum == null ? void 0 : loadoutDatum.teamCharId) ?? ind)) })
  ] });
}
function CharSelButton({
  index,
  teamId,
  loadoutDatum,
  teamData,
  onClickChar
}) {
  const database = useDatabase();
  const { teamCharId } = loadoutDatum;
  const { key: characterKey } = database.teamChars.get(teamCharId);
  const { gender } = useDBMeta();
  const onChangeTeamCharId = (teamCharId2) => {
    database.teams.set(teamId, (team) => {
      team.loadoutData[index] = { teamCharId: teamCharId2 };
    });
  };
  const onActive = () => {
    database.teams.set(teamId, (team) => {
      const oldActive = team.loadoutData[0];
      team.loadoutData[0] = loadoutDatum;
      team.loadoutData[index] = oldActive;
    });
  };
  const onDel = () => database.teams.set(teamId, (team) => {
    team.loadoutData[index] = void 0;
  });
  const charData = characterKey && (teamData == null ? void 0 : teamData[characterKey]);
  const charUIData = charData ? charData.target : void 0;
  const dataContextValue = reactExports.useMemo(() => {
    if (!teamData || !charUIData)
      return void 0;
    return {
      data: charUIData,
      teamData,
      compareData: void 0
    };
  }, [charUIData, teamData]);
  return /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1, flexDirection: "column" }, children: [
    /* @__PURE__ */ jsxs(Box, { sx: { display: "flex", gap: 1 }, children: [
      /* @__PURE__ */ jsx(
        Button,
        {
          onClick: onClickChar,
          color: "success",
          sx: { flexGrow: 1 },
          startIcon: /* @__PURE__ */ jsx(CharIconSide, { characterKey }),
          children: /* @__PURE__ */ jsx(CharacterName, { characterKey, gender })
        }
      ),
      /* @__PURE__ */ jsx(Button, { onClick: onDel, color: "error", sx: { p: 1, minWidth: 0 }, children: /* @__PURE__ */ jsx(default_1$a, {}) })
    ] }),
    /* @__PURE__ */ jsx(
      LoadoutDropdown,
      {
        teamCharId,
        onChangeTeamCharId,
        dropdownBtnProps: { fullWidth: true }
      }
    ),
    /* @__PURE__ */ jsx(
      BuildDropdown,
      {
        teamId,
        loadoutDatum,
        dropdownBtnProps: { fullWidth: true }
      }
    ),
    index ? /* @__PURE__ */ jsx(Button, { onClick: onActive, color: "info", children: "To Field" }) : /* @__PURE__ */ jsx(Button, { disabled: true, color: "info", children: "On-field Character" }),
    dataContextValue && /* @__PURE__ */ jsx(
      TeammateDisplay,
      {
        dataContextValue,
        teamCharId,
        teamId
      }
    )
  ] });
}
function PageTeam() {
  const database = useDatabase();
  const { teamId } = useParams();
  const invalidKey = !teamId || !database.teams.keys.includes(teamId);
  reactExports.useEffect(() => {
    if (invalidKey)
      return;
    database.teams.set(teamId, { lastEdit: Date.now() });
  }, [teamId, database.teams, invalidKey]);
  if (invalidKey)
    return /* @__PURE__ */ jsx(Navigate, { to: "/teams" });
  return /* @__PURE__ */ jsx(Box, { display: "flex", flexDirection: "column", gap: 1, children: /* @__PURE__ */ jsx(
    reactExports.Suspense,
    {
      fallback: /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 1e3 }),
      children: teamId && /* @__PURE__ */ jsx(Page, { teamId })
    }
  ) });
}
const fallback = /* @__PURE__ */ jsx(Skeleton, { variant: "rectangular", width: "100%", height: 1e3 });
const chartDataAll = {};
const graphBuildAll = {};
function Page({ teamId }) {
  var _a;
  const database = useDatabase();
  const navigate = useNavigate();
  const { silly } = reactExports.useContext(SillyContext);
  const { gender } = useDBMeta();
  const team = useTeam(teamId);
  const { loadoutData } = team;
  const {
    params: { characterKey: characterKeyRaw }
  } = useMatch({ path: "/teams/:teamId/:characterKey", end: false }) ?? {
    params: {}
  };
  const {
    params: { tab }
  } = useMatch({ path: "/teams/:teamId/:characterKey/:tab" }) ?? {
    params: {}
  };
  const loadoutDatum = reactExports.useMemo(() => {
    const loadoutDatum2 = loadoutData.find(
      (loadoutDatum3) => {
        var _a2;
        return (loadoutDatum3 == null ? void 0 : loadoutDatum3.teamCharId) && ((_a2 = database.teamChars.get(loadoutDatum3.teamCharId)) == null ? void 0 : _a2.key) === characterKeyRaw;
      }
    );
    return loadoutDatum2;
  }, [loadoutData, database.teamChars, characterKeyRaw]);
  reactExports.useEffect(() => {
    window.scrollTo({ top: 0 });
  }, []);
  reactExports.useEffect(() => {
    if (!loadoutDatum)
      navigate("", { replace: true });
  }, [loadoutDatum, navigate]);
  const teamCharId = loadoutDatum == null ? void 0 : loadoutDatum.teamCharId;
  const characterKey = (_a = database.teamChars.get(teamCharId)) == null ? void 0 : _a.key;
  const teamChar = useTeamChar(teamCharId ?? "");
  const { t: t2 } = useTranslation([
    "sillyWisher_charNames",
    "charNames_gen",
    "page_character"
  ]);
  useTitle(
    reactExports.useMemo(() => {
      const charName = characterKey ? t2(
        `${silly ? "sillyWisher_charNames" : "charNames_gen"}:${charKeyToLocGenderedCharKey(characterKey, gender)}`
      ) : t2("Team Settings");
      const tabName = tab ? t2(`page_character:tabs.${tab}`) : characterKey ? t2("Loadout/Build") : tab;
      return tabName ? `${team.name} - ${charName} - ${tabName}` : `${team.name} - ${charName}`;
    }, [t2, team.name, silly, characterKey, gender, tab])
  );
  const teamCharacterContextValue = reactExports.useMemo(() => {
    if (!teamCharId || !teamChar || !loadoutDatum)
      return void 0;
    return {
      teamId,
      team,
      teamCharId,
      teamChar,
      loadoutDatum
    };
  }, [teamId, team, teamCharId, teamChar, loadoutDatum]);
  const teamData = useTeamDataNoContext(teamId, teamCharId ?? "");
  const { target: charUIData } = (characterKey && (teamData == null ? void 0 : teamData[characterKey])) ?? {};
  const dataContextValue = reactExports.useMemo(() => {
    if (!teamData || !charUIData)
      return void 0;
    return {
      data: charUIData,
      teamData,
      compareData: void 0
    };
  }, [charUIData, teamData]);
  return /* @__PURE__ */ jsx(Box, { sx: { display: "flex", gap: 1, flexDirection: "column" }, children: /* @__PURE__ */ jsxs(CardThemed, { children: [
    /* @__PURE__ */ jsx(
      TeamCharacterSelector,
      {
        teamId,
        characterKey,
        tab
      }
    ),
    /* @__PURE__ */ jsx(
      Box,
      {
        sx: (theme) => {
          const elementKey = characterKey && getCharEle(characterKey);
          if (!elementKey)
            return {};
          const hex2 = theme.palette[elementKey].main;
          const color2 = hexToColor(hex2);
          if (!color2)
            return {};
          const rgba2 = colorToRgbaString(color2, 0.1);
          return {
            background: `linear-gradient(to bottom, ${rgba2} 0%, rgba(0,0,0,0)) 25%`
          };
        },
        children: teamCharacterContextValue ? dataContextValue ? /* @__PURE__ */ jsx(TeamCharacterContext.Provider, { value: teamCharacterContextValue, children: /* @__PURE__ */ jsx(DataContext.Provider, { value: dataContextValue, children: /* @__PURE__ */ jsx(
          CardContent,
          {
            sx: { display: "flex", flexDirection: "column", gap: 1 },
            children: /* @__PURE__ */ jsx(InnerContent, { tab })
          }
        ) }) }) : fallback : /* @__PURE__ */ jsx(TeamSetting, { teamId, teamData })
      }
    )
  ] }) });
}
function InnerContent({ tab }) {
  const database = useDatabase();
  const {
    teamCharId,
    teamChar: { key: characterKey },
    loadoutDatum
  } = reactExports.useContext(TeamCharacterContext);
  const character = useCharacter(characterKey);
  const CharacterContextValue = reactExports.useMemo(
    () => character && {
      character
    },
    [character]
  );
  const [chartData, setChartDataState] = reactExports.useState(
    chartDataAll[teamCharId]
  );
  const [graphBuilds, setGraphBuildState] = reactExports.useState(graphBuildAll[teamCharId]);
  reactExports.useEffect(() => {
    setChartDataState(chartDataAll[teamCharId]);
    setGraphBuildState(graphBuildAll[teamCharId]);
  }, [teamCharId, setChartDataState, setGraphBuildState]);
  const graphContextValue = reactExports.useMemo(() => {
    return {
      chartData,
      setChartData: (data) => {
        if (data)
          chartDataAll[teamCharId] = data;
        setChartDataState(data);
      },
      graphBuilds,
      setGraphBuilds: (data) => {
        if (data)
          graphBuildAll[teamCharId] = data;
        setGraphBuildState(data);
      }
    };
  }, [
    teamCharId,
    chartData,
    graphBuilds,
    setChartDataState,
    setGraphBuildState
  ]);
  const buildTc = useBuildTc(loadoutDatum.buildTcId);
  const setBuildTc = reactExports.useCallback(
    (data) => {
      database.buildTcs.set(loadoutDatum.buildTcId, data);
    },
    [loadoutDatum.buildTcId, database]
  );
  const buildTCContextObj = reactExports.useMemo(
    () => ({
      buildTc: loadoutDatum.buildType === "tc" ? buildTc : void 0,
      setBuildTc
    }),
    [buildTc, loadoutDatum.buildType, setBuildTc]
  );
  if (!CharacterContextValue)
    return fallback;
  return /* @__PURE__ */ jsx(CharacterContext.Provider, { value: CharacterContextValue, children: /* @__PURE__ */ jsx(BuildTcContext.Provider, { value: buildTCContextObj, children: /* @__PURE__ */ jsx(GraphContext.Provider, { value: graphContextValue, children: /* @__PURE__ */ jsx(FormulaDataWrapper, { children: /* @__PURE__ */ jsx(Routes, { children: /* @__PURE__ */ jsx(Route, { path: ":characterKey", children: /* @__PURE__ */ jsx(Route, { path: "*", index: true, element: /* @__PURE__ */ jsx(Content$1, { tab }) }) }) }) }) }) }) });
}
export {
  PageTeam as default
};
