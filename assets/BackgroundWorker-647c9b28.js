(function(){"use strict";const be=function*(t,e,s){for(let n=t;n<=e;n+=s)yield n};function z(t,e,s=1){return[...be(t,e,s)]}function Q(...t){return t.reduce((e,s)=>e.flatMap(n=>s.map(r=>[n,[r]].flat())),[[]])}function P(t,e){return Object.fromEntries(Object.entries(t).map(([s,n],r)=>[s,e(n,s,r)]))}function I(t,e){return Object.fromEntries(t.map((s,n)=>[s,e(s,n)]))}function ve(t,e){return Object.fromEntries(t.map((s,n)=>e(s,n)))}function ye(t,e){if(!(!t||!e))return e.reduce((s,n)=>s==null?void 0:s[n],t)}function C(t){throw new Error(`Should not reach this with value ${t}`)}const ke=["Adventurer","ArchaicPetra","Berserker","BlizzardStrayer","BloodstainedChivalry","BraveHeart","CrimsonWitchOfFlames","DeepwoodMemories","DefendersWill","DesertPavilionChronicle","EchoesOfAnOffering","EmblemOfSeveredFate","FlowerOfParadiseLost","Gambler","GildedDreams","GladiatorsFinale","GoldenTroupe","HeartOfDepth","HuskOfOpulentDreams","Instructor","Lavawalker","LuckyDog","MaidenBeloved","MarechausseeHunter","MartialArtist","NighttimeWhispersInTheEchoingWoods","NoblesseOblige","NymphsDream","OceanHuedClam","PaleFlame","PrayersForDestiny","PrayersForIllumination","PrayersForWisdom","PrayersToSpringtime","ResolutionOfSojourner","RetracingBolide","Scholar","ShimenawasReminiscence","SongOfDaysPast","TenacityOfTheMillelith","TheExile","ThunderingFury","Thundersoother","TinyMiracle","TravelingDoctor","VermillionHereafter","ViridescentVenerer","VourukashasGlow","WanderersTroupe"],S=["flower","plume","sands","goblet","circlet"];ie(1),ie(0);function E(t,e){return typeof t=="number"?{operation:"const",operands:[],type:"number",value:t,info:e}:{operation:"const",operands:[],type:"string",value:t,info:e}}function ie(t,e){return t>=Number.MAX_VALUE/100&&(t=1/0),t<=-Number.MAX_VALUE/100&&(t=-1/0),E(t,{unit:"%",...e})}function Me(...t){return{operation:"min",operands:A(t)}}function xe(...t){return{operation:"max",operands:A(t)}}function ae(...t){return{operation:"add",operands:A(t)}}function Oe(...t){return{operation:"mul",operands:A(t)}}function Se(t,e,s,n,r){return{operation:"threshold",operands:[q(t),q(e),q(s),q(n)],info:r}}function Ee(t,e="add",s){return{operation:"read",operands:[],path:["dyn",t],accu:e,type:"number",info:s}}function A(t){return t.map(e=>typeof e=="object"?e:E(e))}function q(t){return typeof t!="object"?E(t):t}function H(t,e,s){const n=new Set,r=new Set;function a(o){if(!r.has(o)){if(n.has(o)){console.error("Found cyclical dependency during formula traversal");return}n.add(o),e(o),o.operands.forEach(a),s(o),n.delete(o),r.add(o)}}t.forEach(a)}function B(t,e,s){const n=new Set,r=new Map,a=new Map;function o(c){let l=r.get(c);if(l)return l;l=e(c);let g=a.get(l);return g||(n.has(l)?(console.error("Found cyclical dependency during formula mapping"),E(NaN)):(n.add(l),g=s(i(l),c),n.delete(l),r.set(c,g),a.set(l,g),g))}function i(c){const l=c.operands.map(o);return ce(l,c.operands)?c:{...c,operands:l}}const p=t.map(o);return ce(p,t)?t:p}function oe(t,e,s){const n=new Map;function r(a,o){let i=n.get(o);i||n.set(o,i=[new Set,new Map]);const[p,c]=i,l=c.get(a);if(l)return l;if(p.has(a))throw new Error("Found cyclical dependency during formula mapping");p.add(a);const g=s(a,o,r);return c.set(a,g),p.delete(a),g}return t.map(a=>r(a,e))}function ce(t,e){return t===void 0?e===void 0:e===void 0?!1:t.length===e.length&&t.every((s,n)=>s===e[n])}const le={min:t=>Math.min(...t),max:t=>Math.max(...t),add:t=>t.reduce((e,s)=>e+s,0),mul:t=>t.reduce((e,s)=>e*s,1)},F={...le,res:([t])=>t<0?1-t/2:t>=.75?1/(t*4+1):1-t,sum_frac:t=>t[0]/t.reduce((e,s)=>e+s),threshold:([t,e,s,n])=>t>=e?s:n},$e=new Set(Object.keys(le));function ue(t,e,s=n=>!1){let n=Z(t,e,s);return n=je(n),n=Z(n,{}),Re(n)}function Ne(t,e,s,n){let r=`
"use strict";
function res(res) {
  if (res < 0) return 1 - res / 2
  else if (res >= 0.75) return 1 / (res * 4 + 1)
  return 1 - res
}
const x0=0`,a=1;const o=new Map;return H(t,i=>{},i=>{const{operation:p,operands:c}=i,l=`x${a++}`,g=c.map(d=>o.get(d));switch(o.set(i,l),p){case"read":{const d=s(i);let h=n?new Array(n).fill(null).map((u,f)=>`(b[${f}].values["${d}"] ?? 0)`):["0"];e[d]&&e[d]!==0&&(h=[e[d].toString(),...h]),r+=`,${l}=${h.join("+")}
`;break}case"const":o.set(i,`(${i.value})`);break;case"add":case"mul":r+=`,${l}=${g.join(p==="add"?"+":"*")}
`;break;case"min":case"max":r+=`,${l}=Math.${p}(${g})
`;break;case"threshold":{const[d,h,u,f]=g;r+=`,${l}=(${d}>=${h})?${u}:${f}
`;break}case"res":r+=`,${l}=res(${g[0]})
`;break;case"sum_frac":r+=`,${l}=${g[0]}/(${g[0]}+${g[1]})
`;break;default:C(p)}}),r+=`;
return [${t.map(i=>o.get(i))}]`,new Function("b",r)}function je(t){return B(t,e=>e,e=>{let s=e;if($e.has(e.operation)){const n=e,{operation:r}=n;let a=!1;const o=n.operands.flatMap(i=>i.operation===r?(a=!0,i.operands):[i]);s=a?{...n,operands:o}:n}return s})}function Y(t,e,s){if(t.length!==e.length)return t.length-e.length;for(let n=0;n<t.length;n++){const r=s(t[n],e[n]);if(r!==0)return r}return 0}function Re(t){const e=new Map,s=[[]];H(t,i=>{},i=>{switch(i.operation){case"const":case"read":s[0].push(i),e.set(i,0);break;default:{const p=Math.max(...i.operands.map(c=>e.get(c)))+1;s.length<=p&&s.push([]),s[p].push(i),e.set(i,p);break}}});function n(i,p){const c=e.get(i),l=e.get(p);if(c!==l)return c-l;const g=i.operation,d=p.operation;if(g!==d)return g.localeCompare(d);switch(g){case"const":if(g!==d)throw Error("ily jslint");return i.value-p.value;case"read":if(g!==d)throw Error("ily jslint");return Y(i.path,p.path,(h,u)=>h.localeCompare(u));case"res":case"threshold":case"sum_frac":{if(g!==d)throw Error("ily jslint");const h=i.operands.map(f=>a.get(f)),u=p.operands.map(f=>a.get(f));return Y(h,u,(f,m)=>f-m)}case"add":case"mul":case"min":case"max":{if(g!==d)throw Error("ily jslint");const h=i.operands.map(f=>a.get(f)),u=p.operands.map(f=>a.get(f));return h.sort((f,m)=>f-m),u.sort((f,m)=>f-m),Y(h,u,(f,m)=>f-m)}}}let r=0;const a=new Map,o=[];return s.forEach(i=>{i.sort(n),o.push(i[0]),a.set(i[0],r++);for(let p=1;p<i.length;p++)n(i[p-1],i[p])===0?a.set(i[p],a.get(i[p-1])):(o.push(i[p]),a.set(i[p],r++))}),o.forEach((i,p)=>{switch(i.operation){case"add":case"mul":case"min":case"max":o[p]={...i,operands:[...i.operands].sort((c,l)=>a.get(c)-a.get(l))}}}),B(t,i=>o[a.get(i)],i=>i)}function Z(t,e,s=n=>!1){const n={data:[],processed:new Map},r=new Map([[n,new Map]]),a={data:[e],processed:new Map};return r.set(a,new Map),r.get(n).set(e,a),oe(t,a,(o,i,p)=>{const{operation:c}=o,l=(h,u)=>p(h,u),g=(h,u)=>p(h,u);let d;switch(c){case"const":d=o;break;case"add":case"mul":case"max":case"min":{const h=F[c],u=[],f=o.operands.filter(w=>{const b=l(w,i);return b.operation==="const"?(u.push(b.value),!1):!0}).map(w=>l(w,i)),m=h(u);if(isFinite(m)){if(c==="mul"&&m===0){d=E(m);break}}else if(c!=="mul"&&(c!=="max"||m>0)&&(c!=="min"||m<0)){d=E(m);break}m!==h([])&&f.push(E(m)),f.length<=1?d=f[0]??E(h([])):d={operation:c,operands:f};break}case"res":case"sum_frac":{const h=o.operands.map(f=>l(f,i)),u=F[c];h.every(f=>f.operation==="const")?d=E(u(h.map(f=>f.value))):d={...o,operands:h};break}case"lookup":{const h=g(o.operands[0],i);if(h.operation==="const"){const u=o.table[h.value]??o.operands[1];if(u){d=p(u,i);break}}throw new Error(`Unsupported ${c} node while folding`)}case"prio":{const h=o.operands.find(u=>{const f=g(u,i);if(f.operation!=="const")throw new Error(`Unsupported ${c} node while folding`);return f.value!==void 0});d=h?g(h,i):E(void 0);break}case"small":{let h;for(const u of o.operands){const f=g(u,i);if(f.operation!=="const")throw new Error(`Unsupported ${c} node while folding`);((h==null?void 0:h.value)===void 0||f.value!==void 0&&f.value<h.value)&&(h=f)}d=h??E(void 0);break}case"match":{const[h,u,f,m]=o.operands.map(w=>p(w,i));if(h.operation!=="const"||u.operation!=="const")throw new Error(`Unsupported ${c} node while folding`);d=h.value===u.value?f:m;break}case"threshold":{const[h,u,f,m]=o.operands.map(w=>p(w,i));f.operation==="const"&&m.operation==="const"&&f.value===m.value?d=f:h.operation==="const"&&u.operation==="const"?d=h.value>=u.value?f:m:d={...o,operands:[h,u,f,m]};break}case"subscript":{const h=l(o.operands[0],i);if(h.operation!=="const")throw new Error("Found non-constant subscript node while folding");d=E(o.list[h.value]);break}case"read":{const h=i.data.map(u=>ye(u,o.path)).filter(u=>u);if(h.length===0)if(s(o)){const{accu:u}=o;u===void 0||u==="small"?d=o.type==="string"?E(void 0):E(NaN):d=E(F[u]([]))}else d=o;else o.accu===void 0||h.length===1?d=p(h[h.length-1],i):d=p({operation:o.accu,operands:h},i);break}case"data":{o.reset&&(i=n);const h=r.get(i);let u=h.get(o.data);u||(u={data:[...i.data,o.data],processed:new Map},r.set(u,new Map),h.set(o.data,u)),d=p(o.operands[0],u);break}default:C(c)}return d.info&&(d={...d},delete d.info),d})}function pe(t,e,s,n,r,a){let o=a;const i={pruneOrder:{pruneNodeRange:!0},pruneArtRange:{pruneNodeRange:!0},pruneNodeRange:{reaffine:!0},reaffine:{pruneOrder:!0,pruneArtRange:!0,pruneNodeRange:!0}};let p=0;for(;Object.values(o).some(c=>c)&&p++<20;){if(o.pruneOrder){delete o.pruneOrder;const c=_e(s,n,r);s!==c&&(s=c,o={...o,...i.pruneOrder})}if(o.pruneArtRange){delete o.pruneArtRange;const c=Ie(t,s,e);s!==c&&(s=c,o={...o,...i.pruneArtRange})}if(o.pruneNodeRange){delete o.pruneNodeRange;const c=Ce(t,s);t!==c&&(t=c,o={...o,...i.pruneNodeRange})}if(o.reaffine){delete o.reaffine;const{nodes:c,arts:l}=Fe(t,s);(t!==c||s!==l)&&(t=c,s=l,o={...o,...i.reaffine})}}return{nodes:t,arts:s}}function Fe(t,e,s=!1){const n=new Set,r=new Set;function a(u,f){return f?n.add(u):u.operands.forEach(m=>n.has(m)&&r.add(m)),u}const o=new Set;if(t=B(t,u=>u,u=>{const{operation:f}=u;switch(f){case"read":return o.add(u.path[1]),a(u,!0);case"add":{const m=u.operands.filter(v=>n.has(v)),w=u.operands.filter(v=>!n.has(v));if(w.length===0)return a(u,!0);if(m.length<=1)return a(u,!1);const b=a(ae(...m),!0);return a(ae(b,...w),!1)}case"mul":{const m=u.operands.filter(w=>w.operation!=="const");return a(u,m.length===0||m.length===1&&n.has(m[0]))}case"const":return a(u,!0);case"res":case"threshold":case"sum_frac":case"max":case"min":return a(u,!1);default:C(f)}}),t.filter(u=>n.has(u)).forEach(u=>r.add(u)),[...r].every(({operation:u})=>u==="read"||u==="const")&&Object.keys(e.base).length===o.size)return{nodes:t,arts:e};let i=-1;function p(){for(;o.has(`${++i}`););return`${i}`}const c=[...r].filter(u=>u.operation!=="const"),l=new Map(c.map(u=>[u,!s&&u.operation==="read"&&u.path[0]==="dyn"?u:Ee(p())]));t=B(t,u=>l.get(u)??u,u=>u);function g(u){const f=Z([...l.keys()],{dyn:P(u,m=>E(m))},m=>!0);return Object.fromEntries([...l.values()].map((m,w)=>[m.path[1],f[w].value]))}const d={nodes:t,arts:{base:g(e.base),values:I(S,u=>e.values[u].map(({id:f,set:m,values:w})=>({id:f,set:m,values:g(w)})))}},h=Object.entries(g({}));for(const u of Object.values(d.arts.values))for(const{values:f}of u)for(const[m,w]of h)f[m]-=w;return d}function _e(t,e,s){var c;let n=!1;const r=!((c=s.rainbow)!=null&&c.length),a=Object.keys(t.base),o=new Set(Object.entries(s).filter(([l,g])=>g.length).map(([l])=>l)),i=new Set(Object.entries(s).filter(([l,g])=>g.includes(2)&&!g.includes(4)).map(([l])=>l)),p=I(S,l=>{const g=t.values[l],d=g.filter(h=>{let u=0;return g.every(f=>{const m=a.every(y=>(f.values[y]??0)>=(h.values[y]??0)),w=a.some(y=>(f.values[y]??0)>(h.values[y]??0)),b=m&&(w||f.id>h.id),v=r&&!o.has(f.set)&&!i.has(h.set)||h.set===f.set;return b&&v&&u++,u<e})});return d.length!==g.length&&(n=!0),d});return n?{base:t.base,values:p}:t}function Ie(t,e,s){const n=Object.fromEntries(Object.entries(e.base).map(([a,o])=>[a,{min:o,max:o}])),r={arts:e};for(;;){const a=I(S,c=>L(r.arts.values[c])),o=I(S,c=>K(Object.entries(a).map(l=>l[0]===c?n:l[1]).filter(l=>l)));let i=!1;const p=I(S,c=>{const l=r.arts.values[c].filter(g=>{const d=K([L([g]),o[c]]),h=te(t,d);return t.every((u,f)=>h.get(u).max>=(s[f]??-1/0))});return l.length!==r.arts.values[c].length&&(i=!0),l});if(!i)break;r.arts={base:r.arts.base,values:p}}return r.arts}function Ce(t,e){const s=Object.fromEntries(Object.entries(e.base).map(([a,o])=>[a,{min:o,max:o}])),n=K([s,...Object.values(e.values).map(a=>L(a))]),r=te(t,n);return B(t,a=>{{const{min:p,max:c}=r.get(a);if(p===c)return E(p)}const{operation:o}=a,i=a.operands.map(p=>r.get(p));switch(o){case"threshold":{const[p,c,l,g]=i;if(p.min>=c.max)return a.operands[2];if(p.max<c.min)return a.operands[3];if(l.max===l.min&&g.max===g.min&&l.min===g.min&&isFinite(l.min))return E(l.max);break}case"min":{const p=a.operands.filter((c,l)=>{const g=i[l];return i.every(d=>g.min<=d.max)});if(p.length<i.length)return Me(...p);break}case"max":{const p=a.operands.filter((c,l)=>{const g=i[l];return i.every(d=>g.max>=d.min)});if(p.length<i.length)return xe(...p);break}}return a},a=>a)}function K(t){const e={};return t.forEach(s=>{Object.entries(s).forEach(([n,r])=>{e[n]?(e[n].min+=r.min,e[n].max+=r.max):e[n]={...r}})}),e}function L(t){const e={};return t.length&&(Object.keys(t[0].values).filter(s=>t.every(n=>n.values[s])).forEach(s=>e[s]={min:t[0].values[s],max:t[0].values[s]}),t.forEach(({values:s})=>{for(const[n,r]of Object.entries(s))e[n]?(e[n].max<r&&(e[n].max=r),e[n].min>r&&(e[n].min=r)):e[n]={min:0,max:r}})),e}function ee(t){const e=Object.fromEntries(Object.entries(t.base).map(([s,n])=>[s,{min:n,max:n}]));return K([e,...Object.values(t.values).map(s=>L(s))])}function te(t,e){const s=new Map;return H(t,n=>{},n=>{const{operation:r}=n,a=n.operands.map(i=>s.get(i));let o;switch(r){case"read":if(n.path[0]!=="dyn")throw new Error(`Found non-dyn path ${n.path} while computing range`);o=e[n.path[1]]??{min:0,max:0};break;case"const":o=W([n.value]);break;case"add":case"min":case"max":o={min:F[r](a.map(i=>i.min)),max:F[r](a.map(i=>i.max))};break;case"res":o={min:F[r]([a[0].max]),max:F[r]([a[0].min])};break;case"mul":o=a.reduce((i,p)=>W([i.min*p.min,i.min*p.max,i.max*p.min,i.max*p.max]));break;case"threshold":a[0].min>=a[1].max?o=a[2]:a[0].max<a[1].min?o=a[3]:o=W([],[a[2],a[3]]);break;case"sum_frac":{const[i,p]=a,c={min:i.min+p.min,max:i.max+p.max};c.min<=0&&c.max>=0?o=i.min<=0&&i.max>=0?{min:NaN,max:NaN}:{min:-1/0,max:1/0}:o=W([i.min/c.min,i.min/c.max,i.max/c.min,i.max/c.max]);break}default:C(r)}s.set(n,o)}),s}function W(t,e=[]){const s=Math.max(...t,...e.map(r=>r.max));return{min:Math.min(...t,...e.map(r=>r.min)),max:s}}function V(t,e){return{base:t.base,values:I(S,s=>{const n=e[s];switch(n.kind){case"id":return t.values[s].filter(r=>n.ids.has(r.id));case"exclude":return t.values[s].filter(r=>!n.sets.has(r.set));case"required":return t.values[s].filter(r=>n.sets.has(r.set))}})}}function Pe(t){let e=.01;const s=2,n=1500;let r=new Set(t.flatMap(o=>Object.values(o).map(i=>Math.round(i.plot/e))));for(;r.size>n;)e*=s,r=new Set([...r].map(o=>Math.round(o/s)));const a={};for(const o of t)for(const i of Object.values(o)){const p=Math.round(i.plot/e)*e;(!a[p]||a[p].value<i.value)&&(a[p]=i)}return a}function _(t){return S.reduce((e,s)=>e*t.values[s].length,1)}function*Te(t,e){const s=P(e.values,n=>new Set(n.map(r=>r.set)));e:for(const n of t){for(const[r,a]of Object.entries(n)){const o=s[r];switch(a.kind){case"required":if([...a.sets].every(i=>!o.has(i)))continue e;break;case"exclude":if([...o].every(i=>a.sets.has(i)))continue e;break}}yield n}}function de(t){return new Set(t!=null&&t.includes(2)?t.includes(4)?[0,1]:[0,1,4,5]:t!=null&&t.includes(4)?[0,1,2,3]:[0,1,2,3,4,5])}function*Ue(t,e){const s=[...new Set(e)],n=de(t.rainbow);let r=[];function a(d,h,u){if(d.length===5){n.has(u.length)&&r.push(d);return}for(const f of h)a([...d,f],h,u.filter(m=>m!==f));a([...d,d.length],new Set([...h,d.length]),[...u,d.length])}a([0],new Set([0]),[0]);function o(d,h){if(!z(h+1,4).some(u=>d[u]!==5))return d=[...d],d[h]=5,d.reduce((u,f)=>u*6+f,0)}for(let d=4;d>=0;d--){const h=new Map;for(const u of r){const f=o(u,d);f!==void 0&&h.set(f,(h.get(f)??new Set(u.slice(0,d)).size+1)-1)}for(const[u,f]of h.entries())if(f===0){const m=[...r.find(w=>o(w,d)===u)];m[d]=5,r=r.filter(w=>o(w,d)!==u),r.push(m)}}const i={kind:"exclude",sets:new Set},p=I(S,d=>i),c={...P(t,d=>0),...I(s,d=>0)},l=P(t,de);function*g(d){const h=new Set,u=[];let f=[];for(const v of d)f.push([]),v===5?u.push(f.length-1):f[v].push(f.length-1);f=f.filter(v=>v.length).sort((v,y)=>y.length-v.length);let m=u.length;function*w(v){if(v===f.length)return yield*b(0);for(const y of s){if(h.has(y))continue;const x=f[v].length,k=l[y];let O=0;k&&!k.has(x)&&(O=(z(x+1,5).find(M=>k.has(M))??6)-x,O>m)||(h.add(y),c[y]=f[v].length,f[v].forEach(M=>p[S[M]]={kind:"required",sets:new Set([y])}),m-=O,yield*w(v+1),m+=O,c[y]=0,h.delete(y))}}function*b(v){const y=u.length-v,x=[],k=[],O=[];let M=0;for(const $ of s){const N=l[$],R=c[$];N&&(z(1,y).every(U=>!N.has(R+U))?O.push($):N.has(R)?z(0,y).some(U=>!N.has(R+U))&&x.push($):(M+=[...N].find(U=>U>R)-R,k.push($)))}if(!(M>y)){if(v===u.length){yield{...p};return}if(M===y){for(const $ of k)c[$]++,p[S[u[v]]]={kind:"required",sets:new Set([$])},yield*b(v+1),c[$]--;return}for(const $ of[...x,...k])c[$]++,p[S[u[v]]]={kind:"required",sets:new Set([$])},yield*b(v+1),c[$]--;p[S[u[v]]]={kind:"exclude",sets:new Set([...k,...O,...x])},yield*b(v+1)}}yield*w(0)}for(const d of r)yield*g(d)}function Ve(t,e){const s=ee(e),n=[...new Set(t.flatMap(a=>Object.keys(a).filter(o=>o!=="$c")))],{bestKey:r}=n.reduce(({bestKey:a,minHeur:o},i)=>{const{min:p,max:c}=s[i],l=t.reduce((f,m)=>f+((c-p)*(m[i]??0))**2,0),{lowerRange:g,upperRange:d}=S.reduce(({lowerRange:f,upperRange:m},w)=>{const b=e.values[w].map(M=>M.values[i]),v=Math.min(...b),y=Math.max(...b),x=(v+y)/2,k=Math.max(...b.filter(M=>M<=x)),O=Math.min(...b.filter(M=>M>=x));return{lowerRange:f+(k-v),upperRange:m+(y-O)}},{lowerRange:0,upperRange:0}),u=t.reduce((f,m)=>f+(g*(m[i]??0))**2+(d*(m[i]??0))**2,0)/2-l;return u<o?{bestKey:i,minHeur:u}:{bestKey:a,minHeur:o}},{bestKey:"",minHeur:1/0});return{splitOn:r,splitVal:(s[r].min+s[r].max)/2}}function De(t,e){return fe(e,s=>s.map(n=>n.set===t))}function Be(t,e,s){e-=s.base[t];const n=S.map(c=>s.values[c].map(l=>({art:l,val:l.values[t]})).sort((l,g)=>l.val-g.val)),r=n.map(([c])=>c.val),a=n.map(c=>c[c.length-1].val-c[0].val),o=a.reduce((c,l)=>c+l),i=(e-r.reduce((c,l)=>c+l))/Math.max(o,1e-9),p=n.map((c,l)=>{const g=r[l]+i*a[l];let d=0,h=c.length;for(;d!==h;){const u=Math.floor((d+h)/2);g>c[u].val?d=u+1:h=u}return h});return fe(s,(c,l)=>{const g=new Set(n[l].slice(p[l]).map(d=>d.art));return c.map(d=>g.has(d))})}function fe({base:t,values:e},s){const n=S.map((r,a)=>{const o=e[r],i=s(o,a);return[o.filter((p,c)=>i[c]),o.filter((p,c)=>!i[c])].filter(p=>p.length)});return Q(...n).map(r=>({base:t,values:I(S,(a,o)=>r[o])})).sort((r,a)=>_(a)-_(r))}function G(t){return{type:"lin",lin:{$c:t},min:t,max:t}}function ze(t,e){return{type:"lin",lin:{[t]:1,$c:0},...e}}function ne(...t){const e=t.filter(n=>typeof n=="number").reduce((n,r)=>n+r,0),s=t.filter(n=>typeof n!="number");return{type:"sum",terms:s,$c:e,min:s.reduce((n,{min:r})=>n+r,e),max:s.reduce((n,{max:r})=>n+r,e)}}function X(...t){const e=t.filter(r=>typeof r=="number").reduce((r,a)=>r*a,1),s=t.filter(r=>typeof r!="number"),n=s.reduce(({min:r,max:a},{min:o,max:i})=>({min:Math.min(r*o,r*i,a*o,a*i),max:Math.max(r*o,r*i,a*o,a*i)}),{min:e,max:e});return{type:"prod",terms:s,$k:e,...n}}function se(t,e,s,n){return ne(s-t*e,X(t,n))}function he(t,e,s,n,r,a){return Math.abs(t-s)<1e-10?G(a?Math.max(e,n):Math.min(e,n)):se((n-e)/(s-t),t,e,r)}function Ae(t,e){const s=new Map;H(t,c=>{const{operation:l}=c;switch(l==="mul"&&s.set(c,{min:NaN,max:NaN}),l){case"mul":case"min":case"max":case"threshold":case"res":case"sum_frac":c.operands.forEach(g=>s.set(g,{min:NaN,max:NaN}))}},c=>c);const n=ee(e),r=te([...s.keys()],n);for(const[c,l]of r.entries())s.set(c,l);const a="u",o="l",i="e";return oe(t,a,(c,l,g)=>{const{operation:d}=c,h=(f,m=l)=>g(f,m),u=l===a?o:a;switch(d){case"const":return G(c.value);case"read":return ze(c.path[1],s.get(c));case"add":return ne(...c.operands.map(f=>h(f)));case"mul":{if(l===i)return X(...c.operands.map(k=>h(k)));const{min:f,max:m}=s.get(c);if(f===m)return G(f);if(f*m<0||c.operands.some(k=>{const{min:O,max:M}=s.get(k);return O*M<0}))return h(c,i);const b=f===0?m:f,v=F[d],y=v(c.operands.filter(k=>k.operation==="const").map(k=>k.value)),x=c.operands.filter(k=>k.operation!=="const").map(k=>{const{min:O,max:M}=s.get(k),N=b*(O===0?M:O)>0?l:u,R=h(k,N);if(N===o&&M>0&&R.min<-O||N===a&&O<0&&R.max>-M)throw new j("Unallowed large crossing post approximation",d);return R});return X(y,...x)}case"min":case"max":{if(l===i)throw new j("Cannot be exactly represented",d);const f=F[d],m=c.operands.filter(M=>M.operation!=="const"),[w]=m;if(m.length!==1)throw new j("Multivariate",d);const b=h(w),v=f(c.operands.filter(M=>M.operation==="const").map(M=>M.value));if(d==="max"&&l===o||d==="min"&&l===a)return b;const{min:y,max:x}=s.get(w),k=f([y,v]),O=f([x,v]);return he(y,k,x,O,b,l===a)}case"res":{if(l===i)throw new j("Cannot be exactly represented",d);if(l===o)throw new j("Unsupported direction",d);const f=F[d],[m]=c.operands,{min:w,max:b}=s.get(m),v=h(m,u);return w<0&&b<1.75?ne(1,X(-.5,v)):he(w,f([w]),b,f([b]),v,l===a)}case"sum_frac":{if(l===i)throw new j("Cannot be exactly represented",d);if(l===o)throw new j("Unsupported direction",d);const[f,m]=c.operands;if(m.operation!=="const")throw new j("Non-constant node",d);const w=h(f),b=m.value,{min:v,max:y}=s.get(f);if(v<=-b)throw new j("Unallowed negative argument",d);const x=Math.sqrt((v+b)*(y+b));return se(b/(x+b)/(x+b),x,x/(x+b),w)}case"threshold":{if(l===i)throw new j("Cannot be exactly represented",d);const[f,m,w,b]=c.operands;if(m.operation!=="const")throw new j("Non-constant node",d);const{min:v,max:y}=s.get(f);if(v>=m.value)return h(w);if(y<m.value)return h(b);if(b.operation!=="const")throw new j("Non-constant node",d);if(w.operation!=="const"){if(b.value!==0)throw new j("Unsupported pattern",d);const N=Se(f,m,1,b),R=Oe(N,w),{min:U,max:ot}=s.get(w);return s.set(N,{min:0,max:1}),s.set(R,{min:Math.min(U,0),max:Math.max(ot,0)}),h(R)}const x=m.value,k=w.value,O=b.value,M=k>O==(l===a),$=h(f,M?a:o);if(M){const N=(k-O)/(x-v);return se(N,x,k,$)}return G(O)}default:C(d)}}).map(c=>We(c))}function re(t){return{$k:t,terms:[]}}function qe(t,e){return{$k:e,terms:[t]}}function He(...t){return t.flat()}function Ke(...t){return Q(...t).map(e=>e.reduce((s,n)=>(s.$k*=n.$k,s.terms.push(...n.terms),s),{$k:1,terms:[]}))}function Le(t){t.forEach(e=>e.terms.sort()),t.sort(({terms:e},{terms:s})=>{if(e.length!==s.length)return e.length-s.length;for(let n=0;n<e.length;n++)if(e[n]!==s[n])return e[n]<s[n]?-1:1;return 0});for(let e=t.length-2;e>=0;e--){if(t[e].$k===0){t.splice(e,1);continue}const s=t[e].terms,n=t[e+1].terms;s.length===n.length&&s.every((r,a)=>r===n[a])&&(t[e].$k=t[e].$k+t[e+1].$k,t.splice(e+1,1))}return t}function We(t){function e(s){switch(s.type){case"lin":return Object.entries(s.lin).filter(([n,r])=>r!==0).map(([n,r])=>n==="$c"?re(r):qe(n,r));case"sum":return He(...s.terms.map(n=>e(n)),[re(s.$c)]);case"prod":return Ke(...s.terms.map(n=>e(n)),[re(s.$k)])}}return Le(e(t))}class j extends Error{constructor(e,s){super(`Found ${e} in ${s} node when generating polynomial upper bound`)}}const T=1e-8;function Ge(t,e){const s=e.length;return t.every(n=>e.reduce((r,a,o)=>r+a*n[o],0)<=n[s]+T)}function Xe(t,e){const s=e.length+1,n=e[0].length,r=Array(s).fill(0).map(i=>Array(n).fill(0));e.forEach((i,p)=>i.forEach((c,l)=>r[p][l]=c)),t.forEach((i,p)=>r[s-1][p]=i);const a=[];for(;r.some((i,p)=>p<s-1&&i[n-1]<-T);){const i=Qe(r);a.push(i),me(r,i)}for(;r[s-1].some((i,p)=>p<n-1&&i<-T);){const i=Je(r);a.push(i),me(r,i)}const o=t.map((i,p)=>Ye(r,a,p));if(!Ge(e,o))throw Error("COMPUTED SOLUTION IS NOT FEASIBLE");return o}function me(t,{i:e,j:s}){const n=t[e][s];for(let r=0;r<t.length;r++)if(r!==e)for(let a=0;a<t[0].length;a++)a!==s&&(t[r][a]-=t[e][a]*t[r][s]/n);for(let r=0;r<t.length;r++)r!==e&&(t[r][s]=-t[r][s]/n);for(let r=0;r<t[0].length;r++)r!==s&&(t[e][r]=t[e][r]/n);t[e][s]=1/n}function Je(t){const e=t.length,s=t[0].length;let n={i:-1,j:-1,cmp:1/0};for(let r=0;r<s-1;r++)if(!(t[e-1][r]>=-T)){for(let a=0;a<e-1;a++)if(t[a][r]>T){const o=t[a][s-1]/t[a][r];o<n.cmp&&(n={i:a,j:r,cmp:o})}if(n.i<0)throw Error("UNBOUNDED FEASIBLE")}if(n.i<0)throw Error("NO PIVOTS (done)");return{i:n.i,j:n.j}}function Qe(t){const e=t.length,s=t[0].length;let n={i:-1,j:-1,cmp:1/0};for(let r=0;r<e-1;r++)if(!(t[r][s-1]>=-T)){for(let a=0;a<s-1;a++)if(t[r][a]<-T){const o=t[r][s-1]/t[r][a];o<n.cmp&&(n={i:r,j:a,cmp:o})}if(n.i<0)throw Error("INFEASIBLE");return{i:n.i,j:n.j}}throw Error("NO PIVOTS (done)")}function Ye(t,e,s){let n=1;e.forEach(({i:a,j:o})=>{n===1&&o===s?(s=a,n=0):n===0&&a===s&&(s=o,n=1)});const r=t[0].length;return n===0?t[s][r-1]:0}function Ze(...t){const e={$c:0};for(const[s,n]of t)for(const[r,a]of Object.entries(n))e[r]=(e[r]??0)+s*a;return e}function ge(t,e){const s=Ae(t,e),n=ee(e);return s.map(r=>Ze(...r.map(a=>{const o=a.terms.map(l=>n[l]),{w:i,$c:p}=et(o,a.$k>=0?"upper":"lower"),c={$c:p};return a.terms.forEach((l,g)=>c[l]=i[g]+(c[l]??0)),[a.$k,c]})))}function et(t,e="upper"){if(t.length===0)return{w:[],$c:1,err:0};const s=t.length,n=t.map(({min:i,max:p})=>Math.max(-i,p));if(n.some(i=>i===0))return{w:t.map(i=>0),$c:0,err:0};const r=n.reduce((i,p)=>i*p,1);t=t.map(({min:i,max:p},c)=>({min:i/n[c],max:p/n[c]}));const a=Q(...t.map(({min:i,max:p})=>[i,p])).flatMap(i=>{const p=i.reduce((l,g)=>l*g,1),c=i.reduce((l,g)=>l+g,0);switch(e){case"upper":return[[...i,-1,0,c-p-s],[...i.map(l=>-l),1,-1,s+p-c]];case"lower":return[[...i.map(l=>-l),-1,0,p-c-s],[...i,1,-1,s+c-p]];default:C(e)}}),o=[...t.map(i=>0),0,1];try{const i=Xe(o,a);switch(e){case"upper":return{w:i.slice(0,s).map((p,c)=>(1-p)*r/n[c]),$c:r*(i[s]-s),err:r*i[s+1]};case"lower":return{w:i.slice(0,s).map((p,c)=>(1-p)*r/n[c]),$c:r*(s-i[s]),err:r*i[s+1]};default:C(e)}}catch(i){throw console.log("ERROR on bounds",t),console.log("Possibly numerical instability issue."),console.log(i),i}}class tt{constructor({arts:e,optTarget:s,constraints:n,topN:r},a){this.filters=[],this.firstUncalculated=0,this.arts=e,this.min=[-1/0,...n.map(o=>o.min)],this.nodes=[s,...n.map(o=>o.value)],this.callback=a,this.topN=r,ge(this.nodes,e)}addFilter(e){const s=V(this.arts,e),n=_(s);n&&this.filters.push({nodes:this.nodes,arts:s,maxConts:[],lins:[],approxs:[],count:n})}setThreshold(e){e>this.min[0]&&(this.min[0]=e,this.firstUncalculated=0,this.filters.forEach(s=>delete s.calculated))}*split(e,s){for(this.addFilter(e);this.filters.length;){const n=this.getApproxFilter(),{arts:r,count:a}=n;if(a<=s||Object.keys(r.base).length===0){if(!a)continue;this.firstUncalculated<this.filters.length&&this.calculateFilter(this.firstUncalculated++),this.reportInterim(!1),yield P(r.values,o=>({kind:"id",ids:new Set(o.map(i=>i.id))}))}else this.splitOldFilter(n)}this.reportInterim(!0)}reportInterim(e=!1){this.interim&&(this.interim.skipped>1e6||e===!0)&&(this.callback(this.interim),this.interim=void 0)}splitOldFilter(e){const{nodes:s,arts:n,lins:r}=e;if(_(n)===0)return;const{splitOn:a,splitVal:o}=Ve(r,n),i=ke.includes(a)?De(a,n):Be(a,o,n);for(const p of i){const c=_(p);this.filters.push({nodes:s,arts:p,maxConts:[],lins:[],approxs:[],count:c})}}getApproxFilter(){return this.calculateFilter(this.filters.length-1),this.firstUncalculated>this.filters.length&&(this.firstUncalculated=this.filters.length),this.filters.pop()}calculateFilter(e){let{nodes:s,arts:n,maxConts:r,lins:a,approxs:o}=this.filters[e];const{count:i,calculated:p}=this.filters[e];if(p)return;({nodes:s,arts:n}=pe(s,this.min,n,this.topN,{},{pruneNodeRange:!0})),s=ue(s,{},d=>!1),Object.values(n.values).every(d=>d.length)&&({lins:a,approxs:o}=st(s,n),r=o.map(d=>P(n.values,h=>nt(h,d))));const c=r.map((d,h)=>Object.values(d).reduce((u,f)=>u+f,o[h].base-this.min[h])),l=P(n.values,(d,h)=>{const u=c.map((f,m)=>r[m][h]-f);return d.filter(({id:f})=>o.every(({conts:m},w)=>m[f]>=u[w]))});n={base:n.base,values:l};const g=_(n);g!==i&&(this.interim?this.interim.skipped+=i-g:this.interim={resultType:"interim",buildValues:void 0,tested:0,failed:0,skipped:i-g}),this.filters[e]={nodes:s,arts:n,maxConts:r,lins:a,approxs:o,count:g,calculated:!0}}}function nt(t,e){return Math.max(...t.map(({id:s})=>e.conts[s]))}function st(t,e){const s=ge(t,e);return{lins:s,approxs:s.map(n=>({base:we(e.base,n,n.$c),conts:ve(Object.values(e.values).flat(),r=>[r.id,we(r.values,n,0)])}))}}function we(t,e,s){return Object.entries(t).reduce((n,[r,a])=>n+(e[r]??0)*a,s)}class rt{constructor({arts:e,optTarget:s,constraints:n,plotBase:r,topN:a},o){this.builds=[],this.buildValues=void 0,this.threshold=-1/0,this.arts=e,this.min=n.map(i=>i.min),this.topN=a,this.callback=o,this.nodes=n.map(i=>i.value),this.nodes.push(s),r&&(this.plotData={},this.nodes.push(r)),this.nodes=ue(this.nodes,{},i=>!1)}setThreshold(e){this.threshold>e&&(this.threshold=e)}compute(e){const{min:s}=this;let n=V(this.arts,e);const r=_(n),a=this.builds.length;let o=this.nodes;({nodes:o,arts:n}=pe(o,s,n,this.topN,{},{pruneArtRange:!0,pruneNodeRange:!0}));const i=Object.values(n.values).sort((d,h)=>d.length-h.length),p=Ne(o,n.base,d=>d.path[1],i.length),c=Array(i.length),l={tested:0,failed:0,skipped:r-_(n)},g=d=>{if(d<0){const h=p(c);if(s.every((u,f)=>u<=h[f])){const u=h[s.length],{builds:f,plotData:m}=this;let w;if(u>=this.threshold&&(w={value:u,artifactIds:c.map(b=>b.id).filter(b=>b)},f.push(w)),m){const b=h[s.length+1];(!m[b]||m[b].value<u)&&(w||(w={value:u,artifactIds:c.map(v=>v.id).filter(v=>v)}),w.plot=b,m[b]=w)}}else l.failed+=1;return}i[d].forEach(h=>{c[d]=h,g(d-1)}),d===0&&(l.tested+=i[0].length,l.tested>65536&&this.interimReport(l))};g(i.length-1),this.interimReport(l,this.builds.length>a)}refresh(e){const{topN:s}=this;Object.keys(this.plotData??{}).length>=1e5&&(this.plotData=Pe([this.plotData])),(this.builds.length>=1e3||e)&&(this.builds=this.builds.sort((n,r)=>r.value-n.value).slice(0,s),this.buildValues=this.builds.map(n=>n.value),this.threshold=Math.max(this.threshold,this.buildValues[s-1]??-1/0))}interimReport(e,s=!1){this.refresh(s),this.callback({resultType:"interim",buildValues:this.buildValues,...e}),this.buildValues=void 0,e.tested=0,e.failed=0,e.skipped=0}}class it{constructor({arts:e},s){this.stack=[],this.arts=e}setThreshold(e){}add(e,s){this.stack.push({filter:e,count:_(V(this.arts,e)),splittedBy:s})}*split(e,s){this.add(e,"set");for(let n=this.stack.pop();n;n=this.stack.pop()){const{filter:r,count:a,splittedBy:o}=n;if(a<=s){yield r;continue}switch(o){case"set":this.splitBySet(r);break;case"id":this.splitByID(r,a,s);break;default:C(o)}}}splitBySet(e){const s=V(this.arts,e),n=S.map(o=>({slot:o,sets:new Set(s.values[o].map(i=>i.set))})).filter(({sets:o})=>o.size>1);if(!n.length)return this.add(e,"id");const{sets:r,slot:a}=n.reduce((o,i)=>o.sets.size<i.sets.size?o:i);r.forEach(o=>this.add({...e,[a]:{kind:"required",sets:new Set([o])}},"set"))}splitByID(e,s,n){const r=V(this.arts,e),{slot:a,length:o}=S.map(l=>({slot:l,length:r.values[l].length})).filter(l=>l.length>1).reduce((l,g)=>l.length<g.length?l:g),i=Math.ceil(s/n),p=Math.min(i,o),c=Array(p).fill(0).map(l=>new Set);r.values[a].forEach(({id:l},g)=>c[g%p].add(l)),c.forEach(l=>this.add({...e,[a]:{kind:"id",ids:l}},"id"))}}let J,D;async function at(t){const{data:e}=t,{command:s}=e;switch(s){case"split":for(const n of J.split(e.filter,e.maxIterateSize))postMessage({command:"iterate",filter:n}),await new Promise(r=>setTimeout(r));break;case"iterate":D.compute(e.filter);break;case"threshold":{J.setThreshold(e.threshold),D.setThreshold(e.threshold);return}case"finalize":{D.refresh(!0);const{builds:n,plotData:r}=D;postMessage({resultType:"finalize",builds:n,plotData:r});break}case"count":{const{exclusion:n,maxIterateSize:r}=e,a=D.arts,o=Te(Ue(n,[...new Set(Object.values(a.values).flatMap(p=>p.map(c=>c.set)))]),a);let i=0;for(const p of o)postMessage({command:"split",filter:p,maxIterateSize:r}),i+=_(V(a,p));postMessage({resultType:"count",count:i});break}case"setup":try{J=new tt(e,n=>postMessage(n))}catch{J=new it(e,n=>postMessage(n))}D=new rt(e,n=>postMessage(n));break;default:C(s)}postMessage({resultType:"done"})}onmessage=async t=>{try{await at(t)}catch(e){postMessage({resultType:"err",message:e.message})}}})();
